var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// shared/guestPortalSchema.ts
import {
  pgTable as pgTable2,
  serial,
  varchar,
  text as text2,
  timestamp as timestamp2,
  boolean as boolean2,
  integer as integer2,
  decimal,
  jsonb as jsonb2,
  date
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema2 } from "drizzle-zod";
var guestChatConversations, guestChatMessages, guestServiceRequests, serviceRequestNotifications, guestPreArrivalInfo, guestConfirmedExtras, reservationHistoryLog, aiChatIntentAnalysis, insertGuestChatConversationSchema, insertGuestChatMessageSchema, insertGuestServiceRequestSchema, insertGuestPreArrivalInfoSchema, insertGuestConfirmedExtrasSchema, insertReservationHistoryLogSchema, insertAiChatIntentAnalysisSchema, insertServiceRequestNotificationSchema, propertyActivityRecommendations, guestActivityPreferences, guestRecommendationInteractions, aiRecommendationAnalytics, insertPropertyActivityRecommendationSchema, insertGuestActivityPreferencesSchema, insertGuestRecommendationInteractionSchema, insertAiRecommendationAnalyticsSchema;
var init_guestPortalSchema = __esm({
  "shared/guestPortalSchema.ts"() {
    "use strict";
    init_schema();
    guestChatConversations = pgTable2("guest_chat_conversations", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      reservationId: varchar("reservation_id").notNull(),
      // Booking reference
      guestId: varchar("guest_id").notNull(),
      // Guest identifier
      propertyId: integer2("property_id").notNull(),
      // Conversation details
      conversationTitle: varchar("conversation_title"),
      status: varchar("status").default("active"),
      // active, closed, archived
      priority: varchar("priority").default("normal"),
      // low, normal, high, urgent
      // AI settings
      aiEnabled: boolean2("ai_enabled").default(true),
      aiLanguage: varchar("ai_language").default("en"),
      // Metadata
      lastMessageAt: timestamp2("last_message_at"),
      unreadGuestMessages: integer2("unread_guest_messages").default(0),
      unreadStaffMessages: integer2("unread_staff_messages").default(0),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at").defaultNow()
    });
    guestChatMessages = pgTable2("guest_chat_messages", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      conversationId: integer2("conversation_id").references(() => guestChatConversations.id).notNull(),
      // Message details
      messageType: varchar("message_type").notNull(),
      // guest_message, ai_response, staff_response, system_message
      senderType: varchar("sender_type").notNull(),
      // guest, ai, staff, system
      senderId: varchar("sender_id"),
      // User ID if staff message
      messageContent: text2("message_content").notNull(),
      // Message metadata
      isRead: boolean2("is_read").default(false),
      readBy: varchar("read_by"),
      // User ID who read the message
      readAt: timestamp2("read_at"),
      // AI processing
      aiProcessed: boolean2("ai_processed").default(false),
      intentDetected: varchar("intent_detected"),
      // service_request, complaint, question, compliment
      confidenceScore: decimal("confidence_score", { precision: 5, scale: 2 }),
      // 0-100
      sentAt: timestamp2("sent_at").defaultNow(),
      createdAt: timestamp2("created_at").defaultNow()
    });
    guestServiceRequests = pgTable2("guest_service_requests", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      conversationId: integer2("conversation_id").references(() => guestChatConversations.id),
      messageId: integer2("message_id").references(() => guestChatMessages.id),
      // Original message that triggered request
      reservationId: varchar("reservation_id").notNull(),
      guestId: varchar("guest_id").notNull(),
      propertyId: integer2("property_id").notNull(),
      // Request details
      requestType: varchar("request_type").notNull(),
      // maintenance, housekeeping, amenity, transport, food, other
      category: varchar("category").notNull(),
      // cleaning, repair, delivery, booking, complaint
      title: varchar("title").notNull(),
      description: text2("description").notNull(),
      priority: varchar("priority").default("normal"),
      // low, normal, high, urgent
      // Service details
      preferredDate: date("preferred_date"),
      preferredTime: varchar("preferred_time"),
      estimatedDuration: integer2("estimated_duration"),
      // minutes
      guestCount: integer2("guest_count").default(1),
      // Processing status
      status: varchar("status").default("pending"),
      // pending, approved, declined, in_progress, completed, cancelled
      approvedBy: varchar("approved_by"),
      // Staff member who approved
      approvedAt: timestamp2("approved_at"),
      declinedBy: varchar("declined_by"),
      declinedAt: timestamp2("declined_at"),
      declineReason: text2("decline_reason"),
      // Assignment
      assignedDepartment: varchar("assigned_department"),
      // housekeeping, maintenance, concierge
      assignedTo: varchar("assigned_to"),
      // Staff member assigned
      assignedAt: timestamp2("assigned_at"),
      // Costs and billing
      estimatedCost: decimal("estimated_cost", { precision: 10, scale: 2 }),
      finalCost: decimal("final_cost", { precision: 10, scale: 2 }),
      billingType: varchar("billing_type").default("guest_billable"),
      // guest_billable, owner_billable, company_expense, complimentary, split_billing
      chargeToGuest: boolean2("charge_to_guest").default(false),
      // Confirmation workflow
      awaitingConfirmation: boolean2("awaiting_confirmation").default(false),
      guestConfirmedAt: timestamp2("guest_confirmed_at"),
      adminConfirmedAt: timestamp2("admin_confirmed_at"),
      confirmationToken: varchar("confirmation_token"),
      // For secure confirmations
      // Completion
      completedAt: timestamp2("completed_at"),
      completionNotes: text2("completion_notes"),
      guestSatisfaction: integer2("guest_satisfaction"),
      // 1-5 rating
      guestFeedback: text2("guest_feedback"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at").defaultNow()
    });
    serviceRequestNotifications = pgTable2("service_request_notifications", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      serviceRequestId: integer2("service_request_id").references(() => guestServiceRequests.id).notNull(),
      reservationId: varchar("reservation_id").notNull(),
      propertyId: integer2("property_id").notNull(),
      // Notification details
      notificationType: varchar("notification_type").notNull(),
      // new_request, confirmation_needed, urgent, updated
      title: varchar("title").notNull(),
      message: text2("message").notNull(),
      priority: varchar("priority").default("normal"),
      // low, normal, high, urgent
      // Recipients
      notifyRoles: jsonb2("notify_roles"),
      // Array of roles to notify: ["admin", "portfolio-manager", "staff"]
      notifySpecificUsers: jsonb2("notify_specific_users"),
      // Array of specific user IDs
      // Status
      status: varchar("status").default("unread"),
      // unread, read, acknowledged, resolved
      readBy: jsonb2("read_by"),
      // Array of users who have read this notification
      acknowledgedBy: varchar("acknowledged_by"),
      // User who acknowledged/acted on notification
      acknowledgedAt: timestamp2("acknowledged_at"),
      // Actions
      actionRequired: boolean2("action_required").default(true),
      actionUrl: varchar("action_url"),
      // Direct link to review/approve screen
      actionLabel: varchar("action_label").default("Review & Confirm"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at").defaultNow()
    });
    guestPreArrivalInfo = pgTable2("guest_pre_arrival_info", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      reservationId: varchar("reservation_id").notNull(),
      guestId: varchar("guest_id").notNull(),
      propertyId: integer2("property_id").notNull(),
      // Arrival details
      arrivalDate: date("arrival_date").notNull(),
      estimatedArrivalTime: varchar("estimated_arrival_time"),
      flightNumber: varchar("flight_number"),
      transportMethod: varchar("transport_method"),
      // car, taxi, flight, transfer
      // Guest preferences
      dietaryRestrictions: jsonb2("dietary_restrictions"),
      // Array of restrictions
      allergies: jsonb2("allergies"),
      // Array of allergies
      specialRequests: text2("special_requests"),
      accessibilityNeeds: text2("accessibility_needs"),
      // Contact information
      emergencyContact: varchar("emergency_contact"),
      emergencyPhone: varchar("emergency_phone"),
      localContactNumber: varchar("local_contact_number"),
      // Pre-arrival services
      airportTransferRequested: boolean2("airport_transfer_requested").default(false),
      groceryStockingRequested: boolean2("grocery_stocking_requested").default(false),
      additionalCleaning: boolean2("additional_cleaning").default(false),
      // Information status
      infoCompleted: boolean2("info_completed").default(false),
      completedAt: timestamp2("completed_at"),
      unlocked48hBefore: boolean2("unlocked_48h_before").default(false),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at").defaultNow()
    });
    guestConfirmedExtras = pgTable2("guest_confirmed_extras", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      reservationId: varchar("reservation_id").notNull(),
      guestId: varchar("guest_id").notNull(),
      serviceRequestId: integer2("service_request_id").references(() => guestServiceRequests.id),
      // Service details
      serviceName: varchar("service_name").notNull(),
      serviceCategory: varchar("service_category").notNull(),
      // chef, cleaning, massage, transport
      serviceProvider: varchar("service_provider"),
      // Scheduling
      scheduledDate: date("scheduled_date").notNull(),
      scheduledTime: varchar("scheduled_time").notNull(),
      duration: integer2("duration"),
      // minutes
      // Pricing
      unitPrice: decimal("unit_price", { precision: 10, scale: 2 }).notNull(),
      quantity: integer2("quantity").default(1),
      totalCost: decimal("total_cost", { precision: 10, scale: 2 }).notNull(),
      // Status
      status: varchar("status").default("confirmed"),
      // confirmed, in_progress, completed, cancelled
      paymentStatus: varchar("payment_status").default("pending"),
      // pending, paid, refunded
      // Special instructions
      specialInstructions: text2("special_instructions"),
      guestNotes: text2("guest_notes"),
      providerNotes: text2("provider_notes"),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at").defaultNow()
    });
    reservationHistoryLog = pgTable2("reservation_history_log", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      reservationId: varchar("reservation_id").notNull(),
      // Activity details
      actionType: varchar("action_type").notNull(),
      // check_in, service_request, message, task_completion
      actionTitle: varchar("action_title").notNull(),
      actionDescription: text2("action_description"),
      performedBy: varchar("performed_by"),
      // User ID
      performedByType: varchar("performed_by_type"),
      // guest, staff, system
      // Visibility
      visibleToGuest: boolean2("visible_to_guest").default(true),
      // Metadata
      relatedEntityType: varchar("related_entity_type"),
      // task, service_request, message
      relatedEntityId: integer2("related_entity_id"),
      createdAt: timestamp2("created_at").defaultNow()
    });
    aiChatIntentAnalysis = pgTable2("ai_chat_intent_analysis", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      messageId: integer2("message_id").references(() => guestChatMessages.id).notNull(),
      // Analysis results
      detectedIntent: varchar("detected_intent").notNull(),
      // service_request, complaint, question, compliment
      confidenceScore: decimal("confidence_score", { precision: 5, scale: 2 }).notNull(),
      // 0-100
      // Extracted entities
      serviceCategory: varchar("service_category"),
      // maintenance, housekeeping, amenity
      urgency: varchar("urgency"),
      // low, normal, high, urgent
      sentiment: varchar("sentiment"),
      // positive, neutral, negative
      extractedEntities: jsonb2("extracted_entities"),
      // JSON of extracted information
      // Suggested actions
      suggestedActions: jsonb2("suggested_actions"),
      // Array of suggested responses/actions
      // Processing metadata
      aiModel: varchar("ai_model").default("gpt-4o"),
      processingTime: integer2("processing_time"),
      // milliseconds
      createdAt: timestamp2("created_at").defaultNow()
    });
    insertGuestChatConversationSchema = createInsertSchema2(guestChatConversations).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestChatMessageSchema = createInsertSchema2(guestChatMessages).omit({
      id: true,
      createdAt: true
    });
    insertGuestServiceRequestSchema = createInsertSchema2(guestServiceRequests).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestPreArrivalInfoSchema = createInsertSchema2(guestPreArrivalInfo).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestConfirmedExtrasSchema = createInsertSchema2(guestConfirmedExtras).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertReservationHistoryLogSchema = createInsertSchema2(reservationHistoryLog).omit({
      id: true,
      createdAt: true
    });
    insertAiChatIntentAnalysisSchema = createInsertSchema2(aiChatIntentAnalysis).omit({
      id: true,
      createdAt: true
    });
    insertServiceRequestNotificationSchema = createInsertSchema2(serviceRequestNotifications).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    propertyActivityRecommendations = pgTable2("property_activity_recommendations", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer2("property_id").notNull(),
      // Recommendation details
      category: varchar("category").notNull(),
      // restaurant, beach, tour, spa, market, viewpoint, activity
      title: varchar("title").notNull(),
      description: text2("description").notNull(),
      shortDescription: varchar("short_description", { length: 150 }),
      // Location and contact info
      address: text2("address"),
      googleMapsLink: text2("google_maps_link"),
      websiteUrl: text2("website_url"),
      phoneNumber: varchar("phone_number"),
      whatsappNumber: varchar("whatsapp_number"),
      // Booking and pricing
      bookingUrl: text2("booking_url"),
      estimatedPrice: varchar("estimated_price"),
      // e.g., "500-1000 THB per person"
      priceCategory: varchar("price_category"),
      // budget, moderate, luxury
      // Timing and availability
      operatingHours: varchar("operating_hours"),
      bestTimeToVisit: varchar("best_time_to_visit"),
      // morning, afternoon, evening, sunset
      durationNeeded: varchar("duration_needed"),
      // e.g., "2-3 hours", "Full day"
      // Target audience
      suitableFor: jsonb2("suitable_for"),
      // ["couples", "families", "solo", "groups"]
      ageGroup: varchar("age_group"),
      // all_ages, adults_only, family_friendly
      activityLevel: varchar("activity_level"),
      // relaxing, moderate, active, adventure
      // Admin settings
      displayOrder: integer2("display_order").default(1),
      isActive: boolean2("is_active").default(true),
      isFeatured: boolean2("is_featured").default(false),
      requiresAdvanceBooking: boolean2("requires_advance_booking").default(false),
      // Metadata
      tags: jsonb2("tags"),
      // ["romantic", "sunset", "authentic", "hidden_gem"]
      imageUrl: text2("image_url"),
      adminNotes: text2("admin_notes"),
      createdBy: varchar("created_by").notNull(),
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at").defaultNow()
    });
    guestActivityPreferences = pgTable2("guest_activity_preferences", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      reservationId: varchar("reservation_id").notNull(),
      guestId: varchar("guest_id").notNull(),
      propertyId: integer2("property_id").notNull(),
      // Preference categories
      preferredCategories: jsonb2("preferred_categories"),
      // ["restaurant", "beach", "spa"]
      travelStyle: varchar("travel_style"),
      // romantic, family, adventure, relaxation, cultural
      budgetPreference: varchar("budget_preference"),
      // budget, moderate, luxury, no_preference
      // Activity preferences
      activityLevel: varchar("activity_level"),
      // relaxing, moderate, active, mixed
      groupSize: integer2("group_size").default(2),
      hasChildren: boolean2("has_children").default(false),
      mobilityRequirements: varchar("mobility_requirements"),
      // none, wheelchair_accessible, limited_walking
      // Dietary and special needs
      dietaryRestrictions: jsonb2("dietary_restrictions"),
      // ["vegetarian", "gluten_free", "halal"]
      specialInterests: jsonb2("special_interests"),
      // ["photography", "history", "nature", "shopping"]
      // Interaction tracking
      viewedRecommendations: jsonb2("viewed_recommendations"),
      // Array of recommendation IDs
      clickedRecommendations: jsonb2("clicked_recommendations"),
      bookedActivities: jsonb2("booked_activities"),
      // Feedback
      lastUpdated: timestamp2("last_updated").defaultNow(),
      preferencesSetBy: varchar("preferences_set_by"),
      // guest, staff, ai_inferred
      createdAt: timestamp2("created_at").defaultNow(),
      updatedAt: timestamp2("updated_at").defaultNow()
    });
    guestRecommendationInteractions = pgTable2("guest_recommendation_interactions", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      reservationId: varchar("reservation_id").notNull(),
      guestId: varchar("guest_id").notNull(),
      recommendationId: integer2("recommendation_id").references(() => propertyActivityRecommendations.id).notNull(),
      // Interaction details
      interactionType: varchar("interaction_type").notNull(),
      // view, click, bookmark, book, rate
      sessionId: varchar("session_id"),
      deviceType: varchar("device_type"),
      // mobile, tablet, desktop
      // Context
      viewDuration: integer2("view_duration"),
      // seconds spent viewing
      clickedElement: varchar("clicked_element"),
      // website, booking, maps, phone
      bookingStatus: varchar("booking_status"),
      // attempted, completed, cancelled
      // Feedback
      rating: integer2("rating"),
      // 1-5 stars
      feedback: text2("feedback"),
      createdAt: timestamp2("created_at").defaultNow()
    });
    aiRecommendationAnalytics = pgTable2("ai_recommendation_analytics", {
      id: serial("id").primaryKey(),
      organizationId: varchar("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer2("property_id").notNull(),
      // Analytics period
      analysisDate: date("analysis_date").notNull(),
      periodType: varchar("period_type").default("daily"),
      // daily, weekly, monthly
      // Performance metrics
      totalRecommendationsShown: integer2("total_recommendations_shown").default(0),
      totalInteractions: integer2("total_interactions").default(0),
      totalBookings: integer2("total_bookings").default(0),
      clickThroughRate: decimal("click_through_rate", { precision: 5, scale: 4 }),
      conversionRate: decimal("conversion_rate", { precision: 5, scale: 4 }),
      // Category performance
      topPerformingCategory: varchar("top_performing_category"),
      categoryMetrics: jsonb2("category_metrics"),
      // {"restaurant": {"views": 50, "clicks": 10}}
      // Guest segmentation
      guestTypeMetrics: jsonb2("guest_type_metrics"),
      // {"couples": {...}, "families": {...}}
      preferenceAccuracy: decimal("preference_accuracy", { precision: 5, scale: 4 }),
      // AI model performance
      modelVersion: varchar("model_version").default("v1.0"),
      algorithmUsed: varchar("algorithm_used").default("collaborative_filtering"),
      confidenceScore: decimal("confidence_score", { precision: 5, scale: 4 }),
      createdAt: timestamp2("created_at").defaultNow()
    });
    insertPropertyActivityRecommendationSchema = createInsertSchema2(propertyActivityRecommendations).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestActivityPreferencesSchema = createInsertSchema2(guestActivityPreferences).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestRecommendationInteractionSchema = createInsertSchema2(guestRecommendationInteractions).omit({
      id: true,
      createdAt: true
    });
    insertAiRecommendationAnalyticsSchema = createInsertSchema2(aiRecommendationAnalytics).omit({
      id: true,
      createdAt: true
    });
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  accessChangeLog: () => accessChangeLog,
  achievementNotifications: () => achievementNotifications,
  achievementNotificationsRelations: () => achievementNotificationsRelations,
  achievements: () => achievements,
  achievementsRelations: () => achievementsRelations,
  addonBillingRules: () => addonBillingRules,
  addonBookings: () => addonBookings,
  addonBookingsRelations: () => addonBookingsRelations,
  addonServiceAvailability: () => addonServiceAvailability,
  addonServiceBookings: () => addonServiceBookings,
  addonServiceCatalog: () => addonServiceCatalog,
  addonServiceCategories: () => addonServiceCategories,
  addonServiceCommissions: () => addonServiceCommissions,
  addonServiceReports: () => addonServiceReports,
  addonServices: () => addonServices,
  addonServicesRelations: () => addonServicesRelations,
  adminOverridePermissions: () => adminOverridePermissions,
  agentBookingEnquiries: () => agentBookingEnquiries,
  agentBookingEnquiriesRelations: () => agentBookingEnquiriesRelations,
  agentBookingRequests: () => agentBookingRequests2,
  agentBookingRequestsRelations: () => agentBookingRequestsRelations,
  agentBookings: () => agentBookings,
  agentPayouts: () => agentPayouts,
  agentPayoutsRelations: () => agentPayoutsRelations,
  agentSearchPreferences: () => agentSearchPreferences,
  aiChatIntentAnalysis: () => aiChatIntentAnalysis,
  aiConfiguration: () => aiConfiguration,
  aiGeneratedTasks: () => aiGeneratedTasks2,
  aiGeneratedTasksRelations: () => aiGeneratedTasksRelations,
  aiMessageAnalysis: () => aiMessageAnalysis2,
  aiNotificationHistory: () => aiNotificationHistory,
  aiNotifications: () => aiNotifications,
  aiOpsAnomalies: () => aiOpsAnomalies,
  aiRecommendationAnalytics: () => aiRecommendationAnalytics,
  aiReminderSettings: () => aiReminderSettings,
  aiServiceCyclePredictions: () => aiServiceCyclePredictions,
  aiSmartSuggestions: () => aiSmartSuggestions,
  aiSmartSuggestionsRelations: () => aiSmartSuggestionsRelations,
  aiTaskEngine: () => aiTaskEngine,
  aiTaskRules: () => aiTaskRules,
  aiTaskSuggestions: () => aiTaskSuggestions,
  alertLogs: () => alertLogs,
  alertRules: () => alertRules,
  apiConnections: () => apiConnections,
  applianceRepairs: () => applianceRepairs,
  archivedTasks: () => archivedTasks,
  attendanceRecords: () => attendanceRecords,
  auditTrail: () => auditTrail,
  automationLogs: () => automationLogs,
  automations: () => automations,
  balanceOverrideHistory: () => balanceOverrideHistory,
  balanceResetAudit: () => balanceResetAudit,
  balanceResetAuditRelations: () => balanceResetAuditRelations,
  billReminders: () => billReminders,
  billingInvoiceLineItems: () => billingInvoiceLineItems2,
  billingInvoiceTemplates: () => billingInvoiceTemplates,
  billingInvoices: () => billingInvoices,
  billingTemplateLineItems: () => billingTemplateLineItems2,
  bookingIncomeRecords: () => bookingIncomeRecords,
  bookingIncomeRecordsRelations: () => bookingIncomeRecordsRelations,
  bookingLinkedTasks: () => bookingLinkedTasks,
  bookingPlatformRouting: () => bookingPlatformRouting,
  bookingPlatformSync: () => bookingPlatformSync,
  bookingRevenue: () => bookingRevenue,
  bookingRevenueCommissions: () => bookingRevenueCommissions,
  bookingRevenueCommissionsRelations: () => bookingRevenueCommissionsRelations,
  bookingRevenueRelations: () => bookingRevenueRelations,
  bookings: () => bookings,
  bookingsRelations: () => bookingsRelations,
  channelMembers: () => channelMembers,
  checkInOutDemoTasks: () => checkInOutDemoTasks2,
  checkInOutDemoTasksRelations: () => checkInOutDemoTasksRelations,
  codeRotationSchedule: () => codeRotationSchedule,
  commissionEarnings: () => commissionEarnings,
  commissionEarningsRelations: () => commissionEarningsRelations,
  commissionInvoiceItems: () => commissionInvoiceItems,
  commissionInvoices: () => commissionInvoices,
  commissionLog: () => commissionLog,
  commissionPayouts: () => commissionPayouts,
  commissionPayoutsRelations: () => commissionPayoutsRelations,
  communicationChannels: () => communicationChannels,
  communicationLogs: () => communicationLogs,
  contactTemplateZones: () => contactTemplateZones,
  currencyExchangeRates: () => currencyExchangeRates,
  currencyRates: () => currencyRates,
  customExpenseCategories: () => customExpenseCategories,
  customExpenseCategoriesRelations: () => customExpenseCategoriesRelations,
  dailyOperationsSummary: () => dailyOperationsSummary,
  dailyPropertyOperations: () => dailyPropertyOperations,
  dailyStaffAssignments: () => dailyStaffAssignments,
  damageReports: () => damageReports,
  departmentBudgets: () => departmentBudgets,
  documentAccessLogs: () => documentAccessLogs2,
  documentCategories: () => documentCategories2,
  dynamicPricingRecommendations: () => dynamicPricingRecommendations,
  emergencyTaskBonuses: () => emergencyTaskBonuses,
  emergencyWaterDeliveries: () => emergencyWaterDeliveries,
  emergencyWaterDeliveriesRelations: () => emergencyWaterDeliveriesRelations,
  enhancedAiSuggestions: () => enhancedAiSuggestions2,
  enhancedFinanceTransactionLogs: () => enhancedFinanceTransactionLogs2,
  enhancedFinanceTransactionLogsRelations: () => enhancedFinanceTransactionLogsRelations,
  fastActionSuggestions: () => fastActionSuggestions2,
  feedbackProcessingLog: () => feedbackProcessingLog,
  fileUploadSessions: () => fileUploadSessions2,
  financeExportLogs: () => financeExportLogs,
  financeReportTemplates: () => financeReportTemplates,
  finances: () => finances,
  financesRelations: () => financesRelations,
  financialTransactions: () => financialTransactions2,
  freelancerAvailability: () => freelancerAvailability,
  freelancerTaskRequests: () => freelancerTaskRequests,
  generatedInvoices: () => generatedInvoices2,
  generatedInvoicesRelations: () => generatedInvoicesRelations,
  guestAccessSessions: () => guestAccessSessions,
  guestActivityPreferences: () => guestActivityPreferences,
  guestActivityTimeline: () => guestActivityTimeline,
  guestAddonBookings: () => guestAddonBookings,
  guestAddonBookingsRelations: () => guestAddonBookingsRelations,
  guestAddonServiceRequests: () => guestAddonServiceRequests,
  guestAddonServices: () => guestAddonServices,
  guestAddonServicesRelations: () => guestAddonServicesRelations,
  guestAiFaqKnowledge: () => guestAiFaqKnowledge,
  guestAiRecommendations: () => guestAiRecommendations,
  guestAiRecommendationsRelations: () => guestAiRecommendationsRelations,
  guestBookings: () => guestBookings,
  guestBookingsRelations: () => guestBookingsRelations,
  guestChatConversations: () => guestChatConversations,
  guestChatMessages: () => guestChatMessages,
  guestCheckIns: () => guestCheckIns2,
  guestCheckInsRelations: () => guestCheckInsRelations,
  guestCheckOuts: () => guestCheckOuts2,
  guestCheckOutsRelations: () => guestCheckOutsRelations,
  guestCheckoutSurveys: () => guestCheckoutSurveys2,
  guestCommunicationNotifications: () => guestCommunicationNotifications,
  guestCommunicationNotificationsRelations: () => guestCommunicationNotificationsRelations,
  guestConfirmedExtras: () => guestConfirmedExtras,
  guestConfirmedServices: () => guestConfirmedServices,
  guestDashboardAnalytics: () => guestDashboardAnalytics,
  guestFeedback: () => guestFeedback,
  guestIdScans: () => guestIdScans,
  guestLoyaltyProfiles: () => guestLoyaltyProfiles2,
  guestMaintenanceReports: () => guestMaintenanceReports,
  guestMessages: () => guestMessages2,
  guestMessagesRelations: () => guestMessagesRelations,
  guestPortalAccess: () => guestPortalAccess,
  guestPortalAccessRelations: () => guestPortalAccessRelations,
  guestPortalSessions: () => guestPortalSessions,
  guestPortalSettings: () => guestPortalSettings,
  guestPortalSettingsRelations: () => guestPortalSettingsRelations,
  guestPreArrivalInfo: () => guestPreArrivalInfo,
  guestPropertyLocalInfo: () => guestPropertyLocalInfo,
  guestRecommendationInteractions: () => guestRecommendationInteractions,
  guestServiceRequests: () => guestServiceRequests2,
  guestServiceTimeline: () => guestServiceTimeline,
  guestServiceTimelineRelations: () => guestServiceTimelineRelations,
  guestSmartRequests: () => guestSmartRequests,
  impersonationSessions: () => impersonationSessions,
  insertAccessChangeLogSchema: () => insertAccessChangeLogSchema,
  insertAchievementNotificationSchema: () => insertAchievementNotificationSchema,
  insertAchievementSchema: () => insertAchievementSchema,
  insertAddonBillingRuleSchema: () => insertAddonBillingRuleSchema,
  insertAddonBookingSchema: () => insertAddonBookingSchema,
  insertAddonServiceAvailabilitySchema: () => insertAddonServiceAvailabilitySchema,
  insertAddonServiceBookingSchema: () => insertAddonServiceBookingSchema,
  insertAddonServiceCatalogSchema: () => insertAddonServiceCatalogSchema,
  insertAddonServiceCategorySchema: () => insertAddonServiceCategorySchema,
  insertAddonServiceCommissionSchema: () => insertAddonServiceCommissionSchema,
  insertAddonServiceReportSchema: () => insertAddonServiceReportSchema,
  insertAddonServiceSchema: () => insertAddonServiceSchema,
  insertAdminOverridePermissionSchema: () => insertAdminOverridePermissionSchema,
  insertAgentBookingEnquiriesSchema: () => insertAgentBookingEnquiriesSchema,
  insertAgentBookingRequestSchema: () => insertAgentBookingRequestSchema,
  insertAgentPayoutsSchema: () => insertAgentPayoutsSchema,
  insertAgentSearchPreferencesSchema: () => insertAgentSearchPreferencesSchema,
  insertAiChatIntentAnalysisSchema: () => insertAiChatIntentAnalysisSchema,
  insertAiConfigurationSchema: () => insertAiConfigurationSchema,
  insertAiMessageAnalysisSchema: () => insertAiMessageAnalysisSchema,
  insertAiNotificationHistorySchema: () => insertAiNotificationHistorySchema,
  insertAiNotificationSchema: () => insertAiNotificationSchema,
  insertAiOpsAnomalySchema: () => insertAiOpsAnomalySchema,
  insertAiRecommendationAnalyticsSchema: () => insertAiRecommendationAnalyticsSchema,
  insertAiReminderSettingSchema: () => insertAiReminderSettingSchema,
  insertAiServiceCyclePredictionSchema: () => insertAiServiceCyclePredictionSchema,
  insertAiTaskEngineSchema: () => insertAiTaskEngineSchema,
  insertAiTaskRuleSchema: () => insertAiTaskRuleSchema,
  insertAlertLogSchema: () => insertAlertLogSchema,
  insertAlertRuleSchema: () => insertAlertRuleSchema,
  insertApiConnectionSchema: () => insertApiConnectionSchema,
  insertApplianceRepairSchema: () => insertApplianceRepairSchema,
  insertAttendanceRecordSchema: () => insertAttendanceRecordSchema,
  insertAuditTrailSchema: () => insertAuditTrailSchema,
  insertAutomationLogSchema: () => insertAutomationLogSchema,
  insertAutomationSchema: () => insertAutomationSchema,
  insertBalanceOverrideHistorySchema: () => insertBalanceOverrideHistorySchema,
  insertBalanceResetAuditSchema: () => insertBalanceResetAuditSchema,
  insertBillReminderSchema: () => insertBillReminderSchema,
  insertBillingInvoiceLineItemSchema: () => insertBillingInvoiceLineItemSchema,
  insertBillingInvoiceSchema: () => insertBillingInvoiceSchema,
  insertBillingInvoiceTemplateSchema: () => insertBillingInvoiceTemplateSchema,
  insertBillingTemplateLineItemSchema: () => insertBillingTemplateLineItemSchema,
  insertBookingIncomeRecordSchema: () => insertBookingIncomeRecordSchema,
  insertBookingLinkedTaskSchema: () => insertBookingLinkedTaskSchema,
  insertBookingPlatformRoutingSchema: () => insertBookingPlatformRoutingSchema,
  insertBookingPlatformSyncSchema: () => insertBookingPlatformSyncSchema,
  insertBookingRevenueCommissionsSchema: () => insertBookingRevenueCommissionsSchema,
  insertBookingRevenueSchema: () => insertBookingRevenueSchema,
  insertBookingSchema: () => insertBookingSchema,
  insertChannelMemberSchema: () => insertChannelMemberSchema,
  insertCheckInOutDemoTaskSchema: () => insertCheckInOutDemoTaskSchema,
  insertCodeRotationScheduleSchema: () => insertCodeRotationScheduleSchema,
  insertCommissionEarningSchema: () => insertCommissionEarningSchema,
  insertCommissionInvoiceItemsSchema: () => insertCommissionInvoiceItemsSchema,
  insertCommissionInvoicesSchema: () => insertCommissionInvoicesSchema,
  insertCommissionLogSchema: () => insertCommissionLogSchema,
  insertCommissionPayoutSchema: () => insertCommissionPayoutSchema,
  insertCommunicationChannelSchema: () => insertCommunicationChannelSchema,
  insertCommunicationLogSchema: () => insertCommunicationLogSchema,
  insertCurrencyExchangeRateSchema: () => insertCurrencyExchangeRateSchema,
  insertCurrencyRateSchema: () => insertCurrencyRateSchema,
  insertCustomExpenseCategorySchema: () => insertCustomExpenseCategorySchema,
  insertDailyOperationsSummarySchema: () => insertDailyOperationsSummarySchema,
  insertDailyPropertyOperationsSchema: () => insertDailyPropertyOperationsSchema,
  insertDailyStaffAssignmentsSchema: () => insertDailyStaffAssignmentsSchema,
  insertDamageReportSchema: () => insertDamageReportSchema,
  insertDepartmentBudgetSchema: () => insertDepartmentBudgetSchema,
  insertDynamicPricingRecommendationSchema: () => insertDynamicPricingRecommendationSchema,
  insertEmergencyWaterDeliverySchema: () => insertEmergencyWaterDeliverySchema,
  insertEnhancedFinanceTransactionLogSchema: () => insertEnhancedFinanceTransactionLogSchema,
  insertFeedbackProcessingLogSchema: () => insertFeedbackProcessingLogSchema,
  insertFinanceExportLogSchema: () => insertFinanceExportLogSchema,
  insertFinanceReportTemplateSchema: () => insertFinanceReportTemplateSchema,
  insertFinanceSchema: () => insertFinanceSchema,
  insertFinancialTransactionSchema: () => insertFinancialTransactionSchema,
  insertGeneratedInvoiceSchema: () => insertGeneratedInvoiceSchema,
  insertGuestAccessSessionSchema: () => insertGuestAccessSessionSchema,
  insertGuestActivityPreferencesSchema: () => insertGuestActivityPreferencesSchema,
  insertGuestActivityTimelineSchema: () => insertGuestActivityTimelineSchema,
  insertGuestAddonBookingSchema: () => insertGuestAddonBookingSchema,
  insertGuestAddonServiceRequestSchema: () => insertGuestAddonServiceRequestSchema,
  insertGuestAddonServiceSchema: () => insertGuestAddonServiceSchema,
  insertGuestAiFaqKnowledgeSchema: () => insertGuestAiFaqKnowledgeSchema,
  insertGuestAiRecommendationSchema: () => insertGuestAiRecommendationSchema,
  insertGuestBookingSchema: () => insertGuestBookingSchema,
  insertGuestChatConversationSchema: () => insertGuestChatConversationSchema,
  insertGuestChatMessageSchema: () => insertGuestChatMessageSchema,
  insertGuestCheckInSchema: () => insertGuestCheckInSchema,
  insertGuestCheckOutSchema: () => insertGuestCheckOutSchema,
  insertGuestCheckoutSurveySchema: () => insertGuestCheckoutSurveySchema,
  insertGuestConfirmedExtrasSchema: () => insertGuestConfirmedExtrasSchema,
  insertGuestConfirmedServiceSchema: () => insertGuestConfirmedServiceSchema,
  insertGuestFeedbackSchema: () => insertGuestFeedbackSchema,
  insertGuestIdScanSchema: () => insertGuestIdScanSchema,
  insertGuestLoyaltyProfileSchema: () => insertGuestLoyaltyProfileSchema,
  insertGuestMaintenanceReportSchema: () => insertGuestMaintenanceReportSchema,
  insertGuestMessageSchema: () => insertGuestMessageSchema,
  insertGuestPortalAccessSchema: () => insertGuestPortalAccessSchema,
  insertGuestPortalSessionSchema: () => insertGuestPortalSessionSchema,
  insertGuestPreArrivalInfoSchema: () => insertGuestPreArrivalInfoSchema,
  insertGuestPropertyLocalInfoSchema: () => insertGuestPropertyLocalInfoSchema,
  insertGuestRecommendationInteractionSchema: () => insertGuestRecommendationInteractionSchema,
  insertGuestServiceRequestSchema: () => insertGuestServiceRequestSchema2,
  insertGuestServiceTimelineSchema: () => insertGuestServiceTimelineSchema,
  insertGuestSmartRequestSchema: () => insertGuestSmartRequestSchema,
  insertImpersonationSessionSchema: () => insertImpersonationSessionSchema,
  insertInternalMessageSchema: () => insertInternalMessageSchema,
  insertInventorySchema: () => insertInventorySchema,
  insertInvoiceBookingLinkSchema: () => insertInvoiceBookingLinkSchema,
  insertInvoiceLineItemSchema: () => insertInvoiceLineItemSchema,
  insertInvoiceServiceLinkSchema: () => insertInvoiceServiceLinkSchema,
  insertInvoiceTemplateSchema: () => insertInvoiceTemplateSchema,
  insertLeaveRequestSchema: () => insertLeaveRequestSchema,
  insertLegalTemplateSchema: () => insertLegalTemplateSchema,
  insertLiveBookingCalendarSchema: () => insertLiveBookingCalendarSchema,
  insertLoyaltyTierSchema: () => insertLoyaltyTierSchema,
  insertMaintenanceAiSuggestionSchema: () => insertMaintenanceAiSuggestionSchema,
  insertMaintenanceApprovalLogSchema: () => insertMaintenanceApprovalLogSchema,
  insertMaintenanceBudgetForecastSchema: () => insertMaintenanceBudgetForecastSchema,
  insertMaintenanceCostAnalyticsSchema: () => insertMaintenanceCostAnalyticsSchema,
  insertMaintenanceIssueSchema: () => insertMaintenanceIssueSchema,
  insertMaintenanceLogSchema: () => insertMaintenanceLogSchema,
  insertMaintenanceServiceIntervalSchema: () => insertMaintenanceServiceIntervalSchema,
  insertMaintenanceSuggestionSchema: () => insertMaintenanceSuggestionSchema,
  insertMaintenanceSuggestionSettingsSchema: () => insertMaintenanceSuggestionSettingsSchema,
  insertMaintenanceTaskSuggestionSchema: () => insertMaintenanceTaskSuggestionSchema,
  insertMaintenanceTimelineEntrySchema: () => insertMaintenanceTimelineEntrySchema,
  insertMarketingPackSchema: () => insertMarketingPackSchema,
  insertMarketplaceServiceSchema: () => insertMarketplaceServiceSchema,
  insertMessageDeliverySchema: () => insertMessageDeliverySchema,
  insertMessagingTriggerSchema: () => insertMessagingTriggerSchema,
  insertMonthlyExportLogSchema: () => insertMonthlyExportLogSchema,
  insertMonthlyPayrollRecordSchema: () => insertMonthlyPayrollRecordSchema,
  insertMultiCurrencyFinanceSchema: () => insertMultiCurrencyFinanceSchema,
  insertNotificationPreferenceSchema: () => insertNotificationPreferenceSchema,
  insertNotificationSchema: () => insertNotificationSchema,
  insertOccupancyRateSchema: () => insertOccupancyRateSchema,
  insertOfflineTaskCacheSchema: () => insertOfflineTaskCacheSchema,
  insertOrganizationApiKeySchema: () => insertOrganizationApiKeySchema,
  insertOrganizationSchema: () => insertOrganizationSchema,
  insertOtaPlatformSettingsSchema: () => insertOtaPlatformSettingsSchema,
  insertOwnerActivityTimelineSchema: () => insertOwnerActivityTimelineSchema,
  insertOwnerBalanceRequestSchema: () => insertOwnerBalanceRequestSchema,
  insertOwnerBalanceSchema: () => insertOwnerBalanceSchema,
  insertOwnerBalanceTrackerSchema: () => insertOwnerBalanceTrackerSchema,
  insertOwnerChargeRequestSchema: () => insertOwnerChargeRequestSchema,
  insertOwnerDebtTrackerSchema: () => insertOwnerDebtTrackerSchema,
  insertOwnerInvoiceSchema: () => insertOwnerInvoiceSchema,
  insertOwnerPaymentLogSchema: () => insertOwnerPaymentLogSchema,
  insertOwnerPayoutRequestSchema: () => insertOwnerPayoutRequestSchema,
  insertOwnerPayoutSchema: () => insertOwnerPayoutSchema,
  insertOwnerPmCommunicationSchema: () => insertOwnerPmCommunicationSchema,
  insertOwnerPreferencesSchema: () => insertOwnerPreferencesSchema,
  insertOwnerSettingsSchema: () => insertOwnerSettingsSchema,
  insertOwnerStatementExportSchema: () => insertOwnerStatementExportSchema,
  insertPaySlipSchema: () => insertPaySlipSchema,
  insertPaymentConfirmationSchema: () => insertPaymentConfirmationSchema,
  insertPayoutRoutingRuleSchema: () => insertPayoutRoutingRuleSchema,
  insertPayrollRecordSchema: () => insertPayrollRecordSchema,
  insertPermissionPresetSchema: () => insertPermissionPresetSchema,
  insertPlatformAnalyticsSchema: () => insertPlatformAnalyticsSchema,
  insertPlatformRoutingRuleSchema: () => insertPlatformRoutingRuleSchema,
  insertPlatformSettingSchema: () => insertPlatformSettingSchema,
  insertPortfolioAssignmentSchema: () => insertPortfolioAssignmentSchema,
  insertPortfolioHealthScoreSchema: () => insertPortfolioHealthScoreSchema,
  insertPortfolioManagerAssignmentSchema: () => insertPortfolioManagerAssignmentSchema,
  insertPortfolioManagerCommissionSchema: () => insertPortfolioManagerCommissionSchema,
  insertPropertyAccessCredentialSchema: () => insertPropertyAccessCredentialSchema,
  insertPropertyAccessPhotoSchema: () => insertPropertyAccessPhotoSchema,
  insertPropertyActivityRecommendationSchema: () => insertPropertyActivityRecommendationSchema,
  insertPropertyAgentsSchema: () => insertPropertyAgentsSchema,
  insertPropertyAlertSchema: () => insertPropertyAlertSchema,
  insertPropertyAmenitySchema: () => insertPropertyAmenitySchema,
  insertPropertyApplianceSchema: () => insertPropertyApplianceSchema,
  insertPropertyAvailabilitySchema: () => insertPropertyAvailabilitySchema,
  insertPropertyChatMessageSchema: () => insertPropertyChatMessageSchema,
  insertPropertyCommissionRuleSchema: () => insertPropertyCommissionRuleSchema,
  insertPropertyCustomExpensesSchema: () => insertPropertyCustomExpensesSchema,
  insertPropertyDocumentSchema: () => insertPropertyDocumentSchema,
  insertPropertyElectricitySettingsSchema: () => insertPropertyElectricitySettingsSchema,
  insertPropertyFinanceSettingsSchema: () => insertPropertyFinanceSettingsSchema,
  insertPropertyGuideSchema: () => insertPropertyGuideSchema,
  insertPropertyInfoSummarySchema: () => insertPropertyInfoSummarySchema,
  insertPropertyInsuranceSchema: () => insertPropertyInsuranceSchema,
  insertPropertyInternalNotesSchema: () => insertPropertyInternalNotesSchema,
  insertPropertyInvestmentSchema: () => insertPropertyInvestmentSchema,
  insertPropertyMaintenanceHistorySchema: () => insertPropertyMaintenanceHistorySchema,
  insertPropertyMarketingMediaSchema: () => insertPropertyMarketingMediaSchema,
  insertPropertyMediaSchema: () => insertPropertyMediaSchema,
  insertPropertyOccupancyAnalyticsSchema: () => insertPropertyOccupancyAnalyticsSchema,
  insertPropertyPayoutRuleSchema: () => insertPropertyPayoutRuleSchema,
  insertPropertyPayoutSettingsSchema: () => insertPropertyPayoutSettingsSchema,
  insertPropertyPlatformRuleSchema: () => insertPropertyPlatformRuleSchema,
  insertPropertyReferralSchema: () => insertPropertyReferralSchema,
  insertPropertyReviewSchema: () => insertPropertyReviewSchema,
  insertPropertySchema: () => insertPropertySchema,
  insertPropertySearchIndexSchema: () => insertPropertySearchIndexSchema,
  insertPropertyServiceHistorySchema: () => insertPropertyServiceHistorySchema,
  insertPropertyStatusSchema: () => insertPropertyStatusSchema,
  insertPropertyTaskBillingSchema: () => insertPropertyTaskBillingSchema,
  insertPropertyTimelineEventSchema: () => insertPropertyTimelineEventSchema,
  insertPropertyUtilityAccountEnhancedSchema: () => insertPropertyUtilityAccountEnhancedSchema,
  insertPropertyUtilityAccountSchema: () => insertPropertyUtilityAccountSchema,
  insertPropertyUtilitySchema: () => insertPropertyUtilitySchema,
  insertPropertyUtilitySettingsSchema: () => insertPropertyUtilitySettingsSchema,
  insertQuickbooksIntegrationSchema: () => insertQuickbooksIntegrationSchema,
  insertRecurringServiceBillSchema: () => insertRecurringServiceBillSchema,
  insertRecurringServiceChargeSchema: () => insertRecurringServiceChargeSchema,
  insertRecurringServiceSchema: () => insertRecurringServiceSchema,
  insertRecurringTaskAnalyticsSchema: () => insertRecurringTaskAnalyticsSchema,
  insertRecurringTaskSchema: () => insertRecurringTaskSchema,
  insertReferralAgentCommissionLogSchema: () => insertReferralAgentCommissionLogSchema,
  insertReferralEarningsSchema: () => insertReferralEarningsSchema,
  insertReferralProgramRulesSchema: () => insertReferralProgramRulesSchema,
  insertReportSchema: () => insertReportSchema,
  insertReservationHistoryLogSchema: () => insertReservationHistoryLogSchema,
  insertRolePermissionSchema: () => insertRolePermissionSchema,
  insertRoutingAuditLogSchema: () => insertRoutingAuditLogSchema,
  insertSeasonalForecastSchema: () => insertSeasonalForecastSchema,
  insertSecurityDepositSchema: () => insertSecurityDepositSchema,
  insertServiceAnalyticsSchema: () => insertServiceAnalyticsSchema,
  insertServiceBookingSchema: () => insertServiceBookingSchema,
  insertServiceCategorySchema: () => insertServiceCategorySchema,
  insertServicePerformanceSchema: () => insertServicePerformanceSchema,
  insertServiceRequestNotificationSchema: () => insertServiceRequestNotificationSchema,
  insertServiceReviewSchema: () => insertServiceReviewSchema,
  insertServiceVendorSchema: () => insertServiceVendorSchema,
  insertSharedCostSchema: () => insertSharedCostSchema,
  insertSharedCostSplitSchema: () => insertSharedCostSplitSchema,
  insertSmartLockSyncLogSchema: () => insertSmartLockSyncLogSchema,
  insertSmartReplySuggestionSchema: () => insertSmartReplySuggestionSchema,
  insertSmartRequestConfigSchema: () => insertSmartRequestConfigSchema,
  insertStaffAdvanceRequestSchema: () => insertStaffAdvanceRequestSchema,
  insertStaffClockAuditLogSchema: () => insertStaffClockAuditLogSchema,
  insertStaffClockEntrySchema: () => insertStaffClockEntrySchema,
  insertStaffClockSettingsSchema: () => insertStaffClockSettingsSchema,
  insertStaffCommissionSchema: () => insertStaffCommissionSchema,
  insertStaffDocumentSchema: () => insertStaffDocumentSchema,
  insertStaffExpensesSchema: () => insertStaffExpensesSchema,
  insertStaffMemberSchema: () => insertStaffMemberSchema,
  insertStaffMonthlySummarySchema: () => insertStaffMonthlySummarySchema,
  insertStaffOvertimeLogSchema: () => insertStaffOvertimeLogSchema,
  insertStaffOvertimeSettingsSchema: () => insertStaffOvertimeSettingsSchema,
  insertStaffPayrollRecordSchema: () => insertStaffPayrollRecordSchema,
  insertStaffProfileSchema: () => insertStaffProfileSchema,
  insertStaffSalariesSchema: () => insertStaffSalariesSchema,
  insertStaffSkillSchema: () => insertStaffSkillSchema,
  insertStaffTimeSummarySchema: () => insertStaffTimeSummarySchema,
  insertStaffWorkClockSchema: () => insertStaffWorkClockSchema,
  insertStaffWorkloadStatsSchema: () => insertStaffWorkloadStatsSchema,
  insertSupplyOrderSchema: () => insertSupplyOrderSchema,
  insertSurveyAlertSchema: () => insertSurveyAlertSchema,
  insertSurveyAnalyticsSchema: () => insertSurveyAnalyticsSchema,
  insertSurveySettingsSchema: () => insertSurveySettingsSchema,
  insertSustainabilityMetricSchema: () => insertSustainabilityMetricSchema,
  insertTaskAiScanResultSchema: () => insertTaskAiScanResultSchema,
  insertTaskAutoGenRuleSchema: () => insertTaskAutoGenRuleSchema,
  insertTaskChecklistSchema: () => insertTaskChecklistSchema,
  insertTaskChecklistsSchema: () => insertTaskChecklistsSchema,
  insertTaskCompletionSchema: () => insertTaskCompletionSchema,
  insertTaskCompletionsSchema: () => insertTaskCompletionsSchema,
  insertTaskDepartmentStatsSchema: () => insertTaskDepartmentStatsSchema,
  insertTaskEvidenceSchema: () => insertTaskEvidenceSchema,
  insertTaskGenerationLogSchema: () => insertTaskGenerationLogSchema,
  insertTaskHistorySchema: () => insertTaskHistorySchema,
  insertTaskNotificationRuleSchema: () => insertTaskNotificationRuleSchema,
  insertTaskPerformanceLogSchema: () => insertTaskPerformanceLogSchema,
  insertTaskProofUploadSchema: () => insertTaskProofUploadSchema,
  insertTaskScheduleSchema: () => insertTaskScheduleSchema,
  insertTaskSchedulingAlertSchema: () => insertTaskSchedulingAlertSchema,
  insertTaskSchedulingRuleSchema: () => insertTaskSchedulingRuleSchema,
  insertTaskSchema: () => insertTaskSchema,
  insertTaxRuleSchema: () => insertTaxRuleSchema,
  insertTechnicianPerformanceSchema: () => insertTechnicianPerformanceSchema,
  insertUniversalInvoiceLineItemSchema: () => insertUniversalInvoiceLineItemSchema,
  insertUniversalInvoiceSchema: () => insertUniversalInvoiceSchema,
  insertUpsellRecommendationSchema: () => insertUpsellRecommendationSchema,
  insertUserAchievementSchema: () => insertUserAchievementSchema,
  insertUserGameStatsSchema: () => insertUserGameStatsSchema,
  insertUserPermissionOverrideSchema: () => insertUserPermissionOverrideSchema,
  insertUserSchema: () => insertUserSchema,
  insertUtilityAiReminderSchema: () => insertUtilityAiReminderSchema,
  insertUtilityAlertRuleSchema: () => insertUtilityAlertRuleSchema,
  insertUtilityBillAlertSchema: () => insertUtilityBillAlertSchema,
  insertUtilityBillHistorySchema: () => insertUtilityBillHistorySchema,
  insertUtilityBillLogEnhancedSchema: () => insertUtilityBillLogEnhancedSchema,
  insertUtilityBillProcessingSchema: () => insertUtilityBillProcessingSchema,
  insertUtilityBillReminderSchema: () => insertUtilityBillReminderSchema,
  insertUtilityBillSchema: () => insertUtilityBillSchema,
  insertUtilityProviderSchema: () => insertUtilityProviderSchema,
  insertVendorSchema: () => insertVendorSchema,
  insertWarrantyAlertSchema: () => insertWarrantyAlertSchema,
  insertWaterDeliveryAlertSchema: () => insertWaterDeliveryAlertSchema,
  insertWaterUpgradeSuggestionSchema: () => insertWaterUpgradeSuggestionSchema,
  insertWelcomePackItemSchema: () => insertWelcomePackItemSchema,
  insertWelcomePackTemplateSchema: () => insertWelcomePackTemplateSchema,
  insertWelcomePackUsageSchema: () => insertWelcomePackUsageSchema,
  insertWhatsappBotLogSchema: () => insertWhatsappBotLogSchema,
  internalMessages: () => internalMessages,
  inventory: () => inventory,
  inventoryItems: () => inventoryItems2,
  inventoryRelations: () => inventoryRelations,
  inventoryUsageLogs: () => inventoryUsageLogs2,
  invoiceBookingLinks: () => invoiceBookingLinks2,
  invoiceBookingLinksRelations: () => invoiceBookingLinksRelations,
  invoiceGenerationLog: () => invoiceGenerationLog,
  invoiceLineItems: () => invoiceLineItems2,
  invoiceLineItemsRelations: () => invoiceLineItemsRelations,
  invoiceServiceLinks: () => invoiceServiceLinks2,
  invoiceServiceLinksRelations: () => invoiceServiceLinksRelations,
  invoiceTemplates: () => invoiceTemplates2,
  invoiceTemplatesRelations: () => invoiceTemplatesRelations,
  invoices: () => invoices,
  leaveRequests: () => leaveRequests,
  legalTemplates: () => legalTemplates,
  liveBookingCalendar: () => liveBookingCalendar,
  liveBookingCalendarRelations: () => liveBookingCalendarRelations,
  loyaltyTiers: () => loyaltyTiers2,
  maintenanceAiSuggestions: () => maintenanceAiSuggestions,
  maintenanceApprovalLogs: () => maintenanceApprovalLogs,
  maintenanceBudgetForecasts: () => maintenanceBudgetForecasts,
  maintenanceCostAnalytics: () => maintenanceCostAnalytics,
  maintenanceIssues: () => maintenanceIssues,
  maintenanceLog: () => maintenanceLog,
  maintenanceServiceIntervals: () => maintenanceServiceIntervals,
  maintenanceSuggestionSettings: () => maintenanceSuggestionSettings,
  maintenanceSuggestions: () => maintenanceSuggestions,
  maintenanceTaskSuggestions: () => maintenanceTaskSuggestions,
  maintenanceTimelineEntries: () => maintenanceTimelineEntries,
  marketingPacks: () => marketingPacks,
  marketplaceServices: () => marketplaceServices,
  messageDeliveries: () => messageDeliveries2,
  messagingTriggers: () => messagingTriggers2,
  monthlyExportLogs: () => monthlyExportLogs,
  monthlyPayroll: () => monthlyPayroll,
  monthlyPayrollRecords: () => monthlyPayrollRecords,
  multiCurrencyFinances: () => multiCurrencyFinances,
  notificationPreferences: () => notificationPreferences,
  notificationPreferencesRelations: () => notificationPreferencesRelations,
  notifications: () => notifications,
  notificationsRelations: () => notificationsRelations,
  occupancyRates: () => occupancyRates,
  offlineTaskCache: () => offlineTaskCache,
  organizationApiKeys: () => organizationApiKeys,
  organizations: () => organizations,
  otaBookingPayouts: () => otaBookingPayouts,
  otaPayoutAlerts: () => otaPayoutAlerts,
  otaPayoutRules: () => otaPayoutRules,
  otaPlatformSettings: () => otaPlatformSettings,
  otaPlatformSettingsRelations: () => otaPlatformSettingsRelations,
  otaRevenueReports: () => otaRevenueReports,
  ownerActivityTimeline: () => ownerActivityTimeline,
  ownerBalanceRequests: () => ownerBalanceRequests,
  ownerBalanceRequestsRelations: () => ownerBalanceRequestsRelations,
  ownerBalanceTracker: () => ownerBalanceTracker2,
  ownerBalanceTrackerRelations: () => ownerBalanceTrackerRelations,
  ownerBalanceTrackers: () => ownerBalanceTrackers,
  ownerBalances: () => ownerBalances2,
  ownerChargeRequests: () => ownerChargeRequests2,
  ownerDebtTrackers: () => ownerDebtTrackers,
  ownerInvoices: () => ownerInvoices,
  ownerOnboardingChecklists: () => ownerOnboardingChecklists2,
  ownerPaymentLogs: () => ownerPaymentLogs,
  ownerPayoutRequests: () => ownerPayoutRequests,
  ownerPayouts: () => ownerPayouts,
  ownerPayoutsRelations: () => ownerPayoutsRelations,
  ownerPmCommunication: () => ownerPmCommunication,
  ownerPreferences: () => ownerPreferences,
  ownerSettings: () => ownerSettings,
  ownerStatementExports: () => ownerStatementExports,
  ownerStatementExportsRelations: () => ownerStatementExportsRelations,
  paySlips: () => paySlips,
  paymentConfirmations: () => paymentConfirmations,
  payoutRoutingRules: () => payoutRoutingRules2,
  payoutRoutingRulesRelations: () => payoutRoutingRulesRelations,
  payrollRecordRelations: () => payrollRecordRelations,
  payrollRecords: () => payrollRecords,
  payrollSummary: () => payrollSummary,
  permissionPresets: () => permissionPresets,
  platformAnalytics: () => platformAnalytics,
  platformAnalyticsRelations: () => platformAnalyticsRelations,
  platformRoutingRules: () => platformRoutingRules,
  platformSettings: () => platformSettings,
  platformSettingsRelations: () => platformSettingsRelations,
  pmCommissionBalance: () => pmCommissionBalance2,
  pmCommissionBalanceRelations: () => pmCommissionBalanceRelations,
  pmNotifications: () => pmNotifications2,
  pmNotificationsRelations: () => pmNotificationsRelations,
  pmPayoutRequests: () => pmPayoutRequests,
  pmPayoutRequestsRelations: () => pmPayoutRequestsRelations,
  pmPropertyPerformance: () => pmPropertyPerformance2,
  pmPropertyPerformanceRelations: () => pmPropertyPerformanceRelations,
  pmTaskLogs: () => pmTaskLogs2,
  pmTaskLogsRelations: () => pmTaskLogsRelations,
  portfolioAssignments: () => portfolioAssignments,
  portfolioAssignmentsRelations: () => portfolioAssignmentsRelations,
  portfolioHealthScores: () => portfolioHealthScores,
  portfolioManagerAssignments: () => portfolioManagerAssignments,
  portfolioManagerCommissions: () => portfolioManagerCommissions,
  properties: () => properties,
  propertiesRelations: () => propertiesRelations,
  propertyAccessControl: () => propertyAccessControl,
  propertyAccessCredentials: () => propertyAccessCredentials,
  propertyAccessPhotos: () => propertyAccessPhotos,
  propertyAccessTemplates: () => propertyAccessTemplates,
  propertyActivityRecommendations: () => propertyActivityRecommendations,
  propertyAgents: () => propertyAgents,
  propertyAgentsRelations: () => propertyAgentsRelations,
  propertyAlerts: () => propertyAlerts,
  propertyAmenities: () => propertyAmenities,
  propertyAmenitiesRelations: () => propertyAmenitiesRelations,
  propertyAppliances: () => propertyAppliances,
  propertyAvailability: () => propertyAvailability,
  propertyAvailabilityRelations: () => propertyAvailabilityRelations,
  propertyChatMessages: () => propertyChatMessages,
  propertyCommissionRules: () => propertyCommissionRules2,
  propertyCommissionRulesRelations: () => propertyCommissionRulesRelations,
  propertyCustomExpenses: () => propertyCustomExpenses,
  propertyCustomExpensesRelations: () => propertyCustomExpensesRelations,
  propertyDocuments: () => propertyDocuments,
  propertyElectricitySettings: () => propertyElectricitySettings2,
  propertyElectricitySettingsRelations: () => propertyElectricitySettingsRelations,
  propertyFinanceSettings: () => propertyFinanceSettings,
  propertyGoalAttachments: () => propertyGoalAttachments,
  propertyGoalProgress: () => propertyGoalProgress,
  propertyGoals: () => propertyGoals,
  propertyGoalsComments: () => propertyGoalsComments,
  propertyGoalsNotes: () => propertyGoalsNotes,
  propertyGuides: () => propertyGuides,
  propertyInfoSummary: () => propertyInfoSummary,
  propertyInsurance: () => propertyInsurance,
  propertyInternalNotes: () => propertyInternalNotes,
  propertyInvestments: () => propertyInvestments,
  propertyLocalContacts: () => propertyLocalContacts,
  propertyMaintenanceHistory: () => propertyMaintenanceHistory,
  propertyMarketingMedia: () => propertyMarketingMedia2,
  propertyMarketingMediaRelations: () => propertyMarketingMediaRelations,
  propertyMedia: () => propertyMedia,
  propertyOccupancyAnalytics: () => propertyOccupancyAnalytics,
  propertyPayoutRules: () => propertyPayoutRules,
  propertyPayoutRulesRelations: () => propertyPayoutRulesRelations,
  propertyPayoutSettings: () => propertyPayoutSettings,
  propertyPlannedUpgrades: () => propertyPlannedUpgrades,
  propertyPlatformRules: () => propertyPlatformRules,
  propertyReferrals: () => propertyReferrals,
  propertyReferralsRelations: () => propertyReferralsRelations,
  propertyReviews: () => propertyReviews,
  propertySearchIndex: () => propertySearchIndex,
  propertySearchIndexRelations: () => propertySearchIndexRelations,
  propertyServiceHistory: () => propertyServiceHistory,
  propertyStatus: () => propertyStatus,
  propertyTaskBilling: () => propertyTaskBilling,
  propertyTimeline: () => propertyTimeline2,
  propertyTimelineEvents: () => propertyTimelineEvents,
  propertyTimelineEventsRelations: () => propertyTimelineEventsRelations,
  propertyUtilities: () => propertyUtilities,
  propertyUtilitiesMaster: () => propertyUtilitiesMaster,
  propertyUtilityAccounts: () => propertyUtilityAccounts,
  propertyUtilityAccountsEnhanced: () => propertyUtilityAccountsEnhanced,
  propertyUtilityAccountsNew: () => propertyUtilityAccountsNew2,
  propertyUtilityAccountsRelations: () => propertyUtilityAccountsRelations,
  propertyUtilitySettings: () => propertyUtilitySettings,
  propertyUtilitySettingsRelations: () => propertyUtilitySettingsRelations,
  propertyVisibilityMatrix: () => propertyVisibilityMatrix,
  propertyWaterSources: () => propertyWaterSources,
  propertyWaterSourcesRelations: () => propertyWaterSourcesRelations,
  quickbooksIntegration: () => quickbooksIntegration,
  recurringServiceBills: () => recurringServiceBills,
  recurringServiceCharges: () => recurringServiceCharges2,
  recurringServices: () => recurringServices,
  recurringTaskAnalytics: () => recurringTaskAnalytics,
  recurringTasks: () => recurringTasks,
  referralAgentCommissionLogs: () => referralAgentCommissionLogs,
  referralEarnings: () => referralEarnings,
  referralEarningsRelations: () => referralEarningsRelations,
  referralProgramRules: () => referralProgramRules2,
  referralProgramRulesRelations: () => referralProgramRulesRelations,
  reports: () => reports,
  reservationHistoryLog: () => reservationHistoryLog,
  rolePermissions: () => rolePermissions,
  routingAuditLog: () => routingAuditLog,
  seasonalForecasts: () => seasonalForecasts,
  securityDeposits: () => securityDeposits,
  serviceAnalytics: () => serviceAnalytics,
  serviceBookings: () => serviceBookings,
  serviceCategories: () => serviceCategories,
  servicePerformance: () => servicePerformance,
  serviceRequestNotifications: () => serviceRequestNotifications,
  serviceReviews: () => serviceReviews,
  serviceVendors: () => serviceVendors,
  sessions: () => sessions,
  sharedCostSplits: () => sharedCostSplits,
  sharedCosts: () => sharedCosts,
  smartLockSyncLog: () => smartLockSyncLog,
  smartNotifications: () => smartNotifications2,
  smartReplySuggestions: () => smartReplySuggestions2,
  smartRequestConfig: () => smartRequestConfig,
  staffAdvanceRequests: () => staffAdvanceRequests,
  staffClockAuditLog: () => staffClockAuditLog,
  staffClockEntries: () => staffClockEntries,
  staffClockLog: () => staffClockLog,
  staffClockSettings: () => staffClockSettings,
  staffCommissions: () => staffCommissions,
  staffDocumentRelations: () => staffDocumentRelations,
  staffDocuments: () => staffDocuments,
  staffExpenses: () => staffExpenses2,
  staffMemberRelations: () => staffMemberRelations,
  staffMembers: () => staffMembers,
  staffMonthlySummary: () => staffMonthlySummary,
  staffOvertimeLogs: () => staffOvertimeLogs,
  staffOvertimeSessions: () => staffOvertimeSessions,
  staffOvertimeSettings: () => staffOvertimeSettings,
  staffPayrollRecords: () => staffPayrollRecords,
  staffProfiles: () => staffProfiles,
  staffSalaries: () => staffSalaries,
  staffSalarySettings: () => staffSalarySettings,
  staffSkills: () => staffSkills,
  staffTaskPermissions: () => staffTaskPermissions,
  staffTimeSummaries: () => staffTimeSummaries,
  staffWorkClocks: () => staffWorkClocks,
  staffWorkloadStats: () => staffWorkloadStats,
  supplyOrders: () => supplyOrders,
  surveyAlerts: () => surveyAlerts2,
  surveyAnalytics: () => surveyAnalytics2,
  surveySettings: () => surveySettings2,
  sustainabilityMetrics: () => sustainabilityMetrics,
  taskAiScanResults: () => taskAiScanResults,
  taskAutoGenRules: () => taskAutoGenRules,
  taskChecklists: () => taskChecklists2,
  taskCompletions: () => taskCompletions2,
  taskDepartmentStats: () => taskDepartmentStats,
  taskEvidence: () => taskEvidence,
  taskExpenses: () => taskExpenses,
  taskGenerationLogs: () => taskGenerationLogs,
  taskHistory: () => taskHistory,
  taskNotificationRules: () => taskNotificationRules,
  taskPerformanceLogs: () => taskPerformanceLogs,
  taskProofUploads: () => taskProofUploads,
  taskSchedule: () => taskSchedule,
  taskSchedulingAlerts: () => taskSchedulingAlerts,
  taskSchedulingRules: () => taskSchedulingRules,
  tasks: () => tasks,
  tasksRelations: () => tasksRelations,
  taxRules: () => taxRules,
  technicianPerformance: () => technicianPerformance,
  universalInvoiceLineItems: () => universalInvoiceLineItems,
  universalInvoices: () => universalInvoices,
  upsellRecommendations: () => upsellRecommendations,
  userAchievements: () => userAchievements,
  userAchievementsRelations: () => userAchievementsRelations,
  userActivityAudit: () => userActivityAudit,
  userActivityLogs: () => userActivityLogs,
  userGameStats: () => userGameStats,
  userGameStatsRelations: () => userGameStatsRelations,
  userGroupMemberships: () => userGroupMemberships,
  userGroups: () => userGroups,
  userInvitations: () => userInvitations,
  userManagement: () => userManagement,
  userPerformanceMetrics: () => userPerformanceMetrics,
  userPermissionOverrides: () => userPermissionOverrides,
  userPermissions: () => userPermissions,
  userPermissionsMatrix: () => userPermissionsMatrix,
  userPropertyAssignments: () => userPropertyAssignments,
  userRoles: () => userRoles,
  userSessionPermissions: () => userSessionPermissions,
  users: () => users,
  usersRelations: () => usersRelations,
  utilityAccessPermissions: () => utilityAccessPermissions,
  utilityAiPredictions: () => utilityAiPredictions,
  utilityAiReminders: () => utilityAiReminders,
  utilityAlertRules: () => utilityAlertRules,
  utilityBillAlerts: () => utilityBillAlerts,
  utilityBillHistory: () => utilityBillHistory,
  utilityBillLogsEnhanced: () => utilityBillLogsEnhanced,
  utilityBillProcessing: () => utilityBillProcessing2,
  utilityBillProcessingRelations: () => utilityBillProcessingRelations,
  utilityBillReminders: () => utilityBillReminders,
  utilityBillRemindersRelations: () => utilityBillRemindersRelations,
  utilityBills: () => utilityBills,
  utilityBillsExtended: () => utilityBillsExtended,
  utilityBillsNew: () => utilityBillsNew,
  utilityBillsRelations: () => utilityBillsRelations,
  utilityNotifications: () => utilityNotifications,
  utilityProviders: () => utilityProviders,
  utilityProvidersRelations: () => utilityProvidersRelations,
  vendors: () => vendors,
  warrantyAlerts: () => warrantyAlerts,
  waterConsumptionAlerts: () => waterConsumptionAlerts,
  waterConsumptionAlertsRelations: () => waterConsumptionAlertsRelations,
  waterConsumptionEntries: () => waterConsumptionEntries,
  waterConsumptionEntriesRelations: () => waterConsumptionEntriesRelations,
  waterDeliveryAlerts: () => waterDeliveryAlerts,
  waterDeliveryAlertsRelations: () => waterDeliveryAlertsRelations,
  waterRefillAlerts: () => waterRefillAlerts,
  waterRefillAlertsRelations: () => waterRefillAlertsRelations,
  waterRefillBills: () => waterRefillBills,
  waterRefillBillsRelations: () => waterRefillBillsRelations,
  waterSuppliers: () => waterSuppliers,
  waterSuppliersRelations: () => waterSuppliersRelations,
  waterUpgradeSuggestions: () => waterUpgradeSuggestions,
  waterUpgradeSuggestionsRelations: () => waterUpgradeSuggestionsRelations,
  waterUtilityRefills: () => waterUtilityRefills,
  waterUtilityRefillsRelations: () => waterUtilityRefillsRelations,
  welcomePackItems: () => welcomePackItems,
  welcomePackItemsRelations: () => welcomePackItemsRelations,
  welcomePackTemplates: () => welcomePackTemplates,
  welcomePackTemplatesRelations: () => welcomePackTemplatesRelations,
  welcomePackUsage: () => welcomePackUsage,
  welcomePackUsageRelations: () => welcomePackUsageRelations,
  whatsappBotLogs: () => whatsappBotLogs
});
import {
  pgTable as pgTable3,
  text as text3,
  varchar as varchar2,
  timestamp as timestamp3,
  jsonb as jsonb3,
  index,
  serial as serial2,
  integer as integer3,
  decimal as decimal2,
  boolean as boolean3,
  date as date2,
  real,
  json
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema3 } from "drizzle-zod";
import { relations } from "drizzle-orm";
var organizations, organizationApiKeys, apiConnections, sessions, users, userManagement, userPermissionsMatrix, userGroups, userGroupMemberships, userActivityLogs, userRoles, rolePermissions, userPermissionOverrides, staffTaskPermissions, permissionPresets, userPermissions, userPropertyAssignments, freelancerAvailability, freelancerTaskRequests, propertyAccessControl, propertyAccessTemplates, propertyVisibilityMatrix, userSessionPermissions, userActivityAudit, userInvitations, userPerformanceMetrics, properties, tasks, taskChecklists2, propertyGuides, aiTaskSuggestions, enhancedAiSuggestions2, propertyTimeline2, inventoryItems2, inventoryUsageLogs2, smartNotifications2, fastActionSuggestions2, taskExpenses, archivedTasks, taskHistory, taskProofUploads, monthlyExportLogs, bookings, guestServiceRequests2, guestConfirmedServices, bookingLinkedTasks, finances, inventory, addonServices, addonBookings, propertyUtilityAccounts, utilityBills, utilityBillReminders, utilityAlertRules, otaPayoutRules, otaBookingPayouts, otaPayoutAlerts, otaRevenueReports, platformSettings, welcomePackItems, welcomePackTemplates, welcomePackUsage, emergencyWaterDeliveries, waterDeliveryAlerts, waterUpgradeSuggestions, usersRelations, propertiesRelations, tasksRelations, bookingsRelations, financesRelations, inventoryRelations, addonServicesRelations, addonBookingsRelations, propertyUtilityAccountsRelations, utilityBillsRelations, utilityBillRemindersRelations, platformSettingsRelations, welcomePackItemsRelations, welcomePackTemplatesRelations, welcomePackUsageRelations, emergencyWaterDeliveriesRelations, waterDeliveryAlertsRelations, waterUpgradeSuggestionsRelations, waterUtilityRefills, waterRefillAlerts, waterRefillBills, waterUtilityRefillsRelations, waterRefillAlertsRelations, waterRefillBillsRelations, propertyWaterSources, waterConsumptionEntries, waterConsumptionAlerts, waterSuppliers, propertyWaterSourcesRelations, waterConsumptionEntriesRelations, waterConsumptionAlertsRelations, waterSuppliersRelations, ownerPayouts, ownerPayoutsRelations, notifications, notificationPreferences, notificationsRelations, notificationPreferencesRelations, guestBookings, guestAiRecommendations, guestServiceTimeline, propertyAmenities, guestBookingsRelations, guestAiRecommendationsRelations, guestServiceTimelineRelations, propertyAmenitiesRelations, balanceResetAudit, utilityProviders, customExpenseCategories, propertyUtilitySettings, propertyCustomExpenses, commissionEarnings, portfolioAssignments, commissionEarningsRelations, portfolioAssignmentsRelations, pmCommissionBalance2, pmPayoutRequests, pmTaskLogs2, ownerBalances2, ownerChargeRequests2, propertyUtilityAccountsNew2, utilityBillsNew, recurringServiceCharges2, financialTransactions2, pmPropertyPerformance2, pmNotifications2, pmCommissionBalanceRelations, pmPayoutRequestsRelations, pmTaskLogsRelations, pmPropertyPerformanceRelations, pmNotificationsRelations, guestAddonServices, guestAddonBookings, guestPortalAccess, guestAddonServicesRelations, guestAddonBookingsRelations, guestPortalAccessRelations, achievements, userAchievements, userGameStats, achievementNotifications, achievementsRelations, userAchievementsRelations, userGameStatsRelations, achievementNotificationsRelations, insertUserSchema, insertPropertySchema, insertTaskSchema, insertBookingSchema, insertFinanceSchema, insertInventorySchema, insertAddonServiceSchema, insertAddonBookingSchema, insertPropertyUtilityAccountSchema, insertUtilityBillSchema, insertUtilityBillReminderSchema, insertUtilityAlertRuleSchema, insertPlatformSettingSchema, insertWelcomePackItemSchema, insertWelcomePackTemplateSchema, insertWelcomePackUsageSchema, insertEmergencyWaterDeliverySchema, insertWaterDeliveryAlertSchema, insertWaterUpgradeSuggestionSchema, insertOwnerPayoutSchema, insertOwnerBalanceSchema, insertOwnerChargeRequestSchema, insertRecurringServiceChargeSchema, insertFinancialTransactionSchema, insertAchievementSchema, insertUserAchievementSchema, insertUserGameStatsSchema, insertAchievementNotificationSchema, staffMembers, staffDocuments, payrollRecords, departmentBudgets, staffMemberRelations, staffDocumentRelations, payrollRecordRelations, insertStaffMemberSchema, insertStaffDocumentSchema, insertPayrollRecordSchema, insertDepartmentBudgetSchema, communicationChannels, channelMembers, internalMessages, ownerPmCommunication, guestSmartRequests, communicationLogs, smartRequestConfig, propertyUtilityAccountsEnhanced, utilityBillLogsEnhanced, utilityAiReminders, propertyMaintenanceHistory, maintenanceServiceIntervals, maintenanceAiSuggestions, propertyAlerts, insertOrganizationSchema, insertOrganizationApiKeySchema, insertUserPermissionOverrideSchema, insertPermissionPresetSchema, insertRolePermissionSchema, propertyGoals, propertyGoalAttachments, propertyGoalProgress, bookingRevenue, bookingRevenueCommissions, otaPlatformSettings, bookingRevenueRelations, bookingRevenueCommissionsRelations, otaPlatformSettingsRelations, insertBookingRevenueSchema, insertBookingRevenueCommissionsSchema, insertOtaPlatformSettingsSchema, currencyRates, taxRules, offlineTaskCache, marketingPacks, insertTaskHistorySchema, insertNotificationSchema, insertNotificationPreferenceSchema, insertCurrencyRateSchema, insertTaxRuleSchema, insertOfflineTaskCacheSchema, insertMarketingPackSchema, aiOpsAnomalies, insertAiOpsAnomalySchema, sharedCosts, sharedCostSplits, insertSharedCostSchema, insertSharedCostSplitSchema, taskAiScanResults, insertTaskAiScanResultSchema, propertyInvestments, insertPropertyInvestmentSchema, dynamicPricingRecommendations, insertDynamicPricingRecommendationSchema, propertyChatMessages, insertPropertyChatMessageSchema, propertyDocuments, insertPropertyDocumentSchema, upsellRecommendations, insertUpsellRecommendationSchema, insertCommissionEarningSchema, insertPortfolioAssignmentSchema, insertGuestAddonServiceSchema, insertGuestAddonBookingSchema, insertApiConnectionSchema, propertyMarketingMedia2, propertyCommissionRules2, agentBookingRequests2, propertyPlannedUpgrades, propertyGoalsNotes, propertyGoalsComments, propertyMarketingMediaRelations, propertyCommissionRulesRelations, agentBookingRequestsRelations, invoiceTemplates2, generatedInvoices2, invoiceLineItems2, invoiceBookingLinks2, invoiceServiceLinks2, invoiceGenerationLog, invoiceTemplatesRelations, generatedInvoicesRelations, invoiceLineItemsRelations, invoiceBookingLinksRelations, invoiceServiceLinksRelations, insertInvoiceTemplateSchema, insertGeneratedInvoiceSchema, insertInvoiceLineItemSchema, insertInvoiceBookingLinkSchema, insertInvoiceServiceLinkSchema, propertyUtilitiesMaster, utilityBillsExtended, utilityAccessPermissions, utilityAiPredictions, utilityNotifications, ownerStatementExports, ownerStatementExportsRelations, insertOwnerStatementExportSchema, insertPropertyUtilityAccountEnhancedSchema, insertUtilityBillLogEnhancedSchema, insertUtilityAiReminderSchema, insertPropertyMaintenanceHistorySchema, insertMaintenanceServiceIntervalSchema, insertMaintenanceAiSuggestionSchema, insertGuestServiceRequestSchema2, insertGuestConfirmedServiceSchema, insertBookingLinkedTaskSchema, insertPropertyAlertSchema, documentAccessLogs2, ownerOnboardingChecklists2, documentCategories2, fileUploadSessions2, maintenanceLog, warrantyAlerts, aiServiceCyclePredictions, maintenanceCostAnalytics, technicianPerformance, insertMaintenanceLogSchema, insertWarrantyAlertSchema, insertAiServiceCyclePredictionSchema, insertMaintenanceCostAnalyticsSchema, insertTechnicianPerformanceSchema, guestCheckIns2, guestCheckOuts2, propertyElectricitySettings2, checkInOutDemoTasks2, guestCheckInsRelations, guestCheckOutsRelations, propertyElectricitySettingsRelations, checkInOutDemoTasksRelations, insertGuestCheckInSchema, insertGuestCheckOutSchema, insertPropertyElectricitySettingsSchema, insertCheckInOutDemoTaskSchema, insertPropertyMarketingMediaSchema, insertPropertyCommissionRuleSchema, insertAgentBookingRequestSchema, insertGuestPortalAccessSchema, propertyReferrals, referralEarnings, agentPayouts, referralProgramRules2, propertyAgents, agentBookings, commissionLog, commissionInvoices, commissionInvoiceItems, guestFeedback, aiTaskRules, feedbackProcessingLog, aiConfiguration, recurringServices, recurringServiceBills, billReminders, servicePerformance, propertyMedia, propertyInternalNotes, insertRecurringServiceSchema, insertRecurringServiceBillSchema, insertBillReminderSchema, insertServicePerformanceSchema, insertPropertyMediaSchema, insertPropertyInternalNotesSchema, insertGuestFeedbackSchema, insertAiTaskRuleSchema, insertFeedbackProcessingLogSchema, insertAiConfigurationSchema, addonServiceCatalog, addonServiceBookings, addonServiceCategories, addonServiceCommissions, addonServiceReports, addonServiceAvailability, addonBillingRules, guestLoyaltyProfiles2, loyaltyTiers2, guestMessages2, messagingTriggers2, smartReplySuggestions2, aiMessageAnalysis2, messageDeliveries2, ownerActivityTimeline, ownerInvoices, ownerPreferences, ownerSettings, insertOwnerActivityTimelineSchema, insertOwnerInvoiceSchema, insertOwnerPreferencesSchema, insertOwnerSettingsSchema, ownerBalanceTracker2, payoutRoutingRules2, utilityBillProcessing2, enhancedFinanceTransactionLogs2, ownerBalanceTrackerRelations, payoutRoutingRulesRelations, utilityBillProcessingRelations, enhancedFinanceTransactionLogsRelations, insertPayoutRoutingRuleSchema, insertUtilityBillProcessingSchema, insertEnhancedFinanceTransactionLogSchema, taskSchedule, taskAutoGenRules, propertyTaskBilling, aiTaskEngine, taskDepartmentStats, taskEvidence, taskNotificationRules, insertTaskScheduleSchema, insertTaskAutoGenRuleSchema, insertPropertyTaskBillingSchema, insertAiTaskEngineSchema, insertTaskDepartmentStatsSchema, insertTaskEvidenceSchema, insertTaskNotificationRuleSchema, propertyReferralsRelations, referralEarningsRelations, agentPayoutsRelations, referralProgramRulesRelations, propertyAgentsRelations, insertPropertyReferralSchema, insertReferralEarningsSchema, insertAgentPayoutsSchema, insertReferralProgramRulesSchema, insertPropertyAgentsSchema, staffSalaries, taskCompletions2, staffExpenses2, insertStaffSalariesSchema, insertTaskChecklistsSchema, insertTaskCompletionsSchema, insertStaffExpensesSchema, balanceResetAuditRelations, insertBalanceResetAuditSchema, utilityProvidersRelations, customExpenseCategoriesRelations, propertyUtilitySettingsRelations, propertyCustomExpensesRelations, insertUtilityProviderSchema, insertCustomExpenseCategorySchema, insertPropertyUtilitySettingsSchema, insertPropertyCustomExpensesSchema, insertCommissionLogSchema, insertCommissionInvoicesSchema, insertCommissionInvoiceItemsSchema, insertGuestLoyaltyProfileSchema, insertLoyaltyTierSchema, insertGuestMessageSchema, insertMessagingTriggerSchema, insertSmartReplySuggestionSchema, insertAiMessageAnalysisSchema, insertMessageDeliverySchema, insertTaskChecklistSchema, insertPropertyGuideSchema, insertTaskProofUploadSchema, insertTaskCompletionSchema, insertMonthlyExportLogSchema, staffProfiles, monthlyPayrollRecords, taskPerformanceLogs, attendanceRecords, leaveRequests, staffCommissions, paySlips, insertStaffProfileSchema, insertMonthlyPayrollRecordSchema, insertTaskPerformanceLogSchema, insertAttendanceRecordSchema, insertLeaveRequestSchema, insertStaffCommissionSchema, insertPaySlipSchema, staffAdvanceRequests, staffClockEntries, staffOvertimeLogs, staffOvertimeSettings, staffMonthlySummary, insertStaffAdvanceRequestSchema, insertStaffClockEntrySchema, insertStaffOvertimeLogSchema, insertStaffOvertimeSettingsSchema, insertStaffMonthlySummarySchema, staffPayrollRecords, portfolioManagerCommissions, referralAgentCommissionLogs, universalInvoices, universalInvoiceLineItems, paymentConfirmations, insertStaffPayrollRecordSchema, insertPortfolioManagerCommissionSchema, insertReferralAgentCommissionLogSchema, insertUniversalInvoiceSchema, insertUniversalInvoiceLineItemSchema, insertPaymentConfirmationSchema, insertAddonServiceCatalogSchema, insertAddonServiceBookingSchema, insertAddonServiceCategorySchema, insertAddonServiceCommissionSchema, insertAddonServiceReportSchema, insertAddonServiceAvailabilitySchema, insertAddonBillingRuleSchema, liveBookingCalendar, propertyAvailability, agentSearchPreferences, propertySearchIndex, agentBookingEnquiries, bookingPlatformSync, propertyOccupancyAnalytics, liveBookingCalendarRelations, propertyAvailabilityRelations, propertySearchIndexRelations, agentBookingEnquiriesRelations, insertLiveBookingCalendarSchema, insertPropertyAvailabilitySchema, insertAgentSearchPreferencesSchema, insertPropertySearchIndexSchema, insertAgentBookingEnquiriesSchema, insertBookingPlatformSyncSchema, insertPropertyOccupancyAnalyticsSchema, guestPortalSessions, guestActivityTimeline, guestAiFaqKnowledge, guestAddonServiceRequests, guestPropertyLocalInfo, guestMaintenanceReports, insertGuestPortalSessionSchema, insertGuestActivityTimelineSchema, insertGuestAiFaqKnowledgeSchema, insertGuestAddonServiceRequestSchema, insertGuestPropertyLocalInfoSchema, insertGuestMaintenanceReportSchema, ownerBalanceTrackers, ownerPayoutRequests, ownerPaymentLogs, ownerDebtTrackers, propertyPayoutSettings, insertOwnerBalanceTrackerSchema, insertOwnerPayoutRequestSchema, insertOwnerPaymentLogSchema, insertOwnerDebtTrackerSchema, insertPropertyPayoutSettingsSchema, platformRoutingRules, propertyPlatformRules, bookingPlatformRouting, routingAuditLog, staffWorkClocks, staffClockSettings, staffTimeSummaries, staffClockAuditLog, insertPlatformRoutingRuleSchema, insertPropertyPlatformRuleSchema, insertBookingPlatformRoutingSchema, insertRoutingAuditLogSchema, insertStaffWorkClockSchema, insertStaffClockSettingsSchema, insertStaffTimeSummarySchema, insertStaffClockAuditLogSchema, maintenanceSuggestions, maintenanceApprovalLogs, maintenanceSuggestionSettings, serviceVendors, serviceCategories, marketplaceServices, serviceBookings, serviceReviews, serviceAnalytics, maintenanceTimelineEntries, insertMaintenanceSuggestionSchema, insertMaintenanceApprovalLogSchema, insertMaintenanceSuggestionSettingsSchema, insertMaintenanceTimelineEntrySchema, insertServiceVendorSchema, insertServiceCategorySchema, insertMarketplaceServiceSchema, insertServiceBookingSchema, insertServiceReviewSchema, insertServiceAnalyticsSchema, insertGuestBookingSchema, insertGuestAiRecommendationSchema, insertGuestServiceTimelineSchema, insertPropertyAmenitySchema, guestCheckoutSurveys2, surveySettings2, surveyAlerts2, surveyAnalytics2, insertGuestCheckoutSurveySchema, insertSurveySettingsSchema, insertSurveyAlertSchema, insertSurveyAnalyticsSchema, invoices, aiGeneratedTasks2, guestDashboardAnalytics, aiSmartSuggestions, staffSalarySettings, staffClockLog, emergencyTaskBonuses, propertyLocalContacts, contactTemplateZones, monthlyPayroll, payrollSummary, guestCommunicationNotifications, guestPortalSettings, guestMessagesRelations, aiGeneratedTasksRelations, aiSmartSuggestionsRelations, guestCommunicationNotificationsRelations, guestPortalSettingsRelations, propertyPayoutRules, bookingIncomeRecords, ownerBalanceRequests, commissionPayouts, propertyTimelineEvents, platformAnalytics, propertyPayoutRulesRelations, bookingIncomeRecordsRelations, ownerBalanceRequestsRelations, commissionPayoutsRelations, propertyTimelineEventsRelations, platformAnalyticsRelations, insertPropertyPayoutRuleSchema, insertBookingIncomeRecordSchema, insertOwnerBalanceRequestSchema, insertCommissionPayoutSchema, insertPropertyTimelineEventSchema, insertPlatformAnalyticsSchema, staffOvertimeSessions, currencyExchangeRates, multiCurrencyFinances, quickbooksIntegration, propertyFinanceSettings, financeExportLogs, financeReportTemplates, occupancyRates, insertCurrencyExchangeRateSchema, insertMultiCurrencyFinanceSchema, insertQuickbooksIntegrationSchema, insertPropertyFinanceSettingsSchema, insertFinanceExportLogSchema, insertFinanceReportTemplateSchema, insertOccupancyRateSchema, insertCommunicationChannelSchema, insertChannelMemberSchema, insertInternalMessageSchema, insertOwnerPmCommunicationSchema, insertGuestSmartRequestSchema, insertCommunicationLogSchema, insertSmartRequestConfigSchema, auditTrail, adminOverridePermissions, impersonationSessions, balanceOverrideHistory, portfolioManagerAssignments, insertAuditTrailSchema, insertAdminOverridePermissionSchema, insertImpersonationSessionSchema, insertBalanceOverrideHistorySchema, insertPortfolioManagerAssignmentSchema, propertyAccessCredentials, propertyAccessPhotos, accessChangeLog, guestAccessSessions, smartLockSyncLog, codeRotationSchedule, insertPropertyAccessCredentialSchema, insertPropertyAccessPhotoSchema, insertAccessChangeLogSchema, insertGuestAccessSessionSchema, insertSmartLockSyncLogSchema, insertCodeRotationScheduleSchema, dailyOperationsSummary, dailyStaffAssignments, dailyPropertyOperations, insertDailyOperationsSummarySchema, insertDailyStaffAssignmentsSchema, insertDailyPropertyOperationsSchema, maintenanceIssues, propertyServiceHistory, maintenanceTaskSuggestions, propertyUtilities, utilityBillHistory, utilityBillAlerts, propertyInfoSummary, insertMaintenanceIssueSchema, insertPropertyServiceHistorySchema, insertMaintenanceTaskSuggestionSchema, insertPropertyUtilitySchema, insertUtilityBillHistorySchema, insertUtilityBillAlertSchema, insertPropertyInfoSummarySchema, taskSchedulingRules, recurringTasks, taskGenerationLogs, recurringTaskAnalytics, taskSchedulingAlerts, insertTaskSchedulingRuleSchema, insertRecurringTaskSchema, insertTaskGenerationLogSchema, insertRecurringTaskAnalyticsSchema, insertTaskSchedulingAlertSchema, propertyAppliances, applianceRepairs, insertPropertyApplianceSchema, insertApplianceRepairSchema, alertRules, alertLogs, insertAlertRuleSchema, insertAlertLogSchema, legalTemplates, insertLegalTemplateSchema, propertyStatus, insertPropertyStatusSchema, staffSkills, insertStaffSkillSchema, propertyReviews, insertPropertyReviewSchema, securityDeposits, damageReports, insertSecurityDepositSchema, insertDamageReportSchema, vendors, supplyOrders, insertVendorSchema, insertSupplyOrderSchema, whatsappBotLogs, insertWhatsappBotLogSchema, seasonalForecasts, insertSeasonalForecastSchema, sustainabilityMetrics, insertSustainabilityMetricSchema, portfolioHealthScores, insertPortfolioHealthScoreSchema, guestIdScans, insertGuestIdScanSchema, maintenanceBudgetForecasts, insertMaintenanceBudgetForecastSchema, staffWorkloadStats, insertStaffWorkloadStatsSchema, propertyInsurance, insertPropertyInsuranceSchema, reports, insertReportSchema, automations, insertAutomationSchema, automationLogs, insertAutomationLogSchema, aiNotifications, insertAiNotificationSchema, aiReminderSettings, insertAiReminderSettingSchema, aiNotificationHistory, insertAiNotificationHistorySchema, billingInvoices, billingInvoiceLineItems2, billingInvoiceTemplates, billingTemplateLineItems2, insertBillingInvoiceSchema, insertBillingInvoiceLineItemSchema, insertBillingInvoiceTemplateSchema, insertBillingTemplateLineItemSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    init_guestPortalSchema();
    organizations = pgTable3("organizations", {
      id: varchar2("id").primaryKey().notNull(),
      // UUID or company slug
      name: varchar2("name").notNull(),
      domain: varchar2("domain").unique().notNull(),
      // company.hostpilotpro.com
      subdomain: varchar2("subdomain").unique().notNull(),
      // company
      companyLogo: varchar2("company_logo"),
      customDomain: varchar2("custom_domain"),
      // client's custom domain like myproperty.com
      brandingLogoUrl: text3("branding_logo_url"),
      // client's custom branding logo
      themeColor: varchar2("theme_color").default("#0066ff"),
      // client's custom theme color
      settings: jsonb3("settings"),
      // Company-specific settings
      subscriptionTier: varchar2("subscription_tier").default("basic"),
      // basic, pro, enterprise
      maxUsers: integer3("max_users").default(10),
      maxProperties: integer3("max_properties").default(50),
      isActive: boolean3("is_active").default(true),
      trialEndsAt: timestamp3("trial_ends_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    organizationApiKeys = pgTable3(
      "organization_api_keys",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        provider: varchar2("provider").notNull(),
        // hostaway, pea, stripe, twilio, etc.
        keyName: varchar2("key_name").notNull(),
        // api_key, secret_key, account_sid, etc.
        encryptedValue: text3("encrypted_value").notNull(),
        description: varchar2("description"),
        // Human-readable description
        isActive: boolean3("is_active").default(true),
        lastUsed: timestamp3("last_used"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_api_key_org").on(table.organizationId),
        index("IDX_api_key_provider").on(table.provider)
      ]
    );
    apiConnections = pgTable3(
      "api_connections",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        service: varchar2("service").notNull(),
        // stripe, hostaway, openai, twilio
        name: varchar2("name").notNull(),
        status: varchar2("status").default("disconnected"),
        // connected, disconnected, error
        lastTested: timestamp3("last_tested"),
        lastError: text3("last_error"),
        isActive: boolean3("is_active").default(true),
        hasCredentials: boolean3("has_credentials").default(false),
        configuration: jsonb3("configuration"),
        // service-specific settings
        description: text3("description"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_api_connections_org").on(table.organizationId),
        index("IDX_api_connections_service").on(table.service)
      ]
    );
    sessions = pgTable3(
      "sessions",
      {
        sid: varchar2("sid").primaryKey(),
        sess: jsonb3("sess").notNull(),
        expire: timestamp3("expire").notNull(),
        organizationId: varchar2("organization_id").references(
          () => organizations.id
        )
      },
      (table) => [
        index("IDX_session_expire").on(table.expire),
        index("IDX_session_org").on(table.organizationId)
      ]
    );
    users = pgTable3(
      "users",
      {
        id: varchar2("id").primaryKey().notNull(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        email: varchar2("email"),
        password: text3("password"),
        // For secure authentication
        firstName: varchar2("first_name"),
        lastName: varchar2("last_name"),
        profileImageUrl: varchar2("profile_image_url"),
        role: varchar2("role").notNull().default("guest"),
        // admin, portfolio-manager, owner, staff, retail-agent, referral-agent, guest
        isActive: boolean3("is_active").default(true),
        lastLoginAt: timestamp3("last_login_at"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_user_org").on(table.organizationId),
        index("IDX_user_email_org").on(table.email, table.organizationId)
      ]
    );
    userManagement = pgTable3(
      "user_management",
      {
        id: varchar2("id").primaryKey().notNull(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        email: varchar2("email").unique().notNull(),
        firstName: varchar2("first_name").notNull(),
        lastName: varchar2("last_name").notNull(),
        profileImageUrl: varchar2("profile_image_url"),
        // Role System
        primaryRole: varchar2("primary_role").notNull(),
        // admin, portfolio_manager, owner, retail_agent, referral_agent, housekeeping, maintenance, supervisor
        subRole: varchar2("sub_role"),
        // Additional role specificity
        // Listing Access Control
        listingsAccess: jsonb3("listings_access").default([]),
        // Array of villa IDs: ["villa_majesta", "villa_tramonto"]
        // Groups System
        groups: jsonb3("groups").default([]),
        // Custom groups: ["Property Owners", "Adam Portfolio"]
        // Notification Preferences
        dashboardAlerts: boolean3("dashboard_alerts").default(true),
        emailAlerts: boolean3("email_alerts").default(true),
        smsAlerts: boolean3("sms_alerts").default(false),
        // Status and Activity
        isActive: boolean3("is_active").default(true),
        lastLoginAt: timestamp3("last_login_at"),
        lastSeenAt: timestamp3("last_seen_at"),
        // Security and Audit
        createdBy: varchar2("created_by").references(() => users.id),
        updatedBy: varchar2("updated_by").references(() => users.id),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_user_mgmt_org").on(table.organizationId),
        index("IDX_user_mgmt_email").on(table.email),
        index("IDX_user_mgmt_role").on(table.primaryRole)
      ]
    );
    userPermissionsMatrix = pgTable3(
      "user_permissions_matrix",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => userManagement.id).notNull(),
        // Module Permissions
        module: varchar2("module").notNull(),
        // listings, reservations, owner_stays, calendar, booking_engine, financial_reporting, expenses_extras, owner_statements, channel_manager
        // Access Level Permissions
        canView: boolean3("can_view").default(false),
        canModify: boolean3("can_modify").default(false),
        canCreate: boolean3("can_create").default(false),
        canDelete: boolean3("can_delete").default(false),
        // Special Permissions
        canImpersonate: boolean3("can_impersonate").default(false),
        // God mode for admins
        canAccessAllListings: boolean3("can_access_all_listings").default(false),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_permissions_user").on(table.userId),
        index("IDX_permissions_module").on(table.module),
        index("IDX_permissions_org").on(table.organizationId)
      ]
    );
    userGroups = pgTable3(
      "user_groups",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        name: varchar2("name").notNull(),
        description: text3("description"),
        color: varchar2("color").default("#3B82F6"),
        // Hex color for UI
        icon: varchar2("icon").default("Users"),
        // Lucide icon name
        // Group-specific settings
        defaultPermissions: jsonb3("default_permissions").default({}),
        listingsAccess: jsonb3("listings_access").default([]),
        createdBy: varchar2("created_by").references(() => users.id),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_groups_org").on(table.organizationId),
        index("IDX_groups_name").on(table.name)
      ]
    );
    userGroupMemberships = pgTable3(
      "user_group_memberships",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => userManagement.id).notNull(),
        groupId: integer3("group_id").references(() => userGroups.id).notNull(),
        role: varchar2("role").default("member"),
        // member, moderator, admin
        joinedAt: timestamp3("joined_at").defaultNow()
      },
      (table) => [
        index("IDX_membership_user").on(table.userId),
        index("IDX_membership_group").on(table.groupId),
        index("IDX_membership_org").on(table.organizationId)
      ]
    );
    userActivityLogs = pgTable3(
      "user_activity_logs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => userManagement.id),
        impersonatedUserId: varchar2("impersonated_user_id").references(
          () => userManagement.id
        ),
        // For God mode tracking
        action: varchar2("action").notNull(),
        // login, logout, view, create, update, delete, impersonate
        module: varchar2("module"),
        // Which module was accessed
        resourceId: varchar2("resource_id"),
        // ID of the resource that was acted upon
        resourceType: varchar2("resource_type"),
        // Type of resource (listing, reservation, etc.)
        details: jsonb3("details"),
        // Additional context
        ipAddress: varchar2("ip_address"),
        userAgent: text3("user_agent"),
        timestamp: timestamp3("timestamp").defaultNow()
      },
      (table) => [
        index("IDX_activity_user").on(table.userId),
        index("IDX_activity_timestamp").on(table.timestamp),
        index("IDX_activity_org").on(table.organizationId)
      ]
    );
    userRoles = pgTable3(
      "user_roles",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => users.id).notNull(),
        primaryRole: varchar2("primary_role").notNull(),
        // admin, portfolio-manager, owner, staff, retail-agent, referral-agent, freelancer
        subRole: varchar2("sub_role"),
        // For staff: housekeeping, host, supervisor, gardener, handyman, pool, pest; For freelancer: electrician, contractor, plumber, pest, chef, spa, nanny, maid
        isActive: boolean3("is_active").default(true),
        assignedAt: timestamp3("assigned_at").defaultNow(),
        assignedBy: varchar2("assigned_by").references(() => users.id),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_user_role_org").on(table.organizationId),
        index("IDX_user_role_user").on(table.userId)
      ]
    );
    rolePermissions = pgTable3(
      "role_permissions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        roleId: varchar2("role_id").notNull(),
        // admin, portfolio-manager, owner, staff, etc.
        roleName: varchar2("role_name").notNull(),
        displayName: varchar2("display_name").notNull(),
        description: text3("description"),
        permissions: jsonb3("permissions").notNull(),
        // Module permissions object
        isCustom: boolean3("is_custom").default(false),
        // Whether it's a custom role
        userCount: integer3("user_count").default(0),
        // Number of users with this role
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_role_perm_org").on(table.organizationId),
        index("IDX_role_perm_role").on(table.roleId)
      ]
    );
    userPermissionOverrides = pgTable3(
      "user_permission_overrides",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => userManagement.id).notNull(),
        moduleCategory: varchar2("module_category").notNull(),
        // financials, maintenance, bookings, documents, addons
        moduleName: varchar2("module_name").notNull(),
        // specific module name
        permission: varchar2("permission").notNull(),
        // none, view, edit
        isOverride: boolean3("is_override").default(true),
        // true if overriding default role permission
        grantedBy: varchar2("granted_by").references(() => userManagement.id),
        reason: text3("reason"),
        // Why this override was granted
        expiresAt: timestamp3("expires_at"),
        // Optional expiration
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_perm_override_org").on(table.organizationId),
        index("IDX_perm_override_user").on(table.userId),
        index("IDX_perm_override_module").on(
          table.moduleCategory,
          table.moduleName
        )
      ]
    );
    staffTaskPermissions = pgTable3(
      "staff_task_permissions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffUserId: varchar2("staff_user_id").references(() => users.id).notNull(),
        canCreateTasks: boolean3("can_create_tasks").default(false),
        canEditOwnTasks: boolean3("can_edit_own_tasks").default(true),
        canDeleteOwnTasks: boolean3("can_delete_own_tasks").default(false),
        canViewAllTasks: boolean3("can_view_all_tasks").default(true),
        maxTasksPerDay: integer3("max_tasks_per_day").default(5),
        allowedDepartments: jsonb3("allowed_departments"),
        // Array of departments staff can create tasks for
        requiresApproval: boolean3("requires_approval").default(true),
        // Whether staff-created tasks need admin approval
        grantedBy: varchar2("granted_by").references(() => users.id).notNull(),
        reason: text3("reason"),
        // Why this permission was granted
        isActive: boolean3("is_active").default(true),
        expiresAt: timestamp3("expires_at"),
        // Optional expiration
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_staff_task_perm_org").on(table.organizationId),
        index("IDX_staff_task_perm_user").on(table.staffUserId),
        index("IDX_staff_task_perm_active").on(table.isActive)
      ]
    );
    permissionPresets = pgTable3(
      "permission_presets",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        presetName: varchar2("preset_name").notNull(),
        description: text3("description"),
        targetRole: varchar2("target_role").notNull(),
        // which role this preset is for
        permissions: jsonb3("permissions").notNull(),
        // Complete permissions structure
        isDefault: boolean3("is_default").default(false),
        // Whether this is the default for the role
        createdBy: varchar2("created_by").references(() => userManagement.id),
        usageCount: integer3("usage_count").default(0),
        // How many times it's been applied
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_perm_preset_org").on(table.organizationId),
        index("IDX_perm_preset_role").on(table.targetRole)
      ]
    );
    userPermissions = pgTable3(
      "user_permissions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => users.id).notNull(),
        moduleAccess: jsonb3("module_access").notNull(),
        // JSON object with permission flags
        // Module access includes: bookingsView, financialReports, taskAccess, guestChat,
        // utilitiesView, propertyEditor, documentsModule, calendarAccess, salaryVisibility,
        // photoSubmission, maintenanceLogs, fileUpload, notifications, reservationNotes, chatWall
        updatedAt: timestamp3("updated_at").defaultNow(),
        updatedBy: varchar2("updated_by").references(() => users.id)
      },
      (table) => [
        index("IDX_user_perm_org").on(table.organizationId),
        index("IDX_user_perm_user").on(table.userId)
      ]
    );
    userPropertyAssignments = pgTable3(
      "user_property_assignments",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => users.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        assignmentType: varchar2("assignment_type").notNull(),
        // permanent, temporary, project-based
        startDate: date2("start_date"),
        endDate: date2("end_date"),
        // NULL for permanent assignments
        assignedBy: varchar2("assigned_by").references(() => users.id),
        assignedAt: timestamp3("assigned_at").defaultNow(),
        isActive: boolean3("is_active").default(true)
      },
      (table) => [
        index("IDX_user_prop_org").on(table.organizationId),
        index("IDX_user_prop_user").on(table.userId),
        index("IDX_user_prop_property").on(table.propertyId)
      ]
    );
    freelancerAvailability = pgTable3(
      "freelancer_availability",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        freelancerId: varchar2("freelancer_id").references(() => users.id).notNull(),
        availableDate: date2("available_date").notNull(),
        timeSlots: jsonb3("time_slots").notNull(),
        // Array of available time slots
        isAvailable: boolean3("is_available").default(true),
        notes: text3("notes"),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_freelancer_avail_org").on(table.organizationId),
        index("IDX_freelancer_avail_user").on(table.freelancerId),
        index("IDX_freelancer_avail_date").on(table.availableDate)
      ]
    );
    freelancerTaskRequests = pgTable3(
      "freelancer_task_requests",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        freelancerId: varchar2("freelancer_id").references(() => users.id).notNull(),
        requestedBy: varchar2("requested_by").references(() => users.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        taskTitle: varchar2("task_title").notNull(),
        taskDescription: text3("task_description"),
        serviceCategory: varchar2("service_category").notNull(),
        // electrician, plumber, chef, etc.
        proposedDate: date2("proposed_date").notNull(),
        proposedTimeStart: varchar2("proposed_time_start").notNull(),
        // HH:MM format
        proposedTimeEnd: varchar2("proposed_time_end").notNull(),
        estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
        status: varchar2("status").default("pending"),
        // pending, confirmed, declined, counter_proposed, completed
        freelancerResponse: text3("freelancer_response"),
        counterProposedDate: date2("counter_proposed_date"),
        counterProposedTimeStart: varchar2("counter_proposed_time_start"),
        counterProposedTimeEnd: varchar2("counter_proposed_time_end"),
        confirmedDate: date2("confirmed_date"),
        confirmedTimeStart: varchar2("confirmed_time_start"),
        confirmedTimeEnd: varchar2("confirmed_time_end"),
        completedAt: timestamp3("completed_at"),
        requestedAt: timestamp3("requested_at").defaultNow(),
        respondedAt: timestamp3("responded_at"),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_freelancer_req_org").on(table.organizationId),
        index("IDX_freelancer_req_freelancer").on(table.freelancerId),
        index("IDX_freelancer_req_requester").on(table.requestedBy),
        index("IDX_freelancer_req_status").on(table.status)
      ]
    );
    propertyAccessControl = pgTable3(
      "property_access_control",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => userManagement.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Access levels
        canView: boolean3("can_view").default(false),
        canManage: boolean3("can_manage").default(false),
        canReceiveTasks: boolean3("can_receive_tasks").default(false),
        // Owner-specific module toggles
        hasFinancialAccess: boolean3("has_financial_access").default(true),
        hasMaintenanceAccess: boolean3("has_maintenance_access").default(true),
        hasGuestBookingAccess: boolean3("has_guest_booking_access").default(true),
        hasUtilitiesAccess: boolean3("has_utilities_access").default(true),
        hasPropertyInfoAccess: boolean3("has_property_info_access").default(true),
        hasServiceOrderAccess: boolean3("has_service_order_access").default(true),
        assignedBy: varchar2("assigned_by").references(() => userManagement.id).notNull(),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_property_access_org").on(table.organizationId),
        index("IDX_property_access_user").on(table.userId),
        index("IDX_property_access_property").on(table.propertyId)
      ]
    );
    propertyAccessTemplates = pgTable3(
      "property_access_templates",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        templateName: varchar2("template_name").notNull(),
        targetRole: varchar2("target_role").notNull(),
        // owner, staff, manager, agent
        description: text3("description"),
        // Default permissions for this template
        defaultCanView: boolean3("default_can_view").default(false),
        defaultCanManage: boolean3("default_can_manage").default(false),
        defaultCanReceiveTasks: boolean3("default_can_receive_tasks").default(false),
        // Owner-specific defaults
        defaultFinancialAccess: boolean3("default_financial_access").default(true),
        defaultMaintenanceAccess: boolean3("default_maintenance_access").default(
          true
        ),
        defaultGuestBookingAccess: boolean3("default_guest_booking_access").default(
          true
        ),
        defaultUtilitiesAccess: boolean3("default_utilities_access").default(true),
        defaultPropertyInfoAccess: boolean3("default_property_info_access").default(
          true
        ),
        defaultServiceOrderAccess: boolean3("default_service_order_access").default(
          true
        ),
        createdBy: varchar2("created_by").references(() => userManagement.id).notNull(),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_access_template_org").on(table.organizationId),
        index("IDX_access_template_role").on(table.targetRole)
      ]
    );
    propertyVisibilityMatrix = pgTable3(
      "property_visibility_matrix",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => userManagement.id).notNull(),
        // Computed fields for dashboard display
        propertiesLinked: jsonb3("properties_linked").default([]),
        // Array of property IDs
        accessLevel: varchar2("access_level").default("read-only"),
        // read-only, partial, full
        lastUpdated: timestamp3("last_updated").defaultNow(),
        lastUpdatedBy: varchar2("last_updated_by").references(
          () => userManagement.id
        ),
        // Quick action flags
        hasFullAccess: boolean3("has_full_access").default(false),
        hasRestrictedAccess: boolean3("has_restricted_access").default(false),
        requiresReview: boolean3("requires_review").default(false),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_visibility_matrix_org").on(table.organizationId),
        index("IDX_visibility_matrix_user").on(table.userId),
        index("IDX_visibility_matrix_access").on(table.accessLevel)
      ]
    );
    userSessionPermissions = pgTable3(
      "user_session_permissions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => userManagement.id).notNull(),
        sessionId: varchar2("session_id"),
        // For real-time updates
        // Cached permission data for fast access
        permissionsCache: jsonb3("permissions_cache").notNull(),
        // Full permissions object
        propertyAccessCache: jsonb3("property_access_cache").notNull(),
        // Property-specific permissions
        // Sync tracking
        lastSyncAt: timestamp3("last_sync_at").defaultNow(),
        syncVersion: integer3("sync_version").default(1),
        isActive: boolean3("is_active").default(true),
        expiresAt: timestamp3("expires_at"),
        // Session expiration
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_session_perm_org").on(table.organizationId),
        index("IDX_session_perm_user").on(table.userId),
        index("IDX_session_perm_session").on(table.sessionId),
        index("IDX_session_perm_expires").on(table.expiresAt)
      ]
    );
    userActivityAudit = pgTable3(
      "user_activity_audit",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => users.id).notNull(),
        action: varchar2("action").notNull(),
        // login, logout, role_change, permission_update, property_assignment
        details: jsonb3("details"),
        // Additional details about the action
        oldValue: text3("old_value"),
        // For tracking changes
        newValue: text3("new_value"),
        performedBy: varchar2("performed_by").references(() => users.id),
        // Who made the change
        ipAddress: varchar2("ip_address"),
        userAgent: text3("user_agent"),
        timestamp: timestamp3("timestamp").defaultNow()
      },
      (table) => [
        index("IDX_audit_org").on(table.organizationId),
        index("IDX_audit_user").on(table.userId),
        index("IDX_audit_action").on(table.action),
        index("IDX_audit_timestamp").on(table.timestamp)
      ]
    );
    userInvitations = pgTable3(
      "user_invitations",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        email: varchar2("email").notNull(),
        inviteCode: varchar2("invite_code").notNull().unique(),
        roleAssignment: varchar2("role_assignment").notNull(),
        // The role they'll get when they accept
        subRoleAssignment: varchar2("sub_role_assignment"),
        // Sub-role for staff/freelancer
        propertyAssignments: jsonb3("property_assignments"),
        // Array of property IDs to assign
        modulePermissions: jsonb3("module_permissions"),
        // Permissions they'll get
        expiresAt: timestamp3("expires_at"),
        // Optional expiration
        invitedBy: varchar2("invited_by").references(() => users.id).notNull(),
        acceptedAt: timestamp3("accepted_at"),
        acceptedByUserId: varchar2("accepted_by_user_id").references(() => users.id),
        status: varchar2("status").default("pending"),
        // pending, accepted, expired, revoked
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_invite_org").on(table.organizationId),
        index("IDX_invite_email").on(table.email),
        index("IDX_invite_code").on(table.inviteCode),
        index("IDX_invite_status").on(table.status)
      ]
    );
    userPerformanceMetrics = pgTable3(
      "user_performance_metrics",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => users.id).notNull(),
        periodMonth: integer3("period_month").notNull(),
        // 1-12
        periodYear: integer3("period_year").notNull(),
        tasksCompleted: integer3("tasks_completed").default(0),
        tasksOnTime: integer3("tasks_on_time").default(0),
        averageRating: decimal2("average_rating", { precision: 3, scale: 2 }),
        // Out of 5.00
        totalEarnings: decimal2("total_earnings", { precision: 10, scale: 2 }),
        responseTimeHours: decimal2("response_time_hours", {
          precision: 5,
          scale: 2
        }),
        clientSatisfactionScore: decimal2("client_satisfaction_score", {
          precision: 3,
          scale: 2
        }),
        calculatedAt: timestamp3("calculated_at").defaultNow()
      },
      (table) => [
        index("IDX_perf_org").on(table.organizationId),
        index("IDX_perf_user").on(table.userId),
        index("IDX_perf_period").on(table.periodYear, table.periodMonth)
      ]
    );
    properties = pgTable3(
      "properties",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        //  clarify type for TS and keep default
        source: varchar2("source").$type().notNull().default("LOCAL"),
        // LOCAL or HOSTAWAY
        // generic external id (you can still use this for anything)
        externalId: varchar2("external_id"),
        // ID from external system (Hostaway, etc.)
        name: varchar2("name").notNull(),
        address: text3("address").notNull(),
        description: text3("description"),
        bedrooms: integer3("bedrooms"),
        bathrooms: integer3("bathrooms"),
        maxGuests: integer3("max_guests"),
        pricePerNight: decimal2("price_per_night", { precision: 10, scale: 2 }),
        currency: varchar2("currency").default("AUD"),
        status: varchar2("status").notNull().default("active"),
        // active, inactive, maintenance
        amenities: text3("amenities").array(),
        images: text3("images").array(),
        rating: decimal2("rating", { precision: 3, scale: 2 }),
        // Property rating (e.g., 4.85 out of 5.00)
        //  existing field  keep it for backward compatibility
        hostawayId: varchar2("hostaway_id"),
        //  explicit Hostaway mapping fields
        hostawayListingMapId: integer3("hostaway_listing_map_id"),
        // used for reservations API
        hostawayPropertyId: integer3("hostaway_property_id"),
        // original Hostaway property id
        hostawayAccountId: integer3("hostaway_account_id"),
        // for multi-account setups
        googleMapsLink: text3("google_maps_link"),
        // Custom Google Maps link or embed HTML
        ownerId: varchar2("owner_id").references(() => users.id),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_property_org").on(table.organizationId),
        index("IDX_property_owner").on(table.ownerId),
        index("IDX_property_external").on(table.externalId),
        index("IDX_property_source").on(table.source),
        // optional helpful indexes
        index("IDX_property_hostaway_listing").on(table.hostawayListingMapId),
        index("IDX_property_hostaway_property").on(table.hostawayPropertyId)
      ]
    );
    tasks = pgTable3("tasks", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      title: varchar2("title").notNull(),
      description: text3("description"),
      type: varchar2("type").notNull(),
      // cleaning, maintenance, pool-service, garden, inspection
      department: varchar2("department"),
      // housekeeping, maintenance, landscaping, pool, guest-services
      status: varchar2("status").notNull().default("pending"),
      // pending, in-progress, completed, cancelled, skipped, rescheduled
      priority: varchar2("priority").notNull().default("medium"),
      // low, medium, high, urgent
      propertyId: integer3("property_id").references(() => properties.id),
      assignedTo: varchar2("assigned_to").references(() => users.id),
      // Legacy: user assignment
      assignedToStaffId: integer3("assigned_to_staff_id").references(
        () => staffMembers.id
      ),
      // Direct staff assignment (no user account required)
      createdBy: varchar2("created_by").references(() => users.id),
      dueDate: timestamp3("due_date"),
      completedAt: timestamp3("completed_at"),
      estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
      actualCost: decimal2("actual_cost", { precision: 10, scale: 2 }),
      isRecurring: boolean3("is_recurring").default(false),
      recurringType: varchar2("recurring_type"),
      // daily, weekly, monthly, yearly
      recurringInterval: integer3("recurring_interval").default(1),
      nextDueDate: timestamp3("next_due_date"),
      parentTaskId: integer3("parent_task_id").references(() => tasks.id),
      // New staff management fields
      completionNotes: text3("completion_notes"),
      skipReason: text3("skip_reason"),
      rescheduleReason: text3("reschedule_reason"),
      rescheduledDate: timestamp3("rescheduled_date"),
      evidencePhotos: text3("evidence_photos").array().default([]),
      issuesFound: text3("issues_found").array().default([]),
      // AI and Auto-assignment fields
      autoAssigned: boolean3("auto_assigned").default(false),
      aiConfidence: decimal2("ai_confidence", { precision: 4, scale: 2 }),
      // Finance linking
      financeRecordId: integer3("finance_record_id").references(() => finances.id),
      financeLinkedAt: timestamp3("finance_linked_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    taskChecklists2 = pgTable3("task_checklists", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      taskType: varchar2("task_type").notNull(),
      // cleaning, maintenance, pool, garden, inspection
      department: varchar2("department").notNull(),
      // cleaning, maintenance, pool, garden, general
      checklistName: varchar2("checklist_name").notNull(),
      checklistItems: text3("checklist_items").array().notNull(),
      // Array of checklist items
      isDefault: boolean3("is_default").default(false),
      // Whether this is the default checklist for this type
      propertyId: integer3("property_id").references(() => properties.id),
      // NULL for organization-wide, specific for property-specific
      isActive: boolean3("is_active").default(true),
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyGuides = pgTable3("property_guides", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      guideName: varchar2("guide_name").notNull(),
      guideContent: text3("guide_content").notNull(),
      category: varchar2("category").notNull(),
      // equipment, procedures, safety, special-instructions
      department: varchar2("department"),
      // cleaning, maintenance, pool, garden, general
      attachments: text3("attachments").array().default([]),
      // File paths for images/documents
      isActive: boolean3("is_active").default(true),
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    aiTaskSuggestions = pgTable3("ai_task_suggestions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      suggestedTaskType: varchar2("suggested_task_type").notNull(),
      department: varchar2("department").notNull(),
      priority: varchar2("priority").notNull().default("medium"),
      reason: text3("reason").notNull(),
      // Why AI suggested this task
      triggerData: text3("trigger_data"),
      // JSON data about what triggered the suggestion
      suggestedDate: timestamp3("suggested_date"),
      status: varchar2("status").notNull().default("pending"),
      // pending, accepted, rejected, auto-created
      createdTaskId: integer3("created_task_id").references(() => tasks.id),
      // If suggestion was accepted
      reviewedBy: varchar2("reviewed_by").references(() => users.id),
      reviewedAt: timestamp3("reviewed_at"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    enhancedAiSuggestions2 = pgTable3("enhanced_ai_suggestions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id),
      suggestionType: varchar2("suggestion_type").notNull(),
      // 'review-feedback', 'long-stay', 'maintenance-due', 'manual'
      sourceData: jsonb3("source_data"),
      // original review/feedback data
      suggestedTaskType: varchar2("suggested_task_type").notNull(),
      suggestedTitle: varchar2("suggested_title").notNull(),
      suggestedDescription: text3("suggested_description"),
      confidenceScore: decimal2("confidence_score", { precision: 5, scale: 2 }),
      urgencyLevel: varchar2("urgency_level").default("medium"),
      // 'low', 'medium', 'high', 'urgent'
      estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
      aiAnalysis: text3("ai_analysis"),
      notificationRouting: jsonb3("notification_routing"),
      // who to notify (roles/specific users)
      escalationLevel: integer3("escalation_level").default(0),
      // 0=new, 1=24hr, 2=48hr, 3=escalated
      status: varchar2("status").default("pending"),
      // 'pending', 'accepted', 'rejected', 'auto-created'
      reviewedBy: varchar2("reviewed_by").references(() => users.id),
      reviewedAt: timestamp3("reviewed_at"),
      createdTaskId: integer3("created_task_id").references(() => tasks.id),
      triggerKeywords: jsonb3("trigger_keywords"),
      // keywords that triggered the suggestion
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyTimeline2 = pgTable3("property_timeline", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      eventType: varchar2("event_type").notNull(),
      // 'checkin', 'checkout', 'cleaning', 'maintenance', 'garden', 'suggestion', 'manual-note'
      title: varchar2("title").notNull(),
      description: text3("description"),
      emoji: varchar2("emoji"),
      // for visual representation
      linkedId: integer3("linked_id"),
      // booking_id, task_id, or suggestion_id
      linkedType: varchar2("linked_type"),
      // 'booking', 'task', 'suggestion', 'manual'
      attachments: jsonb3("attachments"),
      // photos, documents
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdByRole: varchar2("created_by_role"),
      isVisible: boolean3("is_visible").default(true),
      createdAt: timestamp3("created_at").defaultNow()
    });
    inventoryItems2 = pgTable3(
      "inventory_items",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        itemName: varchar2("item_name").notNull(),
        itemType: varchar2("item_type"),
        // linens, cleaning-supplies, toiletries, food-beverage, maintenance, electronics, welcome-packs
        unit: varchar2("unit").notNull().default("unit"),
        // unit, bottle, liter, kg, meter, roll, pack
        defaultPrice: decimal2("default_price", { precision: 10, scale: 2 }).default(
          "0"
        ),
        isActive: boolean3("is_active").default(true),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_inventory_items_org").on(table.organizationId),
        index("IDX_inventory_items_type").on(table.itemType),
        index("IDX_inventory_items_active").on(table.isActive)
      ]
    );
    inventoryUsageLogs2 = pgTable3(
      "inventory_usage_logs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        taskId: integer3("task_id").references(() => tasks.id),
        propertyId: integer3("property_id").references(() => properties.id),
        itemId: integer3("item_id").references(() => inventoryItems2.id),
        quantityUsed: integer3("quantity_used").notNull(),
        costTotal: decimal2("cost_total", { precision: 10, scale: 2 }),
        usedBy: varchar2("used_by").references(() => users.id),
        usageType: varchar2("usage_type").default("checkout-clean"),
        // checkout-clean, maintenance, guest-amenity, welcome-pack, emergency
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_inventory_usage_org").on(table.organizationId),
        index("IDX_inventory_usage_task").on(table.taskId),
        index("IDX_inventory_usage_property").on(table.propertyId),
        index("IDX_inventory_usage_item").on(table.itemId),
        index("IDX_inventory_usage_user").on(table.usedBy),
        index("IDX_inventory_usage_type").on(table.usageType)
      ]
    );
    smartNotifications2 = pgTable3("smart_notifications", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      recipientId: varchar2("recipient_id").references(() => users.id).notNull(),
      recipientRole: varchar2("recipient_role").notNull(),
      notificationType: varchar2("notification_type").notNull(),
      // 'ai-suggestion', 'escalation', 'approval-request', 'timeline-update'
      title: varchar2("title").notNull(),
      message: text3("message"),
      priority: varchar2("priority").default("medium"),
      // 'low', 'medium', 'high', 'urgent'
      sourceId: integer3("source_id"),
      // ai_suggestion_id, task_id, etc.
      sourceType: varchar2("source_type"),
      // 'ai_suggestion', 'task', 'timeline'
      actionRequired: boolean3("action_required").default(false),
      actionButtons: jsonb3("action_buttons"),
      // approve/reject buttons with actions
      isRead: boolean3("is_read").default(false),
      readAt: timestamp3("read_at"),
      autoEscalateAt: timestamp3("auto_escalate_at"),
      // when to escalate if no action
      createdAt: timestamp3("created_at").defaultNow()
    });
    fastActionSuggestions2 = pgTable3("fast_action_suggestions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      suggestedBy: varchar2("suggested_by").references(() => users.id).notNull(),
      suggestedByRole: varchar2("suggested_by_role").notNull(),
      actionType: varchar2("action_type").notNull(),
      // 'purchase', 'repair', 'replace', 'service'
      title: varchar2("title").notNull(),
      description: text3("description"),
      estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
      urgency: varchar2("urgency").default("medium"),
      attachments: jsonb3("attachments"),
      // photos, quotes
      requiresApproval: boolean3("requires_approval").default(true),
      approvalLevel: varchar2("approval_level").default("manager"),
      // 'owner', 'manager', 'admin'
      status: varchar2("status").default("pending"),
      // 'pending', 'approved', 'rejected', 'completed'
      approvedBy: varchar2("approved_by").references(() => users.id),
      approvedAt: timestamp3("approved_at"),
      rejectionReason: text3("rejection_reason"),
      completedAt: timestamp3("completed_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    taskExpenses = pgTable3("task_expenses", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      taskId: integer3("task_id").references(() => tasks.id).notNull(),
      itemName: varchar2("item_name").notNull(),
      category: varchar2("category").notNull(),
      // supplies, tools, materials, services
      amount: decimal2("amount", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").notNull().default("THB"),
      receipt: varchar2("receipt"),
      // File path for receipt image
      notes: text3("notes"),
      addedBy: varchar2("added_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow()
    });
    archivedTasks = pgTable3("archived_tasks", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      originalTaskId: integer3("original_task_id").notNull(),
      taskData: text3("task_data").notNull(),
      // JSON serialized task data
      archiveMonth: varchar2("archive_month").notNull(),
      // YYYY-MM format
      propertyId: integer3("property_id"),
      archivedAt: timestamp3("archived_at").defaultNow(),
      pdfExported: boolean3("pdf_exported").default(false),
      exportedAt: timestamp3("exported_at")
    });
    taskHistory = pgTable3(
      "task_history",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        taskId: integer3("task_id").references(() => tasks.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        action: varchar2("action").notNull(),
        // created, assigned, started, completed, skipped, rescheduled, cancelled
        previousStatus: varchar2("previous_status"),
        newStatus: varchar2("new_status"),
        performedBy: varchar2("performed_by").references(() => users.id),
        notes: text3("notes"),
        evidencePhotos: text3("evidence_photos").array().default([]),
        issuesFound: text3("issues_found").array().default([]),
        timestamp: timestamp3("timestamp").defaultNow()
      },
      (table) => [
        index("IDX_task_history_task").on(table.taskId),
        index("IDX_task_history_property").on(table.propertyId),
        index("IDX_task_history_user").on(table.performedBy)
      ]
    );
    taskProofUploads = pgTable3(
      "task_proof_uploads",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        taskId: integer3("task_id").references(() => tasks.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        uploadType: varchar2("upload_type").notNull(),
        // before, after, evidence, receipt
        fileName: varchar2("file_name").notNull(),
        fileUrl: varchar2("file_url").notNull(),
        fileSize: integer3("file_size"),
        // in bytes
        mimeType: varchar2("mime_type"),
        description: text3("description"),
        uploadedBy: varchar2("uploaded_by").references(() => users.id).notNull(),
        uploadedAt: timestamp3("uploaded_at").defaultNow(),
        isArchived: boolean3("is_archived").default(false),
        archivedAt: timestamp3("archived_at")
      },
      (table) => [
        index("IDX_task_proof_task").on(table.taskId),
        index("IDX_task_proof_property").on(table.propertyId),
        index("IDX_task_proof_date").on(table.uploadedAt)
      ]
    );
    monthlyExportLogs = pgTable3(
      "monthly_export_logs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        exportMonth: varchar2("export_month").notNull(),
        // YYYY-MM format
        exportType: varchar2("export_type").notNull(),
        // task-logs, maintenance-report, full-report
        fileName: varchar2("file_name").notNull(),
        fileUrl: varchar2("file_url").notNull(),
        fileSize: integer3("file_size"),
        // in bytes
        taskCount: integer3("task_count").default(0),
        photoCount: integer3("photo_count").default(0),
        exportStatus: varchar2("export_status").default("processing"),
        // processing, completed, failed
        errorMessage: text3("error_message"),
        cloudStorageUrl: varchar2("cloud_storage_url"),
        // Google Drive URL
        exportedBy: varchar2("exported_by").references(() => users.id),
        exportedAt: timestamp3("exported_at").defaultNow(),
        retentionDate: timestamp3("retention_date")
        // when to delete from local storage
      },
      (table) => [
        index("IDX_monthly_exports_property").on(table.propertyId),
        index("IDX_monthly_exports_month").on(table.exportMonth)
      ]
    );
    bookings = pgTable3("bookings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      externalId: varchar2("external_id"),
      // ID from external system (Hostaway, etc.)
      source: varchar2("source").default("LOCAL").notNull(),
      // LOCAL or HOSTAWAY
      bookingReference: varchar2("booking_reference").unique(),
      // Guest portal access reference
      propertyId: integer3("property_id").references(() => properties.id),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email"),
      guestPhone: varchar2("guest_phone"),
      checkIn: date2("check_in").notNull(),
      checkOut: date2("check_out").notNull(),
      guests: integer3("guests").notNull(),
      // OTA Dual Commission Tracking
      guestTotalPrice: decimal2("guest_total_price", { precision: 10, scale: 2 }),
      // What guest paid to OTA
      platformPayout: decimal2("platform_payout", { precision: 10, scale: 2 }),
      // What host receives after OTA commission
      otaCommissionAmount: decimal2("ota_commission_amount", {
        precision: 10,
        scale: 2
      }),
      // OTA commission deducted
      otaCommissionPercentage: decimal2("ota_commission_percentage", {
        precision: 5,
        scale: 2
      }),
      // OTA commission rate
      bookingPlatform: varchar2("booking_platform").default("direct"),
      // airbnb, vrbo, booking_com, direct
      // Revenue Transparency Fields
      stripeFees: decimal2("stripe_fees", { precision: 10, scale: 2 }),
      // Payment processing fees
      netHostPayout: decimal2("net_host_payout", { precision: 10, scale: 2 }),
      // Final amount after all fees
      manualOverride: boolean3("manual_override").default(false),
      // True if manually entered
      overrideReason: text3("override_reason"),
      // Why manual entry was needed
      revenueVerified: boolean3("revenue_verified").default(false),
      // Verified against bank/Stripe
      // Legacy field for backward compatibility
      totalAmount: decimal2("total_amount", { precision: 10, scale: 2 }),
      // Will map to platformPayout for existing data
      // Payment Tracking
      paymentStatus: varchar2("payment_status").default("pending"),
      // paid, pending, partial
      amountPaid: decimal2("amount_paid", { precision: 10, scale: 2 }).default("0"),
      // Amount customer has paid
      amountDue: decimal2("amount_due", { precision: 10, scale: 2 }).default("0"),
      // Remaining balance (totalAmount - amountPaid)
      currency: varchar2("currency").default("AUD"),
      status: varchar2("status").notNull().default("confirmed"),
      // pending, confirmed, checked-in, checked-out, cancelled
      hostawayId: varchar2("hostaway_id"),
      specialRequests: text3("special_requests"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestServiceRequests2 = pgTable3(
      "guest_service_requests",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
        reservationId: varchar2("reservation_id").notNull(),
        // e.g., Demo1234
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Request Details
        requestType: varchar2("request_type").notNull(),
        // extra_bed, baby_cot, early_checkin, late_checkout, massage, chef, cleaning, amenities
        serviceName: varchar2("service_name").notNull(),
        description: text3("description"),
        requestedDate: date2("requested_date"),
        requestedTime: varchar2("requested_time"),
        // Billing and Assignment
        estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
        finalCost: decimal2("final_cost", { precision: 10, scale: 2 }),
        billingAssignment: varchar2("billing_assignment").default("guest"),
        // guest, owner, company, complimentary
        // Status and Processing
        status: varchar2("status").default("requested"),
        // requested, approved, scheduled, in_progress, completed, cancelled
        approvedBy: varchar2("approved_by").references(() => users.id),
        approvedAt: timestamp3("approved_at"),
        completedAt: timestamp3("completed_at"),
        // Task Integration
        createdTaskId: integer3("created_task_id").references(() => tasks.id),
        assignedDepartment: varchar2("assigned_department"),
        // housekeeping, spa, kitchen, host
        assignedTo: varchar2("assigned_to").references(() => users.id),
        // Guest Communication
        guestNotes: text3("guest_notes"),
        staffNotes: text3("staff_notes"),
        isVisible: boolean3("is_visible").default(true),
        // Visible to guest
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_guest_service_booking").on(table.bookingId),
        index("IDX_guest_service_reservation").on(table.reservationId),
        index("IDX_guest_service_property").on(table.propertyId)
      ]
    );
    guestConfirmedServices = pgTable3(
      "guest_confirmed_services",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
        reservationId: varchar2("reservation_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Service Information
        serviceType: varchar2("service_type").notNull(),
        // request, addon_service, property_service
        serviceName: varchar2("service_name").notNull(),
        serviceDescription: text3("service_description"),
        // Scheduling
        scheduledDate: date2("scheduled_date"),
        scheduledTime: varchar2("scheduled_time"),
        duration: integer3("duration"),
        // in minutes
        // Visibility and Status
        isActive: boolean3("is_active").default(true),
        isCompleted: boolean3("is_completed").default(false),
        completedAt: timestamp3("completed_at"),
        // Integration
        linkedTaskId: integer3("linked_task_id").references(() => tasks.id),
        linkedServiceRequestId: integer3("linked_service_request_id").references(
          () => guestServiceRequests2.id
        ),
        linkedAddonBookingId: integer3("linked_addon_booking_id").references(
          () => addonBookings.id
        ),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_confirmed_service_booking").on(table.bookingId),
        index("IDX_confirmed_service_reservation").on(table.reservationId),
        index("IDX_confirmed_service_date").on(table.scheduledDate)
      ]
    );
    bookingLinkedTasks = pgTable3(
      "booking_linked_tasks",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        taskId: integer3("task_id").references(() => tasks.id).notNull(),
        bookingId: integer3("booking_id").references(() => bookings.id),
        reservationId: varchar2("reservation_id"),
        // e.g., Demo1234
        // Task-Booking Relationship
        taskCategory: varchar2("task_category").notNull(),
        // pre_arrival, checkin, during_stay, checkout, post_departure
        isGuestVisible: boolean3("is_guest_visible").default(false),
        guestDescription: text3("guest_description"),
        // Guest-friendly description
        // Service Request Integration
        serviceRequestId: integer3("service_request_id").references(
          () => guestServiceRequests2.id
        ),
        isServiceGenerated: boolean3("is_service_generated").default(false),
        // Created from guest request
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_booking_task_booking").on(table.bookingId),
        index("IDX_booking_task_reservation").on(table.reservationId),
        index("IDX_booking_task_category").on(table.taskCategory)
      ]
    );
    finances = pgTable3(
      "finances",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        bookingId: integer3("booking_id").references(() => bookings.id),
        type: varchar2("type").notNull(),
        // income, expense, commission, fee, payout
        source: varchar2("source").notNull(),
        // guest-payment, owner-charge, company-expense, complimentary
        sourceType: varchar2("source_type"),
        // owner-gift, company-gift (for complimentary records)
        category: varchar2("category").notNull(),
        // booking-payment, cleaning, maintenance, utilities, commission, add-on-service, etc.
        subcategory: varchar2("subcategory"),
        // cleaning-fee, pool-service, massage, chef-service, etc.
        // Enhanced Department & Cost Center Tracking
        department: varchar2("department").notNull(),
        // housekeeping, maintenance, front-office, marketing, administration, guest-services
        costCenter: varchar2("cost_center"),
        // specific cost allocation (property-level, corporate, shared-services)
        budgetCategory: varchar2("budget_category"),
        // operational, capital, marketing, personnel
        businessUnit: varchar2("business_unit"),
        // property-operations, corporate, sales-marketing, guest-experience
        // Enhanced Financial Details
        amount: decimal2("amount", { precision: 12, scale: 2 }).notNull(),
        currency: varchar2("currency").notNull().default("USD"),
        exchangeRate: decimal2("exchange_rate", { precision: 10, scale: 6 }),
        baseAmount: decimal2("base_amount", { precision: 12, scale: 2 }),
        // amount in organization base currency
        taxAmount: decimal2("tax_amount", { precision: 10, scale: 2 }),
        taxRate: decimal2("tax_rate", { precision: 5, scale: 2 }),
        // Enhanced Dates & Periods
        description: text3("description"),
        date: date2("date").notNull(),
        dueDate: date2("due_date"),
        periodStart: date2("period_start"),
        // for recurring or period-based transactions
        periodEnd: date2("period_end"),
        fiscalYear: integer3("fiscal_year"),
        fiscalMonth: integer3("fiscal_month"),
        // Status & Approval Workflow
        status: varchar2("status").notNull().default("pending"),
        // pending, approved, paid, overdue, scheduled, cancelled
        approvalStatus: varchar2("approval_status").default("not_required"),
        // not_required, pending_approval, approved, rejected
        approvedBy: varchar2("approved_by").references(() => users.id),
        approvedAt: timestamp3("approved_at"),
        // Recurring & Automation
        isRecurring: boolean3("is_recurring").default(false),
        recurringType: varchar2("recurring_type"),
        // monthly, quarterly, yearly
        nextDueDate: date2("next_due_date"),
        parentTransactionId: integer3("parent_transaction_id").references(
          () => finances.id
        ),
        // for recurring transactions
        // Enhanced User & Ownership Tracking
        ownerId: varchar2("owner_id").references(() => users.id),
        agentId: varchar2("agent_id").references(() => users.id),
        processedBy: varchar2("processed_by").references(() => users.id),
        // user who created/processed the record
        assignedTo: varchar2("assigned_to").references(() => users.id),
        // responsible person for this transaction
        // Commission & Revenue Tracking
        commissionRate: decimal2("commission_rate", { precision: 5, scale: 2 }),
        commissionType: varchar2("commission_type"),
        // flat, percentage, tiered
        revenueStream: varchar2("revenue_stream"),
        // direct-booking, ota, corporate, repeat-guest
        channelSource: varchar2("channel_source"),
        // airbnb, booking.com, direct, vrbo, expedia, etc.
        // Enhanced Documentation & References
        referenceNumber: varchar2("reference_number"),
        // external reference (invoice, receipt, etc.)
        invoiceNumber: varchar2("invoice_number"),
        receiptNumber: varchar2("receipt_number"),
        externalId: varchar2("external_id"),
        // reference to external system (PMS, accounting software)
        attachmentUrl: varchar2("attachment_url"),
        // receipt/invoice attachment
        attachments: text3("attachments").array(),
        // multiple attachments
        // Analytics & Reporting Tags
        tags: text3("tags").array(),
        // custom tags for filtering and reporting
        projectCode: varchar2("project_code"),
        // for capital projects or special initiatives
        glAccount: varchar2("gl_account"),
        // general ledger account code
        // Audit & Compliance
        isAudited: boolean3("is_audited").default(false),
        auditedBy: varchar2("audited_by").references(() => users.id),
        auditedAt: timestamp3("audited_at"),
        complianceNotes: text3("compliance_notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_finances_org").on(table.organizationId),
        index("IDX_finances_property").on(table.propertyId),
        index("IDX_finances_department").on(table.department),
        index("IDX_finances_date").on(table.date),
        index("IDX_finances_type").on(table.type),
        index("IDX_finances_status").on(table.status),
        index("IDX_finances_category").on(table.category),
        index("IDX_finances_cost_center").on(table.costCenter),
        index("IDX_finances_business_unit").on(table.businessUnit),
        index("IDX_finances_channel").on(table.channelSource),
        index("IDX_finances_fiscal").on(table.fiscalYear, table.fiscalMonth)
      ]
    );
    inventory = pgTable3("inventory", {
      id: serial2("id").primaryKey(),
      propertyId: integer3("property_id").references(() => properties.id),
      itemName: varchar2("item_name").notNull(),
      category: varchar2("category").notNull(),
      // welcome-pack, cleaning-supplies, maintenance, amenities
      quantity: integer3("quantity").notNull().default(0),
      minQuantity: integer3("min_quantity").default(0),
      unitCost: decimal2("unit_cost", { precision: 10, scale: 2 }),
      supplier: varchar2("supplier"),
      lastRestocked: timestamp3("last_restocked"),
      usageTracking: boolean3("usage_tracking").default(false),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    addonServices = pgTable3("addon_services", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      name: varchar2("name").notNull(),
      description: text3("description"),
      category: varchar2("category").notNull(),
      // cleaning, massage, chef, transportation, activities, concierge
      pricingModel: varchar2("pricing_model").notNull().default("fixed"),
      // fixed, variable, complimentary
      basePrice: decimal2("base_price", { precision: 10, scale: 2 }),
      defaultPriceCents: integer3("default_price_cents"),
      // Price in cents for standardized handling
      hourlyRate: decimal2("hourly_rate", { precision: 10, scale: 2 }),
      minimumCharge: decimal2("minimum_charge", { precision: 10, scale: 2 }),
      duration: integer3("duration"),
      // in minutes for fixed services
      isActive: boolean3("is_active").default(true),
      availableProperties: integer3("available_properties").array(),
      maxAdvanceBookingDays: integer3("max_advance_booking_days").default(30),
      requiresApproval: boolean3("requires_approval").default(false),
      allowGuestBooking: boolean3("allow_guest_booking").default(true),
      allowManagerBooking: boolean3("allow_manager_booking").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    addonBookings = pgTable3("addon_bookings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      bookingIdRef: varchar2("booking_id_ref", { length: 32 }).unique(),
      // BK-YYYYMMDD-XXXX format
      serviceId: integer3("service_id").references(() => addonServices.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email"),
      guestPhone: varchar2("guest_phone"),
      billingType: varchar2("billing_type", { length: 32 }).notNull(),
      // auto_guest, auto_owner, owner_gift, company_gift
      priceCents: integer3("price_cents"),
      // Price in cents, null for complimentary
      dateDue: date2("date_due"),
      // Optional due date
      scheduledDate: timestamp3("scheduled_date").notNull(),
      duration: integer3("duration"),
      // actual duration for variable pricing
      quantity: integer3("quantity").default(1),
      // for multiple units
      basePrice: decimal2("base_price", { precision: 10, scale: 2 }),
      totalPrice: decimal2("total_price", { precision: 10, scale: 2 }).notNull(),
      status: varchar2("status").notNull().default("pending"),
      // pending, confirmed, completed, cancelled
      chargedTo: varchar2("charged_to"),
      // guest, owner, company (derived from billingType)
      giftReason: text3("gift_reason"),
      // reason for gift bookings
      bookedBy: varchar2("booked_by").references(() => users.id).notNull(),
      // user who made the booking
      bookedByRole: varchar2("booked_by_role").notNull(),
      // manager, guest, staff
      approvedBy: varchar2("approved_by").references(() => users.id),
      // for services requiring approval
      approvalStatus: varchar2("approval_status").default("auto-approved"),
      // pending, approved, denied, auto-approved
      notes: text3("notes"),
      internalNotes: text3("internal_notes"),
      // staff-only notes
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyUtilityAccounts = pgTable3("property_utility_accounts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id, { onDelete: "cascade" }).notNull(),
      utilityType: varchar2("utility_type").notNull(),
      // electricity, water, internet, gas
      provider: varchar2("provider").notNull(),
      accountNumber: varchar2("account_number").notNull(),
      packageInfo: text3("package_info"),
      // For internet plans, service details
      expectedBillDay: integer3("expected_bill_day").notNull(),
      // Day of month (1-31)
      isActive: boolean3("is_active").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    utilityBills = pgTable3("utility_bills", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      utilityAccountId: integer3("utility_account_id").references(
        () => propertyUtilityAccounts.id
      ),
      type: varchar2("type").notNull(),
      // electricity, water, gas, internet, maintenance
      provider: varchar2("provider"),
      accountNumber: varchar2("account_number"),
      amount: decimal2("amount", { precision: 10, scale: 2 }),
      currency: varchar2("currency").default("AUD"),
      dueDate: date2("due_date").notNull(),
      billPeriodStart: date2("bill_period_start"),
      billPeriodEnd: date2("bill_period_end"),
      billingMonth: varchar2("billing_month").notNull(),
      // YYYY-MM format
      status: varchar2("status").notNull().default("pending"),
      // pending, uploaded, paid, overdue
      receiptUrl: varchar2("receipt_url"),
      receiptFilename: varchar2("receipt_filename"),
      reminderSent: boolean3("reminder_sent").default(false),
      isRecurring: boolean3("is_recurring").default(true),
      nextDueDate: date2("next_due_date"),
      responsibleParty: varchar2("responsible_party").notNull().default("owner"),
      // owner, company
      isOwnerBillable: boolean3("is_owner_billable").default(true),
      uploadedBy: varchar2("uploaded_by").references(() => users.id),
      uploadedAt: timestamp3("uploaded_at"),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    utilityBillReminders = pgTable3("utility_bill_reminders", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      utilityBillId: integer3("utility_bill_id").references(() => utilityBills.id, {
        onDelete: "cascade"
      }),
      reminderType: varchar2("reminder_type").notNull(),
      // overdue, due_soon, missing_receipt
      sentAt: timestamp3("sent_at").defaultNow(),
      sentTo: varchar2("sent_to").notNull(),
      // user ID
      reminderMessage: text3("reminder_message"),
      isRead: boolean3("is_read").default(false),
      createdAt: timestamp3("created_at").defaultNow()
    });
    utilityAlertRules = pgTable3("utility_alert_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id, {
        onDelete: "cascade"
      }),
      // NULL = applies to all properties
      utilityType: varchar2("utility_type"),
      // NULL = applies to all types
      alertType: varchar2("alert_type").notNull(),
      // upcoming_due_date, overdue_bill, high_amount, missing_receipt
      threshold: decimal2("threshold", { precision: 10, scale: 2 }),
      // For high_amount alerts
      daysBeforeDue: integer3("days_before_due"),
      // For upcoming_due_date alerts
      isEnabled: boolean3("is_enabled").default(true),
      notifyUsers: text3("notify_users").array(),
      // Array of user IDs to notify
      notifyRoles: text3("notify_roles").array(),
      // Array of roles to notify (admin, owner, etc.)
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    otaPayoutRules = pgTable3("ota_payout_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id, {
        onDelete: "cascade"
      }),
      otaPlatform: varchar2("ota_platform").notNull(),
      // airbnb, booking_com, vrbo, direct
      defaultCommissionRate: decimal2("default_commission_rate", {
        precision: 5,
        scale: 2
      }),
      // Platform's typical commission %
      useHostawayPayout: boolean3("use_hostaway_payout").default(true),
      manualPayoutOverride: boolean3("manual_payout_override").default(false),
      alertOnPayoutMissing: boolean3("alert_on_payout_missing").default(true),
      isActive: boolean3("is_active").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    otaBookingPayouts = pgTable3("ota_booking_payouts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      reservationCode: varchar2("reservation_code").notNull(),
      guestName: varchar2("guest_name").notNull(),
      checkInDate: date2("check_in_date").notNull(),
      checkOutDate: date2("check_out_date").notNull(),
      otaPlatform: varchar2("ota_platform").notNull(),
      // airbnb, booking_com, vrbo, direct
      guestPaidAmount: decimal2("guest_paid_amount", {
        precision: 10,
        scale: 2
      }).notNull(),
      netPayoutAmount: decimal2("net_payout_amount", {
        precision: 10,
        scale: 2
      }).notNull(),
      otaCommissionAmount: decimal2("ota_commission_amount", {
        precision: 10,
        scale: 2
      }).notNull(),
      otaCommissionRate: decimal2("ota_commission_rate", {
        precision: 5,
        scale: 2
      }).notNull(),
      currency: varchar2("currency").default("THB"),
      payoutStatus: varchar2("payout_status").notNull().default("pending"),
      // pending, confirmed, received, discrepancy
      payoutConfirmedAt: timestamp3("payout_confirmed_at"),
      payoutConfirmedBy: varchar2("payout_confirmed_by").references(() => users.id),
      hostawaySync: boolean3("hostaway_sync").default(false),
      emailParsed: boolean3("email_parsed").default(false),
      manualOverride: boolean3("manual_override").default(false),
      overrideReason: text3("override_reason"),
      overrideBy: varchar2("override_by").references(() => users.id),
      overrideAt: timestamp3("override_at"),
      notes: text3("notes"),
      alertGenerated: boolean3("alert_generated").default(false),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    otaPayoutAlerts = pgTable3("ota_payout_alerts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      bookingPayoutId: integer3("booking_payout_id").references(
        () => otaBookingPayouts.id,
        { onDelete: "cascade" }
      ),
      alertType: varchar2("alert_type").notNull(),
      // payout_missing, payout_discrepancy, manual_review_needed
      alertMessage: text3("alert_message").notNull(),
      severity: varchar2("severity").notNull().default("medium"),
      // low, medium, high, critical
      isResolved: boolean3("is_resolved").default(false),
      resolvedBy: varchar2("resolved_by").references(() => users.id),
      resolvedAt: timestamp3("resolved_at"),
      resolutionNotes: text3("resolution_notes"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    otaRevenueReports = pgTable3("ota_revenue_reports", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      reportPeriod: varchar2("report_period").notNull(),
      // monthly, quarterly, yearly
      periodStart: date2("period_start").notNull(),
      periodEnd: date2("period_end").notNull(),
      totalGrossRevenue: decimal2("total_gross_revenue", {
        precision: 12,
        scale: 2
      }).notNull(),
      totalNetPayout: decimal2("total_net_payout", {
        precision: 12,
        scale: 2
      }).notNull(),
      totalOtaCommissions: decimal2("total_ota_commissions", {
        precision: 12,
        scale: 2
      }).notNull(),
      totalBookings: integer3("total_bookings").notNull(),
      averageOtaCommissionRate: decimal2("average_ota_commission_rate", {
        precision: 5,
        scale: 2
      }),
      platformBreakdown: json("platform_breakdown"),
      // JSON with per-platform stats
      generatedBy: varchar2("generated_by").references(() => users.id),
      generatedAt: timestamp3("generated_at").defaultNow()
    });
    platformSettings = pgTable3("platform_settings", {
      id: serial2("id").primaryKey(),
      settingKey: varchar2("setting_key").unique().notNull(),
      settingValue: text3("setting_value"),
      settingType: varchar2("setting_type").notNull(),
      // string, number, boolean, json
      category: varchar2("category").notNull(),
      // currency, commission, billing, automation, api
      description: text3("description"),
      isSecret: boolean3("is_secret").default(false),
      // for API keys
      updatedBy: varchar2("updated_by").references(() => users.id),
      updatedAt: timestamp3("updated_at").defaultNow(),
      createdAt: timestamp3("created_at").defaultNow()
    });
    welcomePackItems = pgTable3("welcome_pack_items", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      name: varchar2("name").notNull(),
      category: varchar2("category").notNull(),
      // toiletries, beverages, snacks, amenities
      unitCost: decimal2("unit_cost", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").default("AUD"),
      supplier: varchar2("supplier"),
      restockThreshold: integer3("restock_threshold").default(10),
      currentStock: integer3("current_stock").default(0),
      isActive: boolean3("is_active").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    welcomePackTemplates = pgTable3("welcome_pack_templates", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull().references(() => properties.id),
      itemId: integer3("item_id").notNull().references(() => welcomePackItems.id),
      defaultQuantity: integer3("default_quantity").notNull(),
      isComplimentary: boolean3("is_complimentary").default(false),
      // if true, no cost to guest
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    welcomePackUsage = pgTable3("welcome_pack_usage", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull().references(() => properties.id),
      bookingId: integer3("booking_id").references(() => bookings.id),
      itemId: integer3("item_id").notNull().references(() => welcomePackItems.id),
      quantityUsed: integer3("quantity_used").notNull(),
      unitCost: decimal2("unit_cost", { precision: 10, scale: 2 }).notNull(),
      totalCost: decimal2("total_cost", { precision: 10, scale: 2 }).notNull(),
      billingOption: varchar2("billing_option").notNull().default("owner_bill"),
      // owner_bill, guest_bill, complimentary
      processedBy: varchar2("processed_by"),
      usageDate: date2("usage_date").notNull(),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    emergencyWaterDeliveries = pgTable3("emergency_water_deliveries", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull().references(() => properties.id),
      deliveryDate: date2("delivery_date").notNull(),
      volumeLiters: integer3("volume_liters").notNull(),
      // Volume in liters
      costTHB: decimal2("cost_thb", { precision: 10, scale: 2 }).notNull(),
      // Cost in THB
      costPerLiter: decimal2("cost_per_liter", {
        precision: 10,
        scale: 4
      }).notNull(),
      // Auto-calculated THB per liter
      supplierName: varchar2("supplier_name"),
      // Optional supplier/company name
      receiptUrl: varchar2("receipt_url"),
      // File upload URL
      notes: text3("notes"),
      // Additional notes
      linkedGuestBooking: varchar2("linked_guest_booking"),
      // Optional guest association
      linkedEvent: varchar2("linked_event"),
      // Optional event association
      deliveryType: varchar2("delivery_type").notNull().default("unexpected"),
      // "unexpected", "preventable", "planned"
      billingType: varchar2("billing_type").notNull().default("owner_billable"),
      // "owner_billable", "company_expense", "guest_billable"
      processedBy: varchar2("processed_by").references(() => users.id),
      approvedBy: varchar2("approved_by").references(() => users.id),
      // Manager/Admin approval
      status: varchar2("status").notNull().default("pending"),
      // "pending", "approved", "billed", "completed"
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    waterDeliveryAlerts = pgTable3("water_delivery_alerts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull().references(() => properties.id),
      alertType: varchar2("alert_type").notNull(),
      // "frequent_delivery", "upgrade_suggestion", "cost_warning"
      alertTitle: varchar2("alert_title").notNull(),
      alertMessage: text3("alert_message").notNull(),
      severity: varchar2("severity").notNull().default("medium"),
      // "low", "medium", "high", "critical"
      triggerCount: integer3("trigger_count").notNull(),
      // Number of deliveries that triggered this alert
      triggerPeriodDays: integer3("trigger_period_days").notNull(),
      // Period in days (30, 60, 90)
      totalCost: decimal2("total_cost", { precision: 10, scale: 2 }),
      // Total cost during trigger period
      recommendationAI: text3("recommendation_ai"),
      // AI-generated recommendation
      isAcknowledged: boolean3("is_acknowledged").default(false),
      acknowledgedBy: varchar2("acknowledged_by").references(() => users.id),
      acknowledgedAt: timestamp3("acknowledged_at"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    waterUpgradeSuggestions = pgTable3("water_upgrade_suggestions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull().references(() => properties.id),
      upgradeType: varchar2("upgrade_type").notNull(),
      // "deep_well", "tank_expansion", "water_conservation", "filtration_system"
      currentIssue: text3("current_issue").notNull(),
      suggestedSolution: text3("suggested_solution").notNull(),
      estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
      estimatedSavingsPerYear: decimal2("estimated_savings_per_year", {
        precision: 10,
        scale: 2
      }),
      paybackPeriodMonths: integer3("payback_period_months"),
      priority: varchar2("priority").notNull().default("medium"),
      // "low", "medium", "high", "urgent"
      basedOnDeliveries: integer3("based_on_deliveries").notNull(),
      // Number of deliveries that triggered this suggestion
      confidenceScore: decimal2("confidence_score", { precision: 3, scale: 2 }),
      // AI confidence 0.00-1.00
      status: varchar2("status").notNull().default("new"),
      // "new", "reviewed", "approved", "implemented", "rejected"
      reviewedBy: varchar2("reviewed_by").references(() => users.id),
      reviewedAt: timestamp3("reviewed_at"),
      implementedAt: timestamp3("implemented_at"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    usersRelations = relations(users, ({ many }) => ({
      ownedProperties: many(properties),
      assignedTasks: many(tasks, { relationName: "assignedTasks" }),
      createdTasks: many(tasks, { relationName: "createdTasks" })
    }));
    propertiesRelations = relations(properties, ({ one, many }) => ({
      owner: one(users, { fields: [properties.ownerId], references: [users.id] }),
      tasks: many(tasks),
      bookings: many(bookings),
      finances: many(finances),
      inventory: many(inventory)
    }));
    tasksRelations = relations(tasks, ({ one }) => ({
      property: one(properties, {
        fields: [tasks.propertyId],
        references: [properties.id]
      }),
      assignee: one(users, {
        fields: [tasks.assignedTo],
        references: [users.id],
        relationName: "assignedTasks"
      }),
      creator: one(users, {
        fields: [tasks.createdBy],
        references: [users.id],
        relationName: "createdTasks"
      })
    }));
    bookingsRelations = relations(bookings, ({ one, many }) => ({
      property: one(properties, {
        fields: [bookings.propertyId],
        references: [properties.id]
      }),
      finances: many(finances)
    }));
    financesRelations = relations(finances, ({ one }) => ({
      property: one(properties, {
        fields: [finances.propertyId],
        references: [properties.id]
      }),
      booking: one(bookings, {
        fields: [finances.bookingId],
        references: [bookings.id]
      }),
      owner: one(users, {
        fields: [finances.ownerId],
        references: [users.id],
        relationName: "ownerFinances"
      }),
      agent: one(users, {
        fields: [finances.agentId],
        references: [users.id],
        relationName: "agentFinances"
      }),
      processedByUser: one(users, {
        fields: [finances.processedBy],
        references: [users.id],
        relationName: "processedFinances"
      })
    }));
    inventoryRelations = relations(inventory, ({ one }) => ({
      property: one(properties, {
        fields: [inventory.propertyId],
        references: [properties.id]
      })
    }));
    addonServicesRelations = relations(addonServices, ({ many }) => ({
      bookings: many(addonBookings)
    }));
    addonBookingsRelations = relations(addonBookings, ({ one }) => ({
      service: one(addonServices, {
        fields: [addonBookings.serviceId],
        references: [addonServices.id]
      }),
      booking: one(bookings, {
        fields: [addonBookings.bookingId],
        references: [bookings.id]
      }),
      property: one(properties, {
        fields: [addonBookings.propertyId],
        references: [properties.id]
      })
    }));
    propertyUtilityAccountsRelations = relations(
      propertyUtilityAccounts,
      ({ one, many }) => ({
        property: one(properties, {
          fields: [propertyUtilityAccounts.propertyId],
          references: [properties.id]
        }),
        bills: many(utilityBills)
      })
    );
    utilityBillsRelations = relations(
      utilityBills,
      ({ one, many }) => ({
        property: one(properties, {
          fields: [utilityBills.propertyId],
          references: [properties.id]
        }),
        utilityAccount: one(propertyUtilityAccounts, {
          fields: [utilityBills.utilityAccountId],
          references: [propertyUtilityAccounts.id]
        }),
        uploadedByUser: one(users, {
          fields: [utilityBills.uploadedBy],
          references: [users.id]
        }),
        reminders: many(utilityBillReminders)
      })
    );
    utilityBillRemindersRelations = relations(
      utilityBillReminders,
      ({ one }) => ({
        utilityBill: one(utilityBills, {
          fields: [utilityBillReminders.utilityBillId],
          references: [utilityBills.id]
        }),
        sentToUser: one(users, {
          fields: [utilityBillReminders.sentTo],
          references: [users.id]
        })
      })
    );
    platformSettingsRelations = relations(
      platformSettings,
      ({ one }) => ({
        updatedByUser: one(users, {
          fields: [platformSettings.updatedBy],
          references: [users.id]
        })
      })
    );
    welcomePackItemsRelations = relations(
      welcomePackItems,
      ({ many }) => ({
        templates: many(welcomePackTemplates),
        usage: many(welcomePackUsage)
      })
    );
    welcomePackTemplatesRelations = relations(
      welcomePackTemplates,
      ({ one }) => ({
        property: one(properties, {
          fields: [welcomePackTemplates.propertyId],
          references: [properties.id]
        }),
        item: one(welcomePackItems, {
          fields: [welcomePackTemplates.itemId],
          references: [welcomePackItems.id]
        })
      })
    );
    welcomePackUsageRelations = relations(
      welcomePackUsage,
      ({ one }) => ({
        property: one(properties, {
          fields: [welcomePackUsage.propertyId],
          references: [properties.id]
        }),
        booking: one(bookings, {
          fields: [welcomePackUsage.bookingId],
          references: [bookings.id]
        }),
        item: one(welcomePackItems, {
          fields: [welcomePackUsage.itemId],
          references: [welcomePackItems.id]
        })
      })
    );
    emergencyWaterDeliveriesRelations = relations(
      emergencyWaterDeliveries,
      ({ one }) => ({
        property: one(properties, {
          fields: [emergencyWaterDeliveries.propertyId],
          references: [properties.id]
        }),
        processedByUser: one(users, {
          fields: [emergencyWaterDeliveries.processedBy],
          references: [users.id]
        }),
        approvedByUser: one(users, {
          fields: [emergencyWaterDeliveries.approvedBy],
          references: [users.id]
        })
      })
    );
    waterDeliveryAlertsRelations = relations(
      waterDeliveryAlerts,
      ({ one }) => ({
        property: one(properties, {
          fields: [waterDeliveryAlerts.propertyId],
          references: [properties.id]
        }),
        acknowledgedByUser: one(users, {
          fields: [waterDeliveryAlerts.acknowledgedBy],
          references: [users.id]
        })
      })
    );
    waterUpgradeSuggestionsRelations = relations(
      waterUpgradeSuggestions,
      ({ one }) => ({
        property: one(properties, {
          fields: [waterUpgradeSuggestions.propertyId],
          references: [properties.id]
        }),
        reviewedByUser: one(users, {
          fields: [waterUpgradeSuggestions.reviewedBy],
          references: [users.id]
        })
      })
    );
    waterUtilityRefills = pgTable3("water_utility_refills", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      // Delivery details
      deliveryDate: timestamp3("delivery_date").notNull(),
      litersDelivered: integer3("liters_delivered").notNull(),
      costAmount: decimal2("cost_amount", { precision: 10, scale: 2 }).notNull(),
      costPerLiter: decimal2("cost_per_liter", {
        precision: 10,
        scale: 4
      }).notNull(),
      // Supplier information
      supplierName: varchar2("supplier_name"),
      supplierContact: varchar2("supplier_contact"),
      // Classification
      waterType: varchar2("water_type").notNull().default("emergency_truck"),
      // 'government', 'deepwell', 'emergency_truck'
      billingRoute: varchar2("billing_route").notNull(),
      // 'guest_billable', 'owner_billable', 'company_expense'
      // Additional details
      notes: text3("notes"),
      status: varchar2("status").notNull().default("delivered"),
      // 'delivered', 'cancelled', 'refunded'
      // Audit trail
      createdBy: varchar2("created_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    waterRefillAlerts = pgTable3("water_refill_alerts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      // Alert details
      alertType: varchar2("alert_type").notNull(),
      // 'frequency_alert', 'cost_alert', 'volume_alert'
      alertMessage: text3("alert_message").notNull(),
      triggerCount: integer3("trigger_count").notNull(),
      triggerPeriodDays: integer3("trigger_period_days").notNull().default(30),
      severity: varchar2("severity").notNull().default("medium"),
      // 'low', 'medium', 'high'
      recommendations: text3("recommendations"),
      // Status
      isAcknowledged: boolean3("is_acknowledged").notNull().default(false),
      acknowledgedBy: varchar2("acknowledged_by"),
      acknowledgedAt: timestamp3("acknowledged_at"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    waterRefillBills = pgTable3("water_refill_bills", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      refillId: integer3("refill_id").notNull(),
      // Bill details
      billAmount: decimal2("bill_amount", { precision: 10, scale: 2 }).notNull(),
      billingRoute: varchar2("billing_route").notNull(),
      billDate: timestamp3("bill_date").notNull(),
      dueDate: timestamp3("due_date"),
      // Status
      paymentStatus: varchar2("payment_status").notNull().default("pending"),
      // 'pending', 'paid', 'overdue'
      paidAt: timestamp3("paid_at"),
      paidBy: varchar2("paid_by"),
      // Integration with water bills
      waterBillId: integer3("water_bill_id"),
      // Reference to existing water bill if added as line item
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    waterUtilityRefillsRelations = relations(
      waterUtilityRefills,
      ({ one, many }) => ({
        property: one(properties, {
          fields: [waterUtilityRefills.propertyId],
          references: [properties.id]
        }),
        createdByUser: one(users, {
          fields: [waterUtilityRefills.createdBy],
          references: [users.id]
        }),
        bills: many(waterRefillBills)
      })
    );
    waterRefillAlertsRelations = relations(
      waterRefillAlerts,
      ({ one }) => ({
        property: one(properties, {
          fields: [waterRefillAlerts.propertyId],
          references: [properties.id]
        }),
        acknowledgedByUser: one(users, {
          fields: [waterRefillAlerts.acknowledgedBy],
          references: [users.id]
        })
      })
    );
    waterRefillBillsRelations = relations(
      waterRefillBills,
      ({ one }) => ({
        property: one(properties, {
          fields: [waterRefillBills.propertyId],
          references: [properties.id]
        }),
        refill: one(waterUtilityRefills, {
          fields: [waterRefillBills.refillId],
          references: [waterUtilityRefills.id]
        }),
        paidByUser: one(users, {
          fields: [waterRefillBills.paidBy],
          references: [users.id]
        })
      })
    );
    propertyWaterSources = pgTable3("property_water_sources", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      // Water source details
      sourceType: varchar2("source_type").notNull(),
      // 'government', 'deepwell', 'emergency_truck'
      sourceName: varchar2("source_name"),
      // Custom name for the source
      isActive: boolean3("is_active").notNull().default(true),
      isPrimary: boolean3("is_primary").notNull().default(false),
      // One primary source per property
      // Source-specific settings
      billingCycle: varchar2("billing_cycle"),
      // 'monthly', 'quarterly' for government/deepwell
      accountNumber: varchar2("account_number"),
      // For government/deepwell
      supplierName: varchar2("supplier_name"),
      // For emergency truck
      contactNumber: varchar2("contact_number"),
      // Cost tracking
      averageCostPerLiter: decimal2("average_cost_per_liter", {
        precision: 8,
        scale: 4
      }),
      currency: varchar2("currency").notNull().default("THB"),
      // Setup and notes
      setupDate: timestamp3("setup_date"),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    waterConsumptionEntries = pgTable3("water_consumption_entries", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      sourceId: integer3("source_id").notNull(),
      // References property_water_sources
      // Entry details
      entryType: varchar2("entry_type").notNull(),
      // 'bill', 'emergency_delivery', 'regular_delivery'
      entryDate: timestamp3("entry_date").notNull(),
      // Volume and cost
      volumeLiters: integer3("volume_liters"),
      // For deliveries
      totalCost: decimal2("total_cost", { precision: 10, scale: 2 }).notNull(),
      costPerLiter: decimal2("cost_per_liter", { precision: 8, scale: 4 }),
      currency: varchar2("currency").notNull().default("THB"),
      // Bill-specific fields
      billDate: timestamp3("bill_date"),
      dueDate: timestamp3("due_date"),
      billNumber: varchar2("bill_number"),
      units: varchar2("units"),
      // m3, liters, etc.
      unitRate: decimal2("unit_rate", { precision: 8, scale: 4 }),
      // Delivery-specific fields
      supplierName: varchar2("supplier_name"),
      deliveryType: varchar2("delivery_type"),
      // 'scheduled', 'emergency', 'top_up'
      driverName: varchar2("driver_name"),
      truckLicensePlate: varchar2("truck_license_plate"),
      // Payment and status
      paidBy: varchar2("paid_by"),
      // 'owner', 'management', 'other'
      paidByCustom: varchar2("paid_by_custom"),
      // When 'other' is selected
      paymentStatus: varchar2("payment_status").notNull().default("pending"),
      // 'pending', 'paid', 'overdue'
      paidAt: timestamp3("paid_at"),
      // Emergency and priority
      isEmergency: boolean3("is_emergency").notNull().default(false),
      urgencyLevel: varchar2("urgency_level"),
      // 'low', 'medium', 'high', 'critical'
      emergencyReason: text3("emergency_reason"),
      // Receipt and documentation
      receiptUrl: varchar2("receipt_url"),
      proofOfDeliveryUrl: varchar2("proof_of_delivery_url"),
      notes: text3("notes"),
      // Audit
      createdBy: varchar2("created_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    waterConsumptionAlerts = pgTable3("water_consumption_alerts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      // Alert details
      alertType: varchar2("alert_type").notNull(),
      // 'no_entry_dry_season', 'frequent_emergency', 'cost_spike', 'overdue_bill'
      alertMessage: text3("alert_message").notNull(),
      severity: varchar2("severity").notNull().default("medium"),
      // 'low', 'medium', 'high', 'critical'
      // Alert triggers
      triggerCount: integer3("trigger_count"),
      // For frequency-based alerts
      triggerPeriodDays: integer3("trigger_period_days").notNull().default(30),
      daysSinceLastEntry: integer3("days_since_last_entry"),
      // Alert metadata
      sourceType: varchar2("source_type"),
      // Which source type triggered the alert
      recommendations: text3("recommendations"),
      aiGenerated: boolean3("ai_generated").notNull().default(false),
      // Status
      isActive: boolean3("is_active").notNull().default(true),
      acknowledgedBy: varchar2("acknowledged_by"),
      acknowledgedAt: timestamp3("acknowledged_at"),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    waterSuppliers = pgTable3("water_suppliers", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      // Supplier details
      supplierName: varchar2("supplier_name").notNull(),
      contactPerson: varchar2("contact_person"),
      phoneNumber: varchar2("phone_number"),
      alternatePhone: varchar2("alternate_phone"),
      email: varchar2("email"),
      // Service details
      serviceAreas: text3("service_areas"),
      // JSON array of areas they serve
      vehicleTypes: text3("vehicle_types"),
      // JSON array of truck types/sizes
      minimumOrder: integer3("minimum_order"),
      // Minimum liters
      maximumCapacity: integer3("maximum_capacity"),
      // Maximum liters per delivery
      // Pricing
      pricePerLiter: decimal2("price_per_liter", { precision: 8, scale: 4 }),
      emergencyUpcharge: decimal2("emergency_upcharge", { precision: 5, scale: 2 }),
      // Percentage
      currency: varchar2("currency").notNull().default("THB"),
      // Performance tracking
      averageResponseTime: integer3("average_response_time"),
      // Hours
      reliabilityRating: decimal2("reliability_rating", { precision: 3, scale: 2 }),
      // 1-5 scale
      totalDeliveries: integer3("total_deliveries").notNull().default(0),
      // Status and notes
      isActive: boolean3("is_active").notNull().default(true),
      isPreferred: boolean3("is_preferred").notNull().default(false),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyWaterSourcesRelations = relations(
      propertyWaterSources,
      ({ one, many }) => ({
        property: one(properties, {
          fields: [propertyWaterSources.propertyId],
          references: [properties.id]
        }),
        consumptionEntries: many(waterConsumptionEntries)
      })
    );
    waterConsumptionEntriesRelations = relations(
      waterConsumptionEntries,
      ({ one }) => ({
        property: one(properties, {
          fields: [waterConsumptionEntries.propertyId],
          references: [properties.id]
        }),
        source: one(propertyWaterSources, {
          fields: [waterConsumptionEntries.sourceId],
          references: [propertyWaterSources.id]
        }),
        createdByUser: one(users, {
          fields: [waterConsumptionEntries.createdBy],
          references: [users.id]
        })
      })
    );
    waterConsumptionAlertsRelations = relations(
      waterConsumptionAlerts,
      ({ one }) => ({
        property: one(properties, {
          fields: [waterConsumptionAlerts.propertyId],
          references: [properties.id]
        }),
        acknowledgedByUser: one(users, {
          fields: [waterConsumptionAlerts.acknowledgedBy],
          references: [users.id]
        })
      })
    );
    waterSuppliersRelations = relations(
      waterSuppliers,
      ({ many }) => ({
        // No direct relations, but can be referenced by supplier name in consumption entries
      })
    );
    ownerPayouts = pgTable3("owner_payouts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      ownerId: varchar2("owner_id").notNull(),
      // User ID of the owner
      propertyId: integer3("property_id"),
      // Optional: specific property or all properties
      requestedAmount: varchar2("requested_amount").notNull(),
      currency: varchar2("currency").notNull().default("USD"),
      status: varchar2("status").notNull().default("pending"),
      // 'pending', 'approved', 'paid', 'completed', 'rejected'
      // Request details
      requestDate: timestamp3("request_date").defaultNow(),
      requestedBy: varchar2("requested_by").notNull(),
      // Usually same as ownerId
      requestNotes: text3("request_notes"),
      // Admin approval
      approvedBy: varchar2("approved_by"),
      // Admin user ID
      approvedDate: timestamp3("approved_date"),
      approvalNotes: text3("approval_notes"),
      // Payment details
      paymentMethod: varchar2("payment_method"),
      // 'bank_transfer', 'check', 'other'
      paymentReference: varchar2("payment_reference"),
      // Reference number
      paymentDate: timestamp3("payment_date"),
      paidBy: varchar2("paid_by"),
      // Admin user ID who processed payment
      // Receipt management
      receiptUrl: varchar2("receipt_url"),
      // URL to uploaded receipt
      receiptUploadedBy: varchar2("receipt_uploaded_by"),
      // Admin user ID
      receiptUploadedDate: timestamp3("receipt_uploaded_date"),
      // Owner confirmation
      confirmedBy: varchar2("confirmed_by"),
      // Owner user ID
      confirmedDate: timestamp3("confirmed_date"),
      // Financial period covered
      periodStartDate: varchar2("period_start_date"),
      periodEndDate: varchar2("period_end_date"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    ownerPayoutsRelations = relations(ownerPayouts, ({ one }) => ({
      owner: one(users, {
        fields: [ownerPayouts.ownerId],
        references: [users.id],
        relationName: "ownerPayouts"
      }),
      property: one(properties, {
        fields: [ownerPayouts.propertyId],
        references: [properties.id]
      }),
      requestedByUser: one(users, {
        fields: [ownerPayouts.requestedBy],
        references: [users.id],
        relationName: "payoutRequests"
      }),
      approvedByUser: one(users, {
        fields: [ownerPayouts.approvedBy],
        references: [users.id],
        relationName: "payoutApprovals"
      }),
      paidByUser: one(users, {
        fields: [ownerPayouts.paidBy],
        references: [users.id],
        relationName: "payoutPayments"
      }),
      receiptUploadedByUser: one(users, {
        fields: [ownerPayouts.receiptUploadedBy],
        references: [users.id],
        relationName: "payoutReceiptUploads"
      }),
      confirmedByUser: one(users, {
        fields: [ownerPayouts.confirmedBy],
        references: [users.id],
        relationName: "payoutConfirmations"
      })
    }));
    notifications = pgTable3("notifications", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      userId: varchar2("user_id").references(() => users.id).notNull(),
      type: varchar2("type").notNull(),
      // task_assignment, booking_update, payout_action, maintenance_approval
      title: varchar2("title").notNull(),
      message: text3("message").notNull(),
      relatedEntityType: varchar2("related_entity_type"),
      // task, booking, payout, property
      relatedEntityId: integer3("related_entity_id"),
      priority: varchar2("priority").default("normal"),
      // low, normal, high, urgent
      isRead: boolean3("is_read").default(false),
      readAt: timestamp3("read_at"),
      actionUrl: varchar2("action_url"),
      // optional URL for action buttons
      actionLabel: varchar2("action_label"),
      // optional label for action button
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      expiresAt: timestamp3("expires_at")
      // optional expiration for time-sensitive notifications
    });
    notificationPreferences = pgTable3("notification_preferences", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      userId: varchar2("user_id").references(() => users.id).notNull(),
      enableInApp: boolean3("enable_in_app").default(true),
      enableEmail: boolean3("enable_email").default(true),
      enableSms: boolean3("enable_sms").default(false),
      enableWhatsapp: boolean3("enable_whatsapp").default(false),
      enableLine: boolean3("enable_line").default(false),
      taskAssignments: boolean3("task_assignments").default(true),
      bookingUpdates: boolean3("booking_updates").default(true),
      payoutActions: boolean3("payout_actions").default(true),
      maintenanceApprovals: boolean3("maintenance_approvals").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    notificationsRelations = relations(notifications, ({ one }) => ({
      user: one(users, { fields: [notifications.userId], references: [users.id] }),
      createdByUser: one(users, {
        fields: [notifications.createdBy],
        references: [users.id]
      })
    }));
    notificationPreferencesRelations = relations(
      notificationPreferences,
      ({ one }) => ({
        user: one(users, {
          fields: [notificationPreferences.userId],
          references: [users.id]
        })
      })
    );
    guestBookings = pgTable3("guest_bookings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email").notNull(),
      guestPhone: varchar2("guest_phone"),
      numberOfGuests: integer3("number_of_guests").notNull(),
      checkInDate: timestamp3("check_in_date").notNull(),
      checkOutDate: timestamp3("check_out_date").notNull(),
      bookingStatus: varchar2("booking_status").default("confirmed"),
      // confirmed, checked_in, checked_out, cancelled
      totalAmount: decimal2("total_amount", { precision: 10, scale: 2 }),
      currency: varchar2("currency").default("THB"),
      depositPaid: decimal2("deposit_paid", { precision: 10, scale: 2 }),
      depositStatus: varchar2("deposit_status").default("pending"),
      // pending, paid, refunded
      emergencyContact: varchar2("emergency_contact"),
      specialRequests: text3("special_requests"),
      wifiCode: varchar2("wifi_code"),
      welcomePackInclusions: jsonb3("welcome_pack_inclusions"),
      managerContact: varchar2("manager_contact"),
      houseRules: text3("house_rules"),
      checkInInstructions: text3("check_in_instructions"),
      checkOutInstructions: text3("check_out_instructions"),
      propertyInfo: jsonb3("property_info"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestAiRecommendations = pgTable3("guest_ai_recommendations", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      guestBookingId: integer3("guest_booking_id").references(
        () => guestBookings.id
      ),
      recommendationType: varchar2("recommendation_type").notNull(),
      // restaurant, attraction, tour, weather, service
      title: varchar2("title").notNull(),
      description: text3("description"),
      location: varchar2("location"),
      distance: varchar2("distance"),
      // e.g., "2.5 km away"
      rating: decimal2("rating", { precision: 3, scale: 1 }),
      // 4.5/5.0
      priceRange: varchar2("price_range"),
      // $, $$, $$$, $$$$
      operatingHours: varchar2("operating_hours"),
      website: varchar2("website"),
      phone: varchar2("phone"),
      imageUrl: varchar2("image_url"),
      category: varchar2("category"),
      // thai_food, seafood, beach, temple, tour_company
      aiConfidenceScore: decimal2("ai_confidence_score", { precision: 5, scale: 2 }),
      weatherData: jsonb3("weather_data"),
      // for weather recommendations
      isActive: boolean3("is_active").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestServiceTimeline = pgTable3("guest_service_timeline", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      guestBookingId: integer3("guest_booking_id").references(
        () => guestBookings.id
      ),
      serviceType: varchar2("service_type").notNull(),
      // cleaning, pool, garden, pest_control, maintenance
      serviceName: varchar2("service_name").notNull(),
      scheduledDate: timestamp3("scheduled_date").notNull(),
      estimatedTime: varchar2("estimated_time"),
      // "2-3 hours"
      serviceProvider: varchar2("service_provider"),
      status: varchar2("status").default("scheduled"),
      // scheduled, in_progress, completed, cancelled
      notes: text3("notes"),
      guestVisible: boolean3("guest_visible").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyAmenities = pgTable3("property_amenities", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      amenityName: varchar2("amenity_name").notNull(),
      amenityType: varchar2("amenity_type").notNull(),
      // wifi, pool, kitchen, parking, ac, etc.
      description: text3("description"),
      isAvailable: boolean3("is_available").default(true),
      instructions: text3("instructions"),
      // how to use
      wifiCode: varchar2("wifi_code"),
      emergencyInfo: text3("emergency_info"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestBookingsRelations = relations(
      guestBookings,
      ({ one, many }) => ({
        property: one(properties, {
          fields: [guestBookings.propertyId],
          references: [properties.id]
        }),
        aiRecommendations: many(guestAiRecommendations),
        serviceTimeline: many(guestServiceTimeline)
      })
    );
    guestAiRecommendationsRelations = relations(
      guestAiRecommendations,
      ({ one }) => ({
        property: one(properties, {
          fields: [guestAiRecommendations.propertyId],
          references: [properties.id]
        }),
        guestBooking: one(guestBookings, {
          fields: [guestAiRecommendations.guestBookingId],
          references: [guestBookings.id]
        })
      })
    );
    guestServiceTimelineRelations = relations(
      guestServiceTimeline,
      ({ one }) => ({
        property: one(properties, {
          fields: [guestServiceTimeline.propertyId],
          references: [properties.id]
        }),
        guestBooking: one(guestBookings, {
          fields: [guestServiceTimeline.guestBookingId],
          references: [guestBookings.id]
        })
      })
    );
    propertyAmenitiesRelations = relations(
      propertyAmenities,
      ({ one }) => ({
        property: one(properties, {
          fields: [propertyAmenities.propertyId],
          references: [properties.id]
        })
      })
    );
    balanceResetAudit = pgTable3("balance_reset_audit", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      userId: varchar2("user_id").notNull(),
      // User whose balance was reset
      userType: varchar2("user_type").notNull(),
      // owner, portfolio-manager, referral-agent, retail-agent
      previousBalance: decimal2("previous_balance", {
        precision: 10,
        scale: 2
      }).notNull(),
      newBalance: decimal2("new_balance", { precision: 10, scale: 2 }).notNull().default("0.00"),
      resetReason: text3("reset_reason"),
      adminUserId: varchar2("admin_user_id").notNull(),
      // Admin who performed the reset
      propertyId: integer3("property_id"),
      // Optional: if reset is property-specific
      createdAt: timestamp3("created_at").defaultNow()
    });
    utilityProviders = pgTable3("utility_providers", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      utilityType: varchar2("utility_type").notNull(),
      // internet, electricity, water, gas, etc.
      providerName: varchar2("provider_name").notNull(),
      country: varchar2("country").default("Thailand"),
      region: varchar2("region"),
      // state, province, city for regional providers
      isDefault: boolean3("is_default").default(false),
      isActive: boolean3("is_active").default(true),
      contactInfo: text3("contact_info"),
      // phone, website, email
      billingCycle: varchar2("billing_cycle").default("monthly"),
      // monthly, quarterly, annual
      notes: text3("notes"),
      displayOrder: integer3("display_order").default(0),
      createdBy: varchar2("created_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    customExpenseCategories = pgTable3("custom_expense_categories", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      categoryName: varchar2("category_name").notNull(),
      description: text3("description"),
      isRecurring: boolean3("is_recurring").default(true),
      billingCycle: varchar2("billing_cycle").default("monthly"),
      // monthly, quarterly, annual, one-time
      defaultAmount: decimal2("default_amount", { precision: 10, scale: 2 }),
      currency: varchar2("currency").default("THB"),
      autoReminder: boolean3("auto_reminder").default(true),
      reminderDays: integer3("reminder_days").default(5),
      // days before due
      isActive: boolean3("is_active").default(true),
      displayOrder: integer3("display_order").default(0),
      createdBy: varchar2("created_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyUtilitySettings = pgTable3("property_utility_settings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      utilityType: varchar2("utility_type").notNull(),
      // internet, electricity, water
      providerId: integer3("provider_id"),
      // references utilityProviders.id
      customProviderName: varchar2("custom_provider_name"),
      // for "Other" option
      accountNumber: varchar2("account_number"),
      monthlyBudget: decimal2("monthly_budget", { precision: 10, scale: 2 }),
      isActive: boolean3("is_active").default(true),
      notes: text3("notes"),
      createdBy: varchar2("created_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyCustomExpenses = pgTable3("property_custom_expenses", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      categoryId: integer3("category_id").notNull(),
      // references customExpenseCategories.id
      monthlyAmount: decimal2("monthly_amount", { precision: 10, scale: 2 }),
      nextDueDate: timestamp3("next_due_date"),
      lastBillDate: timestamp3("last_bill_date"),
      isActive: boolean3("is_active").default(true),
      notes: text3("notes"),
      createdBy: varchar2("created_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    commissionEarnings = pgTable3("commission_earnings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      userId: varchar2("user_id").notNull(),
      // Staff/PM receiving commission
      sourceType: varchar2("source_type").notNull(),
      // 'booking', 'service', 'referral'
      sourceId: integer3("source_id"),
      // Reference to booking/service/etc
      amount: decimal2("amount", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency", { length: 3 }).default("USD"),
      commissionRate: decimal2("commission_rate", {
        precision: 5,
        scale: 2
      }).notNull(),
      baseAmount: decimal2("base_amount", { precision: 10, scale: 2 }).notNull(),
      period: varchar2("period").notNull(),
      // 'YYYY-MM' format
      status: varchar2("status").default("pending"),
      // pending, approved, paid
      processedBy: varchar2("processed_by"),
      processedAt: timestamp3("processed_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    portfolioAssignments = pgTable3("portfolio_assignments", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      managerId: varchar2("manager_id").notNull(),
      // Portfolio manager user ID
      propertyId: integer3("property_id").references(() => properties.id, {
        onDelete: "cascade"
      }),
      commissionRate: decimal2("commission_rate", {
        precision: 5,
        scale: 2
      }).default("50"),
      // Default 50%
      assignedAt: timestamp3("assigned_at").defaultNow(),
      unassignedAt: timestamp3("unassigned_at"),
      isActive: boolean3("is_active").default(true)
    });
    commissionEarningsRelations = relations(
      commissionEarnings,
      ({ one }) => ({
        user: one(users, {
          fields: [commissionEarnings.userId],
          references: [users.id]
        }),
        processedByUser: one(users, {
          fields: [commissionEarnings.processedBy],
          references: [users.id]
        })
      })
    );
    portfolioAssignmentsRelations = relations(
      portfolioAssignments,
      ({ one }) => ({
        manager: one(users, {
          fields: [portfolioAssignments.managerId],
          references: [users.id]
        }),
        property: one(properties, {
          fields: [portfolioAssignments.propertyId],
          references: [properties.id]
        })
      })
    );
    pmCommissionBalance2 = pgTable3("pm_commission_balance", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      managerId: varchar2("manager_id").notNull(),
      totalEarned: decimal2("total_earned", { precision: 12, scale: 2 }).default(
        "0"
      ),
      totalPaid: decimal2("total_paid", { precision: 12, scale: 2 }).default("0"),
      currentBalance: decimal2("current_balance", {
        precision: 12,
        scale: 2
      }).default("0"),
      lastPayoutDate: timestamp3("last_payout_date"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    pmPayoutRequests = pgTable3("pm_payout_requests", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      managerId: varchar2("manager_id").notNull(),
      amount: decimal2("amount", { precision: 12, scale: 2 }).notNull(),
      currency: varchar2("currency", { length: 3 }).default("AUD"),
      requestNotes: text3("request_notes"),
      adminNotes: text3("admin_notes"),
      status: varchar2("status").default("pending"),
      // pending, approved, paid, rejected
      receiptUrl: varchar2("receipt_url"),
      // Admin uploaded receipt
      requestedAt: timestamp3("requested_at").defaultNow(),
      approvedAt: timestamp3("approved_at"),
      paidAt: timestamp3("paid_at"),
      processedBy: varchar2("processed_by")
    });
    pmTaskLogs2 = pgTable3("pm_task_logs", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      managerId: varchar2("manager_id").notNull(),
      taskId: integer3("task_id").references(() => tasks.id, {
        onDelete: "cascade"
      }),
      propertyId: integer3("property_id").references(() => properties.id),
      taskTitle: varchar2("task_title").notNull(),
      department: varchar2("department").notNull(),
      staffAssigned: varchar2("staff_assigned"),
      status: varchar2("status").notNull(),
      completedAt: timestamp3("completed_at"),
      evidencePhotos: jsonb3("evidence_photos"),
      // Array of photo URLs
      assignedAt: timestamp3("assigned_at").defaultNow(),
      completionNotes: text3("completion_notes")
    });
    ownerBalances2 = pgTable3("owner_balances", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      currentBalance: decimal2("current_balance", {
        precision: 12,
        scale: 2
      }).default("0"),
      totalEarnings: decimal2("total_earnings", { precision: 12, scale: 2 }).default(
        "0"
      ),
      totalExpenses: decimal2("total_expenses", { precision: 12, scale: 2 }).default(
        "0"
      ),
      totalPayoutsRequested: decimal2("total_payouts_requested", {
        precision: 12,
        scale: 2
      }).default("0"),
      totalPayoutsPaid: decimal2("total_payouts_paid", {
        precision: 12,
        scale: 2
      }).default("0"),
      thisMonthEarnings: decimal2("this_month_earnings", {
        precision: 12,
        scale: 2
      }).default("0"),
      thisMonthExpenses: decimal2("this_month_expenses", {
        precision: 12,
        scale: 2
      }).default("0"),
      thisMonthNet: decimal2("this_month_net", { precision: 12, scale: 2 }).default(
        "0"
      ),
      lastCalculated: timestamp3("last_calculated").defaultNow(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    ownerChargeRequests2 = pgTable3("owner_charge_requests", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      chargedBy: varchar2("charged_by").references(() => users.id).notNull(),
      // Admin/PM creating charge
      amount: decimal2("amount", { precision: 12, scale: 2 }).notNull(),
      currency: varchar2("currency", { length: 3 }).default("AUD"),
      reason: text3("reason").notNull(),
      description: text3("description"),
      dueDate: date2("due_date"),
      // Payment tracking
      paymentMethod: varchar2("payment_method"),
      // bank, paypal, cash, offset
      paymentReference: varchar2("payment_reference"),
      paymentReceiptUrl: varchar2("payment_receipt_url"),
      status: varchar2("status").default("pending"),
      // pending, paid, overdue, cancelled
      // Workflow timestamps
      chargedAt: timestamp3("charged_at").defaultNow(),
      paidAt: timestamp3("paid_at"),
      processedBy: varchar2("processed_by")
      // Admin who confirmed payment
    });
    propertyUtilityAccountsNew2 = pgTable3(
      "property_utility_accounts_new",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id, {
          onDelete: "cascade"
        }),
        // Utility details
        utilityType: varchar2("utility_type").notNull(),
        // electricity, water, internet, gas, custom
        providerName: varchar2("provider_name").notNull(),
        // PEA, 3BB, CAT, AIS, True, NT, Deepwell
        accountNumber: varchar2("account_number").notNull(),
        contractHolder: varchar2("contract_holder"),
        // Owner name or company
        // Billing schedule
        expectedBillDate: integer3("expected_bill_date").notNull(),
        // Day of month (1-31)
        billingCycle: varchar2("billing_cycle").default("monthly"),
        // monthly, quarterly
        averageMonthlyAmount: decimal2("average_monthly_amount", {
          precision: 10,
          scale: 2
        }),
        // Contact info
        customerServicePhone: varchar2("customer_service_phone"),
        onlinePortalUrl: varchar2("online_portal_url"),
        emergencyContactPhone: varchar2("emergency_contact_phone"),
        // Auto-reminder settings
        autoRemindersEnabled: boolean3("auto_reminders_enabled").default(true),
        reminderDaysAfterDue: integer3("reminder_days_after_due").default(4),
        isActive: boolean3("is_active").default(true),
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    utilityBillsNew = pgTable3("utility_bills_new", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      utilityAccountId: integer3("utility_account_id").references(
        () => propertyUtilityAccountsNew2.id
      ),
      // Bill details
      billNumber: varchar2("bill_number"),
      billingPeriodStart: date2("billing_period_start"),
      billingPeriodEnd: date2("billing_period_end"),
      dueDate: date2("due_date").notNull(),
      amount: decimal2("amount", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency", { length: 3 }).default("THB"),
      // Usage tracking
      currentReading: varchar2("current_reading"),
      previousReading: varchar2("previous_reading"),
      unitsUsed: decimal2("units_used", { precision: 10, scale: 2 }),
      ratePerUnit: decimal2("rate_per_unit", { precision: 10, scale: 4 }),
      // Status tracking
      status: varchar2("status").default("pending"),
      // pending, uploaded, paid, overdue
      billScanUrl: varchar2("bill_scan_url"),
      // Uploaded bill image
      paymentReceiptUrl: varchar2("payment_receipt_url"),
      // Payment proof
      paymentMethod: varchar2("payment_method"),
      // bank, online, cash, auto-debit
      // Payment details
      paidAmount: decimal2("paid_amount", { precision: 10, scale: 2 }),
      paidDate: date2("paid_date"),
      paymentReference: varchar2("payment_reference"),
      // Assignment
      responsibleParty: varchar2("responsible_party").default("owner"),
      // owner, company
      uploadedBy: varchar2("uploaded_by"),
      // User who uploaded bill
      paidBy: varchar2("paid_by"),
      // User who confirmed payment
      // Auto-tracking
      autoReminderSent: boolean3("auto_reminder_sent").default(false),
      reminderSentAt: timestamp3("reminder_sent_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    recurringServiceCharges2 = pgTable3("recurring_service_charges", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id, {
        onDelete: "cascade"
      }),
      // Service details
      serviceName: varchar2("service_name").notNull(),
      // Pool, Garden, Pest, Cleaning, Staff
      serviceCategory: varchar2("service_category").notNull(),
      // maintenance, cleaning, security, utilities
      providerName: varchar2("provider_name"),
      providerContact: varchar2("provider_contact"),
      // Billing details
      monthlyRate: decimal2("monthly_rate", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency", { length: 3 }).default("THB"),
      billingDay: integer3("billing_day").default(1),
      // Day of month to charge
      // Assignment rules
      chargeAssignment: varchar2("charge_assignment").default("owner"),
      // owner, company
      autoDeduct: boolean3("auto_deduct").default(true),
      requiresApproval: boolean3("requires_approval").default(false),
      // Service schedule
      serviceFrequency: varchar2("service_frequency").default("weekly"),
      // daily, weekly, bi-weekly, monthly
      serviceDay: varchar2("service_day"),
      // monday, tuesday, etc.
      serviceTime: varchar2("service_time"),
      // "morning", "afternoon", specific time
      // Status tracking
      isActive: boolean3("is_active").default(true),
      startDate: date2("start_date").notNull(),
      endDate: date2("end_date"),
      // Contract end date
      lastChargedDate: date2("last_charged_date"),
      nextChargeDate: date2("next_charge_date"),
      notes: text3("notes"),
      contractUrl: varchar2("contract_url"),
      // Service contract document
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    financialTransactions2 = pgTable3("financial_transactions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      // Transaction basics
      transactionType: varchar2("transaction_type").notNull(),
      // earning, expense, payout, charge, refund
      amount: decimal2("amount", { precision: 12, scale: 2 }).notNull(),
      currency: varchar2("currency", { length: 3 }).default("AUD"),
      // Parties involved
      fromParty: varchar2("from_party"),
      // user_id or 'company' or external party
      toParty: varchar2("to_party"),
      // user_id or 'company' or external party
      // Reference tracking
      referenceType: varchar2("reference_type"),
      // booking, property, service, payout, bill
      referenceId: integer3("reference_id"),
      bookingReference: varchar2("booking_reference"),
      // Platform tracking
      sourceplatform: varchar2("source_platform"),
      // airbnb, vrbo, booking, direct, stripe
      platformBookingId: varchar2("platform_booking_id"),
      // Details
      description: text3("description").notNull(),
      category: varchar2("category"),
      // commission, maintenance, utility, service, management_fee
      // Status and processing
      status: varchar2("status").default("pending"),
      // pending, completed, failed, cancelled
      processedBy: varchar2("processed_by"),
      // User who processed transaction
      processedAt: timestamp3("processed_at"),
      // Document attachments
      receiptUrl: varchar2("receipt_url"),
      invoiceUrl: varchar2("invoice_url"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    pmPropertyPerformance2 = pgTable3("pm_property_performance", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      managerId: varchar2("manager_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      period: varchar2("period").notNull(),
      // YYYY-MM format
      totalRevenue: decimal2("total_revenue", { precision: 12, scale: 2 }).default(
        "0"
      ),
      commissionEarned: decimal2("commission_earned", {
        precision: 12,
        scale: 2
      }).default("0"),
      bookingCount: integer3("booking_count").default(0),
      occupancyRate: decimal2("occupancy_rate", { precision: 5, scale: 2 }).default(
        "0"
      ),
      // Percentage
      averageRating: decimal2("average_rating", { precision: 3, scale: 2 }).default(
        "0"
      ),
      taskCount: integer3("task_count").default(0),
      issueCount: integer3("issue_count").default(0),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    pmNotifications2 = pgTable3("pm_notifications", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      managerId: varchar2("manager_id").notNull(),
      type: varchar2("type").notNull(),
      // guest_issue, owner_approval, bill_upload, system_suggestion
      title: varchar2("title").notNull(),
      message: text3("message").notNull(),
      severity: varchar2("severity").default("info"),
      // info, warning, urgent
      relatedType: varchar2("related_type"),
      // property, booking, task
      relatedId: varchar2("related_id"),
      actionRequired: boolean3("action_required").default(false),
      isRead: boolean3("is_read").default(false),
      createdAt: timestamp3("created_at").defaultNow()
    });
    pmCommissionBalanceRelations = relations(
      pmCommissionBalance2,
      ({ one }) => ({
        manager: one(users, {
          fields: [pmCommissionBalance2.managerId],
          references: [users.id]
        })
      })
    );
    pmPayoutRequestsRelations = relations(
      pmPayoutRequests,
      ({ one }) => ({
        manager: one(users, {
          fields: [pmPayoutRequests.managerId],
          references: [users.id]
        }),
        processedByUser: one(users, {
          fields: [pmPayoutRequests.processedBy],
          references: [users.id]
        })
      })
    );
    pmTaskLogsRelations = relations(pmTaskLogs2, ({ one }) => ({
      manager: one(users, {
        fields: [pmTaskLogs2.managerId],
        references: [users.id]
      }),
      task: one(tasks, { fields: [pmTaskLogs2.taskId], references: [tasks.id] }),
      property: one(properties, {
        fields: [pmTaskLogs2.propertyId],
        references: [properties.id]
      })
    }));
    pmPropertyPerformanceRelations = relations(
      pmPropertyPerformance2,
      ({ one }) => ({
        manager: one(users, {
          fields: [pmPropertyPerformance2.managerId],
          references: [users.id]
        }),
        property: one(properties, {
          fields: [pmPropertyPerformance2.propertyId],
          references: [properties.id]
        })
      })
    );
    pmNotificationsRelations = relations(
      pmNotifications2,
      ({ one }) => ({
        manager: one(users, {
          fields: [pmNotifications2.managerId],
          references: [users.id]
        })
      })
    );
    guestAddonServices = pgTable3("guest_addon_services", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      serviceName: varchar2("service_name").notNull(),
      description: text3("description"),
      category: varchar2("category").notNull(),
      // wellness, transport, cleaning, catering, etc.
      pricingType: varchar2("pricing_type").notNull(),
      // fixed, variable, hourly
      basePrice: decimal2("base_price", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").default("AUD"),
      isActive: boolean3("is_active").default(true),
      requiresTimeSlot: boolean3("requires_time_slot").default(false),
      maxAdvanceBookingDays: integer3("max_advance_booking_days").default(30),
      cancellationPolicyHours: integer3("cancellation_policy_hours").default(24),
      autoCreateTask: boolean3("auto_create_task").default(true),
      taskType: varchar2("task_type"),
      // cleaning, transport, catering, etc.
      taskPriority: varchar2("task_priority").default("medium"),
      // high, medium, low
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestAddonBookings = pgTable3("guest_addon_bookings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      serviceId: integer3("service_id").references(() => guestAddonServices.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email"),
      guestPhone: varchar2("guest_phone"),
      bookingDate: timestamp3("booking_date").notNull(),
      serviceDate: timestamp3("service_date").notNull(),
      status: varchar2("status").notNull().default("pending"),
      // pending, confirmed, completed, cancelled
      totalAmount: decimal2("total_amount", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").default("AUD"),
      billingRoute: varchar2("billing_route").notNull(),
      // guest_billable, owner_billable, company_expense, complimentary
      complimentaryType: varchar2("complimentary_type"),
      // owner_gift, company_gift
      paymentStatus: varchar2("payment_status").default("pending"),
      // pending, paid, partial, failed
      paymentMethod: varchar2("payment_method"),
      // stripe, cash, bank_transfer, manual
      stripePaymentIntentId: varchar2("stripe_payment_intent_id"),
      specialRequests: text3("special_requests"),
      internalNotes: text3("internal_notes"),
      assignedTaskId: integer3("assigned_task_id").references(() => tasks.id),
      // auto-created task
      bookedBy: varchar2("booked_by").references(() => users.id).notNull(),
      // user ID who made the booking
      confirmedBy: varchar2("confirmed_by").references(() => users.id),
      // staff who confirmed
      cancelledBy: varchar2("cancelled_by").references(() => users.id),
      // who cancelled
      cancellationReason: text3("cancellation_reason"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestPortalAccess = pgTable3("guest_portal_access", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      accessToken: varchar2("access_token").notNull().unique(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email").notNull(),
      checkInDate: timestamp3("check_in_date").notNull(),
      checkOutDate: timestamp3("check_out_date").notNull(),
      isActive: boolean3("is_active").default(true),
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      // staff who created access
      lastAccessedAt: timestamp3("last_accessed_at"),
      expiresAt: timestamp3("expires_at").notNull(),
      createdAt: timestamp3("created_at").defaultNow()
    });
    guestAddonServicesRelations = relations(
      guestAddonServices,
      ({ one, many }) => ({
        organization: one(organizations, {
          fields: [guestAddonServices.organizationId],
          references: [organizations.id]
        }),
        createdByUser: one(users, {
          fields: [guestAddonServices.createdBy],
          references: [users.id]
        }),
        bookings: many(guestAddonBookings)
      })
    );
    guestAddonBookingsRelations = relations(
      guestAddonBookings,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [guestAddonBookings.organizationId],
          references: [organizations.id]
        }),
        service: one(guestAddonServices, {
          fields: [guestAddonBookings.serviceId],
          references: [guestAddonServices.id]
        }),
        property: one(properties, {
          fields: [guestAddonBookings.propertyId],
          references: [properties.id]
        }),
        bookedByUser: one(users, {
          fields: [guestAddonBookings.bookedBy],
          references: [users.id]
        }),
        confirmedByUser: one(users, {
          fields: [guestAddonBookings.confirmedBy],
          references: [users.id]
        }),
        cancelledByUser: one(users, {
          fields: [guestAddonBookings.cancelledBy],
          references: [users.id]
        }),
        assignedTask: one(tasks, {
          fields: [guestAddonBookings.assignedTaskId],
          references: [tasks.id]
        })
      })
    );
    guestPortalAccessRelations = relations(
      guestPortalAccess,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [guestPortalAccess.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [guestPortalAccess.propertyId],
          references: [properties.id]
        }),
        createdByUser: one(users, {
          fields: [guestPortalAccess.createdBy],
          references: [users.id]
        })
      })
    );
    achievements = pgTable3(
      "achievements",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        name: varchar2("name").notNull(),
        description: text3("description"),
        category: varchar2("category").notNull(),
        // task, booking, finance, property, system
        type: varchar2("type").notNull(),
        // milestone, streak, progress, special
        criteria: jsonb3("criteria").notNull(),
        // conditions for earning
        points: integer3("points").default(10),
        iconUrl: varchar2("icon_url"),
        badgeColor: varchar2("badge_color").default("#0066ff"),
        isActive: boolean3("is_active").default(true),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_achievements_org").on(table.organizationId),
        index("IDX_achievements_category").on(table.category)
      ]
    );
    userAchievements = pgTable3(
      "user_achievements",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => users.id).notNull(),
        achievementId: integer3("achievement_id").references(() => achievements.id).notNull(),
        earnedAt: timestamp3("earned_at").defaultNow(),
        progress: integer3("progress").default(0),
        // for progress-based achievements
        metadata: jsonb3("metadata")
        // additional data about how it was earned
      },
      (table) => [
        index("IDX_user_achievements_user").on(table.userId),
        index("IDX_user_achievements_achievement").on(table.achievementId)
      ]
    );
    userGameStats = pgTable3(
      "user_game_stats",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => users.id).notNull(),
        totalPoints: integer3("total_points").default(0),
        level: integer3("level").default(1),
        currentStreak: integer3("current_streak").default(0),
        longestStreak: integer3("longest_streak").default(0),
        tasksCompleted: integer3("tasks_completed").default(0),
        bookingsProcessed: integer3("bookings_processed").default(0),
        propertiesManaged: integer3("properties_managed").default(0),
        lastActivity: timestamp3("last_activity").defaultNow(),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_user_game_stats_user").on(table.userId),
        index("IDX_user_game_stats_points").on(table.totalPoints)
      ]
    );
    achievementNotifications = pgTable3(
      "achievement_notifications",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => users.id).notNull(),
        achievementId: integer3("achievement_id").references(() => achievements.id).notNull(),
        isRead: boolean3("is_read").default(false),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [index("IDX_achievement_notifications_user").on(table.userId)]
    );
    achievementsRelations = relations(
      achievements,
      ({ one, many }) => ({
        organization: one(organizations, {
          fields: [achievements.organizationId],
          references: [organizations.id]
        }),
        userAchievements: many(userAchievements),
        notifications: many(achievementNotifications)
      })
    );
    userAchievementsRelations = relations(
      userAchievements,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [userAchievements.organizationId],
          references: [organizations.id]
        }),
        user: one(users, {
          fields: [userAchievements.userId],
          references: [users.id]
        }),
        achievement: one(achievements, {
          fields: [userAchievements.achievementId],
          references: [achievements.id]
        })
      })
    );
    userGameStatsRelations = relations(userGameStats, ({ one }) => ({
      organization: one(organizations, {
        fields: [userGameStats.organizationId],
        references: [organizations.id]
      }),
      user: one(users, { fields: [userGameStats.userId], references: [users.id] })
    }));
    achievementNotificationsRelations = relations(
      achievementNotifications,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [achievementNotifications.organizationId],
          references: [organizations.id]
        }),
        user: one(users, {
          fields: [achievementNotifications.userId],
          references: [users.id]
        }),
        achievement: one(achievements, {
          fields: [achievementNotifications.achievementId],
          references: [achievements.id]
        })
      })
    );
    insertUserSchema = createInsertSchema3(users).omit({
      createdAt: true,
      updatedAt: true
    });
    insertPropertySchema = createInsertSchema3(properties).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTaskSchema = createInsertSchema3(tasks).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBookingSchema = createInsertSchema3(bookings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertFinanceSchema = createInsertSchema3(finances).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertInventorySchema = createInsertSchema3(inventory).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAddonServiceSchema = createInsertSchema3(addonServices).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAddonBookingSchema = createInsertSchema3(addonBookings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyUtilityAccountSchema = createInsertSchema3(
      propertyUtilityAccounts
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUtilityBillSchema = createInsertSchema3(utilityBills).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUtilityBillReminderSchema = createInsertSchema3(
      utilityBillReminders
    ).omit({
      id: true,
      createdAt: true
    });
    insertUtilityAlertRuleSchema = createInsertSchema3(
      utilityAlertRules
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPlatformSettingSchema = createInsertSchema3(
      platformSettings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertWelcomePackItemSchema = createInsertSchema3(
      welcomePackItems
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertWelcomePackTemplateSchema = createInsertSchema3(
      welcomePackTemplates
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertWelcomePackUsageSchema = createInsertSchema3(
      welcomePackUsage
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertEmergencyWaterDeliverySchema = createInsertSchema3(
      emergencyWaterDeliveries
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertWaterDeliveryAlertSchema = createInsertSchema3(
      waterDeliveryAlerts
    ).omit({
      id: true,
      createdAt: true
    });
    insertWaterUpgradeSuggestionSchema = createInsertSchema3(
      waterUpgradeSuggestions
    ).omit({
      id: true,
      createdAt: true
    });
    insertOwnerPayoutSchema = createInsertSchema3(ownerPayouts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOwnerBalanceSchema = createInsertSchema3(ownerBalances2).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOwnerChargeRequestSchema = createInsertSchema3(
      ownerChargeRequests2
    ).omit({
      id: true,
      chargedAt: true
    });
    insertRecurringServiceChargeSchema = createInsertSchema3(
      recurringServiceCharges2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertFinancialTransactionSchema = createInsertSchema3(
      financialTransactions2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAchievementSchema = createInsertSchema3(achievements).omit({
      id: true,
      createdAt: true
    });
    insertUserAchievementSchema = createInsertSchema3(
      userAchievements
    ).omit({
      id: true,
      earnedAt: true
    });
    insertUserGameStatsSchema = createInsertSchema3(userGameStats).omit(
      {
        id: true,
        createdAt: true,
        updatedAt: true
      }
    );
    insertAchievementNotificationSchema = createInsertSchema3(
      achievementNotifications
    ).omit({
      id: true,
      createdAt: true
    });
    staffMembers = pgTable3("staff_members", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      userId: varchar2("user_id"),
      // Optional - links to users table if staff has account
      employeeId: varchar2("employee_id").notNull(),
      // Unique employee ID
      firstName: varchar2("first_name").notNull(),
      lastName: varchar2("last_name").notNull(),
      dateOfBirth: date2("date_of_birth"),
      phoneNumber: varchar2("phone_number"),
      email: varchar2("email"),
      address: text3("address"),
      // Employment details
      department: varchar2("department").notNull(),
      // housekeeping, pool, garden, manager, supervisor, admin
      position: varchar2("position").notNull(),
      startDate: date2("start_date").notNull(),
      endDate: date2("end_date"),
      // null if still employed
      status: varchar2("status").default("active"),
      // active, inactive, terminated
      // Compensation
      salaryType: varchar2("salary_type").notNull(),
      // monthly, hourly, commission, daily
      monthlySalary: decimal2("monthly_salary", { precision: 10, scale: 2 }),
      hourlyRate: decimal2("hourly_rate", { precision: 8, scale: 2 }),
      commissionRate: decimal2("commission_rate", { precision: 5, scale: 2 }),
      // percentage
      // Banking
      bankName: varchar2("bank_name"),
      accountNumber: varchar2("account_number"),
      accountHolderName: varchar2("account_holder_name"),
      // Work preferences
      preferredDayOff: varchar2("preferred_day_off"),
      // monday, tuesday, etc.
      workingHours: varchar2("working_hours"),
      // e.g., "8:00-17:00"
      // Admin notes
      notes: text3("notes"),
      performanceNotes: text3("performance_notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    staffDocuments = pgTable3("staff_documents", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      staffMemberId: integer3("staff_member_id").references(() => staffMembers.id, {
        onDelete: "cascade"
      }),
      documentType: varchar2("document_type").notNull(),
      // passport, work_permit, id_card, contract, bank_book, photo
      fileName: varchar2("file_name").notNull(),
      fileUrl: varchar2("file_url").notNull(),
      fileSize: integer3("file_size"),
      mimeType: varchar2("mime_type"),
      uploadedBy: varchar2("uploaded_by").notNull(),
      uploadedAt: timestamp3("uploaded_at").defaultNow(),
      expiryDate: date2("expiry_date"),
      // for permits, contracts, etc.
      notes: text3("notes")
    });
    payrollRecords = pgTable3("payroll_records", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      staffMemberId: integer3("staff_member_id").references(() => staffMembers.id, {
        onDelete: "cascade"
      }),
      payPeriodStart: date2("pay_period_start").notNull(),
      payPeriodEnd: date2("pay_period_end").notNull(),
      // Hours and rates
      overtimeHours: decimal2("overtime_hours", { precision: 8, scale: 2 }),
      overtimeRate: decimal2("overtime_rate", { precision: 8, scale: 2 }),
      // Salary calculations
      baseSalary: decimal2("base_salary", { precision: 10, scale: 2 }),
      bonus: decimal2("bonus", { precision: 10, scale: 2 }),
      deductions: decimal2("deductions", { precision: 10, scale: 2 }),
      // Totals
      grossPay: decimal2("gross_pay", { precision: 10, scale: 2 }),
      netPay: decimal2("net_pay", { precision: 10, scale: 2 }),
      taxDeduction: decimal2("tax_deduction", { precision: 10, scale: 2 }),
      socialSecurity: decimal2("social_security", { precision: 10, scale: 2 }),
      // Payment tracking
      status: varchar2("status"),
      // pending, paid, cancelled
      paymentDate: date2("payment_date"),
      paymentMethod: varchar2("payment_method"),
      // bank_transfer, cash, check
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    departmentBudgets = pgTable3("department_budgets", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      department: varchar2("department").notNull(),
      year: integer3("year").notNull(),
      month: integer3("month"),
      // null for yearly budgets
      budgetedAmount: decimal2("budgeted_amount", { precision: 12, scale: 2 }),
      actualAmount: decimal2("actual_amount", { precision: 12, scale: 2 }).default(
        "0"
      ),
      notes: text3("notes"),
      createdBy: varchar2("created_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    staffMemberRelations = relations(staffMembers, ({ many }) => ({
      documents: many(staffDocuments),
      payrollRecords: many(payrollRecords)
    }));
    staffDocumentRelations = relations(staffDocuments, ({ one }) => ({
      staffMember: one(staffMembers, {
        fields: [staffDocuments.staffMemberId],
        references: [staffMembers.id]
      })
    }));
    payrollRecordRelations = relations(payrollRecords, ({ one }) => ({
      staffMember: one(staffMembers, {
        fields: [payrollRecords.staffMemberId],
        references: [staffMembers.id]
      })
    }));
    insertStaffMemberSchema = createInsertSchema3(staffMembers).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertStaffDocumentSchema = createInsertSchema3(
      staffDocuments
    ).omit({
      id: true,
      uploadedAt: true
    });
    insertPayrollRecordSchema = createInsertSchema3(
      payrollRecords
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertDepartmentBudgetSchema = createInsertSchema3(
      departmentBudgets
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    communicationChannels = pgTable3("communication_channels", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      name: varchar2("name").notNull(),
      description: text3("description"),
      channelType: varchar2("channel_type").notNull(),
      // 'department', 'property', 'general', 'admin'
      department: varchar2("department"),
      // 'cleaning', 'maintenance', 'pool', 'garden', 'general'
      propertyId: integer3("property_id").references(() => properties.id),
      isActive: boolean3("is_active").default(true),
      createdBy: varchar2("created_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    channelMembers = pgTable3("channel_members", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      channelId: integer3("channel_id").references(() => communicationChannels.id, {
        onDelete: "cascade"
      }),
      userId: varchar2("user_id").notNull(),
      role: varchar2("role").default("member"),
      // 'admin', 'moderator', 'member'
      joinedAt: timestamp3("joined_at").defaultNow(),
      lastReadAt: timestamp3("last_read_at"),
      notificationsEnabled: boolean3("notifications_enabled").default(true)
    });
    internalMessages = pgTable3("internal_messages", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      channelId: integer3("channel_id").references(() => communicationChannels.id, {
        onDelete: "cascade"
      }),
      senderId: varchar2("sender_id").notNull(),
      message: text3("message").notNull(),
      messageType: varchar2("message_type").default("text"),
      // 'text', 'image', 'file', 'task_link', 'property_update'
      attachmentUrl: varchar2("attachment_url"),
      attachmentType: varchar2("attachment_type"),
      // 'image', 'pdf', 'document'
      replyToMessageId: integer3("reply_to_message_id").references(
        () => internalMessages.id
      ),
      isImportant: boolean3("is_important").default(false),
      logToPropertyTimeline: boolean3("log_to_property_timeline").default(false),
      relatedTaskId: integer3("related_task_id"),
      relatedPropertyId: integer3("related_property_id"),
      sentAt: timestamp3("sent_at").defaultNow(),
      editedAt: timestamp3("edited_at"),
      deletedAt: timestamp3("deleted_at")
    });
    ownerPmCommunication = pgTable3("owner_pm_communication", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      senderId: varchar2("sender_id").notNull(),
      // User ID
      senderType: varchar2("sender_type").notNull(),
      // 'owner', 'pm', 'admin'
      recipientId: varchar2("recipient_id").notNull(),
      recipientType: varchar2("recipient_type").notNull(),
      subject: varchar2("subject"),
      message: text3("message").notNull(),
      messageType: varchar2("message_type").default("update"),
      // 'update', 'approval_request', 'maintenance_suggestion', 'task_summary'
      priority: varchar2("priority").default("normal"),
      // 'low', 'normal', 'high', 'urgent'
      status: varchar2("status").default("sent"),
      // 'sent', 'read', 'replied', 'approved', 'rejected'
      attachmentUrl: varchar2("attachment_url"),
      attachmentType: varchar2("attachment_type"),
      requiresApproval: boolean3("requires_approval").default(false),
      approvalStatus: varchar2("approval_status"),
      // 'pending', 'approved', 'rejected'
      approvedBy: varchar2("approved_by"),
      approvedAt: timestamp3("approved_at"),
      relatedTaskId: integer3("related_task_id"),
      relatedInvoiceId: integer3("related_invoice_id"),
      sentAt: timestamp3("sent_at").defaultNow(),
      readAt: timestamp3("read_at"),
      repliedAt: timestamp3("replied_at")
    });
    guestSmartRequests = pgTable3("guest_smart_requests", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email"),
      guestPhone: varchar2("guest_phone"),
      requestCategory: varchar2("request_category").notNull(),
      // 'ac_water_electricity', 'extra_cleaning', 'order_services', 'other'
      requestSubcategory: varchar2("request_subcategory"),
      // 'ac_issue', 'water_issue', 'electricity_issue', 'massage', 'chef', 'taxi'
      urgencyLevel: varchar2("urgency_level").default("medium"),
      // 'low', 'medium', 'high', 'emergency'
      description: text3("description").notNull(),
      aiAnalysis: text3("ai_analysis"),
      // AI-generated analysis/routing suggestion
      aiConfidence: decimal2("ai_confidence", { precision: 3, scale: 2 }),
      // 0.00-1.00
      routedToDepartment: varchar2("routed_to_department"),
      // 'maintenance', 'cleaning', 'concierge'
      assignedToUserId: varchar2("assigned_to_user_id"),
      status: varchar2("status").default("submitted"),
      // 'submitted', 'acknowledged', 'in_progress', 'resolved', 'escalated'
      autoReplyMessage: text3("auto_reply_message"),
      // Generated smart reply
      estimatedResolutionTime: varchar2("estimated_resolution_time"),
      // "2 hours", "24 hours", etc.
      actualResolutionTime: timestamp3("actual_resolution_time"),
      guestSatisfactionRating: integer3("guest_satisfaction_rating"),
      // 1-5 stars
      guestFeedback: text3("guest_feedback"),
      internalNotes: text3("internal_notes"),
      relatedTaskId: integer3("related_task_id"),
      whatsappMessageSent: boolean3("whatsapp_message_sent").default(false),
      emailAlertSent: boolean3("email_alert_sent").default(false),
      createdAt: timestamp3("created_at").defaultNow(),
      acknowledgedAt: timestamp3("acknowledged_at"),
      resolvedAt: timestamp3("resolved_at")
    });
    communicationLogs = pgTable3("communication_logs", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      logType: varchar2("log_type").notNull(),
      // 'property_activity', 'guest_stay', 'task_log', 'internal_chat'
      sourceType: varchar2("source_type").notNull(),
      // 'internal_message', 'owner_pm_communication', 'guest_request'
      sourceId: integer3("source_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      bookingId: integer3("booking_id").references(() => bookings.id),
      taskId: integer3("task_id"),
      userId: varchar2("user_id").notNull(),
      summary: text3("summary").notNull(),
      details: text3("details"),
      attachmentUrl: varchar2("attachment_url"),
      isArchived: boolean3("is_archived").default(false),
      archivedAt: timestamp3("archived_at"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    smartRequestConfig = pgTable3("smart_request_config", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      category: varchar2("category").notNull(),
      subcategory: varchar2("subcategory"),
      routingDepartment: varchar2("routing_department").notNull(),
      autoReplyTemplate: text3("auto_reply_template").notNull(),
      estimatedResponseTime: varchar2("estimated_response_time").notNull(),
      priorityLevel: varchar2("priority_level").default("medium"),
      requiresImmediateAlert: boolean3("requires_immediate_alert").default(false),
      whatsappTemplate: text3("whatsapp_template"),
      emailTemplate: text3("email_template"),
      aiKeywords: text3("ai_keywords").array(),
      // Keywords for AI routing
      isActive: boolean3("is_active").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyUtilityAccountsEnhanced = pgTable3(
      "property_utility_accounts_enhanced",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id, { onDelete: "cascade" }).notNull(),
        // Utility details
        utilityType: varchar2("utility_type").notNull(),
        // electricity, water, internet, pest_control, gas, hoa_fee, other
        customUtilityName: varchar2("custom_utility_name"),
        // For "other" type
        providerName: varchar2("provider_name").notNull(),
        // PEA, CAT, AIS, True, 3BB, etc.
        accountNumber: varchar2("account_number").notNull(),
        contractHolder: varchar2("contract_holder"),
        // Owner name or company
        // Billing schedule
        paymentFrequency: varchar2("payment_frequency").notNull().default("monthly"),
        // monthly, quarterly, yearly
        defaultDueDate: integer3("default_due_date").notNull(),
        // Day of month (1-31)
        monthlyCostEstimate: decimal2("monthly_cost_estimate", {
          precision: 10,
          scale: 2
        }),
        // Contact and account info
        customerServicePhone: varchar2("customer_service_phone"),
        onlinePortalUrl: varchar2("online_portal_url"),
        loginCredentialsNotes: text3("login_credentials_notes"),
        // Encrypted storage notes
        emergencyContactPhone: varchar2("emergency_contact_phone"),
        // AI reminder settings
        autoRemindersEnabled: boolean3("auto_reminders_enabled").default(true),
        reminderDaysAfterDue: integer3("reminder_days_after_due").default(3),
        predictiveRemindersEnabled: boolean3("predictive_reminders_enabled").default(
          true
        ),
        isActive: boolean3("is_active").default(true),
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    utilityBillLogsEnhanced = pgTable3("utility_bill_logs_enhanced", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      utilityAccountId: integer3("utility_account_id").references(
        () => propertyUtilityAccountsEnhanced.id
      ),
      // Bill details
      billingMonth: varchar2("billing_month").notNull(),
      // YYYY-MM format
      billNumber: varchar2("bill_number"),
      billAmount: decimal2("bill_amount", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency", { length: 3 }).default("THB"),
      dueDate: date2("due_date").notNull(),
      billingPeriodStart: date2("billing_period_start"),
      billingPeriodEnd: date2("billing_period_end"),
      // Usage tracking (for utilities with meter readings)
      currentReading: varchar2("current_reading"),
      previousReading: varchar2("previous_reading"),
      unitsUsed: decimal2("units_used", { precision: 10, scale: 2 }),
      ratePerUnit: decimal2("rate_per_unit", { precision: 10, scale: 4 }),
      // File uploads and OCR
      billScanUrl: varchar2("bill_scan_url"),
      // Scanned bill image/PDF
      billScanFilename: varchar2("bill_scan_filename"),
      ocrExtractedText: text3("ocr_extracted_text"),
      // OCR extracted text
      ocrConfidence: decimal2("ocr_confidence", { precision: 3, scale: 2 }),
      // 0.00-1.00
      paymentReceiptUrl: varchar2("payment_receipt_url"),
      // Payment receipt
      paymentReceiptFilename: varchar2("payment_receipt_filename"),
      // Payment tracking
      paymentStatus: varchar2("payment_status").notNull().default("pending"),
      // pending, paid, overdue
      paidAmount: decimal2("paid_amount", { precision: 10, scale: 2 }),
      paidDate: date2("paid_date"),
      paymentMethod: varchar2("payment_method"),
      // bank_transfer, online, cash, auto_debit
      paymentReference: varchar2("payment_reference"),
      // Manual override and status
      manualOverride: boolean3("manual_override").default(false),
      manualOverrideReason: text3("manual_override_reason"),
      statusResetBy: varchar2("status_reset_by").references(() => users.id),
      statusResetAt: timestamp3("status_reset_at"),
      // Uploads and processing
      uploadedBy: varchar2("uploaded_by").references(() => users.id),
      uploadedAt: timestamp3("uploaded_at"),
      processedBy: varchar2("processed_by").references(() => users.id),
      processedAt: timestamp3("processed_at"),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    utilityAiReminders = pgTable3("utility_ai_reminders", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      utilityAccountId: integer3("utility_account_id").references(
        () => propertyUtilityAccountsEnhanced.id
      ),
      // Reminder details
      reminderType: varchar2("reminder_type").notNull(),
      // predictive, overdue, missing_receipt
      expectedBillDate: date2("expected_bill_date"),
      // AI-predicted bill arrival date
      daysPastPattern: integer3("days_past_pattern"),
      // Days past usual bill arrival pattern
      severity: varchar2("severity").notNull().default("medium"),
      // low, medium, high, critical
      // AI analysis
      aiAnalysis: text3("ai_analysis"),
      // AI reasoning for the reminder
      confidenceScore: decimal2("confidence_score", { precision: 3, scale: 2 }),
      // 0.00-1.00
      basedOnHistory: boolean3("based_on_history").default(true),
      // Status and delivery
      status: varchar2("status").notNull().default("pending"),
      // pending, sent, acknowledged, resolved
      sentTo: varchar2("sent_to").references(() => users.id),
      // Admin or PM
      sentAt: timestamp3("sent_at"),
      acknowledgedBy: varchar2("acknowledged_by").references(() => users.id),
      acknowledgedAt: timestamp3("acknowledged_at"),
      resolvedBy: varchar2("resolved_by").references(() => users.id),
      resolvedAt: timestamp3("resolved_at"),
      // Message content
      reminderMessage: text3("reminder_message").notNull(),
      actionRequired: text3("action_required"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyMaintenanceHistory = pgTable3(
      "property_maintenance_history",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id, { onDelete: "cascade" }).notNull(),
        // Service details
        serviceType: varchar2("service_type").notNull(),
        // renovation, ac_clean, septic_pump, pool_deep_clean, garden_overhaul, pest_control, roof_inspection, custom
        customServiceName: varchar2("custom_service_name"),
        // For custom service types
        serviceProvider: varchar2("service_provider"),
        // Company or technician name
        serviceProviderContact: varchar2("service_provider_contact"),
        // Service execution
        serviceDate: date2("service_date").notNull(),
        serviceCost: decimal2("service_cost", { precision: 10, scale: 2 }),
        currency: varchar2("currency", { length: 3 }).default("THB"),
        invoiceNumber: varchar2("invoice_number"),
        receiptUrl: varchar2("receipt_url"),
        // Service details and results
        workDescription: text3("work_description").notNull(),
        issuesFound: text3("issues_found"),
        warrantyPeriod: varchar2("warranty_period"),
        // "6 months", "1 year", etc.
        warrantyExpiryDate: date2("warranty_expiry_date"),
        // Photo documentation
        beforePhotos: text3("before_photos").array(),
        afterPhotos: text3("after_photos").array(),
        // Quality tracking
        qualityRating: integer3("quality_rating"),
        // 1-5 stars
        qualityNotes: text3("quality_notes"),
        recommendForFuture: boolean3("recommend_for_future").default(true),
        // Manual entry vs system generated
        entryType: varchar2("entry_type").notNull().default("manual"),
        // manual, auto_generated
        loggedBy: varchar2("logged_by").references(() => users.id).notNull(),
        approvedBy: varchar2("approved_by").references(() => users.id),
        approvedAt: timestamp3("approved_at"),
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    maintenanceServiceIntervals = pgTable3(
      "maintenance_service_intervals",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        // null = global default
        serviceType: varchar2("service_type").notNull(),
        // Interval configuration
        intervalMonths: integer3("interval_months").notNull(),
        // Service interval in months
        warningDaysBefore: integer3("warning_days_before").default(7),
        // Warn X days before due
        criticalDaysAfter: integer3("critical_days_after").default(7),
        // Critical X days after due
        // Seasonal preferences
        preferredMonths: text3("preferred_months").array(),
        // ["03", "04", "10", "11"] for seasonal services
        avoidMonths: text3("avoid_months").array(),
        // Months to avoid
        // Cost estimates
        estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
        costCurrency: varchar2("cost_currency", { length: 3 }).default("THB"),
        // AI suggestions
        aiSuggestionsEnabled: boolean3("ai_suggestions_enabled").default(true),
        autoCreateTasks: boolean3("auto_create_tasks").default(false),
        isActive: boolean3("is_active").default(true),
        setBy: varchar2("set_by").references(() => users.id).notNull(),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    maintenanceAiSuggestions = pgTable3("maintenance_ai_suggestions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Suggestion details
      serviceType: varchar2("service_type").notNull(),
      suggestedDate: date2("suggested_date").notNull(),
      urgencyLevel: varchar2("urgency_level").notNull().default("medium"),
      // low, medium, high, critical
      // AI analysis
      aiReasoning: text3("ai_reasoning").notNull(),
      // Why this service is suggested
      basedOnHistory: boolean3("based_on_history").default(true),
      daysPastDue: integer3("days_past_due"),
      // If already overdue
      confidenceScore: decimal2("confidence_score", { precision: 3, scale: 2 }),
      // 0.00-1.00
      // Cost estimation
      estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
      costCurrency: varchar2("cost_currency", { length: 3 }).default("THB"),
      // Status tracking
      status: varchar2("status").notNull().default("pending"),
      // pending, accepted, rejected, scheduled, completed
      reviewedBy: varchar2("reviewed_by").references(() => users.id),
      reviewedAt: timestamp3("reviewed_at"),
      reviewNotes: text3("review_notes"),
      // Task creation
      taskCreated: boolean3("task_created").default(false),
      relatedTaskId: integer3("related_task_id"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyAlerts = pgTable3("property_alerts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Alert details
      alertType: varchar2("alert_type").notNull(),
      // missing_utility_bill, overdue_maintenance, missing_receipt
      alertCategory: varchar2("alert_category").notNull(),
      // utility, maintenance, financial
      severity: varchar2("severity").notNull().default("medium"),
      // low, medium, high, critical
      // Content
      title: varchar2("title").notNull(),
      description: text3("description").notNull(),
      actionRequired: text3("action_required"),
      // Related entities
      relatedUtilityAccountId: integer3("related_utility_account_id").references(
        () => propertyUtilityAccountsEnhanced.id
      ),
      relatedBillLogId: integer3("related_bill_log_id").references(
        () => utilityBillLogsEnhanced.id
      ),
      relatedMaintenanceId: integer3("related_maintenance_id").references(
        () => propertyMaintenanceHistory.id
      ),
      // Status tracking
      status: varchar2("status").notNull().default("active"),
      // active, acknowledged, resolved, dismissed
      acknowledgedBy: varchar2("acknowledged_by").references(() => users.id),
      acknowledgedAt: timestamp3("acknowledged_at"),
      resolvedBy: varchar2("resolved_by").references(() => users.id),
      resolvedAt: timestamp3("resolved_at"),
      dismissedBy: varchar2("dismissed_by").references(() => users.id),
      dismissedAt: timestamp3("dismissed_at"),
      // Auto-resolution
      autoResolvable: boolean3("auto_resolvable").default(false),
      autoResolvedAt: timestamp3("auto_resolved_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    insertOrganizationSchema = createInsertSchema3(organizations).omit({
      createdAt: true,
      updatedAt: true
    });
    insertOrganizationApiKeySchema = createInsertSchema3(
      organizationApiKeys
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUserPermissionOverrideSchema = createInsertSchema3(
      userPermissionOverrides
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPermissionPresetSchema = createInsertSchema3(
      permissionPresets
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertRolePermissionSchema = createInsertSchema3(
      rolePermissions
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    propertyGoals = pgTable3("property_goals", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Goal Details
      goalTitle: varchar2("goal_title").notNull(),
      goalDescription: text3("goal_description"),
      upgradeType: varchar2("upgrade_type").notNull(),
      // Furniture, Electronics, Decor, Maintenance, etc.
      estimatedCost: decimal2("estimated_cost", {
        precision: 10,
        scale: 2
      }).notNull(),
      currency: varchar2("currency").notNull().default("THB"),
      priority: varchar2("priority").notNull().default("medium"),
      // low, medium, high, critical
      // Trigger Conditions
      triggerType: varchar2("trigger_type").notNull(),
      // date, revenue, occupancy, custom
      targetDate: date2("target_date"),
      revenueTarget: decimal2("revenue_target", { precision: 10, scale: 2 }),
      occupancyTarget: decimal2("occupancy_target", { precision: 5, scale: 2 }),
      occupancyDuration: integer3("occupancy_duration"),
      // months
      customTrigger: text3("custom_trigger"),
      // Status & Progress
      status: varchar2("status").notNull().default("not_started"),
      // not_started, in_progress, completed, cancelled
      completionDate: date2("completion_date"),
      actualCost: decimal2("actual_cost", { precision: 10, scale: 2 }),
      // Permissions & Approval
      proposedBy: varchar2("proposed_by").notNull(),
      approvedBy: varchar2("approved_by"),
      approvedDate: date2("approved_date"),
      requiresApproval: boolean3("requires_approval").default(false),
      // Metadata
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyGoalAttachments = pgTable3("property_goal_attachments", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      goalId: integer3("goal_id").references(() => propertyGoals.id).notNull(),
      // File Details
      fileName: varchar2("file_name").notNull(),
      fileType: varchar2("file_type").notNull(),
      // pdf, image, link, document
      fileUrl: varchar2("file_url").notNull(),
      fileSize: integer3("file_size"),
      description: varchar2("description"),
      // Metadata
      uploadedBy: varchar2("uploaded_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow()
    });
    propertyGoalProgress = pgTable3("property_goal_progress", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      goalId: integer3("goal_id").references(() => propertyGoals.id).notNull(),
      // Progress Details
      progressDate: date2("progress_date").notNull(),
      progressPercentage: decimal2("progress_percentage", {
        precision: 5,
        scale: 2
      }).notNull(),
      milestoneDescription: text3("milestone_description"),
      notes: text3("notes"),
      // Metadata
      recordedBy: varchar2("recorded_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow()
    });
    bookingRevenue = pgTable3("booking_revenue", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Reservation Details
      reservationCode: varchar2("reservation_code").notNull(),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email"),
      checkInDate: date2("check_in_date").notNull(),
      checkOutDate: date2("check_out_date").notNull(),
      numberOfNights: integer3("number_of_nights").notNull(),
      numberOfGuests: integer3("number_of_guests").notNull(),
      // OTA Platform Information
      otaName: varchar2("ota_name").notNull(),
      // Airbnb, Booking.com, VRBO, Direct, etc.
      bookingType: varchar2("booking_type").notNull().default("OTA"),
      // OTA, Direct
      // Financial Details (Core OTA Commission Logic)
      guestBookingPrice: decimal2("guest_booking_price", {
        precision: 10,
        scale: 2
      }).notNull(),
      // Total paid by guest
      otaPlatformFee: decimal2("ota_platform_fee", {
        precision: 10,
        scale: 2
      }).notNull(),
      // OTA commission
      finalPayoutAmount: decimal2("final_payout_amount", {
        precision: 10,
        scale: 2
      }).notNull(),
      // Net received from OTA
      currency: varchar2("currency").notNull().default("THB"),
      // Payment & Status
      paymentStatus: varchar2("payment_status").notNull().default("pending"),
      // pending, paid, cancelled
      payoutDate: date2("payout_date"),
      // Commission Settings
      isCommissionable: boolean3("is_commissionable").default(true),
      managementCommissionRate: decimal2("management_commission_rate", {
        precision: 5,
        scale: 2
      }).default("15.00"),
      // Integration Fields
      hostAwayReservationId: varchar2("hostaway_reservation_id"),
      externalReservationId: varchar2("external_reservation_id"),
      // Metadata
      notes: text3("notes"),
      createdBy: varchar2("created_by").notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    bookingRevenueCommissions = pgTable3(
      "booking_revenue_commissions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        bookingRevenueId: integer3("booking_revenue_id").references(() => bookingRevenue.id).notNull(),
        // Commission Breakdown (All calculated from finalPayoutAmount only)
        managementCommissionAmount: decimal2("management_commission_amount", {
          precision: 10,
          scale: 2
        }).notNull(),
        portfolioManagerCommissionAmount: decimal2(
          "portfolio_manager_commission_amount",
          { precision: 10, scale: 2 }
        ).default("0.00"),
        referralAgentCommissionAmount: decimal2("referral_agent_commission_amount", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        ownerNetAmount: decimal2("owner_net_amount", {
          precision: 10,
          scale: 2
        }).notNull(),
        // Commission Recipients
        portfolioManagerId: varchar2("portfolio_manager_id").references(
          () => users.id
        ),
        referralAgentId: varchar2("referral_agent_id").references(() => users.id),
        ownerId: varchar2("owner_id").references(() => users.id).notNull(),
        // Calculation Details
        calculationDate: timestamp3("calculation_date").defaultNow(),
        calculatedBy: varchar2("calculated_by").notNull(),
        isFinalized: boolean3("is_finalized").default(false),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    otaPlatformSettings = pgTable3("ota_platform_settings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      otaName: varchar2("ota_name").notNull(),
      isActive: boolean3("is_active").default(true),
      // Commission Configuration
      expectedCommissionRate: decimal2("expected_commission_rate", {
        precision: 5,
        scale: 2
      }).notNull(),
      // Expected OTA commission %
      minimumPayoutThreshold: decimal2("minimum_payout_threshold", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      // API Integration
      apiConnectionStatus: varchar2("api_connection_status").default("disconnected"),
      // connected, disconnected, error
      lastSyncDate: timestamp3("last_sync_date"),
      autoSyncEnabled: boolean3("auto_sync_enabled").default(false),
      // Settings
      defaultCurrency: varchar2("default_currency").default("THB"),
      payoutFrequency: varchar2("payout_frequency").default("monthly"),
      // daily, weekly, monthly
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    bookingRevenueRelations = relations(
      bookingRevenue,
      ({ one, many }) => ({
        organization: one(organizations, {
          fields: [bookingRevenue.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [bookingRevenue.propertyId],
          references: [properties.id]
        }),
        commissions: many(bookingRevenueCommissions)
      })
    );
    bookingRevenueCommissionsRelations = relations(
      bookingRevenueCommissions,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [bookingRevenueCommissions.organizationId],
          references: [organizations.id]
        }),
        bookingRevenue: one(bookingRevenue, {
          fields: [bookingRevenueCommissions.bookingRevenueId],
          references: [bookingRevenue.id]
        }),
        portfolioManager: one(users, {
          fields: [bookingRevenueCommissions.portfolioManagerId],
          references: [users.id]
        }),
        referralAgent: one(users, {
          fields: [bookingRevenueCommissions.referralAgentId],
          references: [users.id]
        }),
        owner: one(users, {
          fields: [bookingRevenueCommissions.ownerId],
          references: [users.id]
        })
      })
    );
    otaPlatformSettingsRelations = relations(
      otaPlatformSettings,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [otaPlatformSettings.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [otaPlatformSettings.propertyId],
          references: [properties.id]
        })
      })
    );
    insertBookingRevenueSchema = createInsertSchema3(
      bookingRevenue
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBookingRevenueCommissionsSchema = createInsertSchema3(
      bookingRevenueCommissions
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOtaPlatformSettingsSchema = createInsertSchema3(
      otaPlatformSettings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    currencyRates = pgTable3(
      "currency_rates",
      {
        id: serial2("id").primaryKey(),
        baseCurrency: varchar2("base_currency", { length: 3 }).notNull(),
        targetCurrency: varchar2("target_currency", { length: 3 }).notNull(),
        rate: decimal2("rate", { precision: 10, scale: 6 }).notNull(),
        updatedAt: timestamp3("updated_at").defaultNow().notNull()
      },
      (table) => [
        index("IDX_currency_rates_base_target").on(
          table.baseCurrency,
          table.targetCurrency
        )
      ]
    );
    taxRules = pgTable3(
      "tax_rules",
      {
        id: serial2("id").primaryKey(),
        region: varchar2("region").notNull(),
        vatRate: decimal2("vat_rate", { precision: 5, scale: 2 }),
        gstRate: decimal2("gst_rate", { precision: 5, scale: 2 }),
        whtRate: decimal2("wht_rate", { precision: 5, scale: 2 }),
        createdAt: timestamp3("created_at").defaultNow().notNull()
      },
      (table) => [index("IDX_tax_rules_region").on(table.region)]
    );
    offlineTaskCache = pgTable3(
      "offline_task_cache",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        staffId: varchar2("staff_id").notNull(),
        propertyId: integer3("property_id"),
        taskData: json("task_data").notNull(),
        synced: boolean3("synced").default(false),
        createdAt: timestamp3("created_at").defaultNow(),
        syncedAt: timestamp3("synced_at")
      },
      (table) => [
        index("IDX_offline_task_cache_org").on(table.organizationId),
        index("IDX_offline_task_cache_staff").on(table.staffId),
        index("IDX_offline_task_cache_synced").on(table.synced)
      ]
    );
    marketingPacks = pgTable3(
      "marketing_packs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull().default("default-org"),
        propertyId: integer3("property_id").references(() => properties.id),
        generatedBy: varchar2("generated_by"),
        pdfUrl: text3("pdf_url"),
        aiSummary: text3("ai_summary"),
        packType: varchar2("pack_type").default("standard"),
        // standard, premium, luxury, agent-focused
        targetAudience: varchar2("target_audience").default("general"),
        // general, families, couples, business, luxury
        language: varchar2("language").default("en"),
        // en, th, zh, ja, ko
        status: varchar2("status").default("draft"),
        // draft, generated, published, archived
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_marketing_packs_org").on(table.organizationId),
        index("IDX_marketing_packs_property").on(table.propertyId),
        index("IDX_marketing_packs_status").on(table.status),
        index("IDX_marketing_packs_type").on(table.packType)
      ]
    );
    insertTaskHistorySchema = createInsertSchema3(taskHistory);
    insertNotificationSchema = createInsertSchema3(notifications).omit({
      id: true,
      createdAt: true
    });
    insertNotificationPreferenceSchema = createInsertSchema3(
      notificationPreferences
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertCurrencyRateSchema = createInsertSchema3(currencyRates).omit({
      id: true,
      updatedAt: true
    });
    insertTaxRuleSchema = createInsertSchema3(taxRules).omit({
      id: true,
      createdAt: true
    });
    insertOfflineTaskCacheSchema = createInsertSchema3(
      offlineTaskCache
    ).omit({
      id: true,
      createdAt: true,
      syncedAt: true
    });
    insertMarketingPackSchema = createInsertSchema3(
      marketingPacks
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    aiOpsAnomalies = pgTable3("ai_ops_anomalies", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id", { length: 255 }).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      anomalyType: varchar2("anomaly_type", { length: 100 }).notNull(),
      // missing-task, payout-mismatch, overdue-maintenance, booking-conflict, revenue-inconsistency
      detectedAt: timestamp3("detected_at").defaultNow().notNull(),
      autoFixed: boolean3("auto_fixed").default(false).notNull(),
      fixAction: text3("fix_action"),
      status: varchar2("status", { length: 50 }).default("open").notNull(),
      // open, resolved, investigating
      resolvedAt: timestamp3("resolved_at"),
      severity: varchar2("severity", { length: 20 }).default("medium").notNull(),
      // low, medium, high, critical
      details: json("details").$type(),
      createdAt: timestamp3("created_at").defaultNow().notNull(),
      updatedAt: timestamp3("updated_at").defaultNow().notNull()
    });
    insertAiOpsAnomalySchema = createInsertSchema3(aiOpsAnomalies).omit(
      {
        id: true,
        createdAt: true,
        updatedAt: true
      }
    );
    sharedCosts = pgTable3(
      "shared_costs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        buildingId: varchar2("building_id").notNull(),
        description: text3("description"),
        totalAmount: decimal2("total_amount", { precision: 10, scale: 2 }).notNull(),
        costType: varchar2("cost_type").default("electricity"),
        periodStart: date2("period_start"),
        periodEnd: date2("period_end"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_shared_costs_org").on(table.organizationId),
        index("IDX_shared_costs_building").on(table.buildingId),
        index("IDX_shared_costs_type").on(table.costType)
      ]
    );
    sharedCostSplits = pgTable3(
      "shared_cost_splits",
      {
        id: serial2("id").primaryKey(),
        sharedCostId: integer3("shared_cost_id").references(() => sharedCosts.id, { onDelete: "cascade" }).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        ownerId: varchar2("owner_id"),
        splitAmount: decimal2("split_amount", { precision: 10, scale: 2 }).notNull()
      },
      (table) => [
        index("IDX_shared_cost_splits_cost").on(table.sharedCostId),
        index("IDX_shared_cost_splits_property").on(table.propertyId),
        index("IDX_shared_cost_splits_owner").on(table.ownerId)
      ]
    );
    insertSharedCostSchema = createInsertSchema3(sharedCosts).omit({
      id: true,
      createdAt: true
    });
    insertSharedCostSplitSchema = createInsertSchema3(
      sharedCostSplits
    ).omit({
      id: true
    });
    taskAiScanResults = pgTable3(
      "task_ai_scan_results",
      {
        id: serial2("id").primaryKey(),
        taskId: integer3("task_id").references(() => tasks.id).notNull(),
        photoUrl: text3("photo_url").notNull(),
        aiFindings: json("ai_findings"),
        confidenceScore: decimal2("confidence_score", { precision: 4, scale: 2 }),
        flagged: boolean3("flagged").default(false),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_task_ai_scan_task").on(table.taskId),
        index("IDX_task_ai_scan_flagged").on(table.flagged),
        index("IDX_task_ai_scan_confidence").on(table.confidenceScore)
      ]
    );
    insertTaskAiScanResultSchema = createInsertSchema3(
      taskAiScanResults
    ).omit({
      id: true,
      createdAt: true
    });
    propertyInvestments = pgTable3(
      "property_investments",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        investmentType: varchar2("investment_type"),
        description: text3("description"),
        amount: decimal2("amount", { precision: 12, scale: 2 }),
        investmentDate: date2("investment_date"),
        expectedRoi: decimal2("expected_roi", { precision: 5, scale: 2 }),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_property_investments_org").on(table.organizationId),
        index("IDX_property_investments_property").on(table.propertyId),
        index("IDX_property_investments_type").on(table.investmentType),
        index("IDX_property_investments_date").on(table.investmentDate)
      ]
    );
    insertPropertyInvestmentSchema = createInsertSchema3(
      propertyInvestments
    ).omit({
      id: true,
      createdAt: true
    });
    dynamicPricingRecommendations = pgTable3(
      "dynamic_pricing_recommendations",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        currentRate: decimal2("current_rate", { precision: 10, scale: 2 }),
        recommendedRate: decimal2("recommended_rate", { precision: 10, scale: 2 }),
        marketSource: varchar2("market_source"),
        confidenceScore: decimal2("confidence_score", { precision: 4, scale: 2 }),
        generatedAt: timestamp3("generated_at").defaultNow()
      },
      (table) => [
        index("IDX_dynamic_pricing_org").on(table.organizationId),
        index("IDX_dynamic_pricing_property").on(table.propertyId),
        index("IDX_dynamic_pricing_source").on(table.marketSource),
        index("IDX_dynamic_pricing_generated").on(table.generatedAt)
      ]
    );
    insertDynamicPricingRecommendationSchema = createInsertSchema3(
      dynamicPricingRecommendations
    ).omit({
      id: true,
      generatedAt: true
    });
    propertyChatMessages = pgTable3(
      "property_chat_messages",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        senderId: varchar2("sender_id").notNull(),
        recipientId: varchar2("recipient_id"),
        role: varchar2("role").notNull(),
        // owner, staff, admin
        message: text3("message").notNull(),
        translatedMessage: text3("translated_message"),
        languageDetected: varchar2("language_detected", { length: 5 }),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_property_chat_org").on(table.organizationId),
        index("IDX_property_chat_property").on(table.propertyId),
        index("IDX_property_chat_sender").on(table.senderId),
        index("IDX_property_chat_recipient").on(table.recipientId),
        index("IDX_property_chat_created").on(table.createdAt)
      ]
    );
    insertPropertyChatMessageSchema = createInsertSchema3(
      propertyChatMessages
    ).omit({
      id: true,
      createdAt: true
    });
    propertyDocuments = pgTable3(
      "property_documents",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        docType: varchar2("doc_type").notNull(),
        // contract, license, invoice, insurance, warranty, maintenance, other
        fileName: varchar2("file_name"),
        fileUrl: text3("file_url").notNull(),
        fileSize: integer3("file_size"),
        mimeType: varchar2("mime_type"),
        category: varchar2("category"),
        tags: text3("tags").array(),
        description: text3("description"),
        expiryDate: date2("expiry_date"),
        uploadedBy: varchar2("uploaded_by").notNull(),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_property_docs_org").on(table.organizationId),
        index("IDX_property_docs_property").on(table.propertyId),
        index("IDX_property_docs_type").on(table.docType),
        index("IDX_property_docs_expiry").on(table.expiryDate),
        index("IDX_property_docs_created").on(table.createdAt)
      ]
    );
    insertPropertyDocumentSchema = createInsertSchema3(
      propertyDocuments
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    upsellRecommendations = pgTable3(
      "upsell_recommendations",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        guestId: varchar2("guest_id"),
        propertyId: integer3("property_id").references(() => properties.id),
        recommendationType: varchar2("recommendation_type"),
        // extra_cleaning, private_chef, spa_service, tour_guide, grocery_delivery, laundry_service, transportation, other
        message: text3("message"),
        status: varchar2("status").default("pending"),
        // pending, sent, accepted, declined, expired
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_upsell_org").on(table.organizationId),
        index("IDX_upsell_guest").on(table.guestId),
        index("IDX_upsell_property").on(table.propertyId),
        index("IDX_upsell_type").on(table.recommendationType),
        index("IDX_upsell_status").on(table.status),
        index("IDX_upsell_created").on(table.createdAt)
      ]
    );
    insertUpsellRecommendationSchema = createInsertSchema3(
      upsellRecommendations
    ).omit({
      id: true,
      createdAt: true
    });
    insertCommissionEarningSchema = createInsertSchema3(
      commissionEarnings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPortfolioAssignmentSchema = createInsertSchema3(
      portfolioAssignments
    ).omit({
      id: true,
      assignedAt: true
    });
    insertGuestAddonServiceSchema = createInsertSchema3(
      guestAddonServices
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestAddonBookingSchema = createInsertSchema3(
      guestAddonBookings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertApiConnectionSchema = createInsertSchema3(
      apiConnections
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    propertyMarketingMedia2 = pgTable3("property_marketing_media", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      // Media Information
      mediaType: varchar2("media_type").notNull(),
      // photo_folder, video_link, virtual_tour, brochure
      title: varchar2("title").notNull(),
      description: text3("description"),
      // Links and Access
      mediaUrl: varchar2("media_url").notNull(),
      // Google Drive link, etc.
      thumbnailUrl: varchar2("thumbnail_url"),
      accessPassword: varchar2("access_password"),
      // If protected
      // Organization
      category: varchar2("category"),
      // interior, exterior, amenities, location, etc.
      sortOrder: integer3("sort_order").default(0),
      // Visibility and Access Control
      isPublic: boolean3("is_public").default(true),
      agentAccessLevel: varchar2("agent_access_level").default("all"),
      // all, specific, restricted
      // Usage Tracking
      viewCount: integer3("view_count").default(0),
      lastAccessed: timestamp3("last_accessed"),
      // Timestamps
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyCommissionRules2 = pgTable3("property_commission_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      // Commission Configuration
      defaultCommissionRate: decimal2("default_commission_rate", {
        precision: 5,
        scale: 2
      }).default(10),
      seasonalRates: jsonb3("seasonal_rates"),
      // JSON for date-based rates
      minimumStayCommission: decimal2("minimum_stay_commission", {
        precision: 5,
        scale: 2
      }),
      weeklyCommissionBonus: decimal2("weekly_commission_bonus", {
        precision: 5,
        scale: 2
      }),
      monthlyCommissionBonus: decimal2("monthly_commission_bonus", {
        precision: 5,
        scale: 2
      }),
      // Agent-Specific Rules
      agentSpecificRules: jsonb3("agent_specific_rules"),
      // JSON for agent-specific rates
      // Rules and Conditions
      minimumBookingValue: decimal2("minimum_booking_value", {
        precision: 10,
        scale: 2
      }),
      maximumCommissionCap: decimal2("maximum_commission_cap", {
        precision: 10,
        scale: 2
      }),
      // Status
      isActive: boolean3("is_active").default(true),
      // Timestamps
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    agentBookingRequests2 = pgTable3("agent_booking_requests", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      agentId: varchar2("agent_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      // Guest Information
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email").notNull(),
      guestPhone: varchar2("guest_phone"),
      guestCountry: varchar2("guest_country"),
      // Requested Booking Details
      requestedCheckIn: timestamp3("requested_check_in").notNull(),
      requestedCheckOut: timestamp3("requested_check_out").notNull(),
      requestedGuests: integer3("requested_guests").default(1),
      budgetRange: varchar2("budget_range"),
      // Request Details
      specialRequests: text3("special_requests"),
      agentNotes: text3("agent_notes"),
      urgencyLevel: varchar2("urgency_level").default("normal"),
      // low, normal, high, urgent
      // Admin Response
      adminResponse: text3("admin_response"),
      adminNotes: text3("admin_notes"),
      alternativeOffers: jsonb3("alternative_offers"),
      // JSON array of alternative property suggestions
      // Status Tracking
      status: varchar2("status").default("pending"),
      // pending, under_review, approved, declined, converted_to_booking
      // Workflow Timestamps
      submittedAt: timestamp3("submitted_at").defaultNow(),
      reviewedAt: timestamp3("reviewed_at"),
      reviewedBy: varchar2("reviewed_by"),
      respondedAt: timestamp3("responded_at"),
      // Conversion Tracking
      convertedToBookingId: integer3("converted_to_booking_id"),
      // Links to agent_bookings if converted
      // Timestamps
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyPlannedUpgrades = pgTable3("property_planned_upgrades", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Upgrade Details
      upgradeType: varchar2("upgrade_type").notNull(),
      // furniture, appliance, renovation, decor, safety
      title: varchar2("title").notNull(),
      description: text3("description").notNull(),
      suggestedBudget: decimal2("suggested_budget", { precision: 10, scale: 2 }),
      currency: varchar2("currency", { length: 3 }).default("THB"),
      targetDate: date2("target_date"),
      priorityLevel: varchar2("priority_level").notNull().default("medium"),
      // low, medium, high
      // Files and attachments
      attachmentUrl: varchar2("attachment_url"),
      // Image/file attachment
      attachmentFilename: varchar2("attachment_filename"),
      // Conditional trigger
      hasConditionTrigger: boolean3("has_condition_trigger").default(false),
      conditionAmount: decimal2("condition_amount", { precision: 12, scale: 2 }),
      conditionDescription: text3("condition_description"),
      // e.g., "Only if revenue > X THB"
      // Status tracking
      status: varchar2("status").notNull().default("pending"),
      // pending, approved, in_progress, completed, cancelled
      approvedBy: varchar2("approved_by").references(() => users.id),
      approvedAt: timestamp3("approved_at"),
      completedBy: varchar2("completed_by").references(() => users.id),
      completedAt: timestamp3("completed_at"),
      actualCost: decimal2("actual_cost", { precision: 10, scale: 2 }),
      // Notes
      notes: text3("notes"),
      // Timestamps
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyGoalsNotes = pgTable3("property_goals_notes", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Note content
      noteText: text3("note_text").notNull(),
      noteType: varchar2("note_type").default("general"),
      // general, milestone, concern, suggestion
      // Permissions
      isOwnerVisible: boolean3("is_owner_visible").default(true),
      isStaffVisible: boolean3("is_staff_visible").default(false),
      // Timestamps and authorship
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyGoalsComments = pgTable3("property_goals_comments", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      relatedNoteId: integer3("related_note_id").references(
        () => propertyGoalsNotes.id
      ),
      // Comment content
      commentText: text3("comment_text").notNull(),
      // Timestamps and authorship
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyMarketingMediaRelations = relations(
      propertyMarketingMedia2,
      ({ one }) => ({
        property: one(properties, {
          fields: [propertyMarketingMedia2.propertyId],
          references: [properties.id]
        })
      })
    );
    propertyCommissionRulesRelations = relations(
      propertyCommissionRules2,
      ({ one }) => ({
        property: one(properties, {
          fields: [propertyCommissionRules2.propertyId],
          references: [properties.id]
        })
      })
    );
    agentBookingRequestsRelations = relations(
      agentBookingRequests2,
      ({ one }) => ({
        property: one(properties, {
          fields: [agentBookingRequests2.propertyId],
          references: [properties.id]
        }),
        agent: one(users, {
          fields: [agentBookingRequests2.agentId],
          references: [users.id]
        })
      })
    );
    invoiceTemplates2 = pgTable3("invoice_templates", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      templateName: varchar2("template_name").notNull(),
      templateType: varchar2("template_type").notNull(),
      // booking_commission, monthly_summary, portfolio_manager, service_fee, expense_reimbursement
      // Template Configuration
      defaultSender: varchar2("default_sender").notNull(),
      // management, owner, portfolio_manager
      defaultReceiver: varchar2("default_receiver").notNull(),
      // management, owner, portfolio_manager
      autoIncludeItems: jsonb3("auto_include_items"),
      // JSON array of what to include
      taxRate: decimal2("tax_rate", { precision: 5, scale: 2 }).default(0),
      taxEnabled: boolean3("tax_enabled").default(false),
      // Template Styling
      logoUrl: varchar2("logo_url"),
      primaryColor: varchar2("primary_color").default("#000000"),
      headerText: text3("header_text"),
      footerText: text3("footer_text"),
      // Status
      isActive: boolean3("is_active").default(true),
      isDefault: boolean3("is_default").default(false),
      // Timestamps
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    generatedInvoices2 = pgTable3("generated_invoices", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      invoiceNumber: varchar2("invoice_number").notNull().unique(),
      templateId: integer3("template_id").references(() => invoiceTemplates2.id),
      // Parties
      senderType: varchar2("sender_type").notNull(),
      // management, owner, portfolio_manager
      senderId: varchar2("sender_id"),
      // User ID if applicable
      senderName: varchar2("sender_name").notNull(),
      senderEmail: varchar2("sender_email"),
      senderAddress: text3("sender_address"),
      receiverType: varchar2("receiver_type").notNull(),
      // management, owner, portfolio_manager
      receiverId: varchar2("receiver_id"),
      // User ID if applicable
      receiverName: varchar2("receiver_name").notNull(),
      receiverEmail: varchar2("receiver_email"),
      receiverAddress: text3("receiver_address"),
      // Invoice Details
      invoiceDate: date2("invoice_date").notNull(),
      dueDate: date2("due_date"),
      periodStart: date2("period_start"),
      periodEnd: date2("period_end"),
      // Financial
      subtotal: decimal2("subtotal", { precision: 12, scale: 2 }).notNull(),
      taxAmount: decimal2("tax_amount", { precision: 12, scale: 2 }).default(0),
      totalAmount: decimal2("total_amount", { precision: 12, scale: 2 }).notNull(),
      currency: varchar2("currency").default("AUD"),
      // Status and Payment
      status: varchar2("status").default("draft"),
      // draft, sent, paid, overdue, cancelled
      paymentStatus: varchar2("payment_status").default("unpaid"),
      // unpaid, partial, paid
      paymentMethod: varchar2("payment_method"),
      // bank_transfer, stripe, cash, manual
      paymentReference: varchar2("payment_reference"),
      paymentDate: date2("payment_date"),
      // Attachments and Notes
      notes: text3("notes"),
      internalNotes: text3("internal_notes"),
      attachmentUrls: jsonb3("attachment_urls"),
      // Array of receipt/document URLs
      // PDF Generation
      pdfUrl: varchar2("pdf_url"),
      pdfGeneratedAt: timestamp3("pdf_generated_at"),
      // Audit Trail
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      sentBy: varchar2("sent_by").references(() => users.id),
      sentAt: timestamp3("sent_at"),
      lastModifiedBy: varchar2("last_modified_by").references(() => users.id),
      // Timestamps
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    invoiceLineItems2 = pgTable3("invoice_line_items", {
      id: serial2("id").primaryKey(),
      invoiceId: integer3("invoice_id").references(() => generatedInvoices2.id).notNull(),
      // Line Item Details
      itemType: varchar2("item_type").notNull(),
      // booking_revenue, commission, addon_service, expense, adjustment, tax
      description: text3("description").notNull(),
      itemReference: varchar2("item_reference"),
      // booking ID, service ID, etc.
      // Pricing
      quantity: decimal2("quantity", { precision: 10, scale: 2 }).default(1),
      unitPrice: decimal2("unit_price", { precision: 12, scale: 2 }).notNull(),
      lineTotal: decimal2("line_total", { precision: 12, scale: 2 }).notNull(),
      // Categorization
      category: varchar2("category"),
      // revenue, commission, service, expense, adjustment
      subcategory: varchar2("subcategory"),
      // cleaning, transport, management_fee, etc.
      // Source Tracking
      sourceType: varchar2("source_type"),
      // booking, addon_service, manual, commission
      sourceId: integer3("source_id"),
      // ID of source record
      // Manual Adjustments
      isManualEntry: boolean3("is_manual_entry").default(false),
      adjustmentReason: text3("adjustment_reason"),
      // Timestamps
      createdAt: timestamp3("created_at").defaultNow()
    });
    invoiceBookingLinks2 = pgTable3("invoice_booking_links", {
      id: serial2("id").primaryKey(),
      invoiceId: integer3("invoice_id").references(() => generatedInvoices2.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
      // Financial Breakdown for this booking
      bookingRevenue: decimal2("booking_revenue", {
        precision: 12,
        scale: 2
      }).notNull(),
      managementCommission: decimal2("management_commission", {
        precision: 12,
        scale: 2
      }).default(0),
      portfolioManagerCommission: decimal2("portfolio_manager_commission", {
        precision: 12,
        scale: 2
      }).default(0),
      ownerPayout: decimal2("owner_payout", { precision: 12, scale: 2 }).default(0),
      // Add-on Services for this booking
      addonServicesTotal: decimal2("addon_services_total", {
        precision: 12,
        scale: 2
      }).default(0),
      // Timestamps
      createdAt: timestamp3("created_at").defaultNow()
    });
    invoiceServiceLinks2 = pgTable3("invoice_service_links", {
      id: serial2("id").primaryKey(),
      invoiceId: integer3("invoice_id").references(() => generatedInvoices2.id).notNull(),
      serviceBookingId: integer3("service_booking_id").references(() => guestAddonBookings.id).notNull(),
      // Service Details
      serviceName: varchar2("service_name").notNull(),
      serviceAmount: decimal2("service_amount", {
        precision: 10,
        scale: 2
      }).notNull(),
      billingRoute: varchar2("billing_route").notNull(),
      // guest_billable, owner_billable, company_expense
      // Timestamps
      createdAt: timestamp3("created_at").defaultNow()
    });
    invoiceGenerationLog = pgTable3("invoice_generation_log", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Generation Details
      generationType: varchar2("generation_type").notNull(),
      // manual, scheduled, api_triggered
      templateUsed: varchar2("template_used"),
      generatedBy: varchar2("generated_by").references(() => users.id),
      // Scope
      periodStart: date2("period_start"),
      periodEnd: date2("period_end"),
      propertiesIncluded: jsonb3("properties_included"),
      // Array of property IDs
      // Results
      invoicesGenerated: integer3("invoices_generated").default(0),
      totalAmount: decimal2("total_amount", { precision: 15, scale: 2 }).default(0),
      // Status
      status: varchar2("status").default("completed"),
      // in_progress, completed, failed
      errorMessage: text3("error_message"),
      // Timestamps
      createdAt: timestamp3("created_at").defaultNow()
    });
    invoiceTemplatesRelations = relations(
      invoiceTemplates2,
      ({ many }) => ({
        generatedInvoices: many(generatedInvoices2)
      })
    );
    generatedInvoicesRelations = relations(
      generatedInvoices2,
      ({ one, many }) => ({
        template: one(invoiceTemplates2, {
          fields: [generatedInvoices2.templateId],
          references: [invoiceTemplates2.id]
        }),
        lineItems: many(invoiceLineItems2),
        bookingLinks: many(invoiceBookingLinks2),
        serviceLinks: many(invoiceServiceLinks2),
        creator: one(users, {
          fields: [generatedInvoices2.createdBy],
          references: [users.id]
        })
      })
    );
    invoiceLineItemsRelations = relations(
      invoiceLineItems2,
      ({ one }) => ({
        invoice: one(generatedInvoices2, {
          fields: [invoiceLineItems2.invoiceId],
          references: [generatedInvoices2.id]
        })
      })
    );
    invoiceBookingLinksRelations = relations(
      invoiceBookingLinks2,
      ({ one }) => ({
        invoice: one(generatedInvoices2, {
          fields: [invoiceBookingLinks2.invoiceId],
          references: [generatedInvoices2.id]
        }),
        booking: one(bookings, {
          fields: [invoiceBookingLinks2.bookingId],
          references: [bookings.id]
        })
      })
    );
    invoiceServiceLinksRelations = relations(
      invoiceServiceLinks2,
      ({ one }) => ({
        invoice: one(generatedInvoices2, {
          fields: [invoiceServiceLinks2.invoiceId],
          references: [generatedInvoices2.id]
        }),
        serviceBooking: one(guestAddonBookings, {
          fields: [invoiceServiceLinks2.serviceBookingId],
          references: [guestAddonBookings.id]
        })
      })
    );
    insertInvoiceTemplateSchema = createInsertSchema3(
      invoiceTemplates2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGeneratedInvoiceSchema = createInsertSchema3(
      generatedInvoices2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertInvoiceLineItemSchema = createInsertSchema3(
      invoiceLineItems2
    ).omit({
      id: true,
      createdAt: true
    });
    insertInvoiceBookingLinkSchema = createInsertSchema3(
      invoiceBookingLinks2
    ).omit({
      id: true,
      createdAt: true
    });
    insertInvoiceServiceLinkSchema = createInsertSchema3(
      invoiceServiceLinks2
    ).omit({
      id: true,
      createdAt: true
    });
    propertyUtilitiesMaster = pgTable3(
      "property_utilities_master",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        utilityType: varchar2("utility_type").notNull(),
        // electricity, water, internet, pest_control, garden, pool
        providerName: varchar2("provider_name").notNull(),
        // PEA, TOT, 3BB, Local Water, etc.
        accountNumber: varchar2("account_number").notNull(),
        whoPays: varchar2("who_pays").notNull().default("management"),
        // owner, management, guest, other
        whoPayssOtherExplanation: text3("who_pays_other_explanation"),
        // For "other" option
        isActive: boolean3("is_active").default(true),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_util_master_org").on(table.organizationId),
        index("IDX_util_master_property").on(table.propertyId),
        index("IDX_util_master_type").on(table.utilityType)
      ]
    );
    utilityBillsExtended = pgTable3(
      "utility_bills_extended",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        utilityMasterId: integer3("utility_master_id").references(() => propertyUtilitiesMaster.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        billingMonth: varchar2("billing_month").notNull(),
        // YYYY-MM format
        billingPeriodStart: date2("billing_period_start").notNull(),
        billingPeriodEnd: date2("billing_period_end").notNull(),
        amount: decimal2("amount", { precision: 10, scale: 2 }).notNull(),
        currency: varchar2("currency").default("THB"),
        isPaid: boolean3("is_paid").default(false),
        paidDate: date2("paid_date"),
        receiptUploaded: boolean3("receipt_uploaded").default(false),
        receiptFileUrl: varchar2("receipt_file_url"),
        // URL to uploaded receipt
        receiptFileName: varchar2("receipt_file_name"),
        dueDate: date2("due_date"),
        expectedArrivalDate: date2("expected_arrival_date"),
        // AI prediction
        isLate: boolean3("is_late").default(false),
        // Auto-computed based on arrival patterns
        lateReason: text3("late_reason"),
        uploadedBy: varchar2("uploaded_by").references(() => users.id),
        uploadedAt: timestamp3("uploaded_at"),
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_util_bills_org").on(table.organizationId),
        index("IDX_util_bills_utility").on(table.utilityMasterId),
        index("IDX_util_bills_property").on(table.propertyId),
        index("IDX_util_bills_month").on(table.billingMonth)
      ]
    );
    utilityAccessPermissions = pgTable3(
      "utility_access_permissions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        utilityMasterId: integer3("utility_master_id").references(() => propertyUtilitiesMaster.id).notNull(),
        userRole: varchar2("user_role").notNull(),
        // manager, owner
        canEditProviderInfo: boolean3("can_edit_provider_info").default(false),
        canEditAccountNumber: boolean3("can_edit_account_number").default(false),
        canUploadBills: boolean3("can_upload_bills").default(false),
        canViewBills: boolean3("can_view_bills").default(true),
        canSetReminders: boolean3("can_set_reminders").default(false),
        canViewAccountNumber: boolean3("can_view_account_number").default(false),
        // Show full account vs masked
        setBy: varchar2("set_by").references(() => users.id).notNull(),
        // Admin who set permissions
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_util_perms_org").on(table.organizationId),
        index("IDX_util_perms_utility").on(table.utilityMasterId),
        index("IDX_util_perms_role").on(table.userRole)
      ]
    );
    utilityAiPredictions = pgTable3(
      "utility_ai_predictions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        utilityMasterId: integer3("utility_master_id").references(() => propertyUtilitiesMaster.id).notNull(),
        predictionType: varchar2("prediction_type").notNull(),
        // arrival_date, late_alert, amount_estimate
        predictedDate: date2("predicted_date"),
        // For arrival predictions
        predictedAmount: decimal2("predicted_amount", { precision: 10, scale: 2 }),
        // For amount estimates
        confidenceScore: decimal2("confidence_score", { precision: 3, scale: 2 }),
        // 0.00 to 1.00
        basedOnMonths: integer3("based_on_months").default(6),
        // How many months of data used
        lastBillDate: date2("last_bill_date"),
        // Most recent bill for comparison
        averageArrivalDay: integer3("average_arrival_day"),
        // Typical day of month bills arrive
        notes: text3("notes"),
        // AI explanation
        isActive: boolean3("is_active").default(true),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_ai_pred_org").on(table.organizationId),
        index("IDX_ai_pred_utility").on(table.utilityMasterId),
        index("IDX_ai_pred_type").on(table.predictionType)
      ]
    );
    utilityNotifications = pgTable3(
      "utility_notifications",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        utilityMasterId: integer3("utility_master_id").references(() => propertyUtilitiesMaster.id).notNull(),
        notificationType: varchar2("notification_type").notNull(),
        // late_upload_alert, owner_reminder, payment_due
        recipientRole: varchar2("recipient_role").notNull(),
        // admin, manager, owner
        recipientUserId: varchar2("recipient_user_id").references(() => users.id),
        message: text3("message").notNull(),
        severity: varchar2("severity").notNull().default("normal"),
        // low, normal, high, critical
        isRead: boolean3("is_read").default(false),
        readAt: timestamp3("read_at"),
        sentAt: timestamp3("sent_at"),
        relatedBillId: integer3("related_bill_id").references(
          () => utilityBillsExtended.id
        ),
        actionRequired: boolean3("action_required").default(false),
        actionTaken: boolean3("action_taken").default(false),
        actionTakenBy: varchar2("action_taken_by").references(() => users.id),
        actionTakenAt: timestamp3("action_taken_at"),
        actionNotes: text3("action_notes"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_util_notif_org").on(table.organizationId),
        index("IDX_util_notif_utility").on(table.utilityMasterId),
        index("IDX_util_notif_recipient").on(table.recipientUserId),
        index("IDX_util_notif_type").on(table.notificationType)
      ]
    );
    ownerStatementExports = pgTable3("owner_statement_exports", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      // Export parameters
      exportType: varchar2("export_type").notNull(),
      // "pdf", "csv"
      dateRangeType: varchar2("date_range_type").notNull(),
      // "month", "custom"
      startDate: date2("start_date").notNull(),
      endDate: date2("end_date").notNull(),
      // Property selection
      propertyIds: jsonb3("property_ids").notNull(),
      // Array of property IDs for bulk export
      // Export options
      includeNotes: boolean3("include_notes").default(false),
      includeServiceLogs: boolean3("include_service_logs").default(false),
      includeBranding: boolean3("include_branding").default(true),
      // Generated file info
      fileName: varchar2("file_name").notNull(),
      fileSize: integer3("file_size"),
      // in bytes
      fileUrl: varchar2("file_url"),
      // S3 URL or file path
      // Summary data (for quick display)
      totalEarnings: decimal2("total_earnings", { precision: 15, scale: 2 }).default(
        0
      ),
      totalExpenses: decimal2("total_expenses", { precision: 15, scale: 2 }).default(
        0
      ),
      managementCommission: decimal2("management_commission", {
        precision: 15,
        scale: 2
      }).default(0),
      netBalance: decimal2("net_balance", { precision: 15, scale: 2 }).default(0),
      // Status
      status: varchar2("status").default("generating"),
      // generating, completed, failed
      errorMessage: text3("error_message"),
      // Timestamps
      createdAt: timestamp3("created_at").defaultNow(),
      completedAt: timestamp3("completed_at")
    });
    ownerStatementExportsRelations = relations(
      ownerStatementExports,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [ownerStatementExports.organizationId],
          references: [organizations.id]
        }),
        owner: one(users, {
          fields: [ownerStatementExports.ownerId],
          references: [users.id]
        })
      })
    );
    insertOwnerStatementExportSchema = createInsertSchema3(
      ownerStatementExports
    ).omit({
      id: true,
      createdAt: true,
      completedAt: true
    });
    insertPropertyUtilityAccountEnhancedSchema = createInsertSchema3(
      propertyUtilityAccountsEnhanced
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUtilityBillLogEnhancedSchema = createInsertSchema3(
      utilityBillLogsEnhanced
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUtilityAiReminderSchema = createInsertSchema3(
      utilityAiReminders
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyMaintenanceHistorySchema = createInsertSchema3(
      propertyMaintenanceHistory
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMaintenanceServiceIntervalSchema = createInsertSchema3(
      maintenanceServiceIntervals
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMaintenanceAiSuggestionSchema = createInsertSchema3(
      maintenanceAiSuggestions
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestServiceRequestSchema2 = createInsertSchema3(
      guestServiceRequests2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestConfirmedServiceSchema = createInsertSchema3(
      guestConfirmedServices
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBookingLinkedTaskSchema = createInsertSchema3(
      bookingLinkedTasks
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyAlertSchema = createInsertSchema3(
      propertyAlerts
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    documentAccessLogs2 = pgTable3(
      "document_access_logs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        documentId: integer3("document_id").references(() => propertyDocuments.id).notNull(),
        userId: varchar2("user_id").references(() => users.id).notNull(),
        // Access Details
        actionType: varchar2("action_type").notNull(),
        // view, download, upload, edit, delete, share
        accessMethod: varchar2("access_method").default("web"),
        // web, mobile, api
        ipAddress: varchar2("ip_address"),
        userAgent: text3("user_agent"),
        // Additional Context
        success: boolean3("success").default(true),
        errorMessage: text3("error_message"),
        sessionId: varchar2("session_id"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_access_logs_document").on(table.documentId),
        index("IDX_access_logs_user").on(table.userId),
        index("IDX_access_logs_action").on(table.actionType)
      ]
    );
    ownerOnboardingChecklists2 = pgTable3(
      "owner_onboarding_checklists",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        ownerId: varchar2("owner_id").references(() => users.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        // Checklist Progress
        overallProgress: integer3("overall_progress").default(0),
        // percentage 0-100
        isCompleted: boolean3("is_completed").default(false),
        completedAt: timestamp3("completed_at"),
        // Document Upload Tasks
        passportIdUploaded: boolean3("passport_id_uploaded").default(false),
        proofOfOwnershipUploaded: boolean3("proof_of_ownership_uploaded").default(
          false
        ),
        rentalLicenseUploaded: boolean3("rental_license_uploaded").default(false),
        floorPlansUploaded: boolean3("floor_plans_uploaded").default(false),
        houseManualUploaded: boolean3("house_manual_uploaded").default(false),
        inventoryListUploaded: boolean3("inventory_list_uploaded").default(false),
        insuranceDocsUploaded: boolean3("insurance_docs_uploaded").default(false),
        utilityAccountsUploaded: boolean3("utility_accounts_uploaded").default(
          false
        ),
        // Setup Tasks
        propertyDetailsCompleted: boolean3("property_details_completed").default(
          false
        ),
        bankDetailsProvided: boolean3("bank_details_provided").default(false),
        contactInfoCompleted: boolean3("contact_info_completed").default(false),
        preferencesSet: boolean3("preferences_set").default(false),
        welcomePackConfigured: boolean3("welcome_pack_configured").default(false),
        // Communication Tasks
        introductionCallScheduled: boolean3("introduction_call_scheduled").default(
          false
        ),
        introductionCallCompleted: boolean3("introduction_call_completed").default(
          false
        ),
        // Administrative Tasks
        contractSigned: boolean3("contract_signed").default(false),
        firstPayoutScheduled: boolean3("first_payout_scheduled").default(false),
        // Task Completion Dates
        taskCompletionDates: jsonb3("task_completion_dates"),
        // Store completion timestamps for each task
        // Onboarding Management
        assignedTo: varchar2("assigned_to").references(() => users.id),
        // PM or admin handling onboarding
        notes: text3("notes"),
        priority: varchar2("priority").default("normal"),
        // low, normal, high, urgent
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_onboarding_owner").on(table.ownerId),
        index("IDX_onboarding_property").on(table.propertyId),
        index("IDX_onboarding_progress").on(table.overallProgress)
      ]
    );
    documentCategories2 = pgTable3(
      "document_categories",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        // Category Details
        categoryKey: varchar2("category_key").notNull(),
        // contracts, licenses, etc.
        displayName: varchar2("display_name").notNull(),
        description: text3("description"),
        icon: varchar2("icon").default("file-text"),
        // Category Configuration
        isRequired: boolean3("is_required").default(false),
        maxFiles: integer3("max_files").default(10),
        allowedFileTypes: text3("allowed_file_types").array().default(["pdf", "jpg", "jpeg", "png"]),
        maxFileSize: integer3("max_file_size").default(10485760),
        // 10MB in bytes
        // Access Rules
        defaultVisibility: varchar2("default_visibility").default("admin_pm_only"),
        requiresApproval: boolean3("requires_approval").default(false),
        // Organization Customization
        customInstructions: text3("custom_instructions"),
        exampleDocuments: text3("example_documents").array(),
        // Category Management
        isActive: boolean3("is_active").default(true),
        sortOrder: integer3("sort_order").default(0),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_doc_categories_org").on(table.organizationId),
        index("IDX_doc_categories_key").on(table.categoryKey)
      ]
    );
    fileUploadSessions2 = pgTable3(
      "file_upload_sessions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        uploadedBy: varchar2("uploaded_by").references(() => users.id).notNull(),
        // Session Details
        sessionId: varchar2("session_id").notNull().unique(),
        totalFiles: integer3("total_files").default(0),
        completedFiles: integer3("completed_files").default(0),
        failedFiles: integer3("failed_files").default(0),
        // Upload Progress
        status: varchar2("status").default("in_progress"),
        // in_progress, completed, failed, cancelled
        totalBytes: integer3("total_bytes").default(0),
        uploadedBytes: integer3("uploaded_bytes").default(0),
        // Session Management
        isActive: boolean3("is_active").default(true),
        expiresAt: timestamp3("expires_at"),
        errorDetails: jsonb3("error_details"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_upload_sessions_user").on(table.uploadedBy),
        index("IDX_upload_sessions_status").on(table.status)
      ]
    );
    maintenanceLog = pgTable3(
      "maintenance_log",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Task Details
        taskTitle: varchar2("task_title").notNull(),
        repairDate: date2("repair_date").notNull(),
        department: varchar2("department").notNull(),
        // maintenance, pool, garden, ac, pest, electrical, plumbing, hvac, landscaping
        itemArea: varchar2("item_area").notNull(),
        // specific item or area repaired
        issueDescription: text3("issue_description").notNull(),
        actionTaken: text3("action_taken").notNull(),
        // Assignment & Cost
        technicianAssigned: varchar2("technician_assigned").references(
          () => users.id
        ),
        technicianName: varchar2("technician_name"),
        // For external technicians
        cost: decimal2("cost", { precision: 10, scale: 2 }).default("0.00"),
        currency: varchar2("currency").default("THB"),
        invoiceUrl: text3("invoice_url"),
        // Upload path for invoice
        // Status & Progress
        status: varchar2("status").default("in_progress"),
        // finished, in_progress, awaiting_approval, scheduled
        priority: varchar2("priority").default("normal"),
        // low, normal, high, urgent
        // Media & Documentation
        linkedImages: text3("linked_images").array().default([]),
        // Array of image URLs
        notes: text3("notes"),
        // Warranty Information
        hasWarranty: boolean3("has_warranty").default(false),
        warrantyDuration: integer3("warranty_duration"),
        // in months
        warrantyExpirationDate: date2("warranty_expiration_date"),
        warrantyReceiptUrl: text3("warranty_receipt_url"),
        warrantyContactInfo: text3("warranty_contact_info"),
        warrantyClaimStatus: varchar2("warranty_claim_status").default("none"),
        // none, pending, approved, denied
        // AI Service Cycle Tracking
        isRecurringService: boolean3("is_recurring_service").default(false),
        serviceCycleMonths: integer3("service_cycle_months"),
        // e.g., 4 for every 4 months
        nextServiceDate: date2("next_service_date"),
        lastServiceDate: date2("last_service_date"),
        // Audit Trail
        createdBy: varchar2("created_by").references(() => users.id).notNull(),
        completedBy: varchar2("completed_by").references(() => users.id),
        approvedBy: varchar2("approved_by").references(() => users.id),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow(),
        completedAt: timestamp3("completed_at"),
        approvedAt: timestamp3("approved_at")
      },
      (table) => [
        index("IDX_maintenance_log_property").on(table.propertyId),
        index("IDX_maintenance_log_department").on(table.department),
        index("IDX_maintenance_log_status").on(table.status),
        index("IDX_maintenance_log_technician").on(table.technicianAssigned),
        index("IDX_maintenance_log_warranty_exp").on(table.warrantyExpirationDate)
      ]
    );
    warrantyAlerts = pgTable3(
      "warranty_alerts",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        maintenanceLogId: integer3("maintenance_log_id").references(() => maintenanceLog.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Alert Details
        alertType: varchar2("alert_type").notNull(),
        // warranty_expiring, warranty_expired, service_due
        alertMessage: text3("alert_message").notNull(),
        daysUntilExpiration: integer3("days_until_expiration"),
        // Alert Status
        isActive: boolean3("is_active").default(true),
        isSent: boolean3("is_sent").default(false),
        sentAt: timestamp3("sent_at"),
        acknowledgedBy: varchar2("acknowledged_by").references(() => users.id),
        acknowledgedAt: timestamp3("acknowledged_at"),
        // Scheduling
        scheduledFor: timestamp3("scheduled_for").notNull(),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_warranty_alerts_property").on(table.propertyId),
        index("IDX_warranty_alerts_scheduled").on(table.scheduledFor),
        index("IDX_warranty_alerts_active").on(table.isActive)
      ]
    );
    aiServiceCyclePredictions = pgTable3(
      "ai_service_cycle_predictions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Service Pattern Recognition
        department: varchar2("department").notNull(),
        itemArea: varchar2("item_area").notNull(),
        averageCycleMonths: decimal2("average_cycle_months", {
          precision: 5,
          scale: 2
        }),
        lastServiceDates: jsonb3("last_service_dates"),
        // Array of last service dates for pattern analysis
        // AI Prediction
        predictedNextServiceDate: date2("predicted_next_service_date"),
        confidenceScore: decimal2("confidence_score", { precision: 5, scale: 2 }),
        // 0.0 to 1.0
        basedOnHistoricalCount: integer3("based_on_historical_count").default(0),
        // Suggestion Management
        suggestionStatus: varchar2("suggestion_status").default("pending"),
        // pending, accepted, dismissed, converted_to_task
        suggestedBy: varchar2("suggested_by").default("ai_system"),
        reviewedBy: varchar2("reviewed_by").references(() => users.id),
        reviewedAt: timestamp3("reviewed_at"),
        // Task Conversion
        convertedToTaskId: integer3("converted_to_task_id"),
        // Reference to created task
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_ai_predictions_property").on(table.propertyId),
        index("IDX_ai_predictions_department").on(table.department),
        index("IDX_ai_predictions_status").on(table.suggestionStatus),
        index("IDX_ai_predictions_next_service").on(table.predictedNextServiceDate)
      ]
    );
    maintenanceCostAnalytics = pgTable3(
      "maintenance_cost_analytics",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Time Period
        periodType: varchar2("period_type").notNull(),
        // monthly, quarterly, yearly
        periodStart: date2("period_start").notNull(),
        periodEnd: date2("period_end").notNull(),
        // Cost Breakdown by Department
        maintenanceCost: decimal2("maintenance_cost", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        poolCost: decimal2("pool_cost", { precision: 10, scale: 2 }).default("0.00"),
        gardenCost: decimal2("garden_cost", { precision: 10, scale: 2 }).default(
          "0.00"
        ),
        acCost: decimal2("ac_cost", { precision: 10, scale: 2 }).default("0.00"),
        pestCost: decimal2("pest_cost", { precision: 10, scale: 2 }).default("0.00"),
        electricalCost: decimal2("electrical_cost", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        plumbingCost: decimal2("plumbing_cost", { precision: 10, scale: 2 }).default(
          "0.00"
        ),
        hvacCost: decimal2("hvac_cost", { precision: 10, scale: 2 }).default("0.00"),
        landscapingCost: decimal2("landscaping_cost", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        otherCost: decimal2("other_cost", { precision: 10, scale: 2 }).default(
          "0.00"
        ),
        // Summary Analytics
        totalCost: decimal2("total_cost", { precision: 10, scale: 2 }).default(
          "0.00"
        ),
        totalJobs: integer3("total_jobs").default(0),
        averageJobCost: decimal2("average_job_cost", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        // Comparison Metrics
        previousPeriodCost: decimal2("previous_period_cost", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        costChangePercentage: decimal2("cost_change_percentage", {
          precision: 5,
          scale: 2
        }).default("0.00"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_cost_analytics_property").on(table.propertyId),
        index("IDX_cost_analytics_period").on(table.periodStart, table.periodEnd)
      ]
    );
    technicianPerformance = pgTable3(
      "technician_performance",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        technicianId: varchar2("technician_id").references(() => users.id).notNull(),
        // Performance Metrics
        totalJobsCompleted: integer3("total_jobs_completed").default(0),
        averageJobDuration: decimal2("average_job_duration", {
          precision: 5,
          scale: 2
        }).default("0.00"),
        // in days
        averageCustomerRating: decimal2("average_customer_rating", {
          precision: 3,
          scale: 2
        }).default("0.00"),
        // 1-5 scale
        onTimeCompletionRate: decimal2("on_time_completion_rate", {
          precision: 5,
          scale: 2
        }).default("0.00"),
        // percentage
        // Specialization Areas
        specializations: text3("specializations").array().default([]),
        // departments they work in
        certifications: text3("certifications").array().default([]),
        // Period Tracking
        periodStart: date2("period_start").notNull(),
        periodEnd: date2("period_end").notNull(),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_technician_performance_tech").on(table.technicianId),
        index("IDX_technician_performance_period").on(
          table.periodStart,
          table.periodEnd
        )
      ]
    );
    insertMaintenanceLogSchema = createInsertSchema3(
      maintenanceLog
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      completedAt: true,
      approvedAt: true
    });
    insertWarrantyAlertSchema = createInsertSchema3(
      warrantyAlerts
    ).omit({
      id: true,
      createdAt: true,
      sentAt: true,
      acknowledgedAt: true
    });
    insertAiServiceCyclePredictionSchema = createInsertSchema3(
      aiServiceCyclePredictions
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      reviewedAt: true
    });
    insertMaintenanceCostAnalyticsSchema = createInsertSchema3(
      maintenanceCostAnalytics
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTechnicianPerformanceSchema = createInsertSchema3(
      technicianPerformance
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    guestCheckIns2 = pgTable3(
      "guest_check_ins",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Staff Assignment
        assignedToStaff: varchar2("assigned_to_staff").references(() => users.id).notNull(),
        completedByStaff: varchar2("completed_by_staff").references(() => users.id),
        // Passport Documentation
        passportPhotos: text3("passport_photos").array(),
        // Array of photo URLs
        guestNames: text3("guest_names").array(),
        // Names from passports
        passportNumbers: text3("passport_numbers").array(),
        // Passport numbers
        // Deposit Information
        depositType: varchar2("deposit_type").default("none"),
        // none, cash, digital
        depositAmount: decimal2("deposit_amount", { precision: 10, scale: 2 }),
        depositCurrency: varchar2("deposit_currency").default("THB"),
        depositReceiptPhoto: varchar2("deposit_receipt_photo"),
        // Electric Meter Reading
        electricMeterPhoto: varchar2("electric_meter_photo").notNull(),
        electricMeterReading: decimal2("electric_meter_reading", {
          precision: 10,
          scale: 3
        }),
        // kWh reading
        meterReadingMethod: varchar2("meter_reading_method").default("manual"),
        // manual, ocr_auto, ocr_manual_override
        // Task Completion
        status: varchar2("status").default("pending"),
        // pending, in_progress, completed
        completionNotes: text3("completion_notes"),
        // Timestamps
        scheduledDate: date2("scheduled_date").notNull(),
        startedAt: timestamp3("started_at"),
        completedAt: timestamp3("completed_at"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_checkin_booking").on(table.bookingId),
        index("IDX_checkin_property").on(table.propertyId),
        index("IDX_checkin_staff").on(table.assignedToStaff),
        index("IDX_checkin_date").on(table.scheduledDate)
      ]
    );
    guestCheckOuts2 = pgTable3(
      "guest_check_outs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        checkInId: integer3("check_in_id").references(() => guestCheckIns2.id).notNull(),
        // Staff Assignment
        assignedToStaff: varchar2("assigned_to_staff").references(() => users.id).notNull(),
        completedByStaff: varchar2("completed_by_staff").references(() => users.id),
        // Electric Meter Reading (Checkout)
        electricMeterPhoto: varchar2("electric_meter_photo").notNull(),
        electricMeterReading: decimal2("electric_meter_reading", {
          precision: 10,
          scale: 3
        }),
        // Final kWh reading
        meterReadingMethod: varchar2("meter_reading_method").default("manual"),
        // manual, ocr_auto, ocr_manual_override
        // Electricity Usage Calculation
        electricityUsed: decimal2("electricity_used", { precision: 10, scale: 3 }),
        // kWh used (checkout - checkin)
        electricityRatePerKwh: decimal2("electricity_rate_per_kwh", {
          precision: 8,
          scale: 4
        }).default("7.0000"),
        // THB per kWh
        totalElectricityCharge: decimal2("total_electricity_charge", {
          precision: 10,
          scale: 2
        }),
        // Total charge in THB
        // Payment Status
        paymentStatus: varchar2("payment_status").notNull(),
        // included, paid_by_guest, not_charged
        notChargedReason: text3("not_charged_reason"),
        // Reason if not_charged
        paymentMethod: varchar2("payment_method"),
        // cash, digital, deducted_from_deposit
        paymentReceiptPhoto: varchar2("payment_receipt_photo"),
        // Discount and Comments
        discountAmount: decimal2("discount_amount", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        discountReason: text3("discount_reason"),
        // e.g., "Power outage", "Goodwill gesture"
        handlerComments: text3("handler_comments"),
        // Comments from checkout handler
        // Task Completion
        status: varchar2("status").default("pending"),
        // pending, in_progress, completed
        completionNotes: text3("completion_notes"),
        // Timestamps
        scheduledDate: date2("scheduled_date").notNull(),
        startedAt: timestamp3("started_at"),
        completedAt: timestamp3("completed_at"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_checkout_booking").on(table.bookingId),
        index("IDX_checkout_property").on(table.propertyId),
        index("IDX_checkout_checkin").on(table.checkInId),
        index("IDX_checkout_staff").on(table.assignedToStaff),
        index("IDX_checkout_date").on(table.scheduledDate)
      ]
    );
    propertyElectricitySettings2 = pgTable3(
      "property_electricity_settings",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Rate Configuration
        ratePerKwh: decimal2("rate_per_kwh", { precision: 8, scale: 4 }).default(
          "7.0000"
        ),
        // THB per kWh
        currency: varchar2("currency").default("THB"),
        // Billing Rules
        includedInStay: boolean3("included_in_stay").default(false),
        // True if electricity is included
        minimumCharge: decimal2("minimum_charge", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        maximumCharge: decimal2("maximum_charge", { precision: 10, scale: 2 }),
        // Optional cap
        // Settings
        isActive: boolean3("is_active").default(true),
        notes: text3("notes"),
        // Timestamps
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [index("IDX_electricity_property").on(table.propertyId)]
    );
    checkInOutDemoTasks2 = pgTable3(
      "checkin_checkout_demo_tasks",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        // Task Information
        taskType: varchar2("task_type").notNull(),
        // check_in, check_out, pool_cleaning, checkout_cleaning
        title: varchar2("title").notNull(),
        description: text3("description").notNull(),
        department: varchar2("department").notNull(),
        // management, housekeeping, pool, maintenance
        // Assignment
        assignedRole: varchar2("assigned_role").notNull(),
        // staff, manager, host
        assignedToUser: varchar2("assigned_to_user").references(() => users.id),
        // Property and Booking Reference
        propertyId: integer3("property_id").references(() => properties.id),
        bookingId: integer3("booking_id").references(() => bookings.id),
        checkInId: integer3("check_in_id").references(() => guestCheckIns2.id),
        // Status and Priority
        status: varchar2("status").default("pending"),
        // pending, in_progress, completed
        priority: varchar2("priority").default("medium"),
        // low, medium, high, urgent
        // Due Date
        dueDate: timestamp3("due_date").notNull(),
        estimatedDuration: integer3("estimated_duration"),
        // minutes
        // Completion Data
        completedAt: timestamp3("completed_at"),
        completionNotes: text3("completion_notes"),
        evidencePhotos: text3("evidence_photos").array(),
        // Demo Data Flags
        isDemoTask: boolean3("is_demo_task").default(true),
        demoUserType: varchar2("demo_user_type"),
        // pool_staff, housekeeper, host, manager
        // Timestamps
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_demo_tasks_type").on(table.taskType),
        index("IDX_demo_tasks_role").on(table.assignedRole),
        index("IDX_demo_tasks_property").on(table.propertyId),
        index("IDX_demo_tasks_due").on(table.dueDate)
      ]
    );
    guestCheckInsRelations = relations(guestCheckIns2, ({ one }) => ({
      organization: one(organizations, {
        fields: [guestCheckIns2.organizationId],
        references: [organizations.id]
      }),
      booking: one(bookings, {
        fields: [guestCheckIns2.bookingId],
        references: [bookings.id]
      }),
      property: one(properties, {
        fields: [guestCheckIns2.propertyId],
        references: [properties.id]
      }),
      assignedStaff: one(users, {
        fields: [guestCheckIns2.assignedToStaff],
        references: [users.id]
      }),
      completedByUser: one(users, {
        fields: [guestCheckIns2.completedByStaff],
        references: [users.id]
      })
    }));
    guestCheckOutsRelations = relations(guestCheckOuts2, ({ one }) => ({
      organization: one(organizations, {
        fields: [guestCheckOuts2.organizationId],
        references: [organizations.id]
      }),
      booking: one(bookings, {
        fields: [guestCheckOuts2.bookingId],
        references: [bookings.id]
      }),
      property: one(properties, {
        fields: [guestCheckOuts2.propertyId],
        references: [properties.id]
      }),
      checkIn: one(guestCheckIns2, {
        fields: [guestCheckOuts2.checkInId],
        references: [guestCheckIns2.id]
      }),
      assignedStaff: one(users, {
        fields: [guestCheckOuts2.assignedToStaff],
        references: [users.id]
      }),
      completedByUser: one(users, {
        fields: [guestCheckOuts2.completedByStaff],
        references: [users.id]
      })
    }));
    propertyElectricitySettingsRelations = relations(
      propertyElectricitySettings2,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [propertyElectricitySettings2.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [propertyElectricitySettings2.propertyId],
          references: [properties.id]
        })
      })
    );
    checkInOutDemoTasksRelations = relations(
      checkInOutDemoTasks2,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [checkInOutDemoTasks2.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [checkInOutDemoTasks2.propertyId],
          references: [properties.id]
        }),
        booking: one(bookings, {
          fields: [checkInOutDemoTasks2.bookingId],
          references: [bookings.id]
        }),
        checkIn: one(guestCheckIns2, {
          fields: [checkInOutDemoTasks2.checkInId],
          references: [guestCheckIns2.id]
        }),
        assignedUser: one(users, {
          fields: [checkInOutDemoTasks2.assignedToUser],
          references: [users.id]
        })
      })
    );
    insertGuestCheckInSchema = createInsertSchema3(guestCheckIns2).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestCheckOutSchema = createInsertSchema3(
      guestCheckOuts2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyElectricitySettingsSchema = createInsertSchema3(
      propertyElectricitySettings2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertCheckInOutDemoTaskSchema = createInsertSchema3(
      checkInOutDemoTasks2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyMarketingMediaSchema = createInsertSchema3(
      propertyMarketingMedia2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyCommissionRuleSchema = createInsertSchema3(
      propertyCommissionRules2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAgentBookingRequestSchema = createInsertSchema3(
      agentBookingRequests2
    ).omit({
      id: true,
      submittedAt: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestPortalAccessSchema = createInsertSchema3(
      guestPortalAccess
    ).omit({
      id: true,
      createdAt: true
    });
    propertyReferrals = pgTable3("property_referrals", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      referralAgentId: varchar2("referral_agent_id").references(() => users.id).notNull(),
      portfolioManagerId: varchar2("portfolio_manager_id").references(
        () => users.id
      ),
      referralDate: timestamp3("referral_date").defaultNow(),
      commissionRate: decimal2("commission_rate", {
        precision: 5,
        scale: 2
      }).default("10.00"),
      // 10% default
      isActive: boolean3("is_active").default(true),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    referralEarnings = pgTable3("referral_earnings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      referralAgentId: varchar2("referral_agent_id").references(() => users.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      month: integer3("month").notNull(),
      // 1-12
      year: integer3("year").notNull(),
      // Revenue Data
      grossRentalIncome: decimal2("gross_rental_income", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      managementFeeTotal: decimal2("management_fee_total", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      referralCommissionEarned: decimal2("referral_commission_earned", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      // Performance Data
      occupancyRate: decimal2("occupancy_rate", { precision: 5, scale: 2 }).default(
        "0.00"
      ),
      // 0-100%
      averageReviewScore: decimal2("average_review_score", {
        precision: 3,
        scale: 1
      }).default("0.0"),
      // 0-5.0
      totalBookings: integer3("total_bookings").default(0),
      // Status
      status: varchar2("status").default("pending"),
      // pending, calculated, paid
      calculatedAt: timestamp3("calculated_at"),
      paidAt: timestamp3("paid_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    agentPayouts = pgTable3("agent_payouts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      agentId: varchar2("agent_id").references(() => users.id).notNull(),
      agentType: varchar2("agent_type").notNull(),
      // 'retail-agent' or 'referral-agent'
      // Payout Details
      payoutAmount: decimal2("payout_amount", { precision: 10, scale: 2 }).notNull(),
      payoutMethod: varchar2("payout_method").notNull(),
      // 'bank_transfer', 'paypal', 'check'
      agentBankDetails: text3("agent_bank_details"),
      requestNotes: text3("request_notes"),
      // Status Tracking
      payoutStatus: varchar2("payout_status").default("pending"),
      // pending, approved, paid, rejected
      requestedAt: timestamp3("requested_at").defaultNow(),
      approvedAt: timestamp3("approved_at"),
      approvedBy: varchar2("approved_by"),
      paidAt: timestamp3("paid_at"),
      receiptUrl: varchar2("receipt_url"),
      // Admin uploads receipt
      receiptConfirmedAt: timestamp3("receipt_confirmed_at"),
      // Agent confirms receipt
      // Admin Notes
      adminNotes: text3("admin_notes"),
      rejectionReason: text3("rejection_reason"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    referralProgramRules2 = pgTable3("referral_program_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Program Rules
      title: varchar2("title").notNull(),
      description: text3("description"),
      ruleType: varchar2("rule_type").notNull(),
      // 'commission', 'payout', 'qualification'
      ruleContent: text3("rule_content").notNull(),
      // Settings
      isActive: boolean3("is_active").default(true),
      effectiveDate: timestamp3("effective_date").defaultNow(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow(),
      createdBy: varchar2("created_by").references(() => users.id)
    });
    propertyAgents = pgTable3("property_agents", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      agentId: varchar2("agent_id").references(() => users.id).notNull(),
      agentType: varchar2("agent_type").notNull(),
      // 'retail-agent' or 'referral-agent'
      assignedAt: timestamp3("assigned_at").defaultNow(),
      assignedBy: varchar2("assigned_by").references(() => users.id),
      isActive: boolean3("is_active").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    agentBookings = pgTable3("agent_bookings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      retailAgentId: varchar2("retail_agent_id").references(() => users.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email").notNull(),
      guestPhone: varchar2("guest_phone"),
      checkIn: date2("check_in").notNull(),
      checkOut: date2("check_out").notNull(),
      totalAmount: decimal2("total_amount", { precision: 10, scale: 2 }).notNull(),
      // Enhanced Commission System
      commissionType: varchar2("commission_type").default("fixed_percentage"),
      // fixed_percentage, custom_topup
      netPrice: decimal2("net_price", { precision: 10, scale: 2 }),
      // Net cost price from property
      topupAmount: decimal2("topup_amount", { precision: 10, scale: 2 }),
      // Custom amount topped up by agent
      commissionRate: decimal2("commission_rate", {
        precision: 5,
        scale: 2
      }).default("10.00"),
      commissionAmount: decimal2("commission_amount", {
        precision: 10,
        scale: 2
      }).notNull(),
      bookingStatus: varchar2("booking_status").default("confirmed"),
      // confirmed, cancelled, completed
      commissionStatus: varchar2("commission_status").default("pending"),
      // pending, approved, paid
      hostawayBookingId: varchar2("hostaway_booking_id"),
      // Integration with Hostaway
      // Admin Management Fields
      processedBy: varchar2("processed_by").references(() => users.id),
      // Admin who processed commission
      processedAt: timestamp3("processed_at"),
      adjustmentReason: text3("adjustment_reason"),
      // Reason for manual adjustments
      originalAmount: decimal2("original_amount", { precision: 10, scale: 2 }),
      // Original amount before adjustments
      bookingReference: varchar2("booking_reference"),
      // External booking reference
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    commissionLog = pgTable3("commission_log", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      agentId: varchar2("agent_id").references(() => users.id).notNull(),
      agentType: varchar2("agent_type").notNull(),
      // retail-agent, referral-agent
      // Transaction Details
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id),
      referenceNumber: varchar2("reference_number").notNull(),
      // B1245, R1167, etc.
      // Commission Calculation
      baseAmount: decimal2("base_amount", { precision: 10, scale: 2 }).notNull(),
      // Original booking/rental amount
      commissionRate: decimal2("commission_rate", {
        precision: 5,
        scale: 2
      }).notNull(),
      commissionAmount: decimal2("commission_amount", {
        precision: 10,
        scale: 2
      }).notNull(),
      currency: varchar2("currency", { length: 3 }).default("THB"),
      // Status and Processing
      status: varchar2("status").default("pending"),
      // pending, approved, paid, cancelled
      processedBy: varchar2("processed_by").references(() => users.id),
      // Admin who processed
      processedAt: timestamp3("processed_at"),
      payoutId: integer3("payout_id"),
      // Reference to agent_payouts when paid
      // Adjustments and Notes
      isAdjustment: boolean3("is_adjustment").default(false),
      adjustmentReason: text3("adjustment_reason"),
      originalCommissionId: integer3("original_commission_id"),
      // Reference to original commission if adjustment
      adminNotes: text3("admin_notes"),
      // Period tracking (for referral agents)
      commissionMonth: integer3("commission_month"),
      // 1-12 for monthly referral tracking
      commissionYear: integer3("commission_year"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    commissionInvoices = pgTable3("commission_invoices", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      agentId: varchar2("agent_id").references(() => users.id).notNull(),
      agentType: varchar2("agent_type").notNull(),
      // retail-agent, referral-agent
      // Invoice Details
      invoiceNumber: varchar2("invoice_number").notNull().unique(),
      invoiceDate: date2("invoice_date").notNull(),
      dueDate: date2("due_date"),
      // Commission Period
      periodStart: date2("period_start").notNull(),
      periodEnd: date2("period_end").notNull(),
      // Financial Summary
      totalCommissions: decimal2("total_commissions", {
        precision: 10,
        scale: 2
      }).notNull(),
      currency: varchar2("currency", { length: 3 }).default("THB"),
      // Status Management
      status: varchar2("status").default("draft"),
      // draft, submitted, approved, paid, rejected
      submittedAt: timestamp3("submitted_at"),
      approvedBy: varchar2("approved_by").references(() => users.id),
      approvedAt: timestamp3("approved_at"),
      rejectedReason: text3("rejected_reason"),
      // Invoice Content
      description: text3("description"),
      agentNotes: text3("agent_notes"),
      adminNotes: text3("admin_notes"),
      // File Management
      invoiceFileUrl: varchar2("invoice_file_url"),
      // PDF file path
      generatedBy: varchar2("generated_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    commissionInvoiceItems = pgTable3("commission_invoice_items", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      invoiceId: integer3("invoice_id").references(() => commissionInvoices.id).notNull(),
      commissionLogId: integer3("commission_log_id").references(() => commissionLog.id).notNull(),
      // Line Item Details
      description: text3("description").notNull(),
      propertyName: varchar2("property_name").notNull(),
      referenceNumber: varchar2("reference_number").notNull(),
      commissionDate: date2("commission_date").notNull(),
      commissionAmount: decimal2("commission_amount", {
        precision: 10,
        scale: 2
      }).notNull(),
      createdAt: timestamp3("created_at").defaultNow()
    });
    guestFeedback = pgTable3("guest_feedback", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id),
      propertyId: integer3("property_id").references(() => properties.id),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email"),
      feedbackType: varchar2("feedback_type").notNull(),
      // review, message, complaint, compliment
      feedbackChannel: varchar2("feedback_channel").default("portal"),
      // portal, email, phone, sms
      originalMessage: text3("original_message").notNull(),
      detectedKeywords: jsonb3("detected_keywords"),
      // Array of matched keywords
      sentimentScore: decimal2("sentiment_score", { precision: 3, scale: 2 }),
      // -1.0 to 1.0 (future AI)
      urgencyLevel: varchar2("urgency_level").default("medium"),
      // low, medium, high, critical
      isProcessed: boolean3("is_processed").default(false),
      requiresAction: boolean3("requires_action").default(false),
      assignedTaskId: integer3("assigned_task_id").references(() => tasks.id),
      processedBy: varchar2("processed_by").references(() => users.id),
      processingNotes: text3("processing_notes"),
      receivedAt: timestamp3("received_at").defaultNow(),
      processedAt: timestamp3("processed_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    aiTaskRules = pgTable3("ai_task_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ruleName: varchar2("rule_name").notNull(),
      keywords: jsonb3("keywords").notNull(),
      // Array of trigger keywords
      taskType: varchar2("task_type").notNull(),
      taskTitle: varchar2("task_title").notNull(),
      // Template for task title
      taskDescription: text3("task_description"),
      // Template for task description
      assignToDepartment: varchar2("assign_to_department"),
      // cleaning, maintenance, front_desk
      defaultAssignee: varchar2("default_assignee").references(() => users.id),
      priority: varchar2("priority").default("medium"),
      // high, medium, low
      autoAssign: boolean3("auto_assign").default(true),
      isActive: boolean3("is_active").default(true),
      triggerCount: integer3("trigger_count").default(0),
      // How many times this rule has triggered
      lastTriggered: timestamp3("last_triggered"),
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    feedbackProcessingLog = pgTable3("feedback_processing_log", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      feedbackId: integer3("feedback_id").references(() => guestFeedback.id).notNull(),
      processingType: varchar2("processing_type").notNull(),
      // auto, manual, ai_nlp
      triggeredRuleId: integer3("triggered_rule_id").references(
        () => aiTaskRules.id
      ),
      matchedKeywords: jsonb3("matched_keywords"),
      // Which keywords triggered the rule
      confidenceScore: decimal2("confidence_score", { precision: 3, scale: 2 }),
      // AI confidence
      actionTaken: varchar2("action_taken").notNull(),
      // task_created, escalated, ignored
      createdTaskId: integer3("created_task_id").references(() => tasks.id),
      processedBy: varchar2("processed_by").references(() => users.id),
      aiModel: varchar2("ai_model"),
      // gpt-4, claude, etc. (future)
      processingTime: integer3("processing_time"),
      // milliseconds
      errorMessage: text3("error_message"),
      // If processing failed
      createdAt: timestamp3("created_at").defaultNow()
    });
    aiConfiguration = pgTable3("ai_configuration", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      autoProcessingEnabled: boolean3("auto_processing_enabled").default(true),
      aiProvider: varchar2("ai_provider").default("keyword"),
      // keyword, openai, claude, etc.
      confidenceThreshold: decimal2("confidence_threshold", {
        precision: 3,
        scale: 2
      }).default("0.75"),
      autoTaskCreation: boolean3("auto_task_creation").default(true),
      requireManagerApproval: boolean3("require_manager_approval").default(false),
      notificationSettings: jsonb3("notification_settings"),
      // Who gets notified when
      processingCooldown: integer3("processing_cooldown").default(300),
      // seconds between processing same type
      debugMode: boolean3("debug_mode").default(false),
      lastUpdatedBy: varchar2("last_updated_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    recurringServices = pgTable3("recurring_services", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      serviceName: varchar2("service_name").notNull(),
      serviceCategory: varchar2("service_category").notNull(),
      // cleaning, maintenance, security, landscaping, pool, management
      providerName: varchar2("provider_name").notNull(),
      providerContact: varchar2("provider_contact"),
      providerEmail: varchar2("provider_email"),
      billingFrequency: varchar2("billing_frequency").notNull(),
      // monthly, quarterly, bi-annual, annual
      billingAmount: decimal2("billing_amount", {
        precision: 10,
        scale: 2
      }).notNull(),
      nextBillingDate: timestamp3("next_billing_date").notNull(),
      lastBillingDate: timestamp3("last_billing_date"),
      autoPayEnabled: boolean3("auto_pay_enabled").default(false),
      paymentMethod: varchar2("payment_method"),
      // card, bank_transfer, check, cash
      billingRoute: varchar2("billing_route").notNull().default("company_expense"),
      // company_expense, owner_charge
      assignedPropertyOwner: varchar2("assigned_property_owner").references(
        () => users.id
      ),
      contractStartDate: timestamp3("contract_start_date"),
      contractEndDate: timestamp3("contract_end_date"),
      contractDocument: varchar2("contract_document"),
      // URL to contract file
      isActive: boolean3("is_active").default(true),
      notes: text3("notes"),
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    recurringServiceBills = pgTable3("recurring_service_bills", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      serviceId: integer3("service_id").references(() => recurringServices.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      billNumber: varchar2("bill_number"),
      billDate: timestamp3("bill_date").notNull(),
      dueDate: timestamp3("due_date").notNull(),
      billAmount: decimal2("bill_amount", { precision: 10, scale: 2 }).notNull(),
      paidAmount: decimal2("paid_amount", { precision: 10, scale: 2 }).default("0"),
      status: varchar2("status").notNull().default("pending"),
      // pending, paid, overdue, disputed, cancelled
      paymentDate: timestamp3("payment_date"),
      paymentMethod: varchar2("payment_method"),
      paymentReference: varchar2("payment_reference"),
      billDocument: varchar2("bill_document"),
      // URL to bill/invoice file
      receiptDocument: varchar2("receipt_document"),
      // URL to payment receipt
      billingRoute: varchar2("billing_route").notNull(),
      // company_expense, owner_charge
      chargedToOwner: varchar2("charged_to_owner").references(() => users.id),
      processedBy: varchar2("processed_by").references(() => users.id),
      isDisputed: boolean3("is_disputed").default(false),
      disputeReason: text3("dispute_reason"),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    billReminders = pgTable3("bill_reminders", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      billId: integer3("bill_id").references(() => recurringServiceBills.id),
      serviceId: integer3("service_id").references(() => recurringServices.id),
      reminderType: varchar2("reminder_type").notNull(),
      // upcoming_bill, overdue_payment, contract_renewal
      reminderDate: timestamp3("reminder_date").notNull(),
      daysBeforeDue: integer3("days_before_due"),
      // For upcoming bills
      daysOverdue: integer3("days_overdue"),
      // For overdue payments
      recipientUser: varchar2("recipient_user").references(() => users.id),
      recipientEmail: varchar2("recipient_email"),
      status: varchar2("status").default("pending"),
      // pending, sent, acknowledged
      sentAt: timestamp3("sent_at"),
      acknowledgedAt: timestamp3("acknowledged_at"),
      emailSubject: varchar2("email_subject"),
      emailBody: text3("email_body"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    servicePerformance = pgTable3("service_performance", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      serviceId: integer3("service_id").references(() => recurringServices.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      performanceMonth: varchar2("performance_month").notNull(),
      // YYYY-MM
      qualityRating: integer3("quality_rating"),
      // 1-5 stars
      timelinessRating: integer3("timeliness_rating"),
      // 1-5 stars
      costEffectiveness: integer3("cost_effectiveness"),
      // 1-5 stars
      issuesReported: integer3("issues_reported").default(0),
      maintenanceTasksGenerated: integer3("maintenance_tasks_generated").default(0),
      customerSatisfaction: integer3("customer_satisfaction"),
      // 1-5 stars from guests
      serviceNotes: text3("service_notes"),
      improvementSuggestions: text3("improvement_suggestions"),
      reviewedBy: varchar2("reviewed_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow()
    });
    propertyMedia = pgTable3("property_media", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id, {
        onDelete: "cascade"
      }),
      mediaType: varchar2("media_type").notNull(),
      // 'photo', 'video', 'document'
      title: varchar2("title").notNull(),
      description: text3("description"),
      mediaUrl: text3("media_url").notNull(),
      // URL or file path
      thumbnailUrl: text3("thumbnail_url"),
      // For videos and documents
      fileSize: integer3("file_size"),
      // File size in bytes
      mimeType: varchar2("mime_type"),
      // MIME type of the file
      isAgentApproved: boolean3("is_agent_approved").default(false),
      uploadedBy: varchar2("uploaded_by").references(() => users.id).notNull(),
      approvedBy: varchar2("approved_by").references(() => users.id),
      approvedAt: timestamp3("approved_at"),
      displayOrder: integer3("display_order").default(0),
      tags: text3("tags").array(),
      // Searchable tags
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyInternalNotes = pgTable3("property_internal_notes", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id, {
        onDelete: "cascade"
      }),
      category: varchar2("category").notNull(),
      // 'commission', 'restrictions', 'booking_instructions', 'other'
      title: varchar2("title").notNull(),
      content: text3("content").notNull(),
      isVisibleToAgents: boolean3("is_visible_to_agents").default(true),
      priority: varchar2("priority").default("medium"),
      // 'high', 'medium', 'low'
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      updatedBy: varchar2("updated_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    insertRecurringServiceSchema = createInsertSchema3(recurringServices);
    insertRecurringServiceBillSchema = createInsertSchema3(
      recurringServiceBills
    );
    insertBillReminderSchema = createInsertSchema3(billReminders);
    insertServicePerformanceSchema = createInsertSchema3(servicePerformance);
    insertPropertyMediaSchema = createInsertSchema3(propertyMedia).omit(
      {
        id: true,
        createdAt: true,
        updatedAt: true
      }
    );
    insertPropertyInternalNotesSchema = createInsertSchema3(
      propertyInternalNotes
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestFeedbackSchema = createInsertSchema3(guestFeedback);
    insertAiTaskRuleSchema = createInsertSchema3(aiTaskRules);
    insertFeedbackProcessingLogSchema = createInsertSchema3(
      feedbackProcessingLog
    );
    insertAiConfigurationSchema = createInsertSchema3(aiConfiguration);
    addonServiceCatalog = pgTable3("addon_service_catalog", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      serviceName: varchar2("service_name").notNull(),
      category: varchar2("category").notNull(),
      // tours, chef, transport, massage, rental, grocery, baby, photography, airport, events
      description: text3("description"),
      basePrice: decimal2("base_price", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").default("THB"),
      duration: integer3("duration"),
      // in minutes
      imageUrl: varchar2("image_url"),
      thumbnailUrl: varchar2("thumbnail_url"),
      isActive: boolean3("is_active").default(true),
      isAvailableOnline: boolean3("is_available_online").default(true),
      maxGuests: integer3("max_guests").default(10),
      advanceBookingHours: integer3("advance_booking_hours").default(24),
      // min hours before service
      cancellationPolicy: text3("cancellation_policy"),
      specialRequirements: text3("special_requirements"),
      providerName: varchar2("provider_name"),
      // external service provider
      providerContact: varchar2("provider_contact"),
      commissionRate: decimal2("commission_rate", {
        precision: 5,
        scale: 2
      }).default("0.00"),
      // % for internal tracking
      tags: text3("tags").array(),
      displayOrder: integer3("display_order").default(0),
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    addonServiceBookings = pgTable3("addon_service_bookings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      serviceId: integer3("service_id").references(() => addonServiceCatalog.id, { onDelete: "cascade" }).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email"),
      guestPhone: varchar2("guest_phone"),
      guestCount: integer3("guest_count").default(1),
      serviceDate: date2("service_date").notNull(),
      serviceTime: varchar2("service_time"),
      // HH:MM format
      totalAmount: decimal2("total_amount", { precision: 10, scale: 2 }).notNull(),
      // Billing Flexibility
      billingRule: varchar2("billing_rule").notNull(),
      // guest_charged, owner_charged, company_expense, complimentary
      billingType: varchar2("billing_type").notNull(),
      // charged, owner_gift, company_gift, complimentary
      paymentStatus: varchar2("payment_status").default("pending"),
      // pending, paid, cancelled, refunded
      paymentMethod: varchar2("payment_method"),
      // cash, card, online, bank_transfer
      status: varchar2("status").default("pending"),
      // pending, confirmed, in_progress, completed, cancelled
      specialRequests: text3("special_requests"),
      internalNotes: text3("internal_notes"),
      cancellationReason: text3("cancellation_reason"),
      // Financial Tracking
      commissionAmount: decimal2("commission_amount", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      commissionPaidToStaff: boolean3("commission_paid_to_staff").default(false),
      receiptUrl: varchar2("receipt_url"),
      // Upload receipt/proof
      referenceNumber: varchar2("reference_number"),
      // Booking Metadata
      bookedBy: varchar2("booked_by").references(() => users.id),
      // staff who made booking
      confirmedBy: varchar2("confirmed_by").references(() => users.id),
      confirmedAt: timestamp3("confirmed_at"),
      completedAt: timestamp3("completed_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    addonServiceCategories = pgTable3("addon_service_categories", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      categoryName: varchar2("category_name").notNull(),
      categoryIcon: varchar2("category_icon"),
      categoryColor: varchar2("category_color"),
      defaultBillingRule: varchar2("default_billing_rule").default("guest_charged"),
      defaultCommissionRate: decimal2("default_commission_rate", {
        precision: 5,
        scale: 2
      }).default("0.00"),
      isActive: boolean3("is_active").default(true),
      displayOrder: integer3("display_order").default(0),
      description: text3("description"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    addonServiceCommissions = pgTable3("addon_service_commissions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      bookingId: integer3("booking_id").references(() => addonServiceBookings.id, { onDelete: "cascade" }).notNull(),
      serviceId: integer3("service_id").references(() => addonServiceCatalog.id).notNull(),
      category: varchar2("category").notNull(),
      staffId: varchar2("staff_id").references(() => users.id),
      commissionAmount: decimal2("commission_amount", {
        precision: 10,
        scale: 2
      }).notNull(),
      commissionRate: decimal2("commission_rate", {
        precision: 5,
        scale: 2
      }).notNull(),
      paymentStatus: varchar2("payment_status").default("pending"),
      // pending, paid, cancelled
      paymentDate: timestamp3("payment_date"),
      paymentMethod: varchar2("payment_method"),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    addonServiceReports = pgTable3("addon_service_reports", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      reportMonth: varchar2("report_month").notNull(),
      // YYYY-MM format
      category: varchar2("category").notNull(),
      totalBookings: integer3("total_bookings").default(0),
      totalRevenue: decimal2("total_revenue", { precision: 10, scale: 2 }).default(
        "0.00"
      ),
      totalCommissions: decimal2("total_commissions", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      guestChargedRevenue: decimal2("guest_charged_revenue", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      ownerChargedRevenue: decimal2("owner_charged_revenue", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      companyExpenseAmount: decimal2("company_expense_amount", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      complimentaryAmount: decimal2("complimentary_amount", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      averageBookingValue: decimal2("average_booking_value", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      topService: varchar2("top_service"),
      reportGeneratedAt: timestamp3("report_generated_at").defaultNow(),
      createdAt: timestamp3("created_at").defaultNow()
    });
    addonServiceAvailability = pgTable3("addon_service_availability", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      serviceId: integer3("service_id").references(() => addonServiceCatalog.id, { onDelete: "cascade" }).notNull(),
      availableDate: date2("available_date").notNull(),
      timeSlots: jsonb3("time_slots"),
      // Array of available time slots
      maxCapacity: integer3("max_capacity").default(1),
      currentBookings: integer3("current_bookings").default(0),
      isBlocked: boolean3("is_blocked").default(false),
      blockReason: text3("block_reason"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    addonBillingRules = pgTable3("addon_billing_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ruleName: varchar2("rule_name").notNull(),
      category: varchar2("category"),
      // applies to specific category or null for all
      billingRule: varchar2("billing_rule").notNull(),
      // guest_charged, owner_charged, company_expense, complimentary
      billingType: varchar2("billing_type").notNull(),
      // charged, owner_gift, company_gift, complimentary
      autoApply: boolean3("auto_apply").default(false),
      conditions: jsonb3("conditions"),
      // Conditions for auto-application
      isActive: boolean3("is_active").default(true),
      priority: integer3("priority").default(0),
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow()
    });
    guestLoyaltyProfiles2 = pgTable3("guest_loyalty_profiles", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      guestEmail: varchar2("guest_email").notNull(),
      guestName: varchar2("guest_name").notNull(),
      guestPhone: varchar2("guest_phone"),
      totalStays: integer3("total_stays").default(0),
      firstStayDate: timestamp3("first_stay_date"),
      lastStayDate: timestamp3("last_stay_date"),
      loyaltyTier: varchar2("loyalty_tier").default("new"),
      // new, silver, gold, platinum
      totalSpent: decimal2("total_spent", { precision: 10, scale: 2 }).default(
        "0.00"
      ),
      averageStayDuration: integer3("average_stay_duration"),
      // in days
      preferredProperties: text3("preferred_properties").array(),
      specialPreferences: text3("special_preferences"),
      // dietary, accessibility, etc
      communicationPreferences: jsonb3("communication_preferences"),
      // email, sms, preferences
      loyaltyPoints: integer3("loyalty_points").default(0),
      isVip: boolean3("is_vip").default(false),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    loyaltyTiers2 = pgTable3("loyalty_tiers", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      tierName: varchar2("tier_name").notNull(),
      // Silver, Gold, Platinum
      minStays: integer3("min_stays").notNull(),
      tierColor: varchar2("tier_color").default("#6B7280"),
      // hex color for badges
      benefits: text3("benefits").array(),
      // array of benefit descriptions
      perks: jsonb3("perks"),
      // structured perks data
      isActive: boolean3("is_active").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestMessages2 = pgTable3("guest_messages", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      threadId: varchar2("thread_id").notNull(),
      // unique thread identifier
      guestLoyaltyId: integer3("guest_loyalty_id").references(
        () => guestLoyaltyProfiles2.id
      ),
      bookingId: integer3("booking_id").references(() => bookings.id),
      propertyId: integer3("property_id").references(() => properties.id),
      senderId: varchar2("sender_id"),
      // user id or 'guest' or 'system'
      senderType: varchar2("sender_type").notNull(),
      // guest, staff, admin, system
      senderName: varchar2("sender_name").notNull(),
      messageContent: text3("message_content").notNull(),
      messageType: varchar2("message_type").default("text"),
      // text, image, file, automated
      attachments: text3("attachments").array(),
      // file URLs
      isAutomated: boolean3("is_automated").default(false),
      urgencyLevel: varchar2("urgency_level").default("normal"),
      // low, normal, high, urgent
      isRead: boolean3("is_read").default(false),
      readAt: timestamp3("read_at"),
      readBy: varchar2("read_by").references(() => users.id),
      relatedTaskId: integer3("related_task_id").references(() => tasks.id),
      aiAnalysis: jsonb3("ai_analysis"),
      // AI sentiment, topic classification, etc
      createdAt: timestamp3("created_at").defaultNow()
    });
    messagingTriggers2 = pgTable3("messaging_triggers", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      triggerName: varchar2("trigger_name").notNull(),
      triggerType: varchar2("trigger_type").notNull(),
      // check_in, check_out, post_stay, follow_up
      triggerCondition: varchar2("trigger_condition").notNull(),
      // after_check_in, before_check_out, 3_months_later
      delayMinutes: integer3("delay_minutes").default(0),
      // delay before sending
      messageTemplate: text3("message_template").notNull(),
      isActive: boolean3("is_active").default(true),
      loyaltyTierTargets: text3("loyalty_tier_targets").array(),
      // which tiers to target
      propertyTargets: text3("property_targets").array(),
      // which properties
      lastTriggered: timestamp3("last_triggered"),
      triggerCount: integer3("trigger_count").default(0),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    smartReplySuggestions2 = pgTable3("smart_reply_suggestions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      category: varchar2("category").notNull(),
      // greeting, confirmation, apology, upsell, etc
      trigger: varchar2("trigger"),
      // keywords that trigger this suggestion
      messageTemplate: text3("message_template").notNull(),
      useCount: integer3("use_count").default(0),
      lastUsed: timestamp3("last_used"),
      isActive: boolean3("is_active").default(true),
      userRole: varchar2("user_role"),
      // staff, admin, all
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow()
    });
    aiMessageAnalysis2 = pgTable3("ai_message_analysis", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      messageId: integer3("message_id").references(() => guestMessages2.id),
      bookingId: integer3("booking_id").references(() => bookings.id),
      analysisType: varchar2("analysis_type").notNull(),
      // sentiment, issue_detection, task_generation
      sentiment: varchar2("sentiment"),
      // positive, neutral, negative
      detectedIssues: text3("detected_issues").array(),
      // hot_water, pool_dirty, breakfast_quality
      suggestedActions: text3("suggested_actions").array(),
      confidenceScore: decimal2("confidence_score", { precision: 3, scale: 2 }),
      taskGenerated: boolean3("task_generated").default(false),
      generatedTaskId: integer3("generated_task_id").references(() => tasks.id),
      reviewedBy: varchar2("reviewed_by").references(() => users.id),
      reviewedAt: timestamp3("reviewed_at"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    messageDeliveries2 = pgTable3("message_deliveries", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      messageId: integer3("message_id").references(() => guestMessages2.id),
      deliveryMethod: varchar2("delivery_method").notNull(),
      // email, sms, whatsapp, in_app
      recipientEmail: varchar2("recipient_email"),
      recipientPhone: varchar2("recipient_phone"),
      deliveryStatus: varchar2("delivery_status").default("pending"),
      // pending, sent, delivered, failed
      deliveredAt: timestamp3("delivered_at"),
      failureReason: text3("failure_reason"),
      retryCount: integer3("retry_count").default(0),
      lastRetryAt: timestamp3("last_retry_at"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    ownerActivityTimeline = pgTable3("owner_activity_timeline", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      activityType: varchar2("activity_type").notNull(),
      // check_in, check_out, task_completed, guest_feedback, addon_booking, bill_uploaded
      title: varchar2("title").notNull(),
      description: text3("description"),
      metadata: jsonb3("metadata"),
      // Additional data specific to activity type
      referenceId: integer3("reference_id"),
      // ID of related record (booking, task, etc)
      referenceType: varchar2("reference_type"),
      // booking, task, guest_addon_booking, etc
      createdAt: timestamp3("created_at").defaultNow(),
      createdBy: varchar2("created_by").references(() => users.id)
    });
    ownerInvoices = pgTable3("owner_invoices", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      invoiceNumber: varchar2("invoice_number").notNull().unique(),
      invoiceType: varchar2("invoice_type").notNull(),
      // monthly_summary, utility_cost, service_charge, management_fee
      title: varchar2("title").notNull(),
      description: text3("description"),
      amount: decimal2("amount", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").default("AUD"),
      periodStart: date2("period_start"),
      periodEnd: date2("period_end"),
      dueDate: date2("due_date"),
      status: varchar2("status").default("pending"),
      // pending, paid, overdue, cancelled
      pdfUrl: varchar2("pdf_url"),
      metadata: jsonb3("metadata"),
      // Breakdown details
      createdAt: timestamp3("created_at").defaultNow(),
      createdBy: varchar2("created_by").references(() => users.id),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    ownerPreferences = pgTable3("owner_preferences", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      taskApprovalRequired: boolean3("task_approval_required").default(false),
      maintenanceAlerts: boolean3("maintenance_alerts").default(true),
      guestAddonNotifications: boolean3("guest_addon_notifications").default(true),
      financialNotifications: boolean3("financial_notifications").default(true),
      weeklyReports: boolean3("weekly_reports").default(true),
      preferredCurrency: varchar2("preferred_currency").default("AUD"),
      notificationEmail: varchar2("notification_email"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    ownerSettings = pgTable3("owner_settings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      taskApprovalRequired: boolean3("task_approval_required").default(false),
      maintenanceAlerts: boolean3("maintenance_alerts").default(true),
      guestAddonNotifications: boolean3("guest_addon_notifications").default(true),
      financialNotifications: boolean3("financial_notifications").default(true),
      weeklyReports: boolean3("weekly_reports").default(true),
      preferredCurrency: varchar2("preferred_currency").default("AUD"),
      notificationEmail: varchar2("notification_email"),
      transparencyMode: varchar2("transparency_mode").default("summary"),
      // summary, detailed, full
      customBranding: jsonb3("custom_branding").$type(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    insertOwnerActivityTimelineSchema = createInsertSchema3(
      ownerActivityTimeline
    ).omit({
      id: true,
      createdAt: true
    });
    insertOwnerInvoiceSchema = createInsertSchema3(ownerInvoices).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOwnerPreferencesSchema = createInsertSchema3(
      ownerPreferences
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOwnerSettingsSchema = createInsertSchema3(ownerSettings).omit(
      {
        id: true,
        createdAt: true,
        updatedAt: true
      }
    );
    ownerBalanceTracker2 = pgTable3("owner_balance_tracker", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      currentBalance: decimal2("current_balance", {
        precision: 12,
        scale: 2
      }).default("0.00"),
      pendingEarnings: decimal2("pending_earnings", {
        precision: 12,
        scale: 2
      }).default("0.00"),
      thisMonthEarnings: decimal2("this_month_earnings", {
        precision: 12,
        scale: 2
      }).default("0.00"),
      thisMonthExpenses: decimal2("this_month_expenses", {
        precision: 12,
        scale: 2
      }).default("0.00"),
      lastPayoutAmount: decimal2("last_payout_amount", { precision: 12, scale: 2 }),
      lastPayoutDate: timestamp3("last_payout_date"),
      totalLifetimeEarnings: decimal2("total_lifetime_earnings", {
        precision: 12,
        scale: 2
      }).default("0.00"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    payoutRoutingRules2 = pgTable3("payout_routing_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      platform: varchar2("platform").notNull(),
      // airbnb, vrbo, booking_com, direct, stripe
      ownerPercentage: decimal2("owner_percentage", {
        precision: 5,
        scale: 2
      }).notNull(),
      managementPercentage: decimal2("management_percentage", {
        precision: 5,
        scale: 2
      }).notNull(),
      platformFeePercentage: decimal2("platform_fee_percentage", {
        precision: 5,
        scale: 2
      }).default("0.00"),
      routingType: varchar2("routing_type").notNull(),
      // split_payout, management_only, owner_direct
      isActive: boolean3("is_active").default(true),
      notes: text3("notes"),
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    utilityBillProcessing2 = pgTable3("utility_bill_processing", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      utilityBillId: integer3("utility_bill_id").references(() => utilityBills.id).notNull(),
      processedBy: varchar2("processed_by").references(() => users.id),
      processingStatus: varchar2("processing_status").default("pending"),
      // pending, processed, error
      routingDecision: varchar2("routing_decision"),
      // owner_charge, company_expense
      processingNotes: text3("processing_notes"),
      processedAt: timestamp3("processed_at"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    enhancedFinanceTransactionLogs2 = pgTable3(
      "enhanced_finance_transaction_logs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        transactionType: varchar2("transaction_type").notNull(),
        // owner_balance_update, payout_routing, utility_charge
        relatedTableId: integer3("related_table_id").notNull(),
        relatedTableName: varchar2("related_table_name").notNull(),
        amount: decimal2("amount", { precision: 12, scale: 2 }).notNull(),
        currency: varchar2("currency").default("AUD"),
        description: text3("description").notNull(),
        processedBy: varchar2("processed_by").references(() => users.id).notNull(),
        processingNotes: text3("processing_notes"),
        transactionDate: timestamp3("transaction_date").defaultNow(),
        createdAt: timestamp3("created_at").defaultNow()
      }
    );
    ownerBalanceTrackerRelations = relations(
      ownerBalanceTracker2,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [ownerBalanceTracker2.organizationId],
          references: [organizations.id]
        }),
        owner: one(users, {
          fields: [ownerBalanceTracker2.ownerId],
          references: [users.id]
        }),
        property: one(properties, {
          fields: [ownerBalanceTracker2.propertyId],
          references: [properties.id]
        })
      })
    );
    payoutRoutingRulesRelations = relations(
      payoutRoutingRules2,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [payoutRoutingRules2.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [payoutRoutingRules2.propertyId],
          references: [properties.id]
        }),
        createdByUser: one(users, {
          fields: [payoutRoutingRules2.createdBy],
          references: [users.id]
        })
      })
    );
    utilityBillProcessingRelations = relations(
      utilityBillProcessing2,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [utilityBillProcessing2.organizationId],
          references: [organizations.id]
        }),
        utilityBill: one(utilityBills, {
          fields: [utilityBillProcessing2.utilityBillId],
          references: [utilityBills.id]
        }),
        processedByUser: one(users, {
          fields: [utilityBillProcessing2.processedBy],
          references: [users.id]
        })
      })
    );
    enhancedFinanceTransactionLogsRelations = relations(
      enhancedFinanceTransactionLogs2,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [enhancedFinanceTransactionLogs2.organizationId],
          references: [organizations.id]
        }),
        processedByUser: one(users, {
          fields: [enhancedFinanceTransactionLogs2.processedBy],
          references: [users.id]
        })
      })
    );
    insertPayoutRoutingRuleSchema = createInsertSchema3(
      payoutRoutingRules2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUtilityBillProcessingSchema = createInsertSchema3(
      utilityBillProcessing2
    ).omit({
      id: true,
      createdAt: true
    });
    insertEnhancedFinanceTransactionLogSchema = createInsertSchema3(
      enhancedFinanceTransactionLogs2
    ).omit({
      id: true,
      transactionDate: true,
      createdAt: true
    });
    taskSchedule = pgTable3("task_schedule", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      taskId: integer3("task_id").references(() => tasks.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      scheduledDate: date2("scheduled_date").notNull(),
      scheduledStartTime: varchar2("scheduled_start_time"),
      // HH:MM format
      scheduledEndTime: varchar2("scheduled_end_time"),
      // HH:MM format
      timeBlockDuration: integer3("time_block_duration").default(60),
      // minutes
      assignedStaffId: varchar2("assigned_staff_id").references(() => users.id),
      autoAssigned: boolean3("auto_assigned").default(false),
      // true if system auto-assigned
      scheduleType: varchar2("schedule_type").notNull(),
      // auto-generated, recurring, manual, ai-suggested
      priority: varchar2("priority").default("medium"),
      // low, medium, high, urgent
      status: varchar2("status").default("scheduled"),
      // scheduled, in-progress, completed, missed, rescheduled
      actualStartTime: timestamp3("actual_start_time"),
      actualEndTime: timestamp3("actual_end_time"),
      rescheduleReason: text3("reschedule_reason"),
      scheduledBy: varchar2("scheduled_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    taskAutoGenRules = pgTable3("task_auto_gen_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ruleName: varchar2("rule_name").notNull(),
      ruleType: varchar2("rule_type").notNull(),
      // checkout-clean, recurring-service, maintenance-followup
      triggerEvent: varchar2("trigger_event").notNull(),
      // guest-checkout, booking-start, schedule-time, condition-met
      department: varchar2("department").notNull(),
      // cleaning, pool, garden, maintenance, general
      taskType: varchar2("task_type").notNull(),
      taskTitle: varchar2("task_title").notNull(),
      taskDescription: text3("task_description"),
      estimatedDuration: integer3("estimated_duration").default(60),
      // minutes
      defaultPriority: varchar2("default_priority").default("medium"),
      autoAssign: boolean3("auto_assign").default(true),
      preferredStaffRole: varchar2("preferred_staff_role"),
      // staff, maintenance, cleaning
      billingRule: varchar2("billing_rule").notNull(),
      // owner-billable, guest-billable, company-expense, complimentary
      billingAmount: decimal2("billing_amount", { precision: 10, scale: 2 }),
      isActive: boolean3("is_active").default(true),
      conditions: jsonb3("conditions"),
      // Additional trigger conditions (occupancy, booking duration, etc.)
      recurringPattern: jsonb3("recurring_pattern"),
      // For recurring tasks (daily, weekly, monthly)
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyTaskBilling = pgTable3("property_task_billing", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      taskType: varchar2("task_type").notNull(),
      // checkout-clean, pool-service, garden-service, pest-control
      department: varchar2("department").notNull(),
      billingRate: decimal2("billing_rate", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").default("AUD"),
      billingCycle: varchar2("billing_cycle").default("per-occurrence"),
      // per-occurrence, monthly, weekly
      chargeToParty: varchar2("charge_to_party").notNull(),
      // owner, guest, company
      isActive: boolean3("is_active").default(true),
      effectiveFrom: date2("effective_from").notNull(),
      effectiveTo: date2("effective_to"),
      notes: text3("notes"),
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    aiTaskEngine = pgTable3("ai_task_engine", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      triggerSource: varchar2("trigger_source").notNull(),
      // guest-review, guest-message, booking-conditions, maintenance-alert
      sourceId: integer3("source_id"),
      // feedback_id, message_id, booking_id
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      aiAnalysis: text3("ai_analysis").notNull(),
      // AI's analysis of the trigger
      suggestedTaskType: varchar2("suggested_task_type").notNull(),
      suggestedDepartment: varchar2("suggested_department").notNull(),
      suggestedPriority: varchar2("suggested_priority").default("medium"),
      suggestedTitle: varchar2("suggested_title").notNull(),
      suggestedDescription: text3("suggested_description"),
      confidence: decimal2("confidence", { precision: 5, scale: 2 }).notNull(),
      // AI confidence score 0-100
      keywords: text3("keywords").array(),
      // Keywords that triggered the suggestion
      status: varchar2("status").default("pending"),
      // pending, approved, rejected, auto-created
      createdTaskId: integer3("created_task_id").references(() => tasks.id),
      reviewedBy: varchar2("reviewed_by").references(() => users.id),
      reviewedAt: timestamp3("reviewed_at"),
      rejectionReason: text3("rejection_reason"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    taskDepartmentStats = pgTable3("task_department_stats", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      department: varchar2("department").notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      reportMonth: varchar2("report_month").notNull(),
      // YYYY-MM format
      totalTasks: integer3("total_tasks").default(0),
      completedTasks: integer3("completed_tasks").default(0),
      overdueTasks: integer3("overdue_tasks").default(0),
      avgCompletionTime: decimal2("avg_completion_time", { precision: 8, scale: 2 }),
      // hours
      totalCosts: decimal2("total_costs", { precision: 12, scale: 2 }).default("0"),
      ownerBillable: decimal2("owner_billable", { precision: 12, scale: 2 }).default(
        "0"
      ),
      guestBillable: decimal2("guest_billable", { precision: 12, scale: 2 }).default(
        "0"
      ),
      companyExpense: decimal2("company_expense", {
        precision: 12,
        scale: 2
      }).default("0"),
      aiGeneratedTasks: integer3("ai_generated_tasks").default(0),
      emergencyTasks: integer3("emergency_tasks").default(0),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    taskEvidence = pgTable3("task_evidence", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      taskId: integer3("task_id").references(() => tasks.id).notNull(),
      evidenceType: varchar2("evidence_type").notNull(),
      // before-photo, after-photo, receipt, document, note
      fileUrl: varchar2("file_url"),
      fileName: varchar2("file_name"),
      fileSize: integer3("file_size"),
      // bytes
      description: text3("description"),
      uploadedBy: varchar2("uploaded_by").references(() => users.id),
      uploadedAt: timestamp3("uploaded_at").defaultNow(),
      isRequired: boolean3("is_required").default(false)
      // if this evidence is mandatory for task completion
    });
    taskNotificationRules = pgTable3("task_notification_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ruleType: varchar2("rule_type").notNull(),
      // overdue, missing-evidence, emergency, completion
      department: varchar2("department"),
      // null = applies to all departments
      triggerCondition: varchar2("trigger_condition").notNull(),
      // hours-overdue, no-photo-after-hours, priority-urgent
      triggerValue: integer3("trigger_value"),
      // hours, days, etc.
      notifyRoles: text3("notify_roles").array(),
      // admin, portfolio-manager, staff
      notificationMethod: varchar2("notification_method").default("in-app"),
      // in-app, email, sms
      escalationChain: jsonb3("escalation_chain"),
      // sequence of users to notify
      messageTemplate: text3("message_template"),
      isActive: boolean3("is_active").default(true),
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    insertTaskScheduleSchema = createInsertSchema3(taskSchedule).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTaskAutoGenRuleSchema = createInsertSchema3(
      taskAutoGenRules
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyTaskBillingSchema = createInsertSchema3(
      propertyTaskBilling
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAiTaskEngineSchema = createInsertSchema3(aiTaskEngine).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTaskDepartmentStatsSchema = createInsertSchema3(
      taskDepartmentStats
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTaskEvidenceSchema = createInsertSchema3(taskEvidence).omit({
      id: true,
      uploadedAt: true
    });
    insertTaskNotificationRuleSchema = createInsertSchema3(
      taskNotificationRules
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    propertyReferralsRelations = relations(
      propertyReferrals,
      ({ one }) => ({
        property: one(properties, {
          fields: [propertyReferrals.propertyId],
          references: [properties.id]
        }),
        referralAgent: one(users, {
          fields: [propertyReferrals.referralAgentId],
          references: [users.id]
        }),
        portfolioManager: one(users, {
          fields: [propertyReferrals.portfolioManagerId],
          references: [users.id]
        })
      })
    );
    referralEarningsRelations = relations(
      referralEarnings,
      ({ one }) => ({
        property: one(properties, {
          fields: [referralEarnings.propertyId],
          references: [properties.id]
        }),
        referralAgent: one(users, {
          fields: [referralEarnings.referralAgentId],
          references: [users.id]
        })
      })
    );
    agentPayoutsRelations = relations(agentPayouts, ({ one }) => ({
      agent: one(users, {
        fields: [agentPayouts.agentId],
        references: [users.id]
      }),
      approvedByUser: one(users, {
        fields: [agentPayouts.approvedBy],
        references: [users.id]
      })
    }));
    referralProgramRulesRelations = relations(
      referralProgramRules2,
      ({ one }) => ({
        createdByUser: one(users, {
          fields: [referralProgramRules2.createdBy],
          references: [users.id]
        })
      })
    );
    propertyAgentsRelations = relations(propertyAgents, ({ one }) => ({
      property: one(properties, {
        fields: [propertyAgents.propertyId],
        references: [properties.id]
      }),
      agent: one(users, {
        fields: [propertyAgents.agentId],
        references: [users.id]
      }),
      assignedByUser: one(users, {
        fields: [propertyAgents.assignedBy],
        references: [users.id]
      })
    }));
    insertPropertyReferralSchema = createInsertSchema3(
      propertyReferrals
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertReferralEarningsSchema = createInsertSchema3(
      referralEarnings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAgentPayoutsSchema = createInsertSchema3(agentPayouts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertReferralProgramRulesSchema = createInsertSchema3(
      referralProgramRules2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyAgentsSchema = createInsertSchema3(
      propertyAgents
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    staffSalaries = pgTable3("staff_salaries", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      staffId: varchar2("staff_id").references(() => users.id).notNull(),
      // Salary Information
      monthlySalary: decimal2("monthly_salary", {
        precision: 10,
        scale: 2
      }).notNull(),
      currency: varchar2("currency").default("THB"),
      payrollPeriod: varchar2("payroll_period").notNull(),
      // monthly, weekly, bi-weekly
      department: varchar2("department"),
      // cleaning, pool, garden, maintenance, general
      // Task-based bonuses
      taskBonusEnabled: boolean3("task_bonus_enabled").default(false),
      taskBonusAmount: decimal2("task_bonus_amount", {
        precision: 10,
        scale: 2
      }).default("0"),
      taskBonusType: varchar2("task_bonus_type").default("per_task"),
      // per_task, percentage
      // Tips and Additional Income
      tipsReceived: decimal2("tips_received", { precision: 10, scale: 2 }).default(
        "0"
      ),
      additionalIncome: decimal2("additional_income", {
        precision: 10,
        scale: 2
      }).default("0"),
      additionalIncomeNotes: text3("additional_income_notes"),
      // Period Information
      salaryPeriod: varchar2("salary_period").notNull(),
      // "2025-01" format for monthly
      paidAt: timestamp3("paid_at"),
      paidBy: varchar2("paid_by").references(() => users.id),
      paymentReference: varchar2("payment_reference"),
      paymentMethod: varchar2("payment_method"),
      // bank_transfer, cash, paypal
      // Status
      status: varchar2("status").default("pending"),
      // pending, paid, late
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    taskCompletions2 = pgTable3("task_completions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      taskId: integer3("task_id").references(() => tasks.id).notNull(),
      staffId: varchar2("staff_id").references(() => users.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      // Completion Details
      startedAt: timestamp3("started_at"),
      completedAt: timestamp3("completed_at"),
      duration: integer3("duration"),
      // In minutes
      // Checklist Progress
      checklistId: integer3("checklist_id").references(() => taskChecklists2.id),
      completedItems: jsonb3("completed_items"),
      // Array of completed checklist item IDs
      // Evidence & Documentation
      evidencePhotos: text3("evidence_photos").array().default([]),
      completionNotes: text3("completion_notes"),
      issuesFound: text3("issues_found").array().default([]),
      // Expenses
      expenses: jsonb3("expenses"),
      // Array of expense objects {item, amount, description}
      totalExpenseAmount: decimal2("total_expense_amount", {
        precision: 10,
        scale: 2
      }).default("0"),
      // Quality & Rating
      qualityRating: integer3("quality_rating"),
      // 1-5 rating if reviewed
      managerNotes: text3("manager_notes"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    staffExpenses2 = pgTable3("staff_expenses", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      staffId: varchar2("staff_id").references(() => users.id).notNull(),
      taskId: integer3("task_id").references(() => tasks.id),
      propertyId: integer3("property_id").references(() => properties.id),
      // Expense Details
      item: varchar2("item").notNull(),
      amount: decimal2("amount", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").default("THB"),
      category: varchar2("category").notNull(),
      // cleaning_supplies, tools, materials, fuel, other
      description: text3("description"),
      // Receipt & Verification
      receiptUrl: varchar2("receipt_url"),
      isApproved: boolean3("is_approved").default(false),
      approvedBy: varchar2("approved_by").references(() => users.id),
      approvedAt: timestamp3("approved_at"),
      // Reimbursement
      reimbursementStatus: varchar2("reimbursement_status").default("pending"),
      // pending, approved, paid, rejected
      reimbursedAt: timestamp3("reimbursed_at"),
      reimbursedBy: varchar2("reimbursed_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    insertStaffSalariesSchema = createInsertSchema3(staffSalaries).omit(
      {
        id: true,
        createdAt: true,
        updatedAt: true
      }
    );
    insertTaskChecklistsSchema = createInsertSchema3(
      taskChecklists2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTaskCompletionsSchema = createInsertSchema3(
      taskCompletions2
    ).omit({
      id: true,
      createdAt: true
    });
    insertStaffExpensesSchema = createInsertSchema3(staffExpenses2).omit(
      {
        id: true,
        createdAt: true,
        updatedAt: true
      }
    );
    balanceResetAuditRelations = relations(
      balanceResetAudit,
      ({ one }) => ({
        user: one(users, {
          fields: [balanceResetAudit.userId],
          references: [users.id],
          relationName: "balanceResets"
        }),
        adminUser: one(users, {
          fields: [balanceResetAudit.adminUserId],
          references: [users.id],
          relationName: "adminBalanceResets"
        }),
        property: one(properties, {
          fields: [balanceResetAudit.propertyId],
          references: [properties.id]
        })
      })
    );
    insertBalanceResetAuditSchema = createInsertSchema3(
      balanceResetAudit
    ).omit({
      id: true,
      createdAt: true
    });
    utilityProvidersRelations = relations(
      utilityProviders,
      ({ one, many }) => ({
        organization: one(organizations, {
          fields: [utilityProviders.organizationId],
          references: [organizations.id]
        }),
        createdByUser: one(users, {
          fields: [utilityProviders.createdBy],
          references: [users.id]
        }),
        propertySettings: many(propertyUtilitySettings)
      })
    );
    customExpenseCategoriesRelations = relations(
      customExpenseCategories,
      ({ one, many }) => ({
        organization: one(organizations, {
          fields: [customExpenseCategories.organizationId],
          references: [organizations.id]
        }),
        createdByUser: one(users, {
          fields: [customExpenseCategories.createdBy],
          references: [users.id]
        }),
        propertyExpenses: many(propertyCustomExpenses)
      })
    );
    propertyUtilitySettingsRelations = relations(
      propertyUtilitySettings,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [propertyUtilitySettings.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [propertyUtilitySettings.propertyId],
          references: [properties.id]
        }),
        provider: one(utilityProviders, {
          fields: [propertyUtilitySettings.providerId],
          references: [utilityProviders.id]
        }),
        createdByUser: one(users, {
          fields: [propertyUtilitySettings.createdBy],
          references: [users.id]
        })
      })
    );
    propertyCustomExpensesRelations = relations(
      propertyCustomExpenses,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [propertyCustomExpenses.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [propertyCustomExpenses.propertyId],
          references: [properties.id]
        }),
        category: one(customExpenseCategories, {
          fields: [propertyCustomExpenses.categoryId],
          references: [customExpenseCategories.id]
        }),
        createdByUser: one(users, {
          fields: [propertyCustomExpenses.createdBy],
          references: [users.id]
        })
      })
    );
    insertUtilityProviderSchema = createInsertSchema3(
      utilityProviders
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertCustomExpenseCategorySchema = createInsertSchema3(
      customExpenseCategories
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyUtilitySettingsSchema = createInsertSchema3(
      propertyUtilitySettings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyCustomExpensesSchema = createInsertSchema3(
      propertyCustomExpenses
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertCommissionLogSchema = createInsertSchema3(commissionLog).omit(
      {
        id: true,
        createdAt: true,
        updatedAt: true
      }
    );
    insertCommissionInvoicesSchema = createInsertSchema3(
      commissionInvoices
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertCommissionInvoiceItemsSchema = createInsertSchema3(
      commissionInvoiceItems
    ).omit({
      id: true,
      createdAt: true
    });
    insertGuestLoyaltyProfileSchema = createInsertSchema3(
      guestLoyaltyProfiles2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertLoyaltyTierSchema = createInsertSchema3(loyaltyTiers2).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestMessageSchema = createInsertSchema3(guestMessages2).omit({
      id: true,
      createdAt: true
    });
    insertMessagingTriggerSchema = createInsertSchema3(
      messagingTriggers2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertSmartReplySuggestionSchema = createInsertSchema3(
      smartReplySuggestions2
    ).omit({
      id: true,
      createdAt: true
    });
    insertAiMessageAnalysisSchema = createInsertSchema3(
      aiMessageAnalysis2
    ).omit({
      id: true,
      createdAt: true
    });
    insertMessageDeliverySchema = createInsertSchema3(
      messageDeliveries2
    ).omit({
      id: true,
      createdAt: true
    });
    insertTaskChecklistSchema = createInsertSchema3(
      taskChecklists2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyGuideSchema = createInsertSchema3(
      propertyGuides
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTaskProofUploadSchema = createInsertSchema3(
      taskProofUploads
    ).omit({
      id: true,
      uploadedAt: true,
      isArchived: true,
      archivedAt: true
    });
    insertTaskCompletionSchema = createInsertSchema3(
      taskCompletions2
    ).omit({
      id: true,
      completedAt: true,
      createdAt: true
    });
    insertMonthlyExportLogSchema = createInsertSchema3(
      monthlyExportLogs
    ).omit({
      id: true,
      exportedAt: true
    });
    staffProfiles = pgTable3(
      "staff_profiles",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        // Personal Information
        employeeNumber: varchar2("employee_number").unique(),
        department: varchar2("department").notNull(),
        // cleaning, pool, maintenance, garden, office
        position: varchar2("position").notNull(),
        hireDate: date2("hire_date"),
        // Employment Details
        employmentType: varchar2("employment_type").default("full_time"),
        // full_time, part_time, contract
        payType: varchar2("pay_type").default("monthly"),
        // monthly, daily, hourly
        baseSalary: decimal2("base_salary", { precision: 10, scale: 2 }),
        dailyWage: decimal2("daily_wage", { precision: 10, scale: 2 }),
        hourlyRate: decimal2("hourly_rate", { precision: 10, scale: 2 }),
        currency: varchar2("currency").default("THB"),
        // Performance Metrics
        totalTasksCompleted: integer3("total_tasks_completed").default(0),
        averageRating: decimal2("average_rating", {
          precision: 3,
          scale: 2
        }).default("0"),
        // Average star rating
        totalHoursWorked: decimal2("total_hours_worked", {
          precision: 10,
          scale: 2
        }).default("0"),
        totalEarnings: decimal2("total_earnings", {
          precision: 10,
          scale: 2
        }).default("0"),
        // Status
        isActive: boolean3("is_active").default(true),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_staff_profiles_org").on(table.organizationId),
        index("IDX_staff_profiles_dept").on(table.department)
      ]
    );
    monthlyPayrollRecords = pgTable3(
      "monthly_payroll_records",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        // Period Information
        payrollPeriod: varchar2("payroll_period").notNull(),
        // "2025-01" format
        payrollYear: integer3("payroll_year").notNull(),
        payrollMonth: integer3("payroll_month").notNull(),
        // Salary Components
        baseSalary: decimal2("base_salary", { precision: 10, scale: 2 }).default(
          "0"
        ),
        overtimePay: decimal2("overtime_pay", { precision: 10, scale: 2 }).default(
          "0"
        ),
        taskBonuses: decimal2("task_bonuses", { precision: 10, scale: 2 }).default(
          "0"
        ),
        commissions: decimal2("commissions", { precision: 10, scale: 2 }).default(
          "0"
        ),
        // bike rentals, tour sales, etc.
        otherBonuses: decimal2("other_bonuses", { precision: 10, scale: 2 }).default(
          "0"
        ),
        // Deductions
        advanceSalaryDeductions: decimal2("advance_salary_deductions", {
          precision: 10,
          scale: 2
        }).default("0"),
        fines: decimal2("fines", { precision: 10, scale: 2 }).default("0"),
        otherDeductions: decimal2("other_deductions", {
          precision: 10,
          scale: 2
        }).default("0"),
        // Totals
        grossPay: decimal2("gross_pay", { precision: 10, scale: 2 }).default("0"),
        netPay: decimal2("net_pay", { precision: 10, scale: 2 }).default("0"),
        // Payment Status
        status: varchar2("status").default("pending"),
        // pending, approved, paid
        approvedBy: varchar2("approved_by").references(() => users.id),
        approvedAt: timestamp3("approved_at"),
        paidAt: timestamp3("paid_at"),
        paymentMethod: varchar2("payment_method"),
        // bank_transfer, cash, mobile_payment
        paymentReference: varchar2("payment_reference"),
        // Notes
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_payroll_records_period").on(table.payrollPeriod),
        index("IDX_payroll_records_staff").on(table.staffId)
      ]
    );
    taskPerformanceLogs = pgTable3(
      "task_performance_logs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        taskId: integer3("task_id").references(() => tasks.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        // Performance Details
        timeliness: varchar2("timeliness").default("on_time"),
        // early, on_time, late
        qualityRating: integer3("quality_rating"),
        // 1-5 stars
        imageUploads: integer3("image_uploads").default(0),
        completionTime: integer3("completion_time"),
        // minutes
        // Feedback Sources
        portfolioManagerRating: integer3("portfolio_manager_rating"),
        // 1-5 stars
        portfolioManagerFeedback: text3("portfolio_manager_feedback"),
        ownerRating: integer3("owner_rating"),
        // 1-5 stars
        ownerFeedback: text3("owner_feedback"),
        guestRating: integer3("guest_rating"),
        // 1-5 stars
        guestFeedback: text3("guest_feedback"),
        // Task completion details
        completedAt: timestamp3("completed_at"),
        evidencePhotos: text3("evidence_photos").array().default([]),
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_performance_logs_staff").on(table.staffId),
        index("IDX_performance_logs_task").on(table.taskId)
      ]
    );
    attendanceRecords = pgTable3(
      "attendance_records",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        // Date & Shift Information
        workDate: date2("work_date").notNull(),
        shiftType: varchar2("shift_type").default("regular"),
        // regular, overtime, holiday, emergency
        // Clock In/Out
        clockInTime: timestamp3("clock_in_time"),
        clockOutTime: timestamp3("clock_out_time"),
        scheduledStartTime: timestamp3("scheduled_start_time"),
        scheduledEndTime: timestamp3("scheduled_end_time"),
        // Attendance Status
        status: varchar2("status").default("present"),
        // present, absent, late, early_leave, missed_clock_out
        hoursWorked: decimal2("hours_worked", { precision: 5, scale: 2 }).default(
          "0"
        ),
        overtimeHours: decimal2("overtime_hours", {
          precision: 5,
          scale: 2
        }).default("0"),
        // Notes & Explanations
        notes: text3("notes"),
        absenceReason: varchar2("absence_reason"),
        // sick, personal, vacation, emergency
        lateReason: text3("late_reason"),
        // Approval for absences/adjustments
        requiresApproval: boolean3("requires_approval").default(false),
        approvedBy: varchar2("approved_by").references(() => users.id),
        approvedAt: timestamp3("approved_at"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_attendance_staff_date").on(table.staffId, table.workDate),
        index("IDX_attendance_date").on(table.workDate)
      ]
    );
    leaveRequests = pgTable3(
      "leave_requests",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        // Leave Details
        leaveType: varchar2("leave_type").notNull(),
        // vacation, sick, personal, emergency, maternity
        startDate: date2("start_date").notNull(),
        endDate: date2("end_date").notNull(),
        totalDays: integer3("total_days").notNull(),
        // Request Information
        reason: text3("reason"),
        description: text3("description"),
        emergencyContact: varchar2("emergency_contact"),
        // Approval Workflow
        status: varchar2("status").default("pending"),
        // pending, approved, rejected, cancelled
        requestedAt: timestamp3("requested_at").defaultNow(),
        reviewedBy: varchar2("reviewed_by").references(() => users.id),
        reviewedAt: timestamp3("reviewed_at"),
        reviewNotes: text3("review_notes"),
        // Coverage Information
        coverageArranged: boolean3("coverage_arranged").default(false),
        coverageNotes: text3("coverage_notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_leave_requests_staff").on(table.staffId),
        index("IDX_leave_requests_dates").on(table.startDate, table.endDate)
      ]
    );
    staffCommissions = pgTable3(
      "staff_commissions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        // Commission Details
        type: varchar2("type").notNull(),
        // bike_rental, tour_booking, spa_service, other
        description: text3("description").notNull(),
        baseAmount: decimal2("base_amount", { precision: 10, scale: 2 }).notNull(),
        commissionRate: decimal2("commission_rate", { precision: 5, scale: 4 }),
        // e.g., 0.10 for 10%
        commissionAmount: decimal2("commission_amount", {
          precision: 10,
          scale: 2
        }).notNull(),
        currency: varchar2("currency").default("THB"),
        // Reference Information
        referenceId: varchar2("reference_id"),
        // booking ID, rental ID, etc.
        propertyId: integer3("property_id").references(() => properties.id),
        // Period & Payment
        earnedDate: date2("earned_date").notNull(),
        payrollPeriod: varchar2("payroll_period"),
        // Which payroll period this belongs to
        isPaid: boolean3("is_paid").default(false),
        paidAt: timestamp3("paid_at"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_staff_commissions_staff").on(table.staffId),
        index("IDX_staff_commissions_period").on(table.payrollPeriod)
      ]
    );
    paySlips = pgTable3(
      "pay_slips",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        payrollRecordId: integer3("payroll_record_id").references(() => monthlyPayrollRecords.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        // Pay Slip Details
        paySlipNumber: varchar2("pay_slip_number").unique().notNull(),
        period: varchar2("period").notNull(),
        // "January 2025", "2025-01"
        issuedDate: date2("issued_date").notNull(),
        // File Information
        pdfUrl: varchar2("pdf_url"),
        // URL to generated PDF
        generatedBy: varchar2("generated_by").references(() => users.id),
        // Status
        status: varchar2("status").default("draft"),
        // draft, issued, sent
        sentAt: timestamp3("sent_at"),
        viewedByStaff: boolean3("viewed_by_staff").default(false),
        viewedAt: timestamp3("viewed_at"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_pay_slips_staff").on(table.staffId),
        index("IDX_pay_slips_period").on(table.period)
      ]
    );
    insertStaffProfileSchema = createInsertSchema3(staffProfiles).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMonthlyPayrollRecordSchema = createInsertSchema3(
      monthlyPayrollRecords
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTaskPerformanceLogSchema = createInsertSchema3(
      taskPerformanceLogs
    ).omit({
      id: true,
      createdAt: true
    });
    insertAttendanceRecordSchema = createInsertSchema3(
      attendanceRecords
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertLeaveRequestSchema = createInsertSchema3(leaveRequests).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertStaffCommissionSchema = createInsertSchema3(
      staffCommissions
    ).omit({
      id: true,
      createdAt: true
    });
    insertPaySlipSchema = createInsertSchema3(paySlips).omit({
      id: true,
      createdAt: true
    });
    staffAdvanceRequests = pgTable3(
      "staff_advance_requests",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        // Request Details
        requestAmount: decimal2("request_amount", {
          precision: 10,
          scale: 2
        }).notNull(),
        requestReason: text3("request_reason").notNull(),
        requestDate: timestamp3("request_date").defaultNow().notNull(),
        proofAttachment: varchar2("proof_attachment"),
        // Optional file URL
        // Approval Workflow
        status: varchar2("status").default("pending").notNull(),
        // pending, approved, rejected
        reviewedBy: varchar2("reviewed_by").references(() => users.id),
        // Admin/PM who reviewed
        reviewedAt: timestamp3("reviewed_at"),
        reviewNotes: text3("review_notes"),
        // Payment Tracking
        paymentStatus: varchar2("payment_status").default("not_paid"),
        // not_paid, paid, deducted
        paidAmount: decimal2("paid_amount", { precision: 10, scale: 2 }),
        paidDate: timestamp3("paid_date"),
        deductionSchedule: jsonb3("deduction_schedule"),
        // Array of monthly deductions
        remainingBalance: decimal2("remaining_balance", { precision: 10, scale: 2 }),
        // Metadata
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_advance_staff").on(table.staffId),
        index("IDX_advance_org").on(table.organizationId),
        index("IDX_advance_status").on(table.status)
      ]
    );
    staffClockEntries = pgTable3(
      "staff_clock_entries",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        // Task Information
        taskId: integer3("task_id").references(() => tasks.id),
        // Optional link to task
        propertyId: integer3("property_id").references(() => properties.id),
        // Optional property link
        taskDescription: text3("task_description").notNull(),
        // Clock In/Out Timing
        clockInTime: varchar2("clock_in_time").notNull(),
        // HH:mm:ss format
        clockOutTime: varchar2("clock_out_time"),
        // HH:mm:ss format, null if active
        workDate: date2("work_date").defaultNow().notNull(),
        // GPS Tracking
        gpsLocationIn: text3("gps_location_in"),
        // "lat,lng" format
        gpsLocationOut: text3("gps_location_out"),
        // "lat,lng" format
        locationAccuracy: decimal2("location_accuracy", { precision: 6, scale: 2 }),
        // meters
        // Overtime Tracking
        isOvertime: boolean3("is_overtime").default(false),
        overtimeHours: decimal2("overtime_hours", {
          precision: 4,
          scale: 2
        }).default("0.00"),
        totalHours: decimal2("total_hours", { precision: 4, scale: 2 }),
        // Evidence and Approval
        photoEvidence: text3("photo_evidence"),
        // Base64 or URL
        isEmergency: boolean3("is_emergency").default(false),
        emergencyReason: text3("emergency_reason"),
        supervisorApproved: boolean3("supervisor_approved").default(false),
        approvedBy: varchar2("approved_by").references(() => users.id),
        approvedAt: timestamp3("approved_at"),
        // Status Tracking
        status: varchar2("status").default("active").notNull(),
        // active, completed, emergency
        completedAt: timestamp3("completed_at"),
        // Metadata
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_clock_staff").on(table.staffId),
        index("IDX_clock_org").on(table.organizationId),
        index("IDX_clock_date").on(table.workDate),
        index("IDX_clock_status").on(table.status)
      ]
    );
    staffOvertimeLogs = pgTable3(
      "staff_overtime_logs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        // Time Tracking
        workDate: date2("work_date").notNull(),
        timeIn: varchar2("time_in").notNull(),
        // HH:MM format
        timeOut: varchar2("time_out").notNull(),
        totalHours: decimal2("total_hours", { precision: 4, scale: 2 }).notNull(),
        // Task Details
        taskType: varchar2("task_type").notNull(),
        // emergency_pool_fix, late_check_in, maintenance_urgent, etc.
        taskDescription: text3("task_description").notNull(),
        isEmergency: boolean3("is_emergency").default(false),
        // Evidence & Proof
        photoEvidence: jsonb3("photo_evidence"),
        // Array of photo URLs
        guestSignature: varchar2("guest_signature"),
        // Digital signature URL
        additionalNotes: text3("additional_notes"),
        // Approval & Compensation
        status: varchar2("status").default("pending").notNull(),
        // pending, approved, rejected
        approvedBy: varchar2("approved_by").references(() => users.id),
        approvedAt: timestamp3("approved_at"),
        approvalNotes: text3("approval_notes"),
        // Compensation Type
        compensationType: varchar2("compensation_type"),
        // overtime_pay, time_off_credit
        compensationAmount: decimal2("compensation_amount", {
          precision: 10,
          scale: 2
        }),
        timeOffHours: decimal2("time_off_hours", { precision: 4, scale: 2 }),
        // Payment Status
        paymentStatus: varchar2("payment_status").default("pending"),
        // pending, paid, credited
        paidDate: timestamp3("paid_date"),
        // Metadata
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_overtime_staff").on(table.staffId),
        index("IDX_overtime_org").on(table.organizationId),
        index("IDX_overtime_date").on(table.workDate),
        index("IDX_overtime_status").on(table.status)
      ]
    );
    staffOvertimeSettings = pgTable3(
      "staff_overtime_settings",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id),
        // Global or Per-Staff Settings
        isGlobalSetting: boolean3("is_global_setting").default(false),
        // Overtime Rules
        regularHourlyRate: decimal2("regular_hourly_rate", {
          precision: 10,
          scale: 2
        }),
        overtimeMultiplier: decimal2("overtime_multiplier", {
          precision: 3,
          scale: 2
        }).default("1.5"),
        // 1.5x rate
        emergencyMultiplier: decimal2("emergency_multiplier", {
          precision: 3,
          scale: 2
        }).default("2.0"),
        // 2x rate
        // Work Hour Definitions
        standardWorkStart: varchar2("standard_work_start").default("08:00"),
        standardWorkEnd: varchar2("standard_work_end").default("18:00"),
        afterHoursThreshold: varchar2("after_hours_threshold").default("20:00"),
        // After 8 PM = overtime
        // Compensation Preferences
        defaultCompensationType: varchar2("default_compensation_type").default(
          "overtime_pay"
        ),
        // overtime_pay, time_off_credit
        allowStaffChoice: boolean3("allow_staff_choice").default(true),
        // Time Off Credit Rules
        timeOffCreditRate: decimal2("time_off_credit_rate", {
          precision: 3,
          scale: 2
        }).default("1.0"),
        // 1:1 ratio
        maxTimeOffAccumulation: decimal2("max_time_off_accumulation", {
          precision: 4,
          scale: 2
        }).default("40.0"),
        // 40 hours max
        // Metadata
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_overtime_settings_org").on(table.organizationId),
        index("IDX_overtime_settings_staff").on(table.staffId)
      ]
    );
    staffMonthlySummary = pgTable3(
      "staff_monthly_summary",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        // Period
        summaryYear: integer3("summary_year").notNull(),
        summaryMonth: integer3("summary_month").notNull(),
        summaryPeriod: varchar2("summary_period").notNull(),
        // "2025-01" format
        // Advance Summary
        totalAdvanceRequests: integer3("total_advance_requests").default(0),
        approvedAdvances: decimal2("approved_advances", {
          precision: 10,
          scale: 2
        }).default("0"),
        pendingAdvances: decimal2("pending_advances", {
          precision: 10,
          scale: 2
        }).default("0"),
        remainingAdvanceBalance: decimal2("remaining_advance_balance", {
          precision: 10,
          scale: 2
        }).default("0"),
        // Overtime Summary
        totalOvertimeHours: decimal2("total_overtime_hours", {
          precision: 4,
          scale: 2
        }).default("0"),
        approvedOvertimeHours: decimal2("approved_overtime_hours", {
          precision: 4,
          scale: 2
        }).default("0"),
        pendingOvertimeHours: decimal2("pending_overtime_hours", {
          precision: 4,
          scale: 2
        }).default("0"),
        overtimeEarnings: decimal2("overtime_earnings", {
          precision: 10,
          scale: 2
        }).default("0"),
        timeOffCredits: decimal2("time_off_credits", {
          precision: 4,
          scale: 2
        }).default("0"),
        // Task Summary
        emergencyTasks: integer3("emergency_tasks").default(0),
        afterHoursTasks: integer3("after_hours_tasks").default(0),
        // Auto-calculated
        lastUpdated: timestamp3("last_updated").defaultNow()
      },
      (table) => [
        index("IDX_monthly_summary_staff").on(table.staffId),
        index("IDX_monthly_summary_period").on(table.summaryPeriod)
      ]
    );
    insertStaffAdvanceRequestSchema = createInsertSchema3(
      staffAdvanceRequests
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertStaffClockEntrySchema = createInsertSchema3(
      staffClockEntries
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      completedAt: true,
      approvedAt: true
    });
    insertStaffOvertimeLogSchema = createInsertSchema3(
      staffOvertimeLogs
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertStaffOvertimeSettingsSchema = createInsertSchema3(
      staffOvertimeSettings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertStaffMonthlySummarySchema = createInsertSchema3(
      staffMonthlySummary
    ).omit({
      id: true,
      lastUpdated: true
    });
    staffPayrollRecords = pgTable3("staff_payroll_records", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      staffId: varchar2("staff_id").references(() => users.id).notNull(),
      // Payroll Period
      payrollPeriod: varchar2("payroll_period").notNull(),
      // "2025-01" format
      payrollYear: integer3("payroll_year").notNull(),
      payrollMonth: integer3("payroll_month").notNull(),
      // Salary Components
      baseSalary: decimal2("base_salary", { precision: 10, scale: 2 }).notNull(),
      taskBonuses: decimal2("task_bonuses", { precision: 10, scale: 2 }).default(
        "0"
      ),
      commissionEarned: decimal2("commission_earned", {
        precision: 10,
        scale: 2
      }).default("0"),
      overtime: decimal2("overtime", { precision: 10, scale: 2 }).default("0"),
      tips: decimal2("tips", { precision: 10, scale: 2 }).default("0"),
      allowances: decimal2("allowances", { precision: 10, scale: 2 }).default("0"),
      // Deductions
      deductions: decimal2("deductions", { precision: 10, scale: 2 }).default("0"),
      taxes: decimal2("taxes", { precision: 10, scale: 2 }).default("0"),
      socialSecurity: decimal2("social_security", {
        precision: 10,
        scale: 2
      }).default("0"),
      // Total Calculations
      grossPay: decimal2("gross_pay", { precision: 10, scale: 2 }).notNull(),
      netPay: decimal2("net_pay", { precision: 10, scale: 2 }).notNull(),
      // Payment Details
      paymentStatus: varchar2("payment_status").default("pending"),
      // pending, paid, overdue
      paymentDate: timestamp3("payment_date"),
      paymentMethod: varchar2("payment_method"),
      // bank_transfer, cash, check
      paymentReference: varchar2("payment_reference"),
      paymentSlipUrl: varchar2("payment_slip_url"),
      // Admin Actions
      processedBy: varchar2("processed_by").references(() => users.id),
      approvedBy: varchar2("approved_by").references(() => users.id),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    portfolioManagerCommissions = pgTable3(
      "portfolio_manager_commissions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        managerId: varchar2("manager_id").references(() => users.id).notNull(),
        // Commission Period
        commissionPeriod: varchar2("commission_period").notNull(),
        // "2025-01"
        commissionYear: integer3("commission_year").notNull(),
        commissionMonth: integer3("commission_month").notNull(),
        // Property Portfolio
        propertyIds: varchar2("property_ids").array().notNull(),
        totalProperties: integer3("total_properties").notNull(),
        // Revenue Data
        totalRevenue: decimal2("total_revenue", {
          precision: 12,
          scale: 2
        }).notNull(),
        managementFees: decimal2("management_fees", {
          precision: 12,
          scale: 2
        }).notNull(),
        commissionRate: decimal2("commission_rate", {
          precision: 5,
          scale: 2
        }).default("50"),
        // 50%
        commissionAmount: decimal2("commission_amount", {
          precision: 12,
          scale: 2
        }).notNull(),
        // Performance Metrics
        averageOccupancy: decimal2("average_occupancy", { precision: 5, scale: 2 }),
        averageReviewScore: decimal2("average_review_score", {
          precision: 3,
          scale: 2
        }),
        totalBookings: integer3("total_bookings").default(0),
        // Payment Status
        payoutStatus: varchar2("payout_status").default("pending"),
        // pending, approved, paid
        payoutRequestedAt: timestamp3("payout_requested_at"),
        payoutApprovedAt: timestamp3("payout_approved_at"),
        payoutPaidAt: timestamp3("payout_paid_at"),
        // Invoice Generation
        invoiceGenerated: boolean3("invoice_generated").default(false),
        invoiceNumber: varchar2("invoice_number"),
        invoicePdfUrl: varchar2("invoice_pdf_url"),
        // Admin Actions
        approvedBy: varchar2("approved_by").references(() => users.id),
        processedBy: varchar2("processed_by").references(() => users.id),
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    referralAgentCommissionLogs = pgTable3(
      "referral_agent_commission_logs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        agentId: varchar2("agent_id").references(() => users.id).notNull(),
        // Commission Period
        commissionPeriod: varchar2("commission_period").notNull(),
        // "2025-01"
        commissionYear: integer3("commission_year").notNull(),
        commissionMonth: integer3("commission_month").notNull(),
        // Property Referrals
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        propertyName: varchar2("property_name").notNull(),
        // Revenue Data
        managementRevenue: decimal2("management_revenue", {
          precision: 10,
          scale: 2
        }).notNull(),
        commissionRate: decimal2("commission_rate", {
          precision: 5,
          scale: 2
        }).default("10"),
        // 10%
        commissionAmount: decimal2("commission_amount", {
          precision: 10,
          scale: 2
        }).notNull(),
        // Property Performance
        occupancyRate: decimal2("occupancy_rate", { precision: 5, scale: 2 }),
        averageReviewScore: decimal2("average_review_score", {
          precision: 3,
          scale: 2
        }),
        monthlyBookings: integer3("monthly_bookings").default(0),
        // Payment Tracking
        paymentStatus: varchar2("payment_status").default("pending"),
        // pending, requested, paid
        paymentRequestedAt: timestamp3("payment_requested_at"),
        paymentConfirmedAt: timestamp3("payment_confirmed_at"),
        paymentSlipUrl: varchar2("payment_slip_url"),
        // Admin Actions
        processedBy: varchar2("processed_by").references(() => users.id),
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    universalInvoices = pgTable3("universal_invoices", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Invoice Details
      invoiceNumber: varchar2("invoice_number").unique().notNull(),
      invoiceType: varchar2("invoice_type").notNull(),
      // payroll, commission, service, reimbursement, custom
      // Parties
      fromName: varchar2("from_name").notNull(),
      fromAddress: text3("from_address"),
      fromEmail: varchar2("from_email"),
      fromPhone: varchar2("from_phone"),
      toName: varchar2("to_name").notNull(),
      toAddress: text3("to_address"),
      toEmail: varchar2("to_email"),
      toPhone: varchar2("to_phone"),
      // Invoice Content
      invoiceDate: timestamp3("invoice_date").notNull(),
      dueDate: timestamp3("due_date"),
      description: text3("description"),
      // Financial Details
      subtotal: decimal2("subtotal", { precision: 12, scale: 2 }).notNull(),
      taxRate: decimal2("tax_rate", { precision: 5, scale: 2 }).default("0"),
      taxAmount: decimal2("tax_amount", { precision: 12, scale: 2 }).default("0"),
      discountAmount: decimal2("discount_amount", {
        precision: 12,
        scale: 2
      }).default("0"),
      totalAmount: decimal2("total_amount", { precision: 12, scale: 2 }).notNull(),
      // Currency & Payment
      currency: varchar2("currency").default("THB"),
      paymentTerms: varchar2("payment_terms"),
      paymentMethod: varchar2("payment_method"),
      // Status
      status: varchar2("status").default("draft"),
      // draft, sent, paid, overdue, cancelled
      // File Attachments
      invoicePdfUrl: varchar2("invoice_pdf_url"),
      receiptUrl: varchar2("receipt_url"),
      attachmentUrls: varchar2("attachment_urls").array(),
      // Metadata
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      tags: varchar2("tags").array(),
      relatedEntityType: varchar2("related_entity_type"),
      // payroll, commission, property, booking
      relatedEntityId: varchar2("related_entity_id"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    universalInvoiceLineItems = pgTable3(
      "universal_invoice_line_items",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        invoiceId: integer3("invoice_id").references(() => universalInvoices.id).notNull(),
        // Line Item Details
        description: text3("description").notNull(),
        quantity: decimal2("quantity", { precision: 10, scale: 2 }).default("1"),
        unitPrice: decimal2("unit_price", { precision: 10, scale: 2 }).notNull(),
        lineTotal: decimal2("line_total", { precision: 10, scale: 2 }).notNull(),
        // Categorization
        category: varchar2("category"),
        // cleaning, maintenance, commission, salary, bonus, reimbursement
        tags: varchar2("tags").array(),
        createdAt: timestamp3("created_at").defaultNow()
      }
    );
    paymentConfirmations = pgTable3("payment_confirmations", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Payment Reference
      paymentType: varchar2("payment_type").notNull(),
      // payroll, commission, invoice
      referenceEntityType: varchar2("reference_entity_type").notNull(),
      // payroll_record, commission, invoice
      referenceEntityId: integer3("reference_entity_id").notNull(),
      // Payment Details
      paymentAmount: decimal2("payment_amount", {
        precision: 12,
        scale: 2
      }).notNull(),
      paymentDate: timestamp3("payment_date").notNull(),
      paymentMethod: varchar2("payment_method").notNull(),
      paymentReference: varchar2("payment_reference"),
      // Bank/Transfer Details
      bankName: varchar2("bank_name"),
      accountNumber: varchar2("account_number"),
      transactionId: varchar2("transaction_id"),
      // File Uploads
      paymentSlipUrl: varchar2("payment_slip_url"),
      receiptUrl: varchar2("receipt_url"),
      // Status & Confirmation
      confirmationStatus: varchar2("confirmation_status").default("pending"),
      // pending, confirmed, disputed
      confirmedBy: varchar2("confirmed_by").references(() => users.id),
      confirmedAt: timestamp3("confirmed_at"),
      // Metadata
      uploadedBy: varchar2("uploaded_by").references(() => users.id).notNull(),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    insertStaffPayrollRecordSchema = createInsertSchema3(
      staffPayrollRecords
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPortfolioManagerCommissionSchema = createInsertSchema3(
      portfolioManagerCommissions
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertReferralAgentCommissionLogSchema = createInsertSchema3(
      referralAgentCommissionLogs
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUniversalInvoiceSchema = createInsertSchema3(
      universalInvoices
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUniversalInvoiceLineItemSchema = createInsertSchema3(
      universalInvoiceLineItems
    ).omit({
      id: true,
      createdAt: true
    });
    insertPaymentConfirmationSchema = createInsertSchema3(
      paymentConfirmations
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAddonServiceCatalogSchema = createInsertSchema3(
      addonServiceCatalog
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAddonServiceBookingSchema = createInsertSchema3(
      addonServiceBookings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAddonServiceCategorySchema = createInsertSchema3(
      addonServiceCategories
    ).omit({
      id: true,
      createdAt: true
    });
    insertAddonServiceCommissionSchema = createInsertSchema3(
      addonServiceCommissions
    ).omit({
      id: true,
      createdAt: true
    });
    insertAddonServiceReportSchema = createInsertSchema3(
      addonServiceReports
    ).omit({
      id: true,
      createdAt: true,
      reportGeneratedAt: true
    });
    insertAddonServiceAvailabilitySchema = createInsertSchema3(
      addonServiceAvailability
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAddonBillingRuleSchema = createInsertSchema3(
      addonBillingRules
    ).omit({
      id: true,
      createdAt: true
    });
    liveBookingCalendar = pgTable3("live_booking_calendar", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Booking Details
      bookingReference: varchar2("booking_reference").notNull(),
      // External booking ID
      externalBookingId: varchar2("external_booking_id"),
      // Hostaway/Airbnb/etc ID
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email"),
      guestPhone: varchar2("guest_phone"),
      // Dates and Duration
      checkInDate: date2("check_in_date").notNull(),
      checkOutDate: date2("check_out_date").notNull(),
      nightCount: integer3("night_count").notNull(),
      guestCount: integer3("guest_count").default(2),
      // Financial Information
      totalAmount: decimal2("total_amount", { precision: 12, scale: 2 }).notNull(),
      currency: varchar2("currency", { length: 3 }).default("THB"),
      cleaningFee: decimal2("cleaning_fee", { precision: 10, scale: 2 }).default(
        "0.00"
      ),
      // Booking Status and Source
      bookingStatus: varchar2("booking_status").notNull(),
      // confirmed, cancelled, completed, no-show
      bookingSource: varchar2("booking_source").notNull(),
      // airbnb, vrbo, booking.com, direct, etc.
      platformFee: decimal2("platform_fee", { precision: 10, scale: 2 }).default(
        "0.00"
      ),
      // Revenue Split Configuration
      ownerSplit: decimal2("owner_split", { precision: 5, scale: 2 }).default(
        "70.00"
      ),
      // percentage
      managementSplit: decimal2("management_split", {
        precision: 5,
        scale: 2
      }).default("30.00"),
      // percentage
      splitRoutingNotes: text3("split_routing_notes"),
      // Explanation for routing decision
      // API Integration
      apiSource: varchar2("api_source").default("hostaway"),
      // hostaway, hostify, ownerrez
      lastSyncedAt: timestamp3("last_synced_at").defaultNow(),
      syncStatus: varchar2("sync_status").default("active"),
      // active, failed, manual
      apiBookingData: jsonb3("api_booking_data"),
      // Raw API response for debugging
      // Property Details
      bedroomCount: integer3("bedroom_count"),
      bathroomCount: integer3("bathroom_count"),
      maxGuests: integer3("max_guests"),
      // Special Requirements
      specialRequests: text3("special_requests"),
      guestNotes: text3("guest_notes"),
      internalNotes: text3("internal_notes"),
      // Staff/PM notes
      // Commission Tracking
      agentCommissionApplicable: boolean3("agent_commission_applicable").default(
        false
      ),
      referralAgentId: varchar2("referral_agent_id").references(() => users.id),
      retailAgentId: varchar2("retail_agent_id").references(() => users.id),
      agentCommissionAmount: decimal2("agent_commission_amount", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      agentCommissionStatus: varchar2("agent_commission_status").default("pending"),
      // pending, approved, paid
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow(),
      createdBy: varchar2("created_by").references(() => users.id)
    });
    propertyAvailability = pgTable3("property_availability", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Date Range
      startDate: date2("start_date").notNull(),
      endDate: date2("end_date").notNull(),
      // Availability Status
      availabilityType: varchar2("availability_type").notNull(),
      // blocked, maintenance, available, booked
      blockReason: varchar2("block_reason"),
      // owner_personal, maintenance, cleaning, buffer
      // Pricing Information
      basePrice: decimal2("base_price", { precision: 10, scale: 2 }),
      weekendPrice: decimal2("weekend_price", { precision: 10, scale: 2 }),
      holidayPrice: decimal2("holiday_price", { precision: 10, scale: 2 }),
      minimumStay: integer3("minimum_stay").default(1),
      // API Sync
      externalCalendarId: varchar2("external_calendar_id"),
      // From booking platforms
      lastSyncedAt: timestamp3("last_synced_at").defaultNow(),
      // Notes
      internalNotes: text3("internal_notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow(),
      createdBy: varchar2("created_by").references(() => users.id)
    });
    agentSearchPreferences = pgTable3("agent_search_preferences", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      agentId: varchar2("agent_id").references(() => users.id).notNull(),
      // Saved Filter Preferences
      preferredLocations: jsonb3("preferred_locations"),
      // Array of location/zone preferences
      preferredBedroomRange: jsonb3("preferred_bedroom_range"),
      // {min: 2, max: 5}
      preferredPriceRange: jsonb3("preferred_price_range"),
      // {min: 1000, max: 5000}
      preferredAmenities: jsonb3("preferred_amenities"),
      // Array of amenity IDs
      // Search Behavior
      defaultSearchRadius: integer3("default_search_radius").default(50),
      // km
      showCommissionUpfront: boolean3("show_commission_upfront").default(true),
      autoRefreshResults: boolean3("auto_refresh_results").default(true),
      // Notification Preferences
      newListingAlerts: boolean3("new_listing_alerts").default(true),
      priceDropAlerts: boolean3("price_drop_alerts").default(false),
      availabilityAlerts: boolean3("availability_alerts").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertySearchIndex = pgTable3("property_search_index", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Enhanced Property Information
      propertyTitle: varchar2("property_title").notNull(),
      propertyDescription: text3("property_description"),
      shortDescription: varchar2("short_description"),
      // For search results
      // Location Details
      country: varchar2("country").default("Thailand"),
      province: varchar2("province"),
      // Phuket, Bangkok, etc.
      district: varchar2("district"),
      zone: varchar2("zone"),
      // Patong, Kata, etc.
      coordinates: jsonb3("coordinates"),
      // {lat: 7.8804, lng: 98.3923}
      // Property Features
      bedrooms: integer3("bedrooms").notNull(),
      bathrooms: integer3("bathrooms").notNull(),
      maxGuests: integer3("max_guests").notNull(),
      propertySize: integer3("property_size"),
      // sqm
      // Amenities and Features
      amenities: jsonb3("amenities"),
      // Pool, WiFi, Kitchen, etc.
      specialFeatures: jsonb3("special_features"),
      // Sea view, private beach, etc.
      // Pricing Information
      baseNightlyRate: decimal2("base_nightly_rate", {
        precision: 10,
        scale: 2
      }).notNull(),
      weekendRate: decimal2("weekend_rate", { precision: 10, scale: 2 }),
      peakSeasonRate: decimal2("peak_season_rate", { precision: 10, scale: 2 }),
      currency: varchar2("currency", { length: 3 }).default("THB"),
      // Commission Structure
      standardCommissionRate: decimal2("standard_commission_rate", {
        precision: 5,
        scale: 2
      }).default("10.00"),
      specialCommissionRate: decimal2("special_commission_rate", {
        precision: 5,
        scale: 2
      }),
      commissionNotes: text3("commission_notes"),
      // Media and Marketing
      primaryImageUrl: varchar2("primary_image_url"),
      imageGallery: jsonb3("image_gallery"),
      // Array of image URLs
      virtualTourUrl: varchar2("virtual_tour_url"),
      propertyFactSheetUrl: varchar2("property_fact_sheet_url"),
      // Availability and Booking
      isActive: boolean3("is_active").default(true),
      minimumBookingNotice: integer3("minimum_booking_notice").default(1),
      // days
      maximumBookingAdvance: integer3("maximum_booking_advance").default(365),
      // days
      instantBookingEnabled: boolean3("instant_booking_enabled").default(false),
      // Search Optimization
      searchTags: jsonb3("search_tags"),
      // Additional search keywords
      popularityScore: integer3("popularity_score").default(0),
      // Based on booking frequency
      lastBookingDate: date2("last_booking_date"),
      averageOccupancyRate: decimal2("average_occupancy_rate", {
        precision: 5,
        scale: 2
      }),
      averageReviewScore: decimal2("average_review_score", {
        precision: 3,
        scale: 2
      }),
      // API Integration
      hostawayPropertyId: varchar2("hostaway_property_id"),
      airbnbListingId: varchar2("airbnb_listing_id"),
      vrboListingId: varchar2("vrbo_listing_id"),
      bookingComListingId: varchar2("booking_com_listing_id"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow(),
      lastIndexedAt: timestamp3("last_indexed_at").defaultNow()
    });
    agentBookingEnquiries = pgTable3("agent_booking_enquiries", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      agentId: varchar2("agent_id").references(() => users.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Enquiry Details
      enquiryType: varchar2("enquiry_type").notNull(),
      // booking_request, availability_check, price_quote
      enquiryReference: varchar2("enquiry_reference").notNull(),
      // Agent reference number
      // Guest Information
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email").notNull(),
      guestPhone: varchar2("guest_phone"),
      guestNationality: varchar2("guest_nationality"),
      // Booking Request Details
      requestedCheckIn: date2("requested_check_in").notNull(),
      requestedCheckOut: date2("requested_check_out").notNull(),
      guestCount: integer3("guest_count").notNull(),
      specialRequests: text3("special_requests"),
      // Pricing and Commission
      quotedPrice: decimal2("quoted_price", { precision: 12, scale: 2 }),
      currency: varchar2("currency", { length: 3 }).default("THB"),
      calculatedCommission: decimal2("calculated_commission", {
        precision: 10,
        scale: 2
      }),
      commissionRate: decimal2("commission_rate", {
        precision: 5,
        scale: 2
      }).default("10.00"),
      // Status and Processing
      enquiryStatus: varchar2("enquiry_status").default("pending"),
      // pending, quoted, confirmed, cancelled, expired
      responseDeadline: timestamp3("response_deadline"),
      processedBy: varchar2("processed_by").references(() => users.id),
      processedAt: timestamp3("processed_at"),
      // Communication
      agentNotes: text3("agent_notes"),
      internalNotes: text3("internal_notes"),
      communicationHistory: jsonb3("communication_history"),
      // Array of messages/emails
      // Booking Conversion
      convertedToBooking: boolean3("converted_to_booking").default(false),
      bookingId: integer3("booking_id").references(() => liveBookingCalendar.id),
      conversionDate: timestamp3("conversion_date"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    bookingPlatformSync = pgTable3("booking_platform_sync", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Platform Configuration
      platformName: varchar2("platform_name").notNull(),
      // hostaway, hostify, ownerrez
      apiEndpoint: varchar2("api_endpoint").notNull(),
      apiKeyEncrypted: text3("api_key_encrypted").notNull(),
      // Encrypted API key
      isActive: boolean3("is_active").default(true),
      // Sync Settings
      syncFrequency: integer3("sync_frequency").default(15),
      // minutes
      lastSyncAt: timestamp3("last_sync_at"),
      nextSyncAt: timestamp3("next_sync_at"),
      syncStatus: varchar2("sync_status").default("pending"),
      // pending, syncing, completed, failed
      // Error Handling
      lastError: text3("last_error"),
      errorCount: integer3("error_count").default(0),
      maxRetries: integer3("max_retries").default(3),
      // Sync Statistics
      totalBookingsImported: integer3("total_bookings_imported").default(0),
      lastImportCount: integer3("last_import_count").default(0),
      totalSyncTime: integer3("total_sync_time").default(0),
      // milliseconds
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow(),
      createdBy: varchar2("created_by").references(() => users.id)
    });
    propertyOccupancyAnalytics = pgTable3(
      "property_occupancy_analytics",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Time Period
        periodType: varchar2("period_type").notNull(),
        // daily, weekly, monthly, yearly
        periodDate: date2("period_date").notNull(),
        // Start date of the period
        // Occupancy Metrics
        totalNights: integer3("total_nights").notNull(),
        bookedNights: integer3("booked_nights").notNull(),
        blockedNights: integer3("blocked_nights").default(0),
        maintenanceNights: integer3("maintenance_nights").default(0),
        occupancyRate: decimal2("occupancy_rate", {
          precision: 5,
          scale: 2
        }).notNull(),
        // Revenue Metrics
        totalRevenue: decimal2("total_revenue", { precision: 12, scale: 2 }).default(
          "0.00"
        ),
        averageNightlyRate: decimal2("average_nightly_rate", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        revenuePerAvailableNight: decimal2("revenue_per_available_night", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        // Booking Metrics
        totalBookings: integer3("total_bookings").default(0),
        averageStayDuration: decimal2("average_stay_duration", {
          precision: 4,
          scale: 2
        }).default("0.00"),
        averageGuestCount: decimal2("average_guest_count", {
          precision: 4,
          scale: 2
        }).default("0.00"),
        // Platform Breakdown
        platformBreakdown: jsonb3("platform_breakdown"),
        // {airbnb: {bookings: 5, revenue: 25000}, vrbo: {...}}
        // Performance Indicators
        bookingLeadTime: decimal2("booking_lead_time", {
          precision: 5,
          scale: 2
        }).default("0.00"),
        // days
        cancellationRate: decimal2("cancellation_rate", {
          precision: 5,
          scale: 2
        }).default("0.00"),
        reviewScore: decimal2("review_score", { precision: 3, scale: 2 }),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow(),
        calculatedAt: timestamp3("calculated_at").defaultNow()
      }
    );
    liveBookingCalendarRelations = relations(
      liveBookingCalendar,
      ({ one }) => ({
        property: one(properties, {
          fields: [liveBookingCalendar.propertyId],
          references: [properties.id]
        }),
        referralAgent: one(users, {
          fields: [liveBookingCalendar.referralAgentId],
          references: [users.id]
        }),
        retailAgent: one(users, {
          fields: [liveBookingCalendar.retailAgentId],
          references: [users.id]
        })
      })
    );
    propertyAvailabilityRelations = relations(
      propertyAvailability,
      ({ one }) => ({
        property: one(properties, {
          fields: [propertyAvailability.propertyId],
          references: [properties.id]
        })
      })
    );
    propertySearchIndexRelations = relations(
      propertySearchIndex,
      ({ one }) => ({
        property: one(properties, {
          fields: [propertySearchIndex.propertyId],
          references: [properties.id]
        })
      })
    );
    agentBookingEnquiriesRelations = relations(
      agentBookingEnquiries,
      ({ one }) => ({
        agent: one(users, {
          fields: [agentBookingEnquiries.agentId],
          references: [users.id]
        }),
        property: one(properties, {
          fields: [agentBookingEnquiries.propertyId],
          references: [properties.id]
        }),
        booking: one(liveBookingCalendar, {
          fields: [agentBookingEnquiries.bookingId],
          references: [liveBookingCalendar.id]
        })
      })
    );
    insertLiveBookingCalendarSchema = createInsertSchema3(
      liveBookingCalendar
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyAvailabilitySchema = createInsertSchema3(
      propertyAvailability
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAgentSearchPreferencesSchema = createInsertSchema3(
      agentSearchPreferences
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertySearchIndexSchema = createInsertSchema3(
      propertySearchIndex
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAgentBookingEnquiriesSchema = createInsertSchema3(
      agentBookingEnquiries
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBookingPlatformSyncSchema = createInsertSchema3(
      bookingPlatformSync
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyOccupancyAnalyticsSchema = createInsertSchema3(
      propertyOccupancyAnalytics
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    guestPortalSessions = pgTable3("guest_portal_sessions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
      guestEmail: varchar2("guest_email").notNull(),
      accessToken: varchar2("access_token").unique().notNull(),
      // Secure token for guest access
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      checkInDate: date2("check_in_date").notNull(),
      checkOutDate: date2("check_out_date").notNull(),
      guestName: varchar2("guest_name").notNull(),
      guestPhone: varchar2("guest_phone"),
      isActive: boolean3("is_active").default(true),
      lastAccessed: timestamp3("last_accessed").defaultNow(),
      expiresAt: timestamp3("expires_at").notNull(),
      // Expires after checkout + 30 days
      createdAt: timestamp3("created_at").defaultNow()
    });
    guestActivityTimeline = pgTable3("guest_activity_timeline", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      guestSessionId: integer3("guest_session_id").references(() => guestPortalSessions.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
      activityType: varchar2("activity_type").notNull(),
      // service_request, cleaning_request, message, addon_booking
      title: varchar2("title").notNull(),
      description: text3("description"),
      status: varchar2("status").default("pending"),
      // pending, in_progress, completed, cancelled
      requestedAt: timestamp3("requested_at").defaultNow(),
      scheduledAt: timestamp3("scheduled_at"),
      completedAt: timestamp3("completed_at"),
      assignedTo: varchar2("assigned_to").references(() => users.id),
      estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
      finalCost: decimal2("final_cost", { precision: 10, scale: 2 }),
      chargeAssignment: varchar2("charge_assignment").default("guest"),
      // guest, owner, company
      isVisible: boolean3("is_visible").default(true),
      // Visible to guest in portal
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestAiFaqKnowledge = pgTable3("guest_ai_faq_knowledge", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      categoryType: varchar2("category_type").notNull(),
      // property_info, amenities, local_area, policies, troubleshooting
      questionKeywords: jsonb3("question_keywords").notNull(),
      // Array of keywords that trigger this FAQ
      standardQuestion: varchar2("standard_question").notNull(),
      standardAnswer: text3("standard_answer").notNull(),
      propertySpecific: boolean3("property_specific").default(false),
      propertyId: integer3("property_id").references(() => properties.id),
      // Null for general FAQ
      priority: integer3("priority").default(1),
      // 1-10, higher priority responses shown first
      isActive: boolean3("is_active").default(true),
      usageCount: integer3("usage_count").default(0),
      lastUsed: timestamp3("last_used"),
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestAddonServiceRequests = pgTable3(
      "guest_addon_service_requests",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        guestSessionId: integer3("guest_session_id").references(() => guestPortalSessions.id).notNull(),
        bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
        serviceId: integer3("service_id").references(() => guestAddonServices.id).notNull(),
        // Service Details
        serviceName: varchar2("service_name").notNull(),
        serviceType: varchar2("service_type").notNull(),
        // cleaning, chef, massage, transport, babysitting, laundry
        requestedDate: date2("requested_date").notNull(),
        requestedTime: varchar2("requested_time"),
        // Preferred time slot
        duration: integer3("duration"),
        // Duration in minutes/hours
        guestCount: integer3("guest_count").default(1),
        // Number of people for service
        // Pricing and Assignment
        unitPrice: decimal2("unit_price", { precision: 10, scale: 2 }).notNull(),
        quantity: integer3("quantity").default(1),
        totalCost: decimal2("total_cost", { precision: 10, scale: 2 }).notNull(),
        chargeAssignment: varchar2("charge_assignment").default("guest"),
        // guest, owner, company
        assignmentReason: text3("assignment_reason"),
        // Why charged to owner/company
        // Status and Processing
        requestStatus: varchar2("request_status").default("pending"),
        // pending, confirmed, in_progress, completed, cancelled
        confirmedBy: varchar2("confirmed_by").references(() => users.id),
        // Staff who confirmed
        confirmedAt: timestamp3("confirmed_at"),
        scheduledDateTime: timestamp3("scheduled_date_time"),
        completedAt: timestamp3("completed_at"),
        // Service Provider
        serviceProviderId: varchar2("service_provider_id").references(
          () => users.id
        ),
        // Staff assigned
        providerNotes: text3("provider_notes"),
        completionNotes: text3("completion_notes"),
        guestRating: integer3("guest_rating"),
        // 1-5 stars
        guestReview: text3("guest_review"),
        // Special Requirements
        specialRequests: text3("special_requests"),
        guestNotes: text3("guest_notes"),
        adminNotes: text3("admin_notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    guestPropertyLocalInfo = pgTable3("guest_property_local_info", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Location Details
      locationName: varchar2("location_name").notNull(),
      locationType: varchar2("location_type").notNull(),
      // beach, restaurant, pharmacy, convenience_store, activity, tour
      description: text3("description"),
      address: text3("address"),
      // Geographic Data
      latitude: decimal2("latitude", { precision: 10, scale: 7 }),
      longitude: decimal2("longitude", { precision: 10, scale: 7 }),
      distanceFromProperty: decimal2("distance_from_property", {
        precision: 5,
        scale: 2
      }),
      // km
      walkingTime: integer3("walking_time"),
      // minutes
      drivingTime: integer3("driving_time"),
      // minutes
      // Contact and Booking
      phoneNumber: varchar2("phone_number"),
      website: varchar2("website"),
      openingHours: jsonb3("opening_hours"),
      // {monday: "09:00-18:00", tuesday: "09:00-18:00"}
      isPartner: boolean3("is_partner").default(false),
      // Partner locations get commission
      bookingRequired: boolean3("booking_required").default(false),
      // Display and Recommendations
      displayOrder: integer3("display_order").default(0),
      recommendationScore: integer3("recommendation_score").default(1),
      // 1-10
      imageUrl: varchar2("image_url"),
      tags: jsonb3("tags"),
      // Array of tags: ["family_friendly", "romantic", "budget", "luxury"]
      priceRange: varchar2("price_range"),
      // budget, moderate, expensive, luxury
      // Status
      isActive: boolean3("is_active").default(true),
      verifiedAt: timestamp3("verified_at"),
      verifiedBy: varchar2("verified_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestMaintenanceReports = pgTable3("guest_maintenance_reports", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      guestSessionId: integer3("guest_session_id").references(() => guestPortalSessions.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Issue Details
      issueType: varchar2("issue_type").notNull(),
      // electrical, plumbing, appliance, cleaning, amenity, safety
      issueTitle: varchar2("issue_title").notNull(),
      issueDescription: text3("issue_description").notNull(),
      locationInProperty: varchar2("location_in_property"),
      // bedroom_1, kitchen, pool_area, garden
      severityLevel: varchar2("severity_level").default("medium"),
      // low, medium, high, urgent
      // Media Evidence
      reportImages: jsonb3("report_images"),
      // Array of image URLs uploaded by guest
      reportVideos: jsonb3("report_videos"),
      // Array of video URLs if applicable
      // Processing and Assignment
      reportStatus: varchar2("report_status").default("submitted"),
      // submitted, acknowledged, assigned, in_progress, resolved, closed
      acknowledgedBy: varchar2("acknowledged_by").references(() => users.id),
      // First staff to see report
      acknowledgedAt: timestamp3("acknowledged_at"),
      autoCreatedTaskId: integer3("auto_created_task_id").references(() => tasks.id),
      assignedTo: varchar2("assigned_to").references(() => users.id),
      assignedAt: timestamp3("assigned_at"),
      // Resolution
      estimatedResolutionTime: varchar2("estimated_resolution_time"),
      // "within_24h", "1-3_days", "3-7_days"
      actualResolutionTime: timestamp3("actual_resolution_time"),
      resolutionNotes: text3("resolution_notes"),
      resolutionImages: jsonb3("resolution_images"),
      // Before/after photos
      // Follow-up
      guestSatisfied: boolean3("guest_satisfied"),
      guestFeedback: text3("guest_feedback"),
      followUpRequired: boolean3("follow_up_required").default(false),
      // Staff Communication
      staffNotes: text3("staff_notes"),
      internalComments: text3("internal_comments"),
      // Not visible to guest
      reportedAt: timestamp3("reported_at").defaultNow(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    insertGuestPortalSessionSchema = createInsertSchema3(
      guestPortalSessions
    ).omit({
      id: true,
      createdAt: true
    });
    insertGuestActivityTimelineSchema = createInsertSchema3(
      guestActivityTimeline
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestAiFaqKnowledgeSchema = createInsertSchema3(
      guestAiFaqKnowledge
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestAddonServiceRequestSchema = createInsertSchema3(
      guestAddonServiceRequests
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestPropertyLocalInfoSchema = createInsertSchema3(
      guestPropertyLocalInfo
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestMaintenanceReportSchema = createInsertSchema3(
      guestMaintenanceReports
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    ownerBalanceTrackers = pgTable3("owner_balance_trackers", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Balance Components
      totalEarnings: decimal2("total_earnings", { precision: 12, scale: 2 }).default(
        "0.00"
      ),
      totalExpenses: decimal2("total_expenses", { precision: 12, scale: 2 }).default(
        "0.00"
      ),
      totalCommissions: decimal2("total_commissions", {
        precision: 12,
        scale: 2
      }).default("0.00"),
      netBalance: decimal2("net_balance", { precision: 12, scale: 2 }).default(
        "0.00"
      ),
      // Calculation Period
      calculationPeriod: varchar2("calculation_period").default("monthly"),
      // monthly, bi_weekly, quarterly
      lastCalculatedAt: timestamp3("last_calculated_at").defaultNow(),
      periodStartDate: date2("period_start_date").notNull(),
      periodEndDate: date2("period_end_date").notNull(),
      // Status
      balanceStatus: varchar2("balance_status").default("current"),
      // current, pending_payout, processing, paid
      lastPayoutDate: timestamp3("last_payout_date"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    ownerPayoutRequests = pgTable3("owner_payout_requests", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      balanceTrackerId: integer3("balance_tracker_id").references(
        () => ownerBalanceTrackers.id
      ),
      // Request Details
      requestedAmount: decimal2("requested_amount", {
        precision: 12,
        scale: 2
      }).notNull(),
      requestType: varchar2("request_type").default("balance_payout"),
      // balance_payout, partial_payout, advance_request
      requestNotes: text3("request_notes"),
      // Workflow Status
      requestStatus: varchar2("request_status").default("pending"),
      // pending, approved, paid, confirmed, rejected
      requestedAt: timestamp3("requested_at").defaultNow(),
      // Admin/PM Approval
      approvedBy: varchar2("approved_by").references(() => users.id),
      approvedAt: timestamp3("approved_at"),
      approvalNotes: text3("approval_notes"),
      // Payment Processing
      paymentSlipUrl: varchar2("payment_slip_url"),
      // Upload receipt of transfer
      paidBy: varchar2("paid_by").references(() => users.id),
      paidAt: timestamp3("paid_at"),
      paymentMethod: varchar2("payment_method"),
      // bank_transfer, cash, check, digital_wallet
      paymentReference: varchar2("payment_reference"),
      // Owner Confirmation
      confirmedBy: varchar2("confirmed_by").references(() => users.id),
      confirmedAt: timestamp3("confirmed_at"),
      confirmationNotes: text3("confirmation_notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    ownerPaymentLogs = pgTable3("owner_payment_logs", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      payoutRequestId: integer3("payout_request_id").references(
        () => ownerPayoutRequests.id
      ),
      // Payment Details
      paymentType: varchar2("payment_type").notNull(),
      // payout_to_owner, payment_from_owner, balance_adjustment, admin_correction
      paymentDirection: varchar2("payment_direction").notNull(),
      // outgoing, incoming
      amount: decimal2("amount", { precision: 12, scale: 2 }).notNull(),
      description: text3("description").notNull(),
      // Transaction Details
      transactionReference: varchar2("transaction_reference"),
      paymentMethod: varchar2("payment_method"),
      receiptUrl: varchar2("receipt_url"),
      // Processing Info
      processedBy: varchar2("processed_by").references(() => users.id).notNull(),
      processedAt: timestamp3("processed_at").defaultNow(),
      // Balance Impact
      balanceBefore: decimal2("balance_before", { precision: 12, scale: 2 }),
      balanceAfter: decimal2("balance_after", { precision: 12, scale: 2 }),
      // Status and Verification
      logStatus: varchar2("log_status").default("confirmed"),
      // pending, confirmed, disputed, resolved
      verifiedBy: varchar2("verified_by").references(() => users.id),
      verifiedAt: timestamp3("verified_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    ownerDebtTrackers = pgTable3("owner_debt_trackers", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      ownerId: varchar2("owner_id").references(() => users.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id),
      // Debt Details
      debtAmount: decimal2("debt_amount", { precision: 12, scale: 2 }).notNull(),
      debtReason: text3("debt_reason").notNull(),
      debtType: varchar2("debt_type").notNull(),
      // utility_overpay, damage_charge, service_charge, advance_repayment
      // Status and Payment
      debtStatus: varchar2("debt_status").default("outstanding"),
      // outstanding, partial_paid, paid, disputed, forgiven
      paidAmount: decimal2("paid_amount", { precision: 12, scale: 2 }).default(
        "0.00"
      ),
      remainingAmount: decimal2("remaining_amount", {
        precision: 12,
        scale: 2
      }).notNull(),
      // Payment from Owner
      ownerPaymentProofUrl: varchar2("owner_payment_proof_url"),
      ownerPaidAt: timestamp3("owner_paid_at"),
      adminConfirmedBy: varchar2("admin_confirmed_by").references(() => users.id),
      adminConfirmedAt: timestamp3("admin_confirmed_at"),
      // Due Date and Terms
      dueDate: date2("due_date"),
      paymentTerms: varchar2("payment_terms"),
      // immediate, 30_days, 60_days, installment
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyPayoutSettings = pgTable3("property_payout_settings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Payout Frequency Configuration
      ownerPayoutFrequency: varchar2("owner_payout_frequency").default("monthly"),
      // monthly, bi_weekly, quarterly
      pmPayoutFrequency: varchar2("pm_payout_frequency").default("monthly"),
      referralAgentPayoutFrequency: varchar2(
        "referral_agent_payout_frequency"
      ).default("monthly"),
      // Next Scheduled Payouts
      nextOwnerPayoutDate: date2("next_owner_payout_date"),
      nextPmPayoutDate: date2("next_pm_payout_date"),
      nextReferralAgentPayoutDate: date2("next_referral_agent_payout_date"),
      // Automatic Processing
      autoProcessPayouts: boolean3("auto_process_payouts").default(false),
      minimumPayoutAmount: decimal2("minimum_payout_amount", {
        precision: 8,
        scale: 2
      }).default("100.00"),
      // Notification Settings
      notifyOwnerBeforePayout: boolean3("notify_owner_before_payout").default(true),
      notifyDaysBefore: integer3("notify_days_before").default(3),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    insertOwnerBalanceTrackerSchema = createInsertSchema3(
      ownerBalanceTrackers
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOwnerPayoutRequestSchema = createInsertSchema3(
      ownerPayoutRequests
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOwnerPaymentLogSchema = createInsertSchema3(
      ownerPaymentLogs
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOwnerDebtTrackerSchema = createInsertSchema3(
      ownerDebtTrackers
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyPayoutSettingsSchema = createInsertSchema3(
      propertyPayoutSettings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    platformRoutingRules = pgTable3("platform_routing_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Platform Information
      platformName: varchar2("platform_name").notNull(),
      // airbnb, booking_com, vrbo, direct_stripe, marriott, expedia
      platformDisplayName: varchar2("platform_display_name").notNull(),
      // Default Routing Settings
      defaultOwnerPercentage: decimal2("default_owner_percentage", {
        precision: 5,
        scale: 2
      }).notNull(),
      // 70.00 for 70%
      defaultManagementPercentage: decimal2("default_management_percentage", {
        precision: 5,
        scale: 2
      }).notNull(),
      // 30.00 for 30%
      // Platform Settings
      isActive: boolean3("is_active").default(true),
      supportsSplitPayout: boolean3("supports_split_payout").default(false),
      // Airbnb supports this
      platformFeePercentage: decimal2("platform_fee_percentage", {
        precision: 5,
        scale: 2
      }).default("0.00"),
      // e.g., 5% for Stripe
      // Routing Options
      routingType: varchar2("routing_type").notNull(),
      // split_payout, full_to_owner, full_to_management
      paymentMethod: varchar2("payment_method"),
      // automatic, manual_invoice, direct_transfer
      // Admin Settings
      adminNotes: text3("admin_notes"),
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyPlatformRules = pgTable3("property_platform_rules", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      platformRuleId: integer3("platform_rule_id").references(() => platformRoutingRules.id).notNull(),
      // Override Settings
      overrideOwnerPercentage: decimal2("override_owner_percentage", {
        precision: 5,
        scale: 2
      }),
      overrideManagementPercentage: decimal2("override_management_percentage", {
        precision: 5,
        scale: 2
      }),
      overrideRoutingType: varchar2("override_routing_type"),
      // split_payout, full_to_owner, full_to_management
      // Property-specific settings
      isActive: boolean3("is_active").default(true),
      specialInstructions: text3("special_instructions"),
      // Audit
      setBy: varchar2("set_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    bookingPlatformRouting = pgTable3("booking_platform_routing", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
      platformRuleId: integer3("platform_rule_id").references(() => platformRoutingRules.id).notNull(),
      // Booking-specific override
      actualOwnerPercentage: decimal2("actual_owner_percentage", {
        precision: 5,
        scale: 2
      }).notNull(),
      actualManagementPercentage: decimal2("actual_management_percentage", {
        precision: 5,
        scale: 2
      }).notNull(),
      actualRoutingType: varchar2("actual_routing_type").notNull(),
      // Financial Breakdown
      totalBookingAmount: decimal2("total_booking_amount", {
        precision: 12,
        scale: 2
      }).notNull(),
      ownerAmount: decimal2("owner_amount", { precision: 12, scale: 2 }).notNull(),
      managementAmount: decimal2("management_amount", {
        precision: 12,
        scale: 2
      }).notNull(),
      platformFeeAmount: decimal2("platform_fee_amount", {
        precision: 12,
        scale: 2
      }).default("0.00"),
      // Override Reason (if different from default)
      overrideReason: text3("override_reason"),
      isOverride: boolean3("is_override").default(false),
      // Processing Status
      routingStatus: varchar2("routing_status").default("pending"),
      // pending, processed, disputed, corrected
      processedAt: timestamp3("processed_at"),
      processedBy: varchar2("processed_by").references(() => users.id),
      // Audit Trail
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    routingAuditLog = pgTable3("routing_audit_log", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Reference
      relatedType: varchar2("related_type").notNull(),
      // platform_rule, property_rule, booking_routing
      relatedId: integer3("related_id").notNull(),
      // Action Details
      actionType: varchar2("action_type").notNull(),
      // created, updated, override_applied, routing_processed
      previousValues: jsonb3("previous_values"),
      newValues: jsonb3("new_values"),
      changeReason: text3("change_reason"),
      // Impact
      impactedBookings: integer3("impacted_bookings").default(0),
      financialImpact: decimal2("financial_impact", {
        precision: 12,
        scale: 2
      }).default("0.00"),
      // Audit
      performedBy: varchar2("performed_by").references(() => users.id).notNull(),
      performedAt: timestamp3("performed_at").defaultNow(),
      createdAt: timestamp3("created_at").defaultNow()
    });
    staffWorkClocks = pgTable3("staff_work_clocks", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      staffId: varchar2("staff_id").references(() => users.id).notNull(),
      staffName: varchar2("staff_name").notNull(),
      // Clock In/Out Times
      clockInTime: timestamp3("clock_in_time").notNull(),
      clockOutTime: timestamp3("clock_out_time"),
      // Clock Type
      clockType: varchar2("clock_type").notNull().default("workday"),
      // workday, task, emergency_visit
      // Work Details
      totalMinutesWorked: integer3("total_minutes_worked").default(0),
      breakMinutes: integer3("break_minutes").default(0),
      netWorkMinutes: integer3("net_work_minutes").default(0),
      // Location & Notes
      clockInLocation: varchar2("clock_in_location"),
      clockOutLocation: varchar2("clock_out_location"),
      clockInNotes: text3("clock_in_notes"),
      clockOutNotes: text3("clock_out_notes"),
      // Emergency/Overtime Flags
      isEmergencyVisit: boolean3("is_emergency_visit").default(false),
      isOvertimeShift: boolean3("is_overtime_shift").default(false),
      emergencyReason: varchar2("emergency_reason"),
      // Auto-Detection Flags
      isOutsideNormalHours: boolean3("is_outside_normal_hours").default(false),
      isWeekendWork: boolean3("is_weekend_work").default(false),
      isHolidayWork: boolean3("is_holiday_work").default(false),
      // Linked Tasks (for task-based clocks)
      linkedTaskIds: jsonb3("linked_task_ids"),
      // Array of task IDs worked during this clock
      // Admin Override
      manualAdjustment: boolean3("manual_adjustment").default(false),
      adjustmentReason: text3("adjustment_reason"),
      adjustedBy: varchar2("adjusted_by").references(() => users.id),
      adjustedAt: timestamp3("adjusted_at"),
      // Status
      status: varchar2("status").default("active"),
      // active, completed, disputed, adjusted
      approvalStatus: varchar2("approval_status").default("pending"),
      // pending, approved, disputed
      approvedBy: varchar2("approved_by").references(() => users.id),
      approvedAt: timestamp3("approved_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    staffClockSettings = pgTable3("staff_clock_settings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Work Hour Definitions
      standardWorkStartTime: varchar2("standard_work_start_time").default("08:00"),
      // HH:MM format
      standardWorkEndTime: varchar2("standard_work_end_time").default("17:00"),
      standardWorkDays: jsonb3("standard_work_days").default(
        '["monday","tuesday","wednesday","thursday","friday"]'
      ),
      // Overtime & Emergency Rates
      overtimeMultiplier: decimal2("overtime_multiplier", {
        precision: 3,
        scale: 2
      }).default("1.5"),
      emergencyCalloutRate: decimal2("emergency_callout_rate", {
        precision: 8,
        scale: 2
      }).default("50.00"),
      weekendWorkMultiplier: decimal2("weekend_work_multiplier", {
        precision: 3,
        scale: 2
      }).default("1.25"),
      holidayWorkMultiplier: decimal2("holiday_work_multiplier", {
        precision: 3,
        scale: 2
      }).default("2.0"),
      // Clock Policies
      allowGeolocationTracking: boolean3("allow_geolocation_tracking").default(
        false
      ),
      requireClockOutNotes: boolean3("require_clock_out_notes").default(false),
      autoClockOutAfterHours: integer3("auto_clock_out_after_hours").default(12),
      // Hours
      allowManualTimeAdjustment: boolean3("allow_manual_time_adjustment").default(
        true
      ),
      // Approval Requirements
      requireOvertimeApproval: boolean3("require_overtime_approval").default(true),
      requireEmergencyApproval: boolean3("require_emergency_approval").default(true),
      autoApproveRegularHours: boolean3("auto_approve_regular_hours").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    staffTimeSummaries = pgTable3("staff_time_summaries", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      staffId: varchar2("staff_id").references(() => users.id).notNull(),
      staffName: varchar2("staff_name").notNull(),
      // Period
      monthYear: varchar2("month_year").notNull(),
      // YYYY-MM format
      // Regular Hours Summary
      totalRegularMinutes: integer3("total_regular_minutes").default(0),
      totalOvertimeMinutes: integer3("total_overtime_minutes").default(0),
      totalEmergencyMinutes: integer3("total_emergency_minutes").default(0),
      totalBreakMinutes: integer3("total_break_minutes").default(0),
      // Work Pattern Analysis
      totalWorkDays: integer3("total_work_days").default(0),
      weekendWorkDays: integer3("weekend_work_days").default(0),
      holidayWorkDays: integer3("holiday_work_days").default(0),
      emergencyCallouts: integer3("emergency_callouts").default(0),
      // Task-related Statistics
      totalTasksCompleted: integer3("total_tasks_completed").default(0),
      averageTaskDuration: integer3("average_task_duration").default(0),
      // Minutes
      // Financial Calculations
      regularHoursPay: decimal2("regular_hours_pay", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      overtimePay: decimal2("overtime_pay", { precision: 10, scale: 2 }).default(
        "0.00"
      ),
      emergencyPay: decimal2("emergency_pay", { precision: 10, scale: 2 }).default(
        "0.00"
      ),
      totalEarnings: decimal2("total_earnings", { precision: 10, scale: 2 }).default(
        "0.00"
      ),
      // Status
      status: varchar2("status").default("draft"),
      // draft, submitted, approved, paid
      submittedAt: timestamp3("submitted_at"),
      approvedBy: varchar2("approved_by").references(() => users.id),
      approvedAt: timestamp3("approved_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    staffClockAuditLog = pgTable3("staff_clock_audit_log", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Reference
      clockId: integer3("clock_id").references(() => staffWorkClocks.id),
      staffId: varchar2("staff_id").references(() => users.id).notNull(),
      // Action Details
      actionType: varchar2("action_type").notNull(),
      // clock_in, clock_out, manual_adjustment, approval, dispute
      oldValues: jsonb3("old_values"),
      newValues: jsonb3("new_values"),
      changeReason: text3("change_reason"),
      // Metadata
      ipAddress: varchar2("ip_address"),
      userAgent: text3("user_agent"),
      geolocation: jsonb3("geolocation"),
      // lat, lng, accuracy
      // Audit
      performedBy: varchar2("performed_by").references(() => users.id).notNull(),
      performedAt: timestamp3("performed_at").defaultNow(),
      createdAt: timestamp3("created_at").defaultNow()
    });
    insertPlatformRoutingRuleSchema = createInsertSchema3(
      platformRoutingRules
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyPlatformRuleSchema = createInsertSchema3(
      propertyPlatformRules
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBookingPlatformRoutingSchema = createInsertSchema3(
      bookingPlatformRouting
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertRoutingAuditLogSchema = createInsertSchema3(
      routingAuditLog
    ).omit({
      id: true,
      createdAt: true
    });
    insertStaffWorkClockSchema = createInsertSchema3(
      staffWorkClocks
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertStaffClockSettingsSchema = createInsertSchema3(
      staffClockSettings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertStaffTimeSummarySchema = createInsertSchema3(
      staffTimeSummaries
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertStaffClockAuditLogSchema = createInsertSchema3(
      staffClockAuditLog
    ).omit({
      id: true,
      createdAt: true
    });
    maintenanceSuggestions = pgTable3("maintenance_suggestions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Suggestion Details
      title: varchar2("title").notNull(),
      description: text3("description").notNull(),
      maintenanceType: varchar2("maintenance_type").notNull(),
      // repair, replacement, upgrade, other
      urgencyLevel: varchar2("urgency_level").default("normal"),
      // low, normal, high, urgent
      // Cost Information
      estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
      currency: varchar2("currency").default("AUD"),
      costBreakdown: jsonb3("cost_breakdown"),
      // Array of cost items with descriptions
      whoPaysCost: varchar2("who_pays_cost").default("owner"),
      // owner, management, shared, guest
      // Attachments & Evidence
      attachments: text3("attachments").array(),
      // Array of file URLs/paths
      evidencePhotos: text3("evidence_photos").array(),
      supportingDocuments: text3("supporting_documents").array(),
      // Submission Information
      submittedBy: varchar2("submitted_by").references(() => users.id).notNull(),
      submittedByRole: varchar2("submitted_by_role").notNull(),
      // admin, portfolio-manager
      submissionReason: text3("submission_reason"),
      // Owner Response
      ownerResponse: varchar2("owner_response"),
      // approved, declined, request_more_info
      ownerComments: text3("owner_comments"),
      ownerRespondedAt: timestamp3("owner_responded_at"),
      // Status Tracking
      status: varchar2("status").default("pending"),
      // pending, approved, declined, in_progress, completed, cancelled
      approvalDeadline: timestamp3("approval_deadline"),
      remindersSent: integer3("reminders_sent").default(0),
      lastReminderSent: timestamp3("last_reminder_sent"),
      // Task Creation (if approved)
      taskCreated: boolean3("task_created").default(false),
      createdTaskId: integer3("created_task_id").references(() => tasks.id),
      taskCreatedAt: timestamp3("task_created_at"),
      // Completion Information
      completedAt: timestamp3("completed_at"),
      actualCost: decimal2("actual_cost", { precision: 10, scale: 2 }),
      completionNotes: text3("completion_notes"),
      completionPhotos: text3("completion_photos").array(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    maintenanceApprovalLogs = pgTable3("maintenance_approval_logs", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      suggestionId: integer3("suggestion_id").references(() => maintenanceSuggestions.id).notNull(),
      // Log Details
      actionType: varchar2("action_type").notNull(),
      // submitted, approved, declined, commented, reminded, completed
      actionBy: varchar2("action_by").references(() => users.id).notNull(),
      actionByRole: varchar2("action_by_role").notNull(),
      // Action Details
      previousStatus: varchar2("previous_status"),
      newStatus: varchar2("new_status"),
      comments: text3("comments"),
      // Metadata
      ipAddress: varchar2("ip_address"),
      userAgent: text3("user_agent"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    maintenanceSuggestionSettings = pgTable3(
      "maintenance_suggestion_settings",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        // Approval Timeouts
        defaultApprovalTimeoutDays: integer3(
          "default_approval_timeout_days"
        ).default(7),
        urgentApprovalTimeoutDays: integer3("urgent_approval_timeout_days").default(
          3
        ),
        reminderIntervalDays: integer3("reminder_interval_days").default(3),
        maxReminders: integer3("max_reminders").default(3),
        // Auto-approval Thresholds
        enableAutoApproval: boolean3("enable_auto_approval").default(false),
        autoApprovalThreshold: decimal2("auto_approval_threshold", {
          precision: 10,
          scale: 2
        }).default("100.00"),
        autoApprovalTypes: text3("auto_approval_types").array(),
        // repair, maintenance, etc.
        // Notification Settings
        notifyOwnersViaEmail: boolean3("notify_owners_via_email").default(true),
        notifyOwnersViaSms: boolean3("notify_owners_via_sms").default(false),
        notifyManagersOnApproval: boolean3("notify_managers_on_approval").default(
          true
        ),
        notifyStaffOnTaskCreation: boolean3("notify_staff_on_task_creation").default(
          true
        ),
        // Cost Management
        requireCostBreakdown: boolean3("require_cost_breakdown").default(true),
        requireMultipleQuotes: boolean3("require_multiple_quotes").default(false),
        multipleQuotesThreshold: decimal2("multiple_quotes_threshold", {
          precision: 10,
          scale: 2
        }).default("500.00"),
        // Documentation Requirements
        requirePhotos: boolean3("require_photos").default(true),
        requireDetailedDescription: boolean3("require_detailed_description").default(
          true
        ),
        maxAttachmentSize: integer3("max_attachment_size").default(10485760),
        // 10MB in bytes
        allowedFileTypes: text3("allowed_file_types").array().default('["jpg","jpeg","png","pdf","doc","docx"]'),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    serviceVendors = pgTable3("service_vendors", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Vendor Information
      name: varchar2("name").notNull(),
      description: text3("description"),
      logo: varchar2("logo"),
      vendorType: varchar2("vendor_type").notNull(),
      // internal, external, partner
      // Contact Information
      contactPerson: varchar2("contact_person"),
      phone: varchar2("phone"),
      email: varchar2("email"),
      address: text3("address"),
      website: varchar2("website"),
      // Business Details
      businessLicense: varchar2("business_license"),
      taxId: varchar2("tax_id"),
      bankDetails: text3("bank_details"),
      // Performance & Settings
      rating: decimal2("rating", { precision: 3, scale: 2 }).default("5.00"),
      reviewCount: integer3("review_count").default(0),
      responseTime: integer3("response_time_hours").default(24),
      commissionRate: decimal2("commission_rate", {
        precision: 5,
        scale: 2
      }).default("0.00"),
      // percentage
      // Status & Availability
      isActive: boolean3("is_active").default(true),
      isVerified: boolean3("is_verified").default(false),
      availableDays: text3("available_days").array(),
      // ["monday", "tuesday", ...]
      workingHours: jsonb3("working_hours"),
      // {start: "09:00", end: "18:00"}
      // Financial Terms
      paymentTerms: varchar2("payment_terms").default("net_30"),
      // immediate, net_7, net_30
      preferredPaymentMethod: varchar2("preferred_payment_method").default(
        "bank_transfer"
      ),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    serviceCategories = pgTable3("service_categories", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      name: varchar2("name").notNull(),
      description: text3("description"),
      icon: varchar2("icon").default("service"),
      color: varchar2("color").default("#3B82F6"),
      sortOrder: integer3("sort_order").default(0),
      isActive: boolean3("is_active").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    marketplaceServices = pgTable3("marketplace_services", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      vendorId: integer3("vendor_id").references(() => serviceVendors.id).notNull(),
      categoryId: integer3("category_id").references(() => serviceCategories.id).notNull(),
      // Service Details
      name: varchar2("name").notNull(),
      description: text3("description"),
      shortDescription: text3("short_description"),
      photos: text3("photos").array(),
      // Pricing
      pricingType: varchar2("pricing_type").notNull(),
      // flat_rate, hourly, quote_based
      basePrice: decimal2("base_price", { precision: 10, scale: 2 }),
      currency: varchar2("currency").default("THB"),
      priceNotes: text3("price_notes"),
      // Booking Rules
      requiresApproval: boolean3("requires_approval").default(false),
      requiresPrePayment: boolean3("requires_pre_payment").default(false),
      cancellationFee: decimal2("cancellation_fee", {
        precision: 10,
        scale: 2
      }).default("0.00"),
      cancellationHours: integer3("cancellation_hours").default(24),
      // Duration & Scheduling
      estimatedDuration: integer3("estimated_duration_minutes"),
      minimumNotice: integer3("minimum_notice_hours").default(24),
      maximumAdvance: integer3("maximum_advance_days").default(30),
      // Commission & Billing
      commissionTo: varchar2("commission_to").default("company"),
      // company, portfolio_manager
      commissionRate: decimal2("commission_rate", {
        precision: 5,
        scale: 2
      }).default("0.00"),
      defaultBillingTo: varchar2("default_billing_to").default("guest"),
      // guest, owner, company
      // Settings
      isActive: boolean3("is_active").default(true),
      isPopular: boolean3("is_popular").default(false),
      tags: text3("tags").array(),
      requirements: text3("requirements"),
      // Analytics
      bookingCount: integer3("booking_count").default(0),
      totalRevenue: decimal2("total_revenue", { precision: 12, scale: 2 }).default(
        "0.00"
      ),
      averageRating: decimal2("average_rating", { precision: 3, scale: 2 }).default(
        "5.00"
      ),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    serviceBookings = pgTable3("service_bookings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      serviceId: integer3("service_id").references(() => marketplaceServices.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Booking Reference
      bookingNumber: varchar2("booking_number").notNull(),
      // Guest Information
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email"),
      guestPhone: varchar2("guest_phone"),
      guestNotes: text3("guest_notes"),
      // Booking Details
      requestedDate: date2("requested_date"),
      requestedTime: varchar2("requested_time"),
      // stored as "HH:MM" format
      estimatedDuration: integer3("estimated_duration_minutes"),
      // Pricing & Billing
      quotedPrice: decimal2("quoted_price", { precision: 10, scale: 2 }),
      finalPrice: decimal2("final_price", { precision: 10, scale: 2 }),
      currency: varchar2("currency").default("THB"),
      billingAssignment: varchar2("billing_assignment").notNull(),
      // guest_billable, owner_expense, company_expense
      // Status Tracking
      status: varchar2("status").default("pending"),
      // pending, confirmed, in_progress, completed, cancelled
      paymentStatus: varchar2("payment_status").default("pending"),
      // pending, paid, refunded
      // Workflow
      requestedBy: varchar2("requested_by").references(() => users.id).notNull(),
      requestedByRole: varchar2("requested_by_role").notNull(),
      approvedBy: varchar2("approved_by").references(() => users.id),
      approvedAt: timestamp3("approved_at"),
      // Vendor Communication
      vendorNotified: boolean3("vendor_notified").default(false),
      vendorNotifiedAt: timestamp3("vendor_notified_at"),
      vendorConfirmed: boolean3("vendor_confirmed").default(false),
      vendorConfirmedAt: timestamp3("vendor_confirmed_at"),
      vendorNotes: text3("vendor_notes"),
      // Service Execution
      startedAt: timestamp3("started_at"),
      completedAt: timestamp3("completed_at"),
      completedBy: varchar2("completed_by").references(() => users.id),
      completionNotes: text3("completion_notes"),
      completionPhotos: text3("completion_photos").array(),
      // Quality & Feedback
      guestRating: integer3("guest_rating"),
      // 1-5 stars
      guestFeedback: text3("guest_feedback"),
      internalNotes: text3("internal_notes"),
      // Special Instructions
      specialRequirements: text3("special_requirements"),
      accessInstructions: text3("access_instructions"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    serviceReviews = pgTable3("service_reviews", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      serviceId: integer3("service_id").references(() => marketplaceServices.id).notNull(),
      bookingId: integer3("booking_id").references(() => serviceBookings.id).notNull(),
      vendorId: integer3("vendor_id").references(() => serviceVendors.id).notNull(),
      // Review Details
      rating: integer3("rating").notNull(),
      // 1-5 stars
      title: varchar2("title"),
      review: text3("review"),
      // Reviewer Information
      reviewerType: varchar2("reviewer_type").notNull(),
      // guest, staff, manager
      reviewerName: varchar2("reviewer_name"),
      isAnonymous: boolean3("is_anonymous").default(false),
      // Review Categories
      qualityRating: integer3("quality_rating"),
      // 1-5
      timelinessRating: integer3("timeliness_rating"),
      // 1-5
      valueRating: integer3("value_rating"),
      // 1-5
      communicationRating: integer3("communication_rating"),
      // 1-5
      // Review Status
      isApproved: boolean3("is_approved").default(true),
      isPublic: boolean3("is_public").default(true),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    serviceAnalytics = pgTable3("service_analytics", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Time Period
      periodType: varchar2("period_type").notNull(),
      // daily, weekly, monthly
      periodStart: date2("period_start").notNull(),
      periodEnd: date2("period_end").notNull(),
      // Service/Vendor Analytics
      serviceId: integer3("service_id").references(() => marketplaceServices.id),
      vendorId: integer3("vendor_id").references(() => serviceVendors.id),
      categoryId: integer3("category_id").references(() => serviceCategories.id),
      // Metrics
      totalBookings: integer3("total_bookings").default(0),
      completedBookings: integer3("completed_bookings").default(0),
      cancelledBookings: integer3("cancelled_bookings").default(0),
      totalRevenue: decimal2("total_revenue", { precision: 12, scale: 2 }).default(
        "0.00"
      ),
      totalCommission: decimal2("total_commission", {
        precision: 12,
        scale: 2
      }).default("0.00"),
      averageRating: decimal2("average_rating", { precision: 3, scale: 2 }),
      averageResponseTime: integer3("average_response_time_hours"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    maintenanceTimelineEntries = pgTable3(
      "maintenance_timeline_entries",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        suggestionId: integer3("suggestion_id").references(() => maintenanceSuggestions.id).notNull(),
        // Timeline Entry Details
        entryType: varchar2("entry_type").notNull(),
        // suggestion_submitted, approved, declined, completed, reminder_sent
        entryTitle: varchar2("entry_title").notNull(),
        entryDescription: text3("entry_description"),
        entryIcon: varchar2("entry_icon").default("wrench"),
        // icon identifier
        // Visibility Settings
        visibleToOwner: boolean3("visible_to_owner").default(true),
        visibleToStaff: boolean3("visible_to_staff").default(true),
        visibleToGuests: boolean3("visible_to_guests").default(false),
        // Associated Users
        createdBy: varchar2("created_by").references(() => users.id).notNull(),
        affectsUsers: text3("affects_users").array(),
        // Array of user IDs who should see this
        createdAt: timestamp3("created_at").defaultNow()
      }
    );
    insertMaintenanceSuggestionSchema = createInsertSchema3(
      maintenanceSuggestions
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMaintenanceApprovalLogSchema = createInsertSchema3(
      maintenanceApprovalLogs
    ).omit({
      id: true,
      createdAt: true
    });
    insertMaintenanceSuggestionSettingsSchema = createInsertSchema3(
      maintenanceSuggestionSettings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMaintenanceTimelineEntrySchema = createInsertSchema3(
      maintenanceTimelineEntries
    ).omit({
      id: true,
      createdAt: true
    });
    insertServiceVendorSchema = createInsertSchema3(
      serviceVendors
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertServiceCategorySchema = createInsertSchema3(
      serviceCategories
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMarketplaceServiceSchema = createInsertSchema3(
      marketplaceServices
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertServiceBookingSchema = createInsertSchema3(
      serviceBookings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertServiceReviewSchema = createInsertSchema3(
      serviceReviews
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertServiceAnalyticsSchema = createInsertSchema3(
      serviceAnalytics
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestBookingSchema = createInsertSchema3(guestBookings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestAiRecommendationSchema = createInsertSchema3(
      guestAiRecommendations
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGuestServiceTimelineSchema = createInsertSchema3(
      guestServiceTimeline
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyAmenitySchema = createInsertSchema3(
      propertyAmenities
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    guestCheckoutSurveys2 = pgTable3("guest_checkout_surveys", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull().default("default"),
      guestId: varchar2("guest_id").notNull(),
      bookingId: integer3("booking_id"),
      propertyId: integer3("property_id"),
      surveyType: varchar2("survey_type").notNull().default("checkout"),
      // checkout, post_checkin, feedback
      // Rating questions (1-5 stars)
      ratingCheckIn: integer3("rating_check_in"),
      ratingCleanliness: integer3("rating_cleanliness"),
      ratingProperty: integer3("rating_property"),
      ratingLocation: integer3("rating_location"),
      ratingTeam: integer3("rating_team"),
      ratingCommunication: integer3("rating_communication"),
      ratingOverall: integer3("rating_overall"),
      // Text feedback
      improvementSuggestions: text3("improvement_suggestions"),
      wouldRecommend: text3("would_recommend"),
      additionalComments: text3("additional_comments"),
      // AI analysis
      sentimentScore: real("sentiment_score"),
      // -1 to 1
      sentimentCategory: varchar2("sentiment_category"),
      // positive, neutral, negative
      averageRating: real("average_rating"),
      flaggedForReview: boolean3("flagged_for_review").default(false),
      // Status and metadata
      submittedAt: timestamp3("submitted_at").defaultNow(),
      reviewedBy: varchar2("reviewed_by"),
      reviewedAt: timestamp3("reviewed_at"),
      adminNotes: text3("admin_notes"),
      // Incentive tracking
      incentiveOffered: varchar2("incentive_offered"),
      incentiveRedeemed: boolean3("incentive_redeemed").default(false),
      incentiveRedeemedAt: timestamp3("incentive_redeemed_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    surveySettings2 = pgTable3("survey_settings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull().default("default"),
      propertyId: integer3("property_id"),
      // Survey triggers
      enablePreCheckout: boolean3("enable_pre_checkout").default(true),
      enablePostCheckin: boolean3("enable_post_checkin").default(false),
      enablePermanentFeedback: boolean3("enable_permanent_feedback").default(true),
      // Timing settings
      preCheckoutDays: integer3("pre_checkout_days").default(1),
      postCheckinDays: integer3("post_checkin_days").default(1),
      // Review platform links
      airbnbReviewLink: varchar2("airbnb_review_link"),
      bookingReviewLink: varchar2("booking_review_link"),
      googleReviewLink: varchar2("google_review_link"),
      // Sentiment thresholds
      positiveThreshold: real("positive_threshold").default(4.5),
      negativeThreshold: real("negative_threshold").default(3),
      // Incentive settings
      incentiveType: varchar2("incentive_type"),
      // coupon, early_checkin, late_checkout, discount
      incentiveValue: varchar2("incentive_value"),
      incentiveDescription: text3("incentive_description"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    surveyAlerts2 = pgTable3("survey_alerts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull().default("default"),
      surveyId: integer3("survey_id").references(() => guestCheckoutSurveys2.id),
      alertType: varchar2("alert_type").notNull(),
      // negative_feedback, low_rating, flagged_review
      severity: varchar2("severity").notNull().default("medium"),
      // low, medium, high, critical
      recipientRoles: json("recipient_roles").$type().default([]),
      // admin, portfolio-manager, staff
      notificationSent: boolean3("notification_sent").default(false),
      notificationSentAt: timestamp3("notification_sent_at"),
      alertMessage: text3("alert_message"),
      actionRequired: boolean3("action_required").default(false),
      resolvedBy: varchar2("resolved_by"),
      resolvedAt: timestamp3("resolved_at"),
      resolutionNotes: text3("resolution_notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    surveyAnalytics2 = pgTable3("survey_analytics", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull().default("default"),
      propertyId: integer3("property_id"),
      period: varchar2("period").notNull(),
      // daily, weekly, monthly, yearly
      periodStart: date2("period_start").notNull(),
      periodEnd: date2("period_end").notNull(),
      totalSurveys: integer3("total_surveys").default(0),
      completedSurveys: integer3("completed_surveys").default(0),
      completionRate: real("completion_rate").default(0),
      averageOverallRating: real("average_overall_rating").default(0),
      averageCheckInRating: real("average_check_in_rating").default(0),
      averageCleanlinessRating: real("average_cleanliness_rating").default(0),
      averagePropertyRating: real("average_property_rating").default(0),
      averageLocationRating: real("average_location_rating").default(0),
      averageTeamRating: real("average_team_rating").default(0),
      averageCommunicationRating: real("average_communication_rating").default(0),
      positiveFeedbackCount: integer3("positive_feedback_count").default(0),
      neutralFeedbackCount: integer3("neutral_feedback_count").default(0),
      negativeFeedbackCount: integer3("negative_feedback_count").default(0),
      publicReviewsGenerated: integer3("public_reviews_generated").default(0),
      internalFlagsCreated: integer3("internal_flags_created").default(0),
      incentivesOffered: integer3("incentives_offered").default(0),
      incentivesRedeemed: integer3("incentives_redeemed").default(0),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    insertGuestCheckoutSurveySchema = createInsertSchema3(
      guestCheckoutSurveys2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertSurveySettingsSchema = createInsertSchema3(
      surveySettings2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertSurveyAlertSchema = createInsertSchema3(surveyAlerts2).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertSurveyAnalyticsSchema = createInsertSchema3(
      surveyAnalytics2
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    invoices = pgTable3("invoices", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      guestId: varchar2("guest_id").notNull(),
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email"),
      bookingId: integer3("booking_id"),
      propertyId: integer3("property_id"),
      messageContent: text3("message_content").notNull(),
      messageType: varchar2("message_type").notNull(),
      // chat, request, feedback, complaint
      priority: varchar2("priority").default("normal"),
      // low, normal, high, urgent
      status: varchar2("status").default("new"),
      // new, acknowledged, in_progress, resolved
      aiProcessed: boolean3("ai_processed").default(false),
      aiKeywords: text3("ai_keywords").array(),
      aiSentiment: varchar2("ai_sentiment"),
      // positive, neutral, negative
      aiConfidence: decimal2("ai_confidence", { precision: 5, scale: 2 }),
      aiSuggestions: text3("ai_suggestions").array(),
      staffResponse: text3("staff_response"),
      respondedBy: varchar2("responded_by"),
      respondedAt: timestamp3("responded_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    aiGeneratedTasks2 = pgTable3("ai_generated_tasks", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      messageId: integer3("message_id").references(() => guestMessages2.id),
      taskId: integer3("task_id"),
      // Reference to main tasks table
      guestId: varchar2("guest_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      department: varchar2("department").notNull(),
      // cleaning, maintenance, pool, garden, general
      taskType: varchar2("task_type").notNull(),
      // issue_report, service_request, complaint
      urgency: varchar2("urgency").notNull(),
      // low, medium, high, critical
      aiDescription: text3("ai_description").notNull(),
      aiKeywords: text3("ai_keywords").array(),
      confidence: decimal2("confidence", { precision: 5, scale: 2 }).notNull(),
      status: varchar2("status").default("pending"),
      // pending, approved, rejected, completed
      assignedTo: varchar2("assigned_to"),
      approvedBy: varchar2("approved_by"),
      approvedAt: timestamp3("approved_at"),
      completedAt: timestamp3("completed_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestDashboardAnalytics = pgTable3("guest_dashboard_analytics", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").notNull(),
      month: varchar2("month").notNull(),
      // YYYY-MM format
      totalMessages: integer3("total_messages").default(0),
      totalServiceRequests: integer3("total_service_requests").default(0),
      averageResponseTime: decimal2("average_response_time", {
        precision: 10,
        scale: 2
      }),
      // in minutes
      guestSatisfactionScore: decimal2("guest_satisfaction_score", {
        precision: 3,
        scale: 2
      }),
      topRequestedServices: text3("top_requested_services").array(),
      commonIssues: text3("common_issues").array(),
      aiTaskCreationRate: decimal2("ai_task_creation_rate", {
        precision: 5,
        scale: 2
      }),
      resolutionRate: decimal2("resolution_rate", { precision: 5, scale: 2 }),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    aiSmartSuggestions = pgTable3("ai_smart_suggestions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id"),
      suggestionType: varchar2("suggestion_type").notNull(),
      // service_upsell, maintenance_improvement, guest_experience
      targetAudience: varchar2("target_audience").notNull(),
      // guest, owner, staff, admin
      suggestionTitle: varchar2("suggestion_title").notNull(),
      suggestionDescription: text3("suggestion_description").notNull(),
      basedOnData: varchar2("based_on_data").notNull(),
      // guest_reviews, message_analysis, service_patterns
      confidence: decimal2("confidence", { precision: 5, scale: 2 }).notNull(),
      potentialRevenue: decimal2("potential_revenue", { precision: 10, scale: 2 }),
      implementationCost: decimal2("implementation_cost", {
        precision: 10,
        scale: 2
      }),
      priority: varchar2("priority").default("medium"),
      // low, medium, high, critical
      status: varchar2("status").default("pending"),
      // pending, reviewed, approved, implemented, rejected
      reviewedBy: varchar2("reviewed_by"),
      reviewedAt: timestamp3("reviewed_at"),
      implementedAt: timestamp3("implemented_at"),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    staffSalarySettings = pgTable3("staff_salary_settings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      staffId: varchar2("staff_id").notNull(),
      // references users.id
      staffName: varchar2("staff_name").notNull(),
      department: varchar2("department").notNull(),
      // housekeeping, pool, maintenance, security, general
      fixedMonthlySalary: decimal2("fixed_monthly_salary", {
        precision: 10,
        scale: 2
      }).notNull(),
      currency: varchar2("currency").default("AUD"),
      hourlyOvertime: decimal2("hourly_overtime", { precision: 10, scale: 2 }),
      emergencyTaskBonus: decimal2("emergency_task_bonus", {
        precision: 10,
        scale: 2
      }),
      regularShiftStart: varchar2("regular_shift_start"),
      // HH:MM format
      regularShiftEnd: varchar2("regular_shift_end"),
      // HH:MM format
      workingDays: text3("working_days").array(),
      // ["monday", "tuesday", ...]
      bankAccountDetails: jsonb3("bank_account_details"),
      // encrypted bank details
      isActive: boolean3("is_active").default(true),
      effectiveFrom: date2("effective_from").notNull(),
      effectiveTo: date2("effective_to"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    staffClockLog = pgTable3("staff_clock_log", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      staffId: varchar2("staff_id").notNull(),
      staffName: varchar2("staff_name").notNull(),
      clockInTime: timestamp3("clock_in_time").notNull(),
      clockOutTime: timestamp3("clock_out_time"),
      clockInReason: varchar2("clock_in_reason"),
      // regular_shift, overtime_requested, emergency_call
      clockOutReason: varchar2("clock_out_reason"),
      // shift_end, emergency_complete, overtime_complete
      totalHours: decimal2("total_hours", { precision: 10, scale: 2 }),
      regularHours: decimal2("regular_hours", { precision: 10, scale: 2 }),
      overtimeHours: decimal2("overtime_hours", { precision: 10, scale: 2 }),
      overtimeType: varchar2("overtime_type"),
      // pre_approved, emergency, requested
      overtimeApprovalStatus: varchar2("overtime_approval_status").default(
        "pending"
      ),
      // pending, approved, rejected
      approvedBy: varchar2("approved_by"),
      approvedAt: timestamp3("approved_at"),
      rejectionReason: text3("rejection_reason"),
      location: jsonb3("location"),
      // GPS coordinates if available
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    emergencyTaskBonuses = pgTable3("emergency_task_bonuses", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      taskId: integer3("task_id").notNull(),
      // references tasks.id
      staffId: varchar2("staff_id").notNull(),
      staffName: varchar2("staff_name").notNull(),
      emergencyType: varchar2("emergency_type").notNull(),
      // water_leak, electrical, security, guest_emergency
      bonusAmount: decimal2("bonus_amount", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").default("AUD"),
      taskCompletedAt: timestamp3("task_completed_at"),
      bonusApprovalStatus: varchar2("bonus_approval_status").default("pending"),
      // pending, approved, paid
      approvedBy: varchar2("approved_by"),
      approvedAt: timestamp3("approved_at"),
      paidAt: timestamp3("paid_at"),
      paymentReference: varchar2("payment_reference"),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyLocalContacts = pgTable3("property_local_contacts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      category: varchar2("category").notNull(),
      // emergency_health, on_site_staff, transportation, wellness_spa, culinary_services, tours_experiences, convenience_delivery
      contactName: varchar2("contact_name").notNull(),
      contactType: varchar2("contact_type").notNull(),
      // hospital, police, host, housekeeper, taxi, spa_therapist, chef, tour_operator, delivery_app
      phoneNumber: varchar2("phone_number"),
      whatsappNumber: varchar2("whatsapp_number"),
      email: varchar2("email"),
      address: text3("address"),
      googleMapsLink: text3("google_maps_link"),
      websiteUrl: text3("website_url"),
      bookingUrl: text3("booking_url"),
      menuUrl: text3("menu_url"),
      qrCodeUrl: text3("qr_code_url"),
      appStoreLink: text3("app_store_link"),
      playStoreLink: text3("play_store_link"),
      servicesOffered: text3("services_offered"),
      // JSON string or comma-separated
      specialNotes: text3("special_notes"),
      availabilityHours: varchar2("availability_hours"),
      requiresManagerConfirmation: boolean3("requires_manager_confirmation").default(
        false
      ),
      isActive: boolean3("is_active").default(true),
      displayOrder: integer3("display_order").default(0),
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    contactTemplateZones = pgTable3("contact_template_zones", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      zoneName: varchar2("zone_name").notNull(),
      // "North Samui", "Bangkok condos", etc.
      templateName: varchar2("template_name").notNull(),
      isDefault: boolean3("is_default").default(false),
      contactsData: text3("contacts_data").notNull(),
      // JSON string of default contacts
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    monthlyPayroll = pgTable3("monthly_payroll", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      staffId: varchar2("staff_id").notNull(),
      staffName: varchar2("staff_name").notNull(),
      payrollMonth: varchar2("payroll_month").notNull(),
      // YYYY-MM format
      fixedSalary: decimal2("fixed_salary", { precision: 10, scale: 2 }).notNull(),
      overtimeHours: decimal2("overtime_hours", { precision: 10, scale: 2 }).default(
        "0"
      ),
      overtimePay: decimal2("overtime_pay", { precision: 10, scale: 2 }).default(
        "0"
      ),
      emergencyBonuses: decimal2("emergency_bonuses", {
        precision: 10,
        scale: 2
      }).default("0"),
      totalEarnings: decimal2("total_earnings", {
        precision: 10,
        scale: 2
      }).notNull(),
      deductions: decimal2("deductions", { precision: 10, scale: 2 }).default("0"),
      netPay: decimal2("net_pay", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").default("AUD"),
      paymentStatus: varchar2("payment_status").default("pending"),
      // pending, paid, overdue
      paymentMethod: varchar2("payment_method"),
      // bank_transfer, cash, cheque
      paymentDate: date2("payment_date"),
      paymentReference: varchar2("payment_reference"),
      paymentReceiptUrl: varchar2("payment_receipt_url"),
      processedBy: varchar2("processed_by"),
      processedAt: timestamp3("processed_at"),
      staffConfirmed: boolean3("staff_confirmed").default(false),
      staffConfirmedAt: timestamp3("staff_confirmed_at"),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    payrollSummary = pgTable3("payroll_summary", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      summaryMonth: varchar2("summary_month").notNull(),
      // YYYY-MM format
      totalStaff: integer3("total_staff").notNull(),
      totalFixedSalaries: decimal2("total_fixed_salaries", {
        precision: 10,
        scale: 2
      }).notNull(),
      totalOvertimePay: decimal2("total_overtime_pay", {
        precision: 10,
        scale: 2
      }).default("0"),
      totalEmergencyBonuses: decimal2("total_emergency_bonuses", {
        precision: 10,
        scale: 2
      }).default("0"),
      totalPayroll: decimal2("total_payroll", { precision: 10, scale: 2 }).notNull(),
      departmentBreakdown: jsonb3("department_breakdown"),
      // {housekeeping: 5000, pool: 2000, ...}
      overtimeHoursBreakdown: jsonb3("overtime_hours_breakdown"),
      emergencyTasksCount: integer3("emergency_tasks_count").default(0),
      paymentCompletionRate: decimal2("payment_completion_rate", {
        precision: 5,
        scale: 2
      }),
      averageOvertimeHours: decimal2("average_overtime_hours", {
        precision: 10,
        scale: 2
      }),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestCommunicationNotifications = pgTable3(
      "guest_communication_notifications",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        messageId: integer3("message_id").references(() => guestMessages2.id),
        serviceRequestId: integer3("service_request_id").references(
          () => guestAddonServiceRequests.id
        ),
        taskId: integer3("task_id").references(() => aiGeneratedTasks2.id),
        recipientId: varchar2("recipient_id").notNull(),
        recipientRole: varchar2("recipient_role").notNull(),
        // staff, manager, admin
        notificationType: varchar2("notification_type").notNull(),
        // new_message, urgent_issue, service_request, task_created
        title: varchar2("title").notNull(),
        message: text3("message").notNull(),
        isRead: boolean3("is_read").default(false),
        readAt: timestamp3("read_at"),
        createdAt: timestamp3("created_at").defaultNow()
      }
    );
    guestPortalSettings = pgTable3("guest_portal_settings", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id"),
      enableGuestPortal: boolean3("enable_guest_portal").default(true),
      enableAiAssistant: boolean3("enable_ai_assistant").default(true),
      enableServiceBooking: boolean3("enable_service_booking").default(true),
      enableChatSystem: boolean3("enable_chat_system").default(true),
      autoCreateTasks: boolean3("auto_create_tasks").default(true),
      aiConfidenceThreshold: decimal2("ai_confidence_threshold", {
        precision: 3,
        scale: 2
      }).default("0.75"),
      responseTimeTarget: integer3("response_time_target").default(30),
      // in minutes
      welcomeMessage: text3("welcome_message"),
      contactInfo: text3("contact_info"),
      emergencyContact: varchar2("emergency_contact"),
      checkInInstructions: text3("check_in_instructions"),
      checkOutInstructions: text3("check_out_instructions"),
      wifiPassword: varchar2("wifi_password"),
      localRecommendations: text3("local_recommendations").array(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    guestMessagesRelations = relations(
      guestMessages2,
      ({ one, many }) => ({
        organization: one(organizations, {
          fields: [guestMessages2.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [guestMessages2.propertyId],
          references: [properties.id]
        }),
        aiGeneratedTasks: many(aiGeneratedTasks2),
        notifications: many(guestCommunicationNotifications)
      })
    );
    aiGeneratedTasksRelations = relations(
      aiGeneratedTasks2,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [aiGeneratedTasks2.organizationId],
          references: [organizations.id]
        }),
        message: one(guestMessages2, {
          fields: [aiGeneratedTasks2.messageId],
          references: [guestMessages2.id]
        }),
        property: one(properties, {
          fields: [aiGeneratedTasks2.propertyId],
          references: [properties.id]
        })
      })
    );
    aiSmartSuggestionsRelations = relations(
      aiSmartSuggestions,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [aiSmartSuggestions.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [aiSmartSuggestions.propertyId],
          references: [properties.id]
        })
      })
    );
    guestCommunicationNotificationsRelations = relations(
      guestCommunicationNotifications,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [guestCommunicationNotifications.organizationId],
          references: [organizations.id]
        }),
        message: one(guestMessages2, {
          fields: [guestCommunicationNotifications.messageId],
          references: [guestMessages2.id]
        }),
        serviceRequest: one(guestAddonServiceRequests, {
          fields: [guestCommunicationNotifications.serviceRequestId],
          references: [guestAddonServiceRequests.id]
        }),
        aiTask: one(aiGeneratedTasks2, {
          fields: [guestCommunicationNotifications.taskId],
          references: [aiGeneratedTasks2.id]
        })
      })
    );
    guestPortalSettingsRelations = relations(
      guestPortalSettings,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [guestPortalSettings.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [guestPortalSettings.propertyId],
          references: [properties.id]
        })
      })
    );
    propertyPayoutRules = pgTable3(
      "property_payout_rules",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        platform: varchar2("platform").notNull(),
        // airbnb, direct, booking_com, vrbo, agoda, marriott
        ownerPercentage: decimal2("owner_percentage", {
          precision: 5,
          scale: 2
        }).default("70.00"),
        // 70%
        managementPercentage: decimal2("management_percentage", {
          precision: 5,
          scale: 2
        }).default("30.00"),
        // 30%
        stripeFeePercentage: decimal2("stripe_fee_percentage", {
          precision: 5,
          scale: 2
        }).default("5.00"),
        // 5%
        isActive: boolean3("is_active").default(true),
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_payout_rules_org").on(table.organizationId),
        index("IDX_payout_rules_property").on(table.propertyId),
        index("IDX_payout_rules_platform").on(table.platform)
      ]
    );
    bookingIncomeRecords = pgTable3(
      "booking_income_records",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        bookingId: integer3("booking_id").references(() => bookings.id),
        sourceChannel: varchar2("source_channel").notNull(),
        // airbnb, direct, booking_com, etc.
        guestName: varchar2("guest_name").notNull(),
        checkInDate: date2("check_in_date").notNull(),
        checkOutDate: date2("check_out_date").notNull(),
        // OTA Dual Commission Tracking
        guestTotalPrice: decimal2("guest_total_price", {
          precision: 10,
          scale: 2
        }).notNull(),
        // What guest paid to OTA
        platformPayout: decimal2("platform_payout", {
          precision: 10,
          scale: 2
        }).notNull(),
        // What host receives after OTA commission
        otaCommissionAmount: decimal2("ota_commission_amount", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        // OTA commission deducted
        // Legacy field for backward compatibility
        totalRentalIncome: decimal2("total_rental_income", {
          precision: 10,
          scale: 2
        }).notNull(),
        // Will map to platformPayout
        routingApplied: varchar2("routing_applied").notNull(),
        // rule_id reference or 'manual_override'
        ownerAmount: decimal2("owner_amount", { precision: 10, scale: 2 }).notNull(),
        managementAmount: decimal2("management_amount", {
          precision: 10,
          scale: 2
        }).notNull(),
        stripeFeeAmount: decimal2("stripe_fee_amount", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        managementFeePercentage: decimal2("management_fee_percentage", {
          precision: 5,
          scale: 2
        }).notNull(),
        actualAmountReceived: decimal2("actual_amount_received", {
          precision: 10,
          scale: 2
        }),
        payoutStatus: varchar2("payout_status").default("pending"),
        // pending, processed, disputed
        notes: text3("notes"),
        processedBy: varchar2("processed_by"),
        // admin/PM user id
        processedAt: timestamp3("processed_at"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_booking_income_org").on(table.organizationId),
        index("IDX_booking_income_property").on(table.propertyId),
        index("IDX_booking_income_channel").on(table.sourceChannel),
        index("IDX_booking_income_dates").on(table.checkInDate, table.checkOutDate)
      ]
    );
    ownerBalanceRequests = pgTable3(
      "owner_balance_requests",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        ownerId: varchar2("owner_id").references(() => users.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        requestType: varchar2("request_type").notNull(),
        // payout_request, invoice_payment
        requestedAmount: decimal2("requested_amount", {
          precision: 10,
          scale: 2
        }).notNull(),
        currentBalance: decimal2("current_balance", {
          precision: 10,
          scale: 2
        }).notNull(),
        status: varchar2("status").default("pending"),
        // pending, approved, payment_uploaded, confirmed, completed
        portfolioManagerId: varchar2("portfolio_manager_id").references(
          () => users.id
        ),
        adminId: varchar2("admin_id").references(() => users.id),
        paymentSlipUrl: varchar2("payment_slip_url"),
        uploadedBy: varchar2("uploaded_by"),
        // admin/PM user id
        confirmedBy: varchar2("confirmed_by"),
        // owner user id
        notes: text3("notes"),
        requestedAt: timestamp3("requested_at").defaultNow(),
        approvedAt: timestamp3("approved_at"),
        paymentUploadedAt: timestamp3("payment_uploaded_at"),
        confirmedAt: timestamp3("confirmed_at"),
        completedAt: timestamp3("completed_at"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_balance_requests_org").on(table.organizationId),
        index("IDX_balance_requests_owner").on(table.ownerId),
        index("IDX_balance_requests_status").on(table.status)
      ]
    );
    commissionPayouts = pgTable3(
      "commission_payouts",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").references(() => users.id).notNull(),
        userRole: varchar2("user_role").notNull(),
        // referral_agent, portfolio_manager
        propertyId: integer3("property_id").references(() => properties.id),
        period: varchar2("period").notNull(),
        // YYYY-MM format
        baseCommissionAmount: decimal2("base_commission_amount", {
          precision: 10,
          scale: 2
        }).notNull(),
        commissionPercentage: decimal2("commission_percentage", {
          precision: 5,
          scale: 2
        }).notNull(),
        // 10% or 50%
        finalPayoutAmount: decimal2("final_payout_amount", {
          precision: 10,
          scale: 2
        }).notNull(),
        payoutCycle: varchar2("payout_cycle").default("monthly"),
        // monthly, bi_weekly, custom
        status: varchar2("status").default("pending"),
        // pending, approved, paid
        notes: text3("notes"),
        approvedBy: varchar2("approved_by"),
        // admin user id
        paidAt: timestamp3("paid_at"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_commission_payouts_org").on(table.organizationId),
        index("IDX_commission_payouts_user").on(table.userId),
        index("IDX_commission_payouts_period").on(table.period)
      ]
    );
    propertyTimelineEvents = pgTable3(
      "property_timeline_events",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        eventType: varchar2("event_type").notNull(),
        // booking_income, payout_request, commission_payout, invoice_payment
        eventTitle: varchar2("event_title").notNull(),
        eventDescription: text3("event_description"),
        relatedRecordId: integer3("related_record_id"),
        // reference to booking_income_records, owner_balance_requests, etc.
        amount: decimal2("amount", { precision: 10, scale: 2 }),
        userId: varchar2("user_id").references(() => users.id),
        // who performed the action
        metadata: jsonb3("metadata"),
        // additional event data
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_timeline_org").on(table.organizationId),
        index("IDX_timeline_property").on(table.propertyId),
        index("IDX_timeline_type").on(table.eventType),
        index("IDX_timeline_date").on(table.createdAt)
      ]
    );
    platformAnalytics = pgTable3(
      "platform_analytics",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        analyticsType: varchar2("analytics_type").notNull(),
        // monthly_summary, platform_breakdown, commission_summary
        period: varchar2("period").notNull(),
        // YYYY-MM format
        platform: varchar2("platform"),
        // airbnb, direct, booking_com, etc.
        totalRentalIncome: decimal2("total_rental_income", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        totalCommissionEarned: decimal2("total_commission_earned", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        totalAddonServices: decimal2("total_addon_services", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        averageNightlyRate: decimal2("average_nightly_rate", {
          precision: 10,
          scale: 2
        }).default("0.00"),
        occupancyRate: decimal2("occupancy_rate", {
          precision: 5,
          scale: 2
        }).default("0.00"),
        // percentage
        bookingCount: integer3("booking_count").default(0),
        metadata: jsonb3("metadata"),
        // additional analytics data
        generatedAt: timestamp3("generated_at").defaultNow(),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_analytics_org").on(table.organizationId),
        index("IDX_analytics_property").on(table.propertyId),
        index("IDX_analytics_period").on(table.period),
        index("IDX_analytics_type").on(table.analyticsType)
      ]
    );
    propertyPayoutRulesRelations = relations(
      propertyPayoutRules,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [propertyPayoutRules.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [propertyPayoutRules.propertyId],
          references: [properties.id]
        })
      })
    );
    bookingIncomeRecordsRelations = relations(
      bookingIncomeRecords,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [bookingIncomeRecords.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [bookingIncomeRecords.propertyId],
          references: [properties.id]
        }),
        booking: one(bookings, {
          fields: [bookingIncomeRecords.bookingId],
          references: [bookings.id]
        })
      })
    );
    ownerBalanceRequestsRelations = relations(
      ownerBalanceRequests,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [ownerBalanceRequests.organizationId],
          references: [organizations.id]
        }),
        owner: one(users, {
          fields: [ownerBalanceRequests.ownerId],
          references: [users.id]
        }),
        property: one(properties, {
          fields: [ownerBalanceRequests.propertyId],
          references: [properties.id]
        }),
        portfolioManager: one(users, {
          fields: [ownerBalanceRequests.portfolioManagerId],
          references: [users.id]
        }),
        admin: one(users, {
          fields: [ownerBalanceRequests.adminId],
          references: [users.id]
        })
      })
    );
    commissionPayoutsRelations = relations(
      commissionPayouts,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [commissionPayouts.organizationId],
          references: [organizations.id]
        }),
        user: one(users, {
          fields: [commissionPayouts.userId],
          references: [users.id]
        }),
        property: one(properties, {
          fields: [commissionPayouts.propertyId],
          references: [properties.id]
        })
      })
    );
    propertyTimelineEventsRelations = relations(
      propertyTimelineEvents,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [propertyTimelineEvents.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [propertyTimelineEvents.propertyId],
          references: [properties.id]
        }),
        user: one(users, {
          fields: [propertyTimelineEvents.userId],
          references: [users.id]
        })
      })
    );
    platformAnalyticsRelations = relations(
      platformAnalytics,
      ({ one }) => ({
        organization: one(organizations, {
          fields: [platformAnalytics.organizationId],
          references: [organizations.id]
        }),
        property: one(properties, {
          fields: [platformAnalytics.propertyId],
          references: [properties.id]
        })
      })
    );
    insertPropertyPayoutRuleSchema = createInsertSchema3(
      propertyPayoutRules
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBookingIncomeRecordSchema = createInsertSchema3(
      bookingIncomeRecords
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOwnerBalanceRequestSchema = createInsertSchema3(
      ownerBalanceRequests
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertCommissionPayoutSchema = createInsertSchema3(
      commissionPayouts
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyTimelineEventSchema = createInsertSchema3(
      propertyTimelineEvents
    ).omit({
      id: true,
      createdAt: true
    });
    insertPlatformAnalyticsSchema = createInsertSchema3(
      platformAnalytics
    ).omit({
      id: true,
      createdAt: true
    });
    staffOvertimeSessions = pgTable3(
      "staff_overtime_sessions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        // Session Details
        sessionDate: date2("session_date").notNull(),
        clockInTime: timestamp3("clock_in_time").notNull(),
        clockOutTime: timestamp3("clock_out_time"),
        totalHours: decimal2("total_hours", { precision: 5, scale: 2 }),
        // Task Information
        taskId: integer3("task_id").references(() => tasks.id),
        taskDescription: text3("task_description"),
        // Manual description if no task linked
        workLocation: varchar2("work_location"),
        // Villa X, Property Y, etc.
        workType: varchar2("work_type").default("overtime"),
        // overtime, emergency, special_project
        // Emergency/After Hours
        isEmergency: boolean3("is_emergency").default(false),
        isAfterHours: boolean3("is_after_hours").default(false),
        // Auto-set for work after 8 PM
        emergencyReason: text3("emergency_reason"),
        // Approval and Compensation
        status: varchar2("status").default("pending"),
        // pending, approved, rejected
        approvedBy: varchar2("approved_by").references(() => users.id),
        approvedAt: timestamp3("approved_at"),
        compensationType: varchar2("compensation_type"),
        // paid, time_off, pending
        compensationAmount: decimal2("compensation_amount", {
          precision: 10,
          scale: 2
        }),
        compensationRate: decimal2("compensation_rate", { precision: 5, scale: 2 }),
        // Hourly rate for overtime
        // Notes and Proof
        staffNotes: text3("staff_notes"),
        adminNotes: text3("admin_notes"),
        proofImages: jsonb3("proof_images"),
        // Array of image URLs for verification
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_overtime_sessions_staff").on(table.staffId),
        index("IDX_overtime_sessions_date").on(table.sessionDate),
        index("IDX_overtime_sessions_status").on(table.status)
      ]
    );
    currencyExchangeRates = pgTable3(
      "currency_exchange_rates",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        // Rate Details
        fromCurrency: varchar2("from_currency", { length: 3 }).notNull(),
        // USD, EUR, GBP, etc.
        toCurrency: varchar2("to_currency", { length: 3 }).notNull(),
        // THB is base
        exchangeRate: decimal2("exchange_rate", {
          precision: 10,
          scale: 6
        }).notNull(),
        rateDate: date2("rate_date").notNull(),
        // Rate Source
        rateSource: varchar2("rate_source").default("manual"),
        // manual, api, bank
        apiProvider: varchar2("api_provider"),
        // xe.com, currencyapi.com, etc.
        // Metadata
        isActive: boolean3("is_active").default(true),
        updatedBy: varchar2("updated_by").references(() => users.id),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_exchange_rates_org").on(table.organizationId),
        index("IDX_exchange_rates_currencies").on(
          table.fromCurrency,
          table.toCurrency
        ),
        index("IDX_exchange_rates_date").on(table.rateDate)
      ]
    );
    multiCurrencyFinances = pgTable3(
      "multi_currency_finances",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        // Transaction Details
        transactionDate: date2("transaction_date").notNull(),
        description: text3("description").notNull(),
        category: varchar2("category").notNull(),
        // income, expense, transfer
        subcategory: varchar2("subcategory"),
        // booking, utilities, maintenance, etc.
        // Multi-Currency Support
        originalCurrency: varchar2("original_currency", { length: 3 }).notNull(),
        originalAmount: decimal2("original_amount", {
          precision: 12,
          scale: 2
        }).notNull(),
        thbAmount: decimal2("thb_amount", { precision: 12, scale: 2 }).notNull(),
        exchangeRate: decimal2("exchange_rate", {
          precision: 10,
          scale: 6
        }).notNull(),
        exchangeRateId: integer3("exchange_rate_id").references(
          () => currencyExchangeRates.id
        ),
        // Associations
        propertyId: integer3("property_id").references(() => properties.id),
        bookingId: integer3("booking_id").references(() => bookings.id),
        ownerId: varchar2("owner_id").references(() => users.id),
        processedBy: varchar2("processed_by").references(() => users.id),
        // Export and Integration
        exportedToQuickbooks: boolean3("exported_to_quickbooks").default(false),
        quickbooksId: varchar2("quickbooks_id"),
        exportedToGoogleSheets: boolean3("exported_to_google_sheets").default(false),
        googleSheetsRowId: varchar2("google_sheets_row_id"),
        // Attachments and Proof
        receiptUrl: varchar2("receipt_url"),
        invoiceNumber: varchar2("invoice_number"),
        referenceNumber: varchar2("reference_number"),
        // Status and Approval
        status: varchar2("status").default("pending"),
        // pending, approved, rejected
        approvedBy: varchar2("approved_by").references(() => users.id),
        approvedAt: timestamp3("approved_at"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_multi_currency_org").on(table.organizationId),
        index("IDX_multi_currency_date").on(table.transactionDate),
        index("IDX_multi_currency_property").on(table.propertyId),
        index("IDX_multi_currency_owner").on(table.ownerId),
        index("IDX_multi_currency_currency").on(table.originalCurrency)
      ]
    );
    quickbooksIntegration = pgTable3(
      "quickbooks_integration",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        // QuickBooks Credentials (encrypted)
        companyId: varchar2("company_id").notNull(),
        accessToken: text3("access_token"),
        // Encrypted
        refreshToken: text3("refresh_token"),
        // Encrypted
        realmId: varchar2("realm_id"),
        // Integration Settings
        isActive: boolean3("is_active").default(false),
        autoSync: boolean3("auto_sync").default(false),
        syncFrequency: varchar2("sync_frequency").default("daily"),
        // manual, daily, weekly
        lastSyncAt: timestamp3("last_sync_at"),
        // Sync Configuration
        syncIncome: boolean3("sync_income").default(true),
        syncExpenses: boolean3("sync_expenses").default(true),
        syncInvoices: boolean3("sync_invoices").default(true),
        syncPayments: boolean3("sync_payments").default(true),
        // Error Tracking
        lastError: text3("last_error"),
        errorCount: integer3("error_count").default(0),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [index("IDX_quickbooks_org").on(table.organizationId)]
    );
    propertyFinanceSettings = pgTable3(
      "property_finance_settings",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        ownerId: varchar2("owner_id").references(() => users.id).notNull(),
        // Output Preferences
        financeOutputMode: varchar2("finance_output_mode").default("system_reports"),
        // system_reports, google_sheets, both
        preferredCurrency: varchar2("preferred_currency", { length: 3 }).default(
          "THB"
        ),
        // QuickBooks Settings
        enableQuickbooksSync: boolean3("enable_quickbooks_sync").default(false),
        quickbooksCustomerId: varchar2("quickbooks_customer_id"),
        quickbooksItemId: varchar2("quickbooks_item_id"),
        // Google Sheets Settings
        googleSheetsUrl: varchar2("google_sheets_url"),
        googleSheetsTabName: varchar2("google_sheets_tab_name").default("Finances"),
        lastGoogleSheetsSync: timestamp3("last_google_sheets_sync"),
        // Report Settings
        includeInMonthlyReports: boolean3("include_in_monthly_reports").default(
          true
        ),
        emailReportsTo: varchar2("email_reports_to"),
        reportFrequency: varchar2("report_frequency").default("monthly"),
        // weekly, monthly, quarterly
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_property_finance_org").on(table.organizationId),
        index("IDX_property_finance_property").on(table.propertyId),
        index("IDX_property_finance_owner").on(table.ownerId)
      ]
    );
    financeExportLogs = pgTable3(
      "finance_export_logs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        // Export Details
        exportType: varchar2("export_type").notNull(),
        // excel, csv, pdf, quickbooks, google_sheets
        exportFormat: varchar2("export_format"),
        // monthly_summary, annual_report, detailed_breakdown
        dateRange: varchar2("date_range").notNull(),
        // 2025-01, 2025-Q1, 2025
        // Filters Applied
        propertyIds: jsonb3("property_ids"),
        // Array of property IDs
        ownerIds: jsonb3("owner_ids"),
        // Array of owner IDs
        currencies: jsonb3("currencies"),
        // Array of currencies included
        categories: jsonb3("categories"),
        // Array of categories
        // Export Results
        status: varchar2("status").default("pending"),
        // pending, completed, failed
        fileUrl: varchar2("file_url"),
        fileName: varchar2("file_name"),
        fileSize: integer3("file_size"),
        // In bytes
        recordCount: integer3("record_count"),
        // Error Handling
        errorMessage: text3("error_message"),
        // User and Timing
        requestedBy: varchar2("requested_by").references(() => users.id).notNull(),
        completedAt: timestamp3("completed_at"),
        expiresAt: timestamp3("expires_at"),
        // When file download expires
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_export_logs_org").on(table.organizationId),
        index("IDX_export_logs_type").on(table.exportType),
        index("IDX_export_logs_user").on(table.requestedBy),
        index("IDX_export_logs_date").on(table.dateRange)
      ]
    );
    financeReportTemplates = pgTable3(
      "finance_report_templates",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        // Template Details
        templateName: varchar2("template_name").notNull(),
        templateType: varchar2("template_type").notNull(),
        // monthly_summary, annual_report, owner_statement
        description: text3("description"),
        // Configuration
        includedFields: jsonb3("included_fields").notNull(),
        // Array of field names
        groupBy: jsonb3("group_by"),
        // Array of grouping fields
        sortBy: jsonb3("sort_by"),
        // Array of sorting fields
        filters: jsonb3("filters"),
        // Default filters to apply
        // Formatting
        currency: varchar2("currency", { length: 3 }).default("THB"),
        dateFormat: varchar2("date_format").default("DD/MM/YYYY"),
        numberFormat: varchar2("number_format").default("en-US"),
        // Branding
        includeLogo: boolean3("include_logo").default(true),
        headerText: text3("header_text"),
        footerText: text3("footer_text"),
        // Sharing
        isDefault: boolean3("is_default").default(false),
        isPublic: boolean3("is_public").default(false),
        // Can be used by other orgs
        createdBy: varchar2("created_by").references(() => users.id).notNull(),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_report_templates_org").on(table.organizationId),
        index("IDX_report_templates_type").on(table.templateType),
        index("IDX_report_templates_creator").on(table.createdBy)
      ]
    );
    occupancyRates = pgTable3(
      "occupancy_rates",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Time Period
        periodType: varchar2("period_type").notNull(),
        // daily, weekly, monthly, quarterly, yearly
        periodValue: varchar2("period_value").notNull(),
        // 2025-01-15, 2025-W03, 2025-01, 2025-Q1, 2025
        // Occupancy Data
        totalDays: integer3("total_days").notNull(),
        occupiedDays: integer3("occupied_days").notNull(),
        occupancyRate: decimal2("occupancy_rate", {
          precision: 5,
          scale: 2
        }).notNull(),
        // Percentage
        // Revenue Data
        totalRevenue: decimal2("total_revenue", { precision: 12, scale: 2 }).default(
          "0.00"
        ),
        currency: varchar2("currency", { length: 3 }).default("THB"),
        averageDailyRate: decimal2("average_daily_rate", { precision: 8, scale: 2 }),
        revenuePerAvailableRoom: decimal2("revenue_per_available_room", {
          precision: 8,
          scale: 2
        }),
        // Booking Data
        totalBookings: integer3("total_bookings").default(0),
        averageStayLength: decimal2("average_stay_length", {
          precision: 4,
          scale: 1
        }),
        // Auto-calculated
        calculatedAt: timestamp3("calculated_at").defaultNow(),
        calculatedBy: varchar2("calculated_by").references(() => users.id),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_occupancy_org").on(table.organizationId),
        index("IDX_occupancy_property").on(table.propertyId),
        index("IDX_occupancy_period").on(table.periodType, table.periodValue)
      ]
    );
    insertCurrencyExchangeRateSchema = createInsertSchema3(
      currencyExchangeRates
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMultiCurrencyFinanceSchema = createInsertSchema3(
      multiCurrencyFinances
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertQuickbooksIntegrationSchema = createInsertSchema3(
      quickbooksIntegration
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyFinanceSettingsSchema = createInsertSchema3(
      propertyFinanceSettings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertFinanceExportLogSchema = createInsertSchema3(
      financeExportLogs
    ).omit({
      id: true,
      createdAt: true
    });
    insertFinanceReportTemplateSchema = createInsertSchema3(
      financeReportTemplates
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOccupancyRateSchema = createInsertSchema3(
      occupancyRates
    ).omit({
      id: true,
      createdAt: true
    });
    insertCommunicationChannelSchema = createInsertSchema3(
      communicationChannels
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertChannelMemberSchema = createInsertSchema3(
      channelMembers
    ).omit({
      id: true,
      joinedAt: true
    });
    insertInternalMessageSchema = createInsertSchema3(
      internalMessages
    ).omit({
      id: true,
      sentAt: true
    });
    insertOwnerPmCommunicationSchema = createInsertSchema3(
      ownerPmCommunication
    ).omit({
      id: true,
      sentAt: true
    });
    insertGuestSmartRequestSchema = createInsertSchema3(
      guestSmartRequests
    ).omit({
      id: true,
      createdAt: true
    });
    insertCommunicationLogSchema = createInsertSchema3(
      communicationLogs
    ).omit({
      id: true,
      createdAt: true
    });
    insertSmartRequestConfigSchema = createInsertSchema3(
      smartRequestConfig
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    auditTrail = pgTable3(
      "audit_trail",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").notNull(),
        // ID of user performing action
        userRole: varchar2("user_role").notNull(),
        // admin, portfolio-manager, etc.
        userName: varchar2("user_name").notNull(),
        // Name of user performing action
        actionType: varchar2("action_type").notNull(),
        // create, update, delete, approve, override, impersonate
        entityType: varchar2("entity_type").notNull(),
        // task, booking, finance, user, property, etc.
        entityId: varchar2("entity_id").notNull(),
        // ID of affected entity
        entityDescription: varchar2("entity_description"),
        // Human readable description
        oldValues: jsonb3("old_values"),
        // Previous state before change
        newValues: jsonb3("new_values"),
        // New state after change
        changeReason: text3("change_reason"),
        // Reason for the change
        impersonatedUserId: varchar2("impersonated_user_id"),
        // If action was performed via impersonation
        ipAddress: varchar2("ip_address"),
        // IP address of user
        userAgent: text3("user_agent"),
        // Browser/client info
        severity: varchar2("severity").default("medium"),
        // low, medium, high, critical
        isOverride: boolean3("is_override").default(false),
        // Was this an admin override?
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_audit_org_user").on(table.organizationId, table.userId),
        index("IDX_audit_entity").on(table.entityType, table.entityId),
        index("IDX_audit_action_type").on(table.actionType),
        index("IDX_audit_date").on(table.createdAt)
      ]
    );
    adminOverridePermissions = pgTable3(
      "admin_override_permissions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        userId: varchar2("user_id").notNull(),
        // User with override permissions
        userRole: varchar2("user_role").notNull(),
        // admin, portfolio-manager
        entityType: varchar2("entity_type").notNull(),
        // task, finance, booking, property, user
        canCreate: boolean3("can_create").default(false),
        canRead: boolean3("can_read").default(true),
        canUpdate: boolean3("can_update").default(false),
        canDelete: boolean3("can_delete").default(false),
        canApprove: boolean3("can_approve").default(false),
        canOverride: boolean3("can_override").default(false),
        // Can override system restrictions
        canImpersonate: boolean3("can_impersonate").default(false),
        // Can act as other users
        propertyRestrictions: jsonb3("property_restrictions"),
        // Array of property IDs for PM restrictions
        isActive: boolean3("is_active").default(true),
        grantedBy: varchar2("granted_by").notNull(),
        // ID of admin who granted permission
        grantedAt: timestamp3("granted_at").defaultNow(),
        expiresAt: timestamp3("expires_at"),
        // Optional expiration
        notes: text3("notes")
        // Administrative notes
      },
      (table) => [
        index("IDX_override_user").on(table.organizationId, table.userId),
        index("IDX_override_entity").on(table.entityType)
      ]
    );
    impersonationSessions = pgTable3(
      "impersonation_sessions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        adminUserId: varchar2("admin_user_id").notNull(),
        // Admin performing impersonation
        targetUserId: varchar2("target_user_id").notNull(),
        // User being impersonated
        targetUserRole: varchar2("target_user_role").notNull(),
        sessionToken: varchar2("session_token").unique().notNull(),
        // Unique session identifier
        reason: text3("reason").notNull(),
        // Required reason for impersonation
        startedAt: timestamp3("started_at").defaultNow(),
        endedAt: timestamp3("ended_at"),
        // When session ended
        isActive: boolean3("is_active").default(true),
        actionsPerformed: jsonb3("actions_performed"),
        // Log of actions during impersonation
        ipAddress: varchar2("ip_address"),
        userAgent: text3("user_agent")
      },
      (table) => [
        index("IDX_impersonate_admin").on(table.organizationId, table.adminUserId),
        index("IDX_impersonate_target").on(table.targetUserId),
        index("IDX_impersonate_session").on(table.sessionToken)
      ]
    );
    balanceOverrideHistory = pgTable3(
      "balance_override_history",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        targetUserId: varchar2("target_user_id").notNull(),
        // User whose balance was reset
        targetUserRole: varchar2("target_user_role").notNull(),
        adminUserId: varchar2("admin_user_id").notNull(),
        // Admin performing reset
        adminUserName: varchar2("admin_user_name").notNull(),
        overrideType: varchar2("override_type").notNull(),
        // balance_reset, balance_adjustment, payout_override
        entityType: varchar2("entity_type").notNull(),
        // owner_balance, agent_commission, pm_balance
        entityId: varchar2("entity_id"),
        // Reference to specific balance record
        previousValue: decimal2("previous_value", {
          precision: 12,
          scale: 2
        }).notNull(),
        newValue: decimal2("new_value", { precision: 12, scale: 2 }).notNull(),
        adjustmentAmount: decimal2("adjustment_amount", {
          precision: 12,
          scale: 2
        }).notNull(),
        reason: text3("reason").notNull(),
        // Required justification
        approvalRequired: boolean3("approval_required").default(false),
        approvedBy: varchar2("approved_by"),
        // For high-value adjustments
        approvedAt: timestamp3("approved_at"),
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_balance_override_user").on(
          table.organizationId,
          table.targetUserId
        ),
        index("IDX_balance_override_admin").on(table.adminUserId),
        index("IDX_balance_override_type").on(table.overrideType)
      ]
    );
    portfolioManagerAssignments = pgTable3(
      "portfolio_assignments",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        managerId: varchar2("manager_id").notNull(),
        // Portfolio Manager user ID
        propertyId: integer3("property_id").references(() => properties.id),
        commissionRate: decimal2("commission_rate", { precision: 5, scale: 2 }).default("50"),
        assignedAt: timestamp3("assigned_at").defaultNow(),
        unassignedAt: timestamp3("unassigned_at"),
        isActive: boolean3("is_active").default(true)
      },
      (table) => [
        index("IDX_pm_assignment_manager").on(
          table.organizationId,
          table.managerId
        ),
        index("IDX_pm_assignment_property").on(table.propertyId)
      ]
    );
    insertAuditTrailSchema = createInsertSchema3(auditTrail).omit({
      id: true,
      createdAt: true
    });
    insertAdminOverridePermissionSchema = createInsertSchema3(
      adminOverridePermissions
    ).omit({
      id: true,
      grantedAt: true
    });
    insertImpersonationSessionSchema = createInsertSchema3(
      impersonationSessions
    ).omit({
      id: true,
      startedAt: true
    });
    insertBalanceOverrideHistorySchema = createInsertSchema3(
      balanceOverrideHistory
    ).omit({
      id: true,
      createdAt: true
    });
    insertPortfolioManagerAssignmentSchema = createInsertSchema3(
      portfolioManagerAssignments
    ).omit({
      id: true,
      assignedAt: true
    });
    propertyAccessCredentials = pgTable3(
      "property_access_credentials",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Access Details
        accessType: varchar2("access_type").notNull(),
        // door_lock, safe_box, wifi, smart_lock, alarm, gate, parking
        accessName: varchar2("access_name").notNull(),
        // "Front Door Lock", "Master Bedroom Safe", "WiFi Network"
        accessDetails: jsonb3("access_details").notNull(),
        // Code, PIN, password, URL, etc.
        // Smart Lock Integration
        smartLockProvider: varchar2("smart_lock_provider"),
        // ttlock, igloohome, august, schlage
        smartLockApiData: jsonb3("smart_lock_api_data"),
        // API-specific data for sync
        isApiEnabled: boolean3("is_api_enabled").default(false),
        // Visibility Controls
        visibleTo: jsonb3("visible_to").notNull(),
        // ["admin", "pm", "staff", "owner", "guest"]
        guestAccessWindow: boolean3("guest_access_window").default(false),
        // Show to guests only during stay
        // Photos and Documentation
        photoUrl: varchar2("photo_url"),
        // URL to photo of key location/lockbox
        instructions: text3("instructions"),
        // Special instructions for access
        location: varchar2("location"),
        // "Behind the bush", "Under the mat"
        // Security and Maintenance
        lastUpdated: timestamp3("last_updated").defaultNow(),
        codeRotationDays: integer3("code_rotation_days").default(90),
        // Days until code should be rotated
        nextRotationDate: timestamp3("next_rotation_date"),
        rotationRemindersEnabled: boolean3("rotation_reminders_enabled").default(
          true
        ),
        // Audit
        isActive: boolean3("is_active").default(true),
        createdBy: varchar2("created_by").references(() => users.id).notNull(),
        lastModifiedBy: varchar2("last_modified_by").references(() => users.id),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    propertyAccessPhotos = pgTable3("property_access_photos", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      credentialId: integer3("credential_id").references(() => propertyAccessCredentials.id).notNull(),
      // Photo Details
      photoUrl: varchar2("photo_url").notNull(),
      photoDescription: varchar2("photo_description"),
      // "Lockbox behind bush", "Key safe location"
      photoType: varchar2("photo_type").default("location"),
      // location, instruction, reference
      // Metadata
      fileName: varchar2("file_name"),
      fileSize: integer3("file_size"),
      uploadedBy: varchar2("uploaded_by").references(() => users.id).notNull(),
      uploadedAt: timestamp3("uploaded_at").defaultNow(),
      isActive: boolean3("is_active").default(true)
    });
    accessChangeLog = pgTable3("access_change_log", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      credentialId: integer3("credential_id").references(() => propertyAccessCredentials.id).notNull(),
      // Change Details
      changeType: varchar2("change_type").notNull(),
      // created, updated, rotated, deactivated, deleted
      fieldChanged: varchar2("field_changed"),
      // access_details, visibility, instructions
      oldValue: text3("old_value"),
      // Previous value (encrypted)
      newValue: text3("new_value"),
      // New value (encrypted)
      changeReason: varchar2("change_reason"),
      // scheduled_rotation, security_breach, guest_checkout, manual_update
      // Context
      triggeredBy: varchar2("triggered_by"),
      // manual, scheduled, api_sync, security_event
      relatedBookingId: integer3("related_booking_id").references(() => bookings.id),
      // Audit
      changedBy: varchar2("changed_by").references(() => users.id).notNull(),
      changedAt: timestamp3("changed_at").defaultNow(),
      ipAddress: varchar2("ip_address"),
      userAgent: varchar2("user_agent")
    });
    guestAccessSessions = pgTable3("guest_access_sessions", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      credentialId: integer3("credential_id").references(() => propertyAccessCredentials.id).notNull(),
      bookingId: integer3("booking_id").references(() => bookings.id).notNull(),
      // Access Session
      guestName: varchar2("guest_name").notNull(),
      guestEmail: varchar2("guest_email").notNull(),
      accessGrantedAt: timestamp3("access_granted_at").defaultNow(),
      accessExpiresAt: timestamp3("access_expires_at").notNull(),
      // Access Method
      accessMethod: varchar2("access_method").notNull(),
      // qr_code, email_link, sms_link, manual_share
      accessToken: varchar2("access_token"),
      // Unique token for digital access
      qrCodeUrl: varchar2("qr_code_url"),
      // URL to generated QR code
      // Usage Tracking
      viewCount: integer3("view_count").default(0),
      lastViewed: timestamp3("last_viewed"),
      deviceInfo: jsonb3("device_info"),
      // Device details when accessed
      // Status
      isActive: boolean3("is_active").default(true),
      revokedAt: timestamp3("revoked_at"),
      revokedBy: varchar2("revoked_by").references(() => users.id),
      revokedReason: varchar2("revoked_reason")
    });
    smartLockSyncLog = pgTable3("smart_lock_sync_log", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      credentialId: integer3("credential_id").references(() => propertyAccessCredentials.id).notNull(),
      // Sync Details
      provider: varchar2("provider").notNull(),
      // ttlock, igloohome, august
      syncType: varchar2("sync_type").notNull(),
      // update_code, create_temp_code, revoke_access, sync_status
      syncDirection: varchar2("sync_direction").notNull(),
      // to_provider, from_provider, bidirectional
      // API Response
      apiRequest: jsonb3("api_request"),
      // Request payload sent to provider
      apiResponse: jsonb3("api_response"),
      // Response received from provider
      status: varchar2("status").notNull(),
      // success, failed, pending, timeout
      errorMessage: text3("error_message"),
      httpStatusCode: integer3("http_status_code"),
      // Timing
      syncInitiatedBy: varchar2("sync_initiated_by").references(() => users.id),
      syncStartedAt: timestamp3("sync_started_at").defaultNow(),
      syncCompletedAt: timestamp3("sync_completed_at"),
      responseTimeMs: integer3("response_time_ms"),
      // Context
      triggeredBy: varchar2("triggered_by"),
      // manual, scheduled, booking_event, code_rotation
      relatedBookingId: integer3("related_booking_id").references(() => bookings.id)
    });
    codeRotationSchedule = pgTable3("code_rotation_schedule", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      credentialId: integer3("credential_id").references(() => propertyAccessCredentials.id).notNull(),
      // Rotation Settings
      rotationFrequencyDays: integer3("rotation_frequency_days").default(90),
      lastRotationDate: timestamp3("last_rotation_date"),
      nextRotationDate: timestamp3("next_rotation_date").notNull(),
      // Notification Settings
      reminderDaysBefore: integer3("reminder_days_before").default(7),
      // Remind 7 days before rotation
      reminderSent: boolean3("reminder_sent").default(false),
      reminderSentAt: timestamp3("reminder_sent_at"),
      // Automation
      autoRotationEnabled: boolean3("auto_rotation_enabled").default(false),
      autoNotifyStaff: boolean3("auto_notify_staff").default(true),
      autoNotifyOwner: boolean3("auto_notify_owner").default(false),
      // Status
      isActive: boolean3("is_active").default(true),
      pausedUntil: timestamp3("paused_until"),
      // Temporarily pause rotation
      pauseReason: varchar2("pause_reason"),
      // high_occupancy, maintenance, owner_request
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    insertPropertyAccessCredentialSchema = createInsertSchema3(
      propertyAccessCredentials
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyAccessPhotoSchema = createInsertSchema3(
      propertyAccessPhotos
    ).omit({
      id: true,
      uploadedAt: true
    });
    insertAccessChangeLogSchema = createInsertSchema3(
      accessChangeLog
    ).omit({
      id: true,
      changedAt: true
    });
    insertGuestAccessSessionSchema = createInsertSchema3(
      guestAccessSessions
    ).omit({
      id: true,
      accessGrantedAt: true
    });
    insertSmartLockSyncLogSchema = createInsertSchema3(
      smartLockSyncLog
    ).omit({
      id: true,
      syncStartedAt: true
    });
    insertCodeRotationScheduleSchema = createInsertSchema3(
      codeRotationSchedule
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    dailyOperationsSummary = pgTable3(
      "daily_operations_summary",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        operationDate: date2("operation_date").notNull(),
        // Department Task Counts
        cleaningTasks: integer3("cleaning_tasks").default(0),
        cleaningCompleted: integer3("cleaning_completed").default(0),
        poolTasks: integer3("pool_tasks").default(0),
        poolCompleted: integer3("pool_completed").default(0),
        gardenTasks: integer3("garden_tasks").default(0),
        gardenCompleted: integer3("garden_completed").default(0),
        maintenanceTasks: integer3("maintenance_tasks").default(0),
        maintenanceCompleted: integer3("maintenance_completed").default(0),
        generalTasks: integer3("general_tasks").default(0),
        generalCompleted: integer3("general_completed").default(0),
        // Urgency Metrics
        overdueTasks: integer3("overdue_tasks").default(0),
        tasksWithoutProof: integer3("tasks_without_proof").default(0),
        uncleanedCheckinProperties: integer3("uncleaned_checkin_properties").default(
          0
        ),
        unassignedTasks: integer3("unassigned_tasks").default(0),
        // Staff Metrics
        totalStaffScheduled: integer3("total_staff_scheduled").default(0),
        totalTasksAssigned: integer3("total_tasks_assigned").default(0),
        lastUpdated: timestamp3("last_updated").defaultNow(),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_daily_ops_org_date").on(
          table.organizationId,
          table.operationDate
        )
      ]
    );
    dailyStaffAssignments = pgTable3(
      "daily_staff_assignments",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        operationDate: date2("operation_date").notNull(),
        // Shift Information
        shiftStart: varchar2("shift_start"),
        // e.g., "08:00"
        shiftEnd: varchar2("shift_end"),
        // e.g., "17:00"
        isAvailable: boolean3("is_available").default(true),
        unavailableReason: varchar2("unavailable_reason"),
        // sick, vacation, training
        // Task Assignment Summary
        totalTasksAssigned: integer3("total_tasks_assigned").default(0),
        totalTasksCompleted: integer3("total_tasks_completed").default(0),
        departmentFocus: varchar2("department_focus"),
        // primary department for the day
        // Performance Metrics
        avgTaskCompletionTime: integer3("avg_task_completion_time"),
        // in minutes
        taskCompletionRate: decimal2("task_completion_rate", {
          precision: 5,
          scale: 2
        }),
        // percentage
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_staff_assign_date").on(table.operationDate),
        index("IDX_staff_assign_staff").on(table.staffId)
      ]
    );
    dailyPropertyOperations = pgTable3(
      "daily_property_operations",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        operationDate: date2("operation_date").notNull(),
        // Check-in/Check-out Status
        hasCheckin: boolean3("has_checkin").default(false),
        checkinTime: varchar2("checkin_time"),
        hasCheckout: boolean3("has_checkout").default(false),
        checkoutTime: varchar2("checkout_time"),
        // Cleaning Status
        needsCleaning: boolean3("needs_cleaning").default(false),
        cleaningCompleted: boolean3("cleaning_completed").default(false),
        cleaningCompletedAt: timestamp3("cleaning_completed_at"),
        cleaningStaffId: varchar2("cleaning_staff_id").references(() => users.id),
        // Maintenance Tasks
        maintenanceTasks: integer3("maintenance_tasks").default(0),
        maintenanceCompleted: integer3("maintenance_completed").default(0),
        maintenanceOverdue: integer3("maintenance_overdue").default(0),
        // Recurring Services
        recurringServices: integer3("recurring_services").default(0),
        recurringCompleted: integer3("recurring_completed").default(0),
        // Urgency Flags
        isUrgent: boolean3("is_urgent").default(false),
        urgencyReason: varchar2("urgency_reason"),
        // overdue_cleaning, overdue_maintenance, guest_complaint
        // Status Summary
        operationStatus: varchar2("operation_status").default("scheduled"),
        // scheduled, in_progress, completed, delayed
        statusNotes: text3("status_notes"),
        lastUpdated: timestamp3("last_updated").defaultNow(),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_prop_ops_date").on(table.operationDate),
        index("IDX_prop_ops_property").on(table.propertyId),
        index("IDX_prop_ops_urgent").on(table.isUrgent)
      ]
    );
    insertDailyOperationsSummarySchema = createInsertSchema3(
      dailyOperationsSummary
    ).omit({
      id: true,
      lastUpdated: true,
      createdAt: true
    });
    insertDailyStaffAssignmentsSchema = createInsertSchema3(
      dailyStaffAssignments
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertDailyPropertyOperationsSchema = createInsertSchema3(
      dailyPropertyOperations
    ).omit({
      id: true,
      lastUpdated: true,
      createdAt: true
    });
    maintenanceIssues = pgTable3("maintenance_issues", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Issue Details
      issueTitle: varchar2("issue_title").notNull(),
      issueDescription: text3("issue_description").notNull(),
      issueType: varchar2("issue_type").notNull(),
      // AC, Electrical, Plumbing, Pool, Garden, General
      urgencyLevel: varchar2("urgency_level").notNull(),
      // Low, Normal, Urgent
      currentStatus: varchar2("current_status").default("open"),
      // open, in_progress, resolved, closed
      // Assignment & Tracking
      reportedBy: varchar2("reported_by").references(() => users.id).notNull(),
      reportedByName: varchar2("reported_by_name").notNull(),
      assignedTo: varchar2("assigned_to").references(() => users.id),
      assignedToName: varchar2("assigned_to_name"),
      assignedToType: varchar2("assigned_to_type"),
      // staff, contractor, external
      // Resolution Details
      resolvedBy: varchar2("resolved_by").references(() => users.id),
      resolvedByName: varchar2("resolved_by_name"),
      resolutionDate: timestamp3("resolution_date"),
      resolutionNotes: text3("resolution_notes"),
      resolutionPhotos: text3("resolution_photos").array(),
      // Financial
      estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
      actualCost: decimal2("actual_cost", { precision: 10, scale: 2 }),
      receipts: text3("receipts").array(),
      // Array of receipt file URLs
      currency: varchar2("currency").default("THB"),
      // Tracking
      dueDateEstimate: timestamp3("due_date_estimate"),
      startedAt: timestamp3("started_at"),
      completedAt: timestamp3("completed_at"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    propertyServiceHistory = pgTable3("property_service_history", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Service Details
      serviceType: varchar2("service_type").notNull(),
      // renovation, ac_service, pest_control, deep_clean, pool_inspection, septic_service, landscaping
      serviceName: varchar2("service_name").notNull(),
      serviceDescription: text3("service_description"),
      serviceDate: date2("service_date").notNull(),
      // Provider Information
      serviceProvider: varchar2("service_provider"),
      providerContact: varchar2("provider_contact"),
      serviceCategory: varchar2("service_category").notNull(),
      // major_renovation, routine_maintenance, emergency_repair
      // Documentation
      serviceNotes: text3("service_notes"),
      attachments: text3("attachments").array(),
      // Photos, documents, receipts
      serviceCost: decimal2("service_cost", { precision: 10, scale: 2 }),
      currency: varchar2("currency").default("THB"),
      // Quality & Follow-up
      qualityRating: integer3("quality_rating"),
      // 1-5 stars
      followUpRequired: boolean3("follow_up_required").default(false),
      nextServiceDue: date2("next_service_due"),
      serviceWarranty: varchar2("service_warranty"),
      // warranty period
      // Tracking
      createdBy: varchar2("created_by").references(() => users.id).notNull(),
      createdByName: varchar2("created_by_name").notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    maintenanceTaskSuggestions = pgTable3(
      "maintenance_task_suggestions",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Suggestion Details
        suggestionType: varchar2("suggestion_type").notNull(),
        // recurring_service, overdue_maintenance, predictive_alert
        taskType: varchar2("task_type").notNull(),
        // AC, Electrical, Plumbing, Pool, Pest Control, etc.
        suggestionTitle: varchar2("suggestion_title").notNull(),
        suggestionDescription: text3("suggestion_description").notNull(),
        // AI Analysis
        aiConfidence: decimal2("ai_confidence", { precision: 5, scale: 2 }),
        // 0-100%
        basedOnData: varchar2("based_on_data").notNull(),
        // historical_pattern, days_since_last, industry_standard
        lastServiceDate: date2("last_service_date"),
        daysSinceLastService: integer3("days_since_last_service"),
        recommendedInterval: integer3("recommended_interval"),
        // days
        // Priority & Timing
        priorityLevel: varchar2("priority_level").notNull(),
        // low, medium, high, urgent
        suggestedDueDate: date2("suggested_due_date"),
        estimatedCost: decimal2("estimated_cost", { precision: 10, scale: 2 }),
        currency: varchar2("currency").default("THB"),
        // Status & Actions
        suggestionStatus: varchar2("suggestion_status").default("pending"),
        // pending, approved, dismissed, task_created
        approvedBy: varchar2("approved_by").references(() => users.id),
        approvedAt: timestamp3("approved_at"),
        dismissedBy: varchar2("dismissed_by").references(() => users.id),
        dismissedAt: timestamp3("dismissed_at"),
        dismissalReason: text3("dismissal_reason"),
        taskCreatedId: integer3("task_created_id"),
        // Reference to created task
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      }
    );
    propertyUtilities = pgTable3("property_utilities", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Utility Details
      utilityType: varchar2("utility_type").notNull(),
      // electricity, water, internet, pest_control, gas, hoa_fee, custom
      customUtilityName: varchar2("custom_utility_name"),
      // For custom utilities
      provider: varchar2("provider").notNull(),
      accountNumber: varchar2("account_number").notNull(),
      // Billing Information
      billingCycle: varchar2("billing_cycle").notNull(),
      // monthly, quarterly, annually
      averageBillAmount: decimal2("average_bill_amount", {
        precision: 10,
        scale: 2
      }),
      currency: varchar2("currency").default("THB"),
      // Alert Settings
      expectedBillDate: integer3("expected_bill_date"),
      // Day of month (e.g., 17 for 17th)
      alertDaysAfter: integer3("alert_days_after").default(4),
      // Alert if no bill after X days
      autoRemindersEnabled: boolean3("auto_reminders_enabled").default(true),
      // Contact & Access
      providerContact: varchar2("provider_contact"),
      onlinePortal: varchar2("online_portal"),
      loginCredentials: text3("login_credentials"),
      // Encrypted
      // Status
      isActive: boolean3("is_active").default(true),
      notes: text3("notes"),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    utilityBillHistory = pgTable3("utility_bill_history", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      utilityId: integer3("utility_id").references(() => propertyUtilities.id).notNull(),
      // Bill Details
      billingMonth: varchar2("billing_month").notNull(),
      // YYYY-MM format
      billAmount: decimal2("bill_amount", { precision: 10, scale: 2 }).notNull(),
      currency: varchar2("currency").default("THB"),
      billDueDate: date2("bill_due_date"),
      billReceivedDate: date2("bill_received_date"),
      // Payment Status
      paymentStatus: varchar2("payment_status").default("pending"),
      // pending, paid, overdue, disputed
      paidDate: date2("paid_date"),
      paidBy: varchar2("paid_by").references(() => users.id),
      paidByName: varchar2("paid_by_name"),
      // Documentation
      receiptUrl: varchar2("receipt_url"),
      // Uploaded bill/receipt
      paymentReceiptUrl: varchar2("payment_receipt_url"),
      notes: text3("notes"),
      // Alerts
      alertSent: boolean3("alert_sent").default(false),
      alertSentDate: timestamp3("alert_sent_date"),
      alertSentTo: text3("alert_sent_to").array(),
      // Array of user IDs
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    });
    utilityBillAlerts = pgTable3("utility_bill_alerts", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      utilityId: integer3("utility_id").references(() => propertyUtilities.id).notNull(),
      // Alert Details
      alertType: varchar2("alert_type").notNull(),
      // overdue_bill, missing_receipt, payment_reminder
      alertTitle: varchar2("alert_title").notNull(),
      alertMessage: text3("alert_message").notNull(),
      alertSeverity: varchar2("alert_severity").notNull(),
      // info, warning, urgent
      // Recipients
      sentTo: text3("sent_to").array(),
      // Array of user IDs
      sentToRoles: text3("sent_to_roles").array(),
      // Array of roles (admin, pm, owner)
      // Status
      alertStatus: varchar2("alert_status").default("active"),
      // active, acknowledged, resolved
      acknowledgedBy: varchar2("acknowledged_by").references(() => users.id),
      acknowledgedAt: timestamp3("acknowledged_at"),
      resolvedBy: varchar2("resolved_by").references(() => users.id),
      resolvedAt: timestamp3("resolved_at"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    propertyInfoSummary = pgTable3("property_info_summary", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").notNull(),
      propertyId: integer3("property_id").references(() => properties.id).notNull(),
      // Utility Status Summary
      totalUtilities: integer3("total_utilities").default(0),
      utilitiesWithUnpaidBills: integer3("utilities_with_unpaid_bills").default(0),
      utilitiesWithOverdueBills: integer3("utilities_with_overdue_bills").default(0),
      totalMonthlyUtilityCost: decimal2("total_monthly_utility_cost", {
        precision: 10,
        scale: 2
      }),
      // Maintenance Summary
      openMaintenanceIssues: integer3("open_maintenance_issues").default(0),
      urgentMaintenanceIssues: integer3("urgent_maintenance_issues").default(0),
      totalMaintenanceCostThisYear: decimal2("total_maintenance_cost_this_year", {
        precision: 10,
        scale: 2
      }),
      // Recent Activity
      lastMaintenanceDate: date2("last_maintenance_date"),
      lastServiceDate: date2("last_service_date"),
      lastUtilityBillDate: date2("last_utility_bill_date"),
      // AI Suggestions
      activeSuggestions: integer3("active_suggestions").default(0),
      urgentSuggestions: integer3("urgent_suggestions").default(0),
      // Cache Control
      lastUpdated: timestamp3("last_updated").defaultNow(),
      cacheVersion: integer3("cache_version").default(1)
    });
    insertMaintenanceIssueSchema = createInsertSchema3(
      maintenanceIssues
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyServiceHistorySchema = createInsertSchema3(
      propertyServiceHistory
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertMaintenanceTaskSuggestionSchema = createInsertSchema3(
      maintenanceTaskSuggestions
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPropertyUtilitySchema = createInsertSchema3(
      propertyUtilities
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUtilityBillHistorySchema = createInsertSchema3(
      utilityBillHistory
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUtilityBillAlertSchema = createInsertSchema3(
      utilityBillAlerts
    ).omit({
      id: true,
      createdAt: true
    });
    insertPropertyInfoSummarySchema = createInsertSchema3(
      propertyInfoSummary
    ).omit({
      id: true,
      lastUpdated: true
    });
    taskSchedulingRules = pgTable3(
      "task_scheduling_rules",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Rule Definition
        ruleName: varchar2("rule_name").notNull(),
        ruleDescription: text3("rule_description"),
        taskTemplate: varchar2("task_template").notNull(),
        // Template for generated tasks
        department: varchar2("department").notNull(),
        // Pool, Garden, Housekeeping, Maintenance, etc.
        priority: varchar2("priority").default("normal"),
        // low, normal, high, urgent
        // Scheduling Configuration
        scheduleType: varchar2("schedule_type").notNull(),
        // daily, weekly, monthly, every_x_days, custom_dates
        scheduleValue: integer3("schedule_value"),
        // For every_x_days (e.g., 3 for every 3 days)
        weeklyDay: integer3("weekly_day"),
        // 0-6 for Sunday-Saturday
        monthlyDate: integer3("monthly_date"),
        // 1-31 for monthly tasks
        customDates: text3("custom_dates").array(),
        // Array of custom dates like ["5", "20"] for 5th and 20th
        // Assignment Rules
        assignmentType: varchar2("assignment_type").default("auto"),
        // auto, specific_user
        assignedUserId: varchar2("assigned_user_id").references(() => users.id),
        // Task Duration & Timing
        estimatedDuration: integer3("estimated_duration"),
        // Minutes
        preferredStartTime: varchar2("preferred_start_time"),
        // HH:MM format
        // Booking-based Rules
        bookingTrigger: boolean3("booking_trigger").default(false),
        minBookingDays: integer3("min_booking_days"),
        // Minimum booking length to trigger
        triggerDay: integer3("trigger_day"),
        // Which day of booking to trigger (e.g., day 3)
        // Rule Status
        isActive: boolean3("is_active").default(true),
        nextScheduledDate: date2("next_scheduled_date"),
        lastGeneratedDate: date2("last_generated_date"),
        // Created By
        createdBy: varchar2("created_by").references(() => users.id).notNull(),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_scheduling_property").on(table.propertyId),
        index("IDX_scheduling_department").on(table.department),
        index("IDX_scheduling_next_date").on(table.nextScheduledDate)
      ]
    );
    recurringTasks = pgTable3(
      "recurring_tasks",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        ruleId: integer3("rule_id").references(() => taskSchedulingRules.id).notNull(),
        // Task Details
        taskTitle: varchar2("task_title").notNull(),
        taskDescription: text3("task_description"),
        department: varchar2("department").notNull(),
        priority: varchar2("priority").default("normal"),
        // Assignment
        assignedTo: varchar2("assigned_to").references(() => users.id),
        assignedBy: varchar2("assigned_by").references(() => users.id),
        // Scheduling
        scheduledDate: date2("scheduled_date").notNull(),
        dueDate: date2("due_date"),
        estimatedDuration: integer3("estimated_duration"),
        // Status Tracking
        status: varchar2("status").default("scheduled"),
        // scheduled, today, in_progress, completed, missed, skipped
        startedAt: timestamp3("started_at"),
        completedAt: timestamp3("completed_at"),
        completionNotes: text3("completion_notes"),
        // Evidence & Proof
        evidencePhotos: text3("evidence_photos").array(),
        issuesFound: text3("issues_found").array(),
        // Booking Association (if applicable)
        bookingId: integer3("booking_id").references(() => bookings.id),
        bookingDay: integer3("booking_day"),
        // Which day of the booking this was scheduled for
        // Skip/Miss Tracking
        skipReason: text3("skip_reason"),
        missedReason: text3("missed_reason"),
        rescheduledDate: date2("rescheduled_date"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_recurring_property").on(table.propertyId),
        index("IDX_recurring_rule").on(table.ruleId),
        index("IDX_recurring_assigned").on(table.assignedTo),
        index("IDX_recurring_scheduled").on(table.scheduledDate),
        index("IDX_recurring_status").on(table.status)
      ]
    );
    taskGenerationLogs = pgTable3("task_generation_logs", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Generation Details
      generationDate: date2("generation_date").notNull(),
      rulesProcessed: integer3("rules_processed").default(0),
      tasksGenerated: integer3("tasks_generated").default(0),
      errorsEncountered: integer3("errors_encountered").default(0),
      // Rule Processing Results
      ruleResults: jsonb3("rule_results"),
      // Detailed results per rule
      errorDetails: text3("error_details").array(),
      // Performance Metrics
      processingTimeMs: integer3("processing_time_ms"),
      createdAt: timestamp3("created_at").defaultNow()
    });
    recurringTaskAnalytics = pgTable3(
      "recurring_task_analytics",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id).notNull(),
        // Analytics Period
        periodMonth: integer3("period_month").notNull(),
        // 1-12
        periodYear: integer3("period_year").notNull(),
        department: varchar2("department").notNull(),
        // Performance Metrics
        totalScheduled: integer3("total_scheduled").default(0),
        totalCompleted: integer3("total_completed").default(0),
        totalMissed: integer3("total_missed").default(0),
        totalSkipped: integer3("total_skipped").default(0),
        completionRate: decimal2("completion_rate", { precision: 5, scale: 2 }),
        // Percentage
        // Timing Analytics
        avgCompletionTime: decimal2("avg_completion_time", {
          precision: 10,
          scale: 2
        }),
        // Minutes
        avgDelay: decimal2("avg_delay", { precision: 10, scale: 2 }),
        // Days delayed from scheduled
        // Quality Metrics
        issuesFoundCount: integer3("issues_found_count").default(0),
        photoEvidenceRate: decimal2("photo_evidence_rate", {
          precision: 5,
          scale: 2
        }),
        lastUpdated: timestamp3("last_updated").defaultNow()
      },
      (table) => [
        index("IDX_analytics_property_period").on(
          table.propertyId,
          table.periodYear,
          table.periodMonth
        ),
        index("IDX_analytics_department").on(table.department)
      ]
    );
    taskSchedulingAlerts = pgTable3(
      "task_scheduling_alerts",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        // Alert Details
        alertType: varchar2("alert_type").notNull(),
        // rule_disabled, task_overdue, pattern_missed, ai_suggestion
        alertTitle: varchar2("alert_title").notNull(),
        alertDescription: text3("alert_description"),
        severity: varchar2("severity").default("medium"),
        // low, medium, high, critical
        // References
        ruleId: integer3("rule_id").references(() => taskSchedulingRules.id),
        taskId: integer3("task_id").references(() => recurringTasks.id),
        // Alert Status
        status: varchar2("status").default("active"),
        // active, acknowledged, resolved, dismissed
        acknowledgedBy: varchar2("acknowledged_by").references(() => users.id),
        acknowledgedAt: timestamp3("acknowledged_at"),
        resolvedAt: timestamp3("resolved_at"),
        // AI Suggestions (if applicable)
        aiSuggestion: text3("ai_suggestion"),
        suggestionConfidence: decimal2("suggestion_confidence", {
          precision: 5,
          scale: 2
        }),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_alerts_property").on(table.propertyId),
        index("IDX_alerts_status").on(table.status),
        index("IDX_alerts_severity").on(table.severity)
      ]
    );
    insertTaskSchedulingRuleSchema = createInsertSchema3(
      taskSchedulingRules
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertRecurringTaskSchema = createInsertSchema3(
      recurringTasks
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTaskGenerationLogSchema = createInsertSchema3(
      taskGenerationLogs
    ).omit({
      id: true,
      createdAt: true
    });
    insertRecurringTaskAnalyticsSchema = createInsertSchema3(
      recurringTaskAnalytics
    ).omit({
      id: true,
      lastUpdated: true
    });
    insertTaskSchedulingAlertSchema = createInsertSchema3(
      taskSchedulingAlerts
    ).omit({
      id: true,
      createdAt: true
    });
    propertyAppliances = pgTable3(
      "property_appliances",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        applianceType: varchar2("appliance_type").notNull(),
        // refrigerator, washing_machine, air_conditioner, etc.
        brand: varchar2("brand"),
        model: varchar2("model"),
        serialNumber: varchar2("serial_number"),
        installDate: date2("install_date"),
        warrantyExpiry: date2("warranty_expiry"),
        notes: text3("notes"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_appliances_property").on(table.propertyId),
        index("IDX_appliances_type").on(table.applianceType),
        index("IDX_appliances_warranty").on(table.warrantyExpiry)
      ]
    );
    applianceRepairs = pgTable3(
      "appliance_repairs",
      {
        id: serial2("id").primaryKey(),
        applianceId: integer3("appliance_id").references(
          () => propertyAppliances.id
        ),
        issueReported: text3("issue_reported").notNull(),
        fixDescription: text3("fix_description"),
        technicianName: varchar2("technician_name"),
        repairCost: decimal2("repair_cost", { precision: 10, scale: 2 }),
        receiptUrl: text3("receipt_url"),
        repairedAt: timestamp3("repaired_at"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_repairs_appliance").on(table.applianceId),
        index("IDX_repairs_date").on(table.repairedAt)
      ]
    );
    insertPropertyApplianceSchema = createInsertSchema3(
      propertyAppliances
    ).omit({
      id: true,
      createdAt: true
    });
    insertApplianceRepairSchema = createInsertSchema3(
      applianceRepairs
    ).omit({
      id: true,
      createdAt: true
    });
    alertRules = pgTable3(
      "alert_rules",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        name: varchar2("name").notNull(),
        triggerType: varchar2("trigger_type").notNull(),
        // warranty_expiration, repair_overdue, cost_threshold, maintenance_due, etc.
        conditionJson: json("condition_json").notNull(),
        // JSON configuration for alert conditions
        alertLevel: varchar2("alert_level").default("warning"),
        // info, warning, critical, urgent
        sendTo: varchar2("send_to").array(),
        // array of user IDs or email addresses
        isActive: boolean3("is_active").default(true),
        description: text3("description"),
        // Human-readable description of the alert rule
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_alert_rules_org").on(table.organizationId),
        index("IDX_alert_rules_trigger").on(table.triggerType),
        index("IDX_alert_rules_active").on(table.isActive)
      ]
    );
    alertLogs = pgTable3(
      "alert_logs",
      {
        id: serial2("id").primaryKey(),
        ruleId: integer3("rule_id").references(() => alertRules.id),
        triggeredAt: timestamp3("triggered_at").defaultNow(),
        message: text3("message"),
        status: varchar2("status").default("open"),
        // open, acknowledged, resolved, dismissed
        acknowledgedBy: varchar2("acknowledged_by"),
        acknowledgedAt: timestamp3("acknowledged_at"),
        resolvedAt: timestamp3("resolved_at"),
        resolvedBy: varchar2("resolved_by"),
        metadataJson: json("metadata_json"),
        // Additional context data (property ID, appliance ID, etc.)
        alertLevel: varchar2("alert_level").default("warning"),
        // Copied from rule for historical tracking
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_alert_logs_rule").on(table.ruleId),
        index("IDX_alert_logs_status").on(table.status),
        index("IDX_alert_logs_triggered").on(table.triggeredAt)
      ]
    );
    insertAlertRuleSchema = createInsertSchema3(alertRules).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAlertLogSchema = createInsertSchema3(alertLogs).omit({
      id: true,
      createdAt: true
    });
    legalTemplates = pgTable3("legal_templates", {
      id: serial2("id").primaryKey(),
      countryCode: varchar2("country_code", { length: 3 }).notNull(),
      docType: varchar2("doc_type", { length: 100 }).notNull(),
      // contract, deposit_rules, terms_conditions
      templateText: text3("template_text").notNull(),
      createdAt: timestamp3("created_at").defaultNow().notNull()
    });
    insertLegalTemplateSchema = createInsertSchema3(
      legalTemplates
    ).omit({
      id: true,
      createdAt: true
    });
    propertyStatus = pgTable3(
      "property_status",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        status: varchar2("status").notNull(),
        // occupied, vacant, urgent-maintenance, cleaning-due
        lastUpdate: timestamp3("last_update").defaultNow(),
        notes: text3("notes")
      },
      (table) => [
        index("IDX_property_status_org").on(table.organizationId),
        index("IDX_property_status_property").on(table.propertyId),
        index("IDX_property_status_status").on(table.status)
      ]
    );
    insertPropertyStatusSchema = createInsertSchema3(
      propertyStatus
    ).omit({
      id: true,
      lastUpdate: true
    });
    staffSkills = pgTable3(
      "staff_skills",
      {
        id: serial2("id").primaryKey(),
        staffId: varchar2("staff_id").references(() => users.id).notNull(),
        skillName: varchar2("skill_name").notNull(),
        certificationUrl: text3("certification_url"),
        expiryDate: date2("expiry_date"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_staff_skills_staff").on(table.staffId),
        index("IDX_staff_skills_skill").on(table.skillName),
        index("IDX_staff_skills_expiry").on(table.expiryDate)
      ]
    );
    insertStaffSkillSchema = createInsertSchema3(staffSkills).omit({
      id: true,
      createdAt: true
    });
    propertyReviews = pgTable3(
      "property_reviews",
      {
        id: serial2("id").primaryKey(),
        propertyId: integer3("property_id").references(() => properties.id),
        source: varchar2("source").notNull(),
        // Airbnb, Booking.com, VRBO, Direct
        reviewerName: varchar2("reviewer_name"),
        rating: decimal2("rating", { precision: 3, scale: 2 }),
        reviewText: text3("review_text"),
        aiSummary: text3("ai_summary"),
        sentimentScore: decimal2("sentiment_score", { precision: 4, scale: 2 }),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_property_reviews_property").on(table.propertyId),
        index("IDX_property_reviews_source").on(table.source),
        index("IDX_property_reviews_rating").on(table.rating),
        index("IDX_property_reviews_sentiment").on(table.sentimentScore),
        index("IDX_property_reviews_created").on(table.createdAt)
      ]
    );
    insertPropertyReviewSchema = createInsertSchema3(
      propertyReviews
    ).omit({
      id: true,
      createdAt: true
    });
    securityDeposits = pgTable3(
      "security_deposits",
      {
        id: serial2("id").primaryKey(),
        bookingId: integer3("booking_id").references(() => bookings.id),
        propertyId: integer3("property_id").references(() => properties.id),
        guestId: varchar2("guest_id"),
        amount: decimal2("amount", { precision: 10, scale: 2 }).notNull(),
        status: varchar2("status").default("held"),
        // held, released, partial-deducted
        createdAt: timestamp3("created_at").defaultNow(),
        releasedAt: timestamp3("released_at")
      },
      (table) => [
        index("IDX_security_deposits_booking").on(table.bookingId),
        index("IDX_security_deposits_property").on(table.propertyId),
        index("IDX_security_deposits_guest").on(table.guestId),
        index("IDX_security_deposits_status").on(table.status)
      ]
    );
    damageReports = pgTable3(
      "damage_reports",
      {
        id: serial2("id").primaryKey(),
        bookingId: integer3("booking_id").references(() => bookings.id),
        propertyId: integer3("property_id").references(() => properties.id),
        description: text3("description"),
        photoUrl: text3("photo_url"),
        repairCost: decimal2("repair_cost", { precision: 10, scale: 2 }),
        chargedToGuest: boolean3("charged_to_guest").default(false),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_damage_reports_booking").on(table.bookingId),
        index("IDX_damage_reports_property").on(table.propertyId),
        index("IDX_damage_reports_charged").on(table.chargedToGuest),
        index("IDX_damage_reports_created").on(table.createdAt)
      ]
    );
    insertSecurityDepositSchema = createInsertSchema3(
      securityDeposits
    ).omit({
      id: true,
      createdAt: true
    });
    insertDamageReportSchema = createInsertSchema3(damageReports).omit({
      id: true,
      createdAt: true
    });
    vendors = pgTable3(
      "vendors",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        name: varchar2("name").notNull(),
        contactInfo: text3("contact_info"),
        apiUrl: text3("api_url"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_vendors_organization").on(table.organizationId),
        index("IDX_vendors_name").on(table.name)
      ]
    );
    supplyOrders = pgTable3(
      "supply_orders",
      {
        id: serial2("id").primaryKey(),
        vendorId: integer3("vendor_id").references(() => vendors.id),
        propertyId: integer3("property_id").references(() => properties.id),
        itemName: varchar2("item_name").notNull(),
        quantity: integer3("quantity"),
        costTotal: decimal2("cost_total", { precision: 10, scale: 2 }),
        status: varchar2("status").default("pending"),
        // pending, ordered, delivered
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_supply_orders_vendor").on(table.vendorId),
        index("IDX_supply_orders_property").on(table.propertyId),
        index("IDX_supply_orders_status").on(table.status),
        index("IDX_supply_orders_created").on(table.createdAt)
      ]
    );
    insertVendorSchema = createInsertSchema3(vendors).omit({
      id: true,
      createdAt: true
    });
    insertSupplyOrderSchema = createInsertSchema3(supplyOrders).omit({
      id: true,
      createdAt: true
    });
    whatsappBotLogs = pgTable3(
      "whatsapp_bot_logs",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        userId: varchar2("user_id"),
        command: varchar2("command").notNull(),
        response: text3("response"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_whatsapp_bot_logs_organization").on(table.organizationId),
        index("IDX_whatsapp_bot_logs_user").on(table.userId),
        index("IDX_whatsapp_bot_logs_command").on(table.command),
        index("IDX_whatsapp_bot_logs_created").on(table.createdAt)
      ]
    );
    insertWhatsappBotLogSchema = createInsertSchema3(
      whatsappBotLogs
    ).omit({
      id: true,
      createdAt: true
    });
    seasonalForecasts = pgTable3(
      "seasonal_forecasts",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        forecastMonth: varchar2("forecast_month").notNull(),
        // YYYY-MM format
        expectedOccupancy: decimal2("expected_occupancy", {
          precision: 5,
          scale: 2
        }),
        expectedRate: decimal2("expected_rate", { precision: 10, scale: 2 }),
        aiNotes: text3("ai_notes"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_seasonal_forecasts_organization").on(table.organizationId),
        index("IDX_seasonal_forecasts_property").on(table.propertyId),
        index("IDX_seasonal_forecasts_month").on(table.forecastMonth),
        index("IDX_seasonal_forecasts_created").on(table.createdAt)
      ]
    );
    insertSeasonalForecastSchema = createInsertSchema3(
      seasonalForecasts
    ).omit({
      id: true,
      createdAt: true
    });
    sustainabilityMetrics = pgTable3(
      "sustainability_metrics",
      {
        id: serial2("id").primaryKey(),
        propertyId: integer3("property_id").references(() => properties.id),
        periodStart: date2("period_start"),
        periodEnd: date2("period_end"),
        waterUsage: decimal2("water_usage", { precision: 10, scale: 2 }),
        electricityUsage: decimal2("electricity_usage", { precision: 10, scale: 2 }),
        carbonScore: decimal2("carbon_score", { precision: 5, scale: 2 }),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_sustainability_metrics_property").on(table.propertyId),
        index("IDX_sustainability_metrics_period").on(
          table.periodStart,
          table.periodEnd
        ),
        index("IDX_sustainability_metrics_created").on(table.createdAt)
      ]
    );
    insertSustainabilityMetricSchema = createInsertSchema3(
      sustainabilityMetrics
    ).omit({
      id: true,
      createdAt: true
    });
    portfolioHealthScores = pgTable3(
      "portfolio_health_scores",
      {
        id: serial2("id").primaryKey(),
        propertyId: integer3("property_id").references(() => properties.id),
        score: decimal2("score", { precision: 5, scale: 2 }),
        factors: json("factors").$type(),
        calculatedAt: timestamp3("calculated_at").defaultNow()
      },
      (table) => [
        index("IDX_portfolio_health_property").on(table.propertyId),
        index("IDX_portfolio_health_calculated").on(table.calculatedAt),
        index("IDX_portfolio_health_score").on(table.score)
      ]
    );
    insertPortfolioHealthScoreSchema = createInsertSchema3(
      portfolioHealthScores
    ).omit({
      id: true,
      calculatedAt: true
    });
    guestIdScans = pgTable3(
      "guest_id_scans",
      {
        id: serial2("id").primaryKey(),
        bookingId: integer3("booking_id").references(() => bookings.id),
        guestName: varchar2("guest_name", { length: 255 }),
        documentType: varchar2("document_type", { length: 50 }),
        scanUrl: text3("scan_url"),
        ocrData: json("ocr_data").$type(),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_guest_id_scans_booking").on(table.bookingId),
        index("IDX_guest_id_scans_document").on(table.documentType),
        index("IDX_guest_id_scans_created").on(table.createdAt)
      ]
    );
    insertGuestIdScanSchema = createInsertSchema3(guestIdScans).omit({
      id: true,
      createdAt: true
    });
    maintenanceBudgetForecasts = pgTable3(
      "maintenance_budget_forecasts",
      {
        id: serial2("id").primaryKey(),
        propertyId: integer3("property_id").references(() => properties.id),
        forecastYear: integer3("forecast_year").notNull(),
        expectedCost: decimal2("expected_cost", { precision: 12, scale: 2 }),
        aiNotes: text3("ai_notes"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_maintenance_budget_property").on(table.propertyId),
        index("IDX_maintenance_budget_year").on(table.forecastYear),
        index("IDX_maintenance_budget_created").on(table.createdAt)
      ]
    );
    insertMaintenanceBudgetForecastSchema = createInsertSchema3(
      maintenanceBudgetForecasts
    ).omit({
      id: true,
      createdAt: true
    });
    staffWorkloadStats = pgTable3(
      "staff_workload_stats",
      {
        id: serial2("id").primaryKey(),
        staffId: varchar2("staff_id").notNull().references(() => users.id),
        weekStart: date2("week_start"),
        tasksAssigned: integer3("tasks_assigned").default(0),
        hoursLogged: decimal2("hours_logged", { precision: 5, scale: 2 }).default(
          "0"
        ),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_staff_workload_staff").on(table.staffId),
        index("IDX_staff_workload_week").on(table.weekStart),
        index("IDX_staff_workload_created").on(table.createdAt)
      ]
    );
    insertStaffWorkloadStatsSchema = createInsertSchema3(
      staffWorkloadStats
    ).omit({
      id: true,
      createdAt: true
    });
    propertyInsurance = pgTable3(
      "property_insurance",
      {
        id: serial2("id").primaryKey(),
        propertyId: integer3("property_id").references(() => properties.id),
        policyNumber: varchar2("policy_number"),
        insurerName: varchar2("insurer_name"),
        coverageDetails: text3("coverage_details"),
        expiryDate: date2("expiry_date"),
        uploadedBy: varchar2("uploaded_by"),
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_property_insurance_property").on(table.propertyId),
        index("IDX_property_insurance_expiry").on(table.expiryDate),
        index("IDX_property_insurance_created").on(table.createdAt)
      ]
    );
    insertPropertyInsuranceSchema = createInsertSchema3(
      propertyInsurance
    ).omit({
      id: true,
      createdAt: true
    });
    reports = pgTable3(
      "reports",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        title: varchar2("title", { length: 255 }).notNull(),
        type: varchar2("type", { length: 50 }).notNull(),
        // bookings, finances, tasks, properties, etc.
        data: jsonb3("data").$type().notNull(),
        generatedBy: varchar2("generated_by").references(() => users.id),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_reports_org").on(table.organizationId),
        index("IDX_reports_type").on(table.type),
        index("IDX_reports_created").on(table.createdAt)
      ]
    );
    insertReportSchema = createInsertSchema3(reports).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    automations = pgTable3(
      "automations",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        name: varchar2("name", { length: 255 }).notNull(),
        description: text3("description"),
        trigger: varchar2("trigger", { length: 100 }).notNull(),
        // booking_due, task_overdue, payment_pending, utility_threshold, etc.
        triggerCondition: jsonb3("trigger_condition").$type(),
        action: varchar2("action", { length: 100 }).notNull(),
        // send_email, send_sms, create_task, send_notification, etc.
        actionConfig: jsonb3("action_config").$type(),
        schedule: varchar2("schedule", { length: 50 }),
        // cron expression or interval
        isActive: boolean3("is_active").default(true),
        lastTriggered: timestamp3("last_triggered"),
        triggerCount: integer3("trigger_count").default(0),
        createdBy: varchar2("created_by").references(() => users.id),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_automations_org").on(table.organizationId),
        index("IDX_automations_trigger").on(table.trigger),
        index("IDX_automations_active").on(table.isActive),
        index("IDX_automations_created").on(table.createdAt)
      ]
    );
    insertAutomationSchema = createInsertSchema3(automations).omit({
      id: true,
      triggerCount: true,
      lastTriggered: true,
      createdAt: true,
      updatedAt: true
    });
    automationLogs = pgTable3(
      "automation_logs",
      {
        id: serial2("id").primaryKey(),
        automationId: integer3("automation_id").references(() => automations.id).notNull(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        status: varchar2("status", { length: 50 }).notNull(),
        // success, failed, pending
        triggerData: jsonb3("trigger_data"),
        result: jsonb3("result"),
        error: text3("error"),
        executedAt: timestamp3("executed_at").defaultNow()
      },
      (table) => [
        index("IDX_automation_logs_automation").on(table.automationId),
        index("IDX_automation_logs_org").on(table.organizationId),
        index("IDX_automation_logs_status").on(table.status),
        index("IDX_automation_logs_executed").on(table.executedAt)
      ]
    );
    insertAutomationLogSchema = createInsertSchema3(
      automationLogs
    ).omit({
      id: true,
      executedAt: true
    });
    aiNotifications = pgTable3(
      "ai_notifications",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        alertType: varchar2("alert_type", { length: 100 }).notNull(),
        // pest, electricity, cleaning, ac, upgrade, etc.
        title: varchar2("title", { length: 255 }).notNull(),
        description: text3("description"),
        priority: varchar2("priority", { length: 50 }).notNull(),
        // low, medium, high, critical
        status: varchar2("status", { length: 50 }).notNull(),
        // active, snoozed, resolved, dismissed
        dueDate: timestamp3("due_date"),
        snoozeUntil: timestamp3("snooze_until"),
        lastServiceDate: timestamp3("last_service_date"),
        estimatedNextDate: timestamp3("estimated_next_date"),
        aiConfidence: varchar2("ai_confidence", { length: 10 }),
        // 0.00-1.00
        sourceType: varchar2("source_type", { length: 100 }),
        // service_log, bill_pattern, maintenance_history, manual, etc.
        sourceId: varchar2("source_id", { length: 255 }),
        visibleToRoles: text3("visible_to_roles").array(),
        assignedTo: varchar2("assigned_to").references(() => users.id),
        createdBy: varchar2("created_by").notNull(),
        // can be ai-system, goals-system, or user ID
        actionTaken: boolean3("action_taken").default(false),
        actionTakenBy: varchar2("action_taken_by").references(() => users.id),
        actionTakenAt: timestamp3("action_taken_at"),
        actionNotes: text3("action_notes"),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_ai_notifications_org").on(table.organizationId),
        index("IDX_ai_notifications_property").on(table.propertyId),
        index("IDX_ai_notifications_type").on(table.alertType),
        index("IDX_ai_notifications_status").on(table.status),
        index("IDX_ai_notifications_priority").on(table.priority),
        index("IDX_ai_notifications_due").on(table.dueDate)
      ]
    );
    insertAiNotificationSchema = createInsertSchema3(
      aiNotifications
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    aiReminderSettings = pgTable3(
      "ai_reminder_settings",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        propertyId: integer3("property_id").references(() => properties.id),
        alertType: varchar2("alert_type", { length: 100 }).notNull(),
        // pest, electricity, cleaning, etc.
        enabled: boolean3("enabled").default(true),
        intervalDays: integer3("interval_days").notNull(),
        // How often the service/check should occur
        reminderDaysBefore: integer3("reminder_days_before").default(3),
        // How many days before due date to remind
        autoCreateTasks: boolean3("auto_create_tasks").default(false),
        notificationMethods: text3("notification_methods").array(),
        // dashboard, email, sms, etc.
        customRules: jsonb3("custom_rules").$type(),
        createdAt: timestamp3("created_at").defaultNow(),
        updatedAt: timestamp3("updated_at").defaultNow()
      },
      (table) => [
        index("IDX_ai_reminder_org").on(table.organizationId),
        index("IDX_ai_reminder_property").on(table.propertyId),
        index("IDX_ai_reminder_type").on(table.alertType),
        index("IDX_ai_reminder_enabled").on(table.enabled)
      ]
    );
    insertAiReminderSettingSchema = createInsertSchema3(
      aiReminderSettings
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    aiNotificationHistory = pgTable3(
      "ai_notification_history",
      {
        id: serial2("id").primaryKey(),
        organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
        notificationId: integer3("notification_id").references(
          () => aiNotifications.id
        ),
        eventType: varchar2("event_type", { length: 100 }).notNull(),
        // created, updated, snoozed, resolved, dismissed, etc.
        eventStatus: varchar2("event_status", { length: 50 }),
        metadata: jsonb3("metadata"),
        actorId: varchar2("actor_id").references(() => users.id),
        // Who performed the action
        actorType: varchar2("actor_type", { length: 50 }),
        // user, ai-system, automation, etc.
        createdAt: timestamp3("created_at").defaultNow()
      },
      (table) => [
        index("IDX_ai_history_org").on(table.organizationId),
        index("IDX_ai_history_notification").on(table.notificationId),
        index("IDX_ai_history_event").on(table.eventType),
        index("IDX_ai_history_created").on(table.createdAt)
      ]
    );
    insertAiNotificationHistorySchema = createInsertSchema3(
      aiNotificationHistory
    ).omit({
      id: true,
      createdAt: true
    });
    billingInvoices = pgTable3("billing_invoices", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      invoiceNumber: varchar2("invoice_number").notNull().unique(),
      // e.g., INV-2025-001
      // Client information
      clientType: varchar2("client_type").notNull(),
      // owner, agent, service_provider
      clientId: varchar2("client_id"),
      // References users.id for owner/agent
      clientName: varchar2("client_name").notNull(),
      clientEmail: varchar2("client_email"),
      // Property reference (optional)
      propertyId: integer3("property_id").references(() => properties.id),
      // Template reference (optional)
      templateId: integer3("template_id"),
      // Invoice details
      issueDate: date2("issue_date").notNull(),
      dueDate: date2("due_date").notNull(),
      description: text3("description"),
      // High-level invoice description
      // Status tracking
      status: varchar2("status").notNull().default("draft"),
      // draft, sent, paid, overdue, void
      // Financial totals (computed from line items)
      subtotal: decimal2("subtotal", { precision: 12, scale: 2 }).notNull().default("0"),
      taxTotal: decimal2("tax_total", { precision: 12, scale: 2 }).notNull().default("0"),
      discountTotal: decimal2("discount_total", { precision: 12, scale: 2 }).notNull().default("0"),
      total: decimal2("total", { precision: 12, scale: 2 }).notNull().default("0"),
      // Payment tracking
      paidAmount: decimal2("paid_amount", { precision: 12, scale: 2 }).default("0"),
      paidDate: date2("paid_date"),
      // Audit fields
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    }, (table) => [
      index("IDX_billing_invoice_org").on(table.organizationId),
      index("IDX_billing_invoice_client").on(table.clientId),
      index("IDX_billing_invoice_property").on(table.propertyId),
      index("IDX_billing_invoice_status").on(table.status),
      index("IDX_billing_invoice_number").on(table.invoiceNumber)
    ]);
    billingInvoiceLineItems2 = pgTable3("billing_invoice_line_items", {
      id: serial2("id").primaryKey(),
      invoiceId: integer3("invoice_id").references(() => billingInvoices.id, { onDelete: "cascade" }).notNull(),
      // Line item details
      description: text3("description").notNull(),
      quantity: decimal2("quantity", { precision: 10, scale: 2 }).notNull().default("1"),
      unitPrice: decimal2("unit_price", { precision: 12, scale: 2 }).notNull(),
      // Tax and discount (optional)
      taxRate: decimal2("tax_rate", { precision: 5, scale: 2 }).default("0"),
      // Percentage (e.g., 7.00 for 7%)
      discount: decimal2("discount", { precision: 12, scale: 2 }).default("0"),
      // Flat amount
      // Computed amount (quantity * unitPrice - discount + tax)
      amount: decimal2("amount", { precision: 12, scale: 2 }).notNull(),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    }, (table) => [
      index("IDX_billing_line_item_invoice").on(table.invoiceId)
    ]);
    billingInvoiceTemplates = pgTable3("billing_invoice_templates", {
      id: serial2("id").primaryKey(),
      organizationId: varchar2("organization_id").references(() => organizations.id).notNull(),
      // Template details
      name: varchar2("name").notNull(),
      description: text3("description"),
      // Status
      isActive: boolean3("is_active").default(true),
      // Audit fields
      createdBy: varchar2("created_by").references(() => users.id),
      createdAt: timestamp3("created_at").defaultNow(),
      updatedAt: timestamp3("updated_at").defaultNow()
    }, (table) => [
      index("IDX_billing_template_org").on(table.organizationId),
      index("IDX_billing_template_active").on(table.isActive)
    ]);
    billingTemplateLineItems2 = pgTable3("billing_template_line_items", {
      id: serial2("id").primaryKey(),
      templateId: integer3("template_id").references(() => billingInvoiceTemplates.id, { onDelete: "cascade" }).notNull(),
      // Default line item configuration
      description: text3("description").notNull(),
      quantity: decimal2("quantity", { precision: 10, scale: 2 }).notNull().default("1"),
      unitPrice: decimal2("unit_price", { precision: 12, scale: 2 }).notNull(),
      taxRate: decimal2("tax_rate", { precision: 5, scale: 2 }).default("0"),
      discount: decimal2("discount", { precision: 12, scale: 2 }).default("0"),
      createdAt: timestamp3("created_at").defaultNow()
    }, (table) => [
      index("IDX_billing_template_line_template").on(table.templateId)
    ]);
    insertBillingInvoiceSchema = createInsertSchema3(billingInvoices).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBillingInvoiceLineItemSchema = createInsertSchema3(billingInvoiceLineItems2).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBillingInvoiceTemplateSchema = createInsertSchema3(billingInvoiceTemplates).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBillingTemplateLineItemSchema = createInsertSchema3(billingTemplateLineItems2).omit({
      id: true,
      createdAt: true
    });
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  db: () => db,
  pool: () => pool
});
import { neon as neon3 } from "@neondatabase/serverless";
import { drizzle as drizzle3 } from "drizzle-orm/neon-http";
var databaseUrl, sql2, db, pool;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    databaseUrl = process.env.DATABASE_URL;
    if (!databaseUrl) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    console.log("\u{1F517} Connecting to database:", databaseUrl.includes("supabase") ? "Supabase" : "Neon");
    sql2 = neon3(databaseUrl);
    db = drizzle3(sql2, { schema: schema_exports });
    pool = {
      query: sql2,
      end: () => Promise.resolve(),
      on: () => {
      }
    };
  }
});

// server/realtime-events.ts
import { EventEmitter } from "events";
function emitRealtimeEvent(type, action, entityId, organizationId2, payload) {
  realtimeEvents.broadcast({
    type,
    action,
    entityId,
    organizationId: organizationId2,
    payload
  });
}
var RealtimeEventEmitter, realtimeEvents;
var init_realtime_events = __esm({
  "server/realtime-events.ts"() {
    "use strict";
    RealtimeEventEmitter = class extends EventEmitter {
      constructor() {
        super();
        this.clients = /* @__PURE__ */ new Map();
        this.clientCounter = 0;
        this.setMaxListeners(100);
      }
      addClient(res, organizationId2) {
        const clientId = `client_${++this.clientCounter}_${Date.now()}`;
        res.writeHead(200, {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          "Connection": "keep-alive",
          "Access-Control-Allow-Origin": "*",
          "X-Accel-Buffering": "no"
        });
        res.write(`data: ${JSON.stringify({ type: "connected", clientId })}

`);
        const heartbeat = setInterval(() => {
          if (!res.writableEnded) {
            res.write(`: heartbeat

`);
          }
        }, 3e4);
        res.__clientId = clientId;
        res.__organizationId = organizationId2;
        res.__heartbeat = heartbeat;
        this.clients.set(clientId, res);
        res.on("close", () => {
          clearInterval(heartbeat);
          this.clients.delete(clientId);
          console.log(`[SSE] Client ${clientId} disconnected. Active clients: ${this.clients.size}`);
        });
        console.log(`[SSE] Client ${clientId} connected (org: ${organizationId2}). Active clients: ${this.clients.size}`);
        return clientId;
      }
      broadcast(event) {
        const fullEvent = {
          ...event,
          timestamp: Date.now()
        };
        const eventData = `data: ${JSON.stringify(fullEvent)}

`;
        let sentCount = 0;
        this.clients.forEach((res, clientId) => {
          try {
            const clientOrgId = res.__organizationId;
            if (event.organizationId && clientOrgId && event.organizationId !== clientOrgId) {
              return;
            }
            if (!res.writableEnded) {
              res.write(eventData);
              sentCount++;
            }
          } catch (error) {
            console.error(`[SSE] Error sending to client ${clientId}:`, error);
            this.clients.delete(clientId);
          }
        });
        if (sentCount > 0) {
          console.log(`[SSE] Broadcast ${event.type}:${event.action} to ${sentCount} clients`);
        }
      }
      getClientCount() {
        return this.clients.size;
      }
    };
    realtimeEvents = new RealtimeEventEmitter();
  }
});

// server/storage.ts
var storage_exports = {};
__export(storage_exports, {
  DatabaseStorage: () => DatabaseStorage,
  storage: () => storage
});
import { eq as eq2, and as and3, or, desc as desc2, asc, lt, gte as gte2, lte as lte2, isNull as isNull2, sql as sql3, sum, count, avg, max, like } from "drizzle-orm";
import bcrypt from "bcrypt";
var DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema();
    init_guestPortalSchema();
    init_db();
    init_realtime_events();
    DatabaseStorage = class {
      // User operations
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq2(users.id, id));
        return user;
      }
      async getUserByEmail(email) {
        const [user] = await db.select().from(users).where(eq2(users.email, email));
        return user;
      }
      async upsertUser(userData) {
        const [user] = await db.insert(users).values(userData).onConflictDoUpdate({
          target: users.id,
          set: {
            ...userData,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return user;
      }
      async updateUser(id, updates) {
        if (updates.name) {
          const nameParts = updates.name.split(" ");
          updates.firstName = nameParts[0] || "";
          updates.lastName = nameParts.slice(1).join(" ") || "";
          delete updates.name;
        }
        const [user] = await db.update(users).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(users.id, id)).returning();
        return user;
      }
      // Property operations
      async getProperties(source) {
        if (source) {
          return await db.select().from(properties).where(eq2(properties.source, source)).orderBy(desc2(properties.createdAt));
        }
        return await db.select().from(properties).orderBy(desc2(properties.createdAt));
      }
      async getPropertiesByOwner(ownerId) {
        return await db.select().from(properties).where(eq2(properties.ownerId, ownerId)).orderBy(desc2(properties.createdAt));
      }
      async getProperty(id) {
        const [property] = await db.select().from(properties).where(eq2(properties.id, id));
        return property;
      }
      async createProperty(property) {
        const [newProperty] = await db.insert(properties).values(property).returning();
        emitRealtimeEvent("property", "create", newProperty.id, newProperty.organizationId);
        return newProperty;
      }
      async updateProperty(id, property) {
        const [updatedProperty] = await db.update(properties).set({ ...property, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(properties.id, id)).returning();
        emitRealtimeEvent("property", "update", id, updatedProperty?.organizationId);
        return updatedProperty;
      }
      async deleteProperty(id) {
        try {
          console.log(`\u{1F5D1}\uFE0F Deleting property ${id} and all related records...`);
          const propertyBookings = await db.select({ id: bookings.id }).from(bookings).where(eq2(bookings.propertyId, id));
          const bookingIds = propertyBookings.map((b) => b.id);
          const propertyFinances = await db.select({ id: finances.id }).from(finances).where(eq2(finances.propertyId, id));
          const financeIds = propertyFinances.map((f) => f.id);
          if (financeIds.length > 0) {
            for (const financeId of financeIds) {
              await db.update(tasks).set({ financeRecordId: null }).where(eq2(tasks.financeRecordId, financeId));
            }
          }
          if (bookingIds.length > 0) {
            for (const bookingId of bookingIds) {
              const bookingFinances = await db.select({ id: finances.id }).from(finances).where(eq2(finances.bookingId, bookingId));
              for (const f of bookingFinances) {
                await db.update(tasks).set({ financeRecordId: null }).where(eq2(tasks.financeRecordId, f.id));
              }
            }
          }
          await db.delete(tasks).where(eq2(tasks.propertyId, id));
          if (bookingIds.length > 0) {
            for (const bookingId of bookingIds) {
              await db.delete(finances).where(eq2(finances.bookingId, bookingId));
            }
          }
          await db.delete(finances).where(eq2(finances.propertyId, id));
          await db.delete(addonBookings).where(eq2(addonBookings.propertyId, id));
          await db.delete(bookingRevenue).where(eq2(bookingRevenue.propertyId, id));
          await db.delete(bookings).where(eq2(bookings.propertyId, id));
          await db.delete(propertyDocuments).where(eq2(propertyDocuments.propertyId, id));
          await db.delete(propertyInsurance).where(eq2(propertyInsurance.propertyId, id));
          const result = await db.delete(properties).where(eq2(properties.id, id));
          console.log(`\u2705 Successfully deleted property ${id} and all related records`);
          emitRealtimeEvent("property", "delete", id);
          return result.rowCount ? result.rowCount > 0 : true;
        } catch (error) {
          console.error(`\u274C Error in deleteProperty for ${id}:`, error);
          throw error;
        }
      }
      async getTasks(dueFrom, dueTo) {
        let query = db.select().from(tasks);
        if (dueFrom && dueTo) {
          query = query.where(
            and3(
              gte2(tasks.dueDate, new Date(dueFrom)),
              lte2(tasks.dueDate, new Date(dueTo))
            )
          );
        }
        return await query.orderBy(desc2(tasks.createdAt));
      }
      async getTasksByProperty(propertyId) {
        return await db.select().from(tasks).where(eq2(tasks.propertyId, propertyId)).orderBy(desc2(tasks.createdAt));
      }
      async getTasksByAssignee(assigneeId, dueFrom, dueTo) {
        let query = db.select().from(tasks).where(eq2(tasks.assignedTo, assigneeId));
        if (dueFrom && dueTo) {
          query = query.where(
            and3(
              eq2(tasks.assignedTo, assigneeId),
              gte2(tasks.dueDate, new Date(dueFrom)),
              lte2(tasks.dueDate, new Date(dueTo))
            )
          );
        }
        return await query.orderBy(desc2(tasks.createdAt));
      }
      async getTask(id) {
        const [task] = await db.select().from(tasks).where(eq2(tasks.id, id));
        return task;
      }
      async createTask(task) {
        const [newTask] = await db.insert(tasks).values(task).returning();
        emitRealtimeEvent("task", "create", newTask.id, newTask.organizationId);
        return newTask;
      }
      async updateTask(id, task) {
        const [updatedTask] = await db.update(tasks).set({ ...task, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(tasks.id, id)).returning();
        emitRealtimeEvent("task", "update", id, updatedTask?.organizationId);
        return updatedTask;
      }
      async deleteTask(id) {
        const result = await db.delete(tasks).where(eq2(tasks.id, id));
        emitRealtimeEvent("task", "delete", id);
        return result.rowCount > 0;
      }
      // Enhanced staff task management
      async completeTask(id, userId, evidencePhotos, issuesFound, notes) {
        const [task] = await db.select().from(tasks).where(eq2(tasks.id, id));
        if (!task) return void 0;
        const [updatedTask] = await db.update(tasks).set({
          status: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          completionNotes: notes,
          evidencePhotos,
          issuesFound,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(tasks.id, id)).returning();
        await this.createTaskHistory({
          organizationId: task.organizationId,
          taskId: id,
          propertyId: task.propertyId,
          action: "completed",
          previousStatus: task.status,
          newStatus: "completed",
          performedBy: userId,
          notes,
          evidencePhotos,
          issuesFound
        });
        return updatedTask;
      }
      async skipTask(id, userId, reason) {
        const [task] = await db.select().from(tasks).where(eq2(tasks.id, id));
        if (!task) return void 0;
        const [updatedTask] = await db.update(tasks).set({
          status: "skipped",
          skipReason: reason,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(tasks.id, id)).returning();
        await this.createTaskHistory({
          organizationId: task.organizationId,
          taskId: id,
          propertyId: task.propertyId,
          action: "skipped",
          previousStatus: task.status,
          newStatus: "skipped",
          performedBy: userId,
          notes: reason,
          evidencePhotos: [],
          issuesFound: []
        });
        return updatedTask;
      }
      async rescheduleTask(id, userId, newDate, reason) {
        const [task] = await db.select().from(tasks).where(eq2(tasks.id, id));
        if (!task) return void 0;
        const [updatedTask] = await db.update(tasks).set({
          status: "rescheduled",
          rescheduledDate: newDate,
          rescheduleReason: reason,
          dueDate: newDate,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(tasks.id, id)).returning();
        await this.createTaskHistory({
          organizationId: task.organizationId,
          taskId: id,
          propertyId: task.propertyId,
          action: "rescheduled",
          previousStatus: task.status,
          newStatus: "rescheduled",
          performedBy: userId,
          notes: `Rescheduled to ${newDate.toISOString()}: ${reason}`,
          evidencePhotos: [],
          issuesFound: []
        });
        return updatedTask;
      }
      async startTask(id, userId) {
        const [task] = await db.select().from(tasks).where(eq2(tasks.id, id));
        if (!task) return void 0;
        const [updatedTask] = await db.update(tasks).set({
          status: "in-progress",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(tasks.id, id)).returning();
        await this.createTaskHistory({
          organizationId: task.organizationId,
          taskId: id,
          propertyId: task.propertyId,
          action: "started",
          previousStatus: task.status,
          newStatus: "in-progress",
          performedBy: userId,
          notes: "Task started",
          evidencePhotos: [],
          issuesFound: []
        });
        return updatedTask;
      }
      // Task history operations
      async getTaskHistory(taskId) {
        return await db.select().from(taskHistory).where(eq2(taskHistory.taskId, taskId)).orderBy(desc2(taskHistory.timestamp));
      }
      async getTaskHistoryByProperty(propertyId) {
        return await db.select().from(taskHistory).where(eq2(taskHistory.propertyId, propertyId)).orderBy(desc2(taskHistory.timestamp));
      }
      async createTaskHistory(history) {
        const [newHistory] = await db.insert(taskHistory).values(history).returning();
        return newHistory;
      }
      // Booking operations
      async getBookings(organizationId2, source) {
        let query = db.select().from(bookings).where(eq2(bookings.organizationId, organizationId2));
        if (source) {
          query = query.where(and3(eq2(bookings.organizationId, organizationId2), eq2(bookings.source, source)));
        }
        return await query.orderBy(desc2(bookings.createdAt));
      }
      async getBookingsByProperty(propertyId) {
        return await db.select().from(bookings).where(eq2(bookings.propertyId, propertyId)).orderBy(asc(bookings.checkIn));
      }
      // Enhanced method to get bookings with source information for transparency
      async getBookingsWithSource(organizationId2, propertyId) {
        let legacyQuery = db.select({
          id: bookings.id,
          organizationId: bookings.organizationId,
          propertyId: bookings.propertyId,
          guestName: bookings.guestName,
          guestEmail: bookings.guestEmail,
          guestPhone: bookings.guestPhone,
          checkIn: bookings.checkIn,
          checkOut: bookings.checkOut,
          guests: bookings.guests,
          totalAmount: bookings.totalAmount,
          currency: bookings.currency,
          status: bookings.status,
          paymentStatus: bookings.paymentStatus,
          amountPaid: bookings.amountPaid,
          amountDue: bookings.amountDue,
          bookingPlatform: bookings.bookingPlatform,
          bookingReference: bookings.bookingReference,
          specialRequests: bookings.specialRequests,
          createdAt: bookings.createdAt,
          // Add source identification
          source: sql3`CASE 
          WHEN ${bookings.source} IN ('HOSTAWAY', 'LOCAL') THEN ${bookings.source}
          WHEN ${bookings.bookingPlatform} = 'retail-agent' THEN 'Retail Agent'
          WHEN ${bookings.bookingPlatform} = 'direct' THEN 'Direct Booking'
          ELSE ${bookings.bookingPlatform}
        END`.as("source"),
          // Get agent information if it's an agent booking
          agentInfo: sql3`(
          SELECT json_build_object(
            'agentId', ${agentBookings.retailAgentId},
            'commissionRate', ${agentBookings.commissionRate},
            'commissionAmount', ${agentBookings.commissionAmount}
          )
          FROM ${agentBookings} 
          WHERE ${agentBookings.bookingId} = ${bookings.id}
        )`.as("agentInfo")
        }).from(bookings).where(eq2(bookings.organizationId, organizationId2));
        if (propertyId) {
          legacyQuery = legacyQuery.where(eq2(bookings.propertyId, propertyId));
        }
        const legacyBookings = await legacyQuery.orderBy(asc(bookings.checkIn));
        const existingBookingRefs = new Set(
          legacyBookings.filter((b) => b.bookingReference).map((b) => b.bookingReference)
        );
        let revenueQuery = db.select({
          id: bookingRevenue.id,
          organizationId: bookingRevenue.organizationId,
          propertyId: bookingRevenue.propertyId,
          guestName: bookingRevenue.guestName,
          guestEmail: bookingRevenue.guestEmail,
          guestPhone: sql3`NULL`.as("guestPhone"),
          // booking_revenue doesn't have phone
          checkIn: bookingRevenue.checkInDate,
          checkOut: bookingRevenue.checkOutDate,
          guests: bookingRevenue.numberOfGuests,
          totalAmount: bookingRevenue.guestBookingPrice,
          currency: bookingRevenue.currency,
          status: bookingRevenue.paymentStatus,
          paymentStatus: bookingRevenue.paymentStatus,
          amountPaid: sql3`CASE WHEN ${bookingRevenue.paymentStatus} = 'paid' THEN ${bookingRevenue.guestBookingPrice} ELSE 0 END`.as("amountPaid"),
          amountDue: sql3`CASE WHEN ${bookingRevenue.paymentStatus} = 'paid' THEN 0 ELSE ${bookingRevenue.guestBookingPrice} END`.as("amountDue"),
          bookingPlatform: bookingRevenue.otaName,
          reservationCode: bookingRevenue.reservationCode,
          specialRequests: bookingRevenue.notes,
          createdAt: bookingRevenue.createdAt,
          source: sql3`${bookingRevenue.otaName}`.as("source"),
          agentInfo: sql3`NULL`.as("agentInfo")
        }).from(bookingRevenue).where(eq2(bookingRevenue.organizationId, organizationId2));
        if (propertyId) {
          revenueQuery = revenueQuery.where(eq2(bookingRevenue.propertyId, propertyId));
        }
        const revenueBookings = await revenueQuery.orderBy(asc(bookingRevenue.checkInDate));
        const uniqueRevenueBookings = revenueBookings.filter(
          (rb) => !existingBookingRefs.has(rb.reservationCode)
        );
        const allBookings = [...legacyBookings, ...uniqueRevenueBookings];
        allBookings.sort((a, b) => {
          const dateA = new Date(a.checkIn);
          const dateB = new Date(b.checkIn);
          return dateA.getTime() - dateB.getTime();
        });
        return allBookings;
      }
      async getBooking(id) {
        const [booking] = await db.select().from(bookings).where(eq2(bookings.id, id));
        return booking;
      }
      async getBookingByReferenceAndEmail(bookingReference, guestEmail) {
        const [booking] = await db.select().from(bookings).where(and3(
          eq2(bookings.bookingReference, bookingReference),
          eq2(bookings.guestEmail, guestEmail)
        ));
        return booking;
      }
      async createBooking(booking) {
        const [newBooking] = await db.insert(bookings).values(booking).returning();
        emitRealtimeEvent("booking", "create", newBooking.id, newBooking.organizationId);
        return newBooking;
      }
      async updateBooking(id, booking) {
        const [updatedBooking] = await db.update(bookings).set({ ...booking, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(bookings.id, id)).returning();
        emitRealtimeEvent("booking", "update", id, updatedBooking?.organizationId);
        return updatedBooking;
      }
      async deleteBooking(id) {
        const result = await db.delete(bookings).where(eq2(bookings.id, id));
        emitRealtimeEvent("booking", "delete", id);
        return result.rowCount > 0;
      }
      // Finance operations
      async getFinances() {
        return await db.select().from(finances).orderBy(desc2(finances.date));
      }
      async getFinancesByProperty(propertyId) {
        return await db.select().from(finances).where(eq2(finances.propertyId, propertyId)).orderBy(desc2(finances.date));
      }
      async createFinance(finance) {
        const [newFinance] = await db.insert(finances).values(finance).returning();
        emitRealtimeEvent("finance", "create", newFinance.id, newFinance.organizationId);
        return newFinance;
      }
      async updateFinance(id, finance) {
        const [updatedFinance] = await db.update(finances).set({ ...finance, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(finances.id, id)).returning();
        emitRealtimeEvent("finance", "update", id, updatedFinance?.organizationId);
        return updatedFinance;
      }
      // Inventory operations
      async getInventoryByProperty(propertyId) {
        return await db.select().from(inventory).where(eq2(inventory.propertyId, propertyId)).orderBy(asc(inventory.itemName));
      }
      async createInventoryItem(item) {
        const [newItem] = await db.insert(inventory).values(item).returning();
        return newItem;
      }
      async updateInventoryItem(id, item) {
        const [updatedItem] = await db.update(inventory).set({ ...item, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(inventory.id, id)).returning();
        return updatedItem;
      }
      // Platform settings operations
      async getPlatformSettings() {
        return await db.select().from(platformSettings).orderBy(asc(platformSettings.category), asc(platformSettings.settingKey));
      }
      async getPlatformSettingsByCategory(category) {
        return await db.select().from(platformSettings).where(eq2(platformSettings.category, category)).orderBy(asc(platformSettings.settingKey));
      }
      async getPlatformSetting(key) {
        const [setting] = await db.select().from(platformSettings).where(eq2(platformSettings.settingKey, key));
        return setting;
      }
      async upsertPlatformSetting(setting) {
        const [newSetting] = await db.insert(platformSettings).values({ ...setting, updatedAt: /* @__PURE__ */ new Date() }).onConflictDoUpdate({
          target: platformSettings.settingKey,
          set: {
            settingValue: setting.settingValue,
            settingType: setting.settingType,
            category: setting.category,
            description: setting.description,
            isSecret: setting.isSecret,
            updatedBy: setting.updatedBy,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return newSetting;
      }
      async deletePlatformSetting(key) {
        const result = await db.delete(platformSettings).where(eq2(platformSettings.settingKey, key));
        return result.rowCount > 0;
      }
      // Add-on services operations
      async getAddonServices() {
        return await db.select().from(addonServices).orderBy(addonServices.category, addonServices.name);
      }
      async getAddonServicesByCategory(category) {
        return await db.select().from(addonServices).where(eq2(addonServices.category, category)).orderBy(addonServices.name);
      }
      async getAddonService(id) {
        const [service] = await db.select().from(addonServices).where(eq2(addonServices.id, id));
        return service;
      }
      async createAddonService(service) {
        const [newService] = await db.insert(addonServices).values(service).returning();
        emitRealtimeEvent("service", "create", newService.id, newService.organizationId);
        return newService;
      }
      async updateAddonService(id, service) {
        const [updatedService] = await db.update(addonServices).set({ ...service, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(addonServices.id, id)).returning();
        emitRealtimeEvent("service", "update", id, updatedService?.organizationId);
        return updatedService;
      }
      async deleteAddonService(id) {
        const result = await db.delete(addonServices).where(eq2(addonServices.id, id));
        emitRealtimeEvent("service", "delete", id);
        return result.rowCount > 0;
      }
      // Add-on bookings operations
      async getAddonBookings() {
        return await db.select().from(addonBookings).orderBy(addonBookings.scheduledDate);
      }
      async getAddonBookingsByProperty(propertyId) {
        return await db.select().from(addonBookings).where(eq2(addonBookings.propertyId, propertyId)).orderBy(addonBookings.scheduledDate);
      }
      async getAddonBookingsByService(serviceId) {
        return await db.select().from(addonBookings).where(eq2(addonBookings.serviceId, serviceId)).orderBy(addonBookings.scheduledDate);
      }
      async getAddonBooking(id) {
        const [booking] = await db.select().from(addonBookings).where(eq2(addonBookings.id, id));
        return booking;
      }
      async createAddonBooking(booking) {
        const [newBooking] = await db.insert(addonBookings).values(booking).returning();
        emitRealtimeEvent("serviceBooking", "create", newBooking.id, newBooking.organizationId);
        return newBooking;
      }
      async updateAddonBooking(id, booking) {
        const [updatedBooking] = await db.update(addonBookings).set({ ...booking, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(addonBookings.id, id)).returning();
        emitRealtimeEvent("serviceBooking", "update", id, updatedBooking?.organizationId);
        return updatedBooking;
      }
      async deleteAddonBooking(id) {
        const result = await db.delete(addonBookings).where(eq2(addonBookings.id, id));
        emitRealtimeEvent("serviceBooking", "delete", id);
        return result.rowCount > 0;
      }
      // Utility bills operations
      async getUtilityBills() {
        return await db.select().from(utilityBills).orderBy(utilityBills.dueDate);
      }
      async getUtilityBillsByProperty(propertyId) {
        return await db.select().from(utilityBills).where(eq2(utilityBills.propertyId, propertyId)).orderBy(utilityBills.dueDate);
      }
      async getUtilityBill(id) {
        const [bill] = await db.select().from(utilityBills).where(eq2(utilityBills.id, id));
        return bill;
      }
      async createUtilityBill(bill) {
        const [newBill] = await db.insert(utilityBills).values(bill).returning();
        emitRealtimeEvent("utility", "create", newBill.id, newBill.organizationId);
        return newBill;
      }
      async updateUtilityBill(id, bill) {
        const [updatedBill] = await db.update(utilityBills).set({ ...bill, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(utilityBills.id, id)).returning();
        emitRealtimeEvent("utility", "update", id, updatedBill?.organizationId);
        return updatedBill;
      }
      async deleteUtilityBill(id) {
        const result = await db.delete(utilityBills).where(eq2(utilityBills.id, id));
        emitRealtimeEvent("utility", "delete", id);
        return result.rowCount > 0;
      }
      // Welcome pack inventory operations
      async getWelcomePackItems() {
        return await db.select().from(welcomePackItems);
      }
      async getWelcomePackItem(id) {
        const [item] = await db.select().from(welcomePackItems).where(eq2(welcomePackItems.id, id));
        return item;
      }
      async createWelcomePackItem(item) {
        const [newItem] = await db.insert(welcomePackItems).values(item).returning();
        return newItem;
      }
      async updateWelcomePackItem(id, item) {
        const [updatedItem] = await db.update(welcomePackItems).set({ ...item, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(welcomePackItems.id, id)).returning();
        return updatedItem;
      }
      async deleteWelcomePackItem(id) {
        const result = await db.delete(welcomePackItems).where(eq2(welcomePackItems.id, id));
        return result.rowCount > 0;
      }
      // Welcome pack templates operations
      async getWelcomePackTemplates() {
        return await db.select().from(welcomePackTemplates);
      }
      async getWelcomePackTemplatesByProperty(propertyId) {
        return await db.select().from(welcomePackTemplates).where(eq2(welcomePackTemplates.propertyId, propertyId));
      }
      async createWelcomePackTemplate(template) {
        const [newTemplate] = await db.insert(welcomePackTemplates).values(template).returning();
        return newTemplate;
      }
      async updateWelcomePackTemplate(id, template) {
        const [updatedTemplate] = await db.update(welcomePackTemplates).set({ ...template, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(welcomePackTemplates.id, id)).returning();
        return updatedTemplate;
      }
      async deleteWelcomePackTemplate(id) {
        const result = await db.delete(welcomePackTemplates).where(eq2(welcomePackTemplates.id, id));
        return result.rowCount > 0;
      }
      // Welcome pack usage operations
      async getWelcomePackUsage() {
        return await db.select().from(welcomePackUsage);
      }
      async getWelcomePackUsageByProperty(propertyId) {
        return await db.select().from(welcomePackUsage).where(eq2(welcomePackUsage.propertyId, propertyId));
      }
      async getWelcomePackUsageByBooking(bookingId) {
        return await db.select().from(welcomePackUsage).where(eq2(welcomePackUsage.bookingId, bookingId));
      }
      async createWelcomePackUsage(usage) {
        const [newUsage] = await db.insert(welcomePackUsage).values(usage).returning();
        return newUsage;
      }
      async updateWelcomePackUsage(id, usage) {
        const [updatedUsage] = await db.update(welcomePackUsage).set({ ...usage, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(welcomePackUsage.id, id)).returning();
        return updatedUsage;
      }
      // Welcome pack automation - logs default welcome pack usage from checkout
      async logWelcomePackUsageFromCheckout(bookingId, propertyId, processedBy) {
        const templates = await this.getWelcomePackTemplatesByProperty(propertyId);
        const usageRecords = [];
        for (const template of templates) {
          const item = await this.getWelcomePackItem(template.itemId);
          if (!item) continue;
          const totalCost = template.isComplimentary ? 0 : template.defaultQuantity * Number(item.unitCost);
          const usage = await this.createWelcomePackUsage({
            organizationId: item.organizationId,
            propertyId,
            bookingId,
            itemId: template.itemId,
            quantityUsed: template.defaultQuantity,
            unitCost: item.unitCost,
            totalCost: totalCost.toString(),
            billingOption: template.isComplimentary ? "complimentary" : "owner_bill",
            processedBy,
            usageDate: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
            notes: "Auto-logged from checkout"
          });
          usageRecords.push(usage);
        }
        return usageRecords;
      }
      // Inventory analytics operations
      async getInventoryStats(organizationId2, filters) {
        const { pool: pool2 } = await Promise.resolve().then(() => (init_db(), db_exports));
        let query = `
      SELECT 
        COUNT(DISTINCT wi.id) as total_items,
        COALESCE(SUM(wu.quantity_used), 0) as total_usage,
        COALESCE(SUM(CAST(wu.total_cost AS DECIMAL)), 0) as total_cost,
        COUNT(CASE WHEN wi.current_stock <= wi.restock_threshold THEN 1 END) as low_stock_alerts
      FROM welcome_pack_items wi
      LEFT JOIN welcome_pack_usage wu ON wi.id = wu.item_id
      WHERE wi.organization_id = $1
    `;
        const params = [organizationId2];
        let paramIndex = 2;
        if (filters?.propertyId) {
          query += ` AND wu.property_id = $${paramIndex}`;
          params.push(filters.propertyId);
          paramIndex++;
        }
        if (filters?.staffId) {
          query += ` AND wu.processed_by = $${paramIndex}`;
          params.push(filters.staffId);
          paramIndex++;
        }
        if (filters?.fromDate) {
          query += ` AND wu.usage_date >= $${paramIndex}`;
          params.push(filters.fromDate.toISOString().split("T")[0]);
          paramIndex++;
        }
        if (filters?.toDate) {
          query += ` AND wu.usage_date <= $${paramIndex}`;
          params.push(filters.toDate.toISOString().split("T")[0]);
          paramIndex++;
        }
        const result = await pool2.query(query, params);
        const stats = result.rows[0];
        const topItemsQuery = `
      SELECT 
        wi.name as item_name,
        wi.category,
        SUM(wu.quantity_used) as total_used,
        SUM(CAST(wu.total_cost AS DECIMAL)) as total_cost
      FROM welcome_pack_usage wu
      JOIN welcome_pack_items wi ON wu.item_id = wi.id
      WHERE wi.organization_id = $1
      ${filters?.propertyId ? `AND wu.property_id = '${filters.propertyId}'` : ""}
      ${filters?.staffId ? `AND wu.processed_by = '${filters.staffId}'` : ""}
      ${filters?.fromDate ? `AND wu.usage_date >= '${filters.fromDate.toISOString().split("T")[0]}'` : ""}
      ${filters?.toDate ? `AND wu.usage_date <= '${filters.toDate.toISOString().split("T")[0]}'` : ""}
      GROUP BY wi.id, wi.name, wi.category
      ORDER BY total_used DESC
      LIMIT 10
    `;
        const topItemsResult = await pool2.query(topItemsQuery, [organizationId2]);
        const topPropertiesQuery = `
      SELECT 
        p.name as property_name,
        SUM(wu.quantity_used) as total_usage,
        SUM(CAST(wu.total_cost AS DECIMAL)) as total_cost
      FROM welcome_pack_usage wu
      JOIN properties p ON wu.property_id = p.id
      JOIN welcome_pack_items wi ON wu.item_id = wi.id
      WHERE wi.organization_id = $1
      ${filters?.staffId ? `AND wu.processed_by = '${filters.staffId}'` : ""}
      ${filters?.fromDate ? `AND wu.usage_date >= '${filters.fromDate.toISOString().split("T")[0]}'` : ""}
      ${filters?.toDate ? `AND wu.usage_date <= '${filters.toDate.toISOString().split("T")[0]}'` : ""}
      GROUP BY p.id, p.name
      ORDER BY total_usage DESC
      LIMIT 10
    `;
        const topPropertiesResult = await pool2.query(topPropertiesQuery, [organizationId2]);
        const staffUsageQuery = `
      SELECT 
        CONCAT(u.first_name, ' ', u.last_name) as staff_name,
        SUM(wu.quantity_used) as total_usage,
        SUM(CAST(wu.total_cost AS DECIMAL)) as total_cost
      FROM welcome_pack_usage wu
      JOIN users u ON wu.processed_by = u.id
      JOIN welcome_pack_items wi ON wu.item_id = wi.id
      WHERE wi.organization_id = $1
      ${filters?.propertyId ? `AND wu.property_id = '${filters.propertyId}'` : ""}
      ${filters?.fromDate ? `AND wu.usage_date >= '${filters.fromDate.toISOString().split("T")[0]}'` : ""}
      ${filters?.toDate ? `AND wu.usage_date <= '${filters.toDate.toISOString().split("T")[0]}'` : ""}
      GROUP BY u.id, u.first_name, u.last_name
      ORDER BY total_usage DESC
      LIMIT 10
    `;
        const staffUsageResult = await pool2.query(staffUsageQuery, [organizationId2]);
        return {
          totalItems: parseInt(stats.total_items) || 0,
          totalUsage: parseInt(stats.total_usage) || 0,
          totalCost: parseFloat(stats.total_cost) || 0,
          lowStockAlerts: parseInt(stats.low_stock_alerts) || 0,
          topUsedItems: topItemsResult.rows || [],
          topProperties: topPropertiesResult.rows || [],
          staffUsage: staffUsageResult.rows || [],
          monthlyUsage: []
        };
      }
      async getDetailedWelcomePackUsage(organizationId2, filters) {
        const { pool: pool2 } = await Promise.resolve().then(() => (init_db(), db_exports));
        let query = `
      SELECT 
        wu.*,
        wi.name as item_name,
        p.name as property_name,
        CONCAT(u.first_name, ' ', u.last_name) as staff_name
      FROM welcome_pack_usage wu
      JOIN welcome_pack_items wi ON wu.item_id = wi.id
      LEFT JOIN properties p ON wu.property_id = p.id
      LEFT JOIN users u ON wu.processed_by = u.id
      WHERE wi.organization_id = $1
    `;
        const params = [organizationId2];
        let paramIndex = 2;
        if (filters?.propertyId) {
          query += ` AND wu.property_id = $${paramIndex}`;
          params.push(filters.propertyId);
          paramIndex++;
        }
        if (filters?.staffId) {
          query += ` AND wu.processed_by = $${paramIndex}`;
          params.push(filters.staffId);
          paramIndex++;
        }
        if (filters?.fromDate) {
          query += ` AND wu.usage_date >= $${paramIndex}`;
          params.push(filters.fromDate.toISOString().split("T")[0]);
          paramIndex++;
        }
        if (filters?.toDate) {
          query += ` AND wu.usage_date <= $${paramIndex}`;
          params.push(filters.toDate.toISOString().split("T")[0]);
          paramIndex++;
        }
        query += ` ORDER BY wu.usage_date DESC, wu.created_at DESC`;
        const result = await pool2.query(query, params);
        return result.rows || [];
      }
      // Financial & Invoice Toolkit operations
      // Staff salary operations
      async getStaffSalary(organizationId2, userId, period) {
        const mockSalary = {
          userId,
          baseSalary: 25e3,
          overtimeHours: 8,
          overtimeRate: 150,
          bonuses: 2e3,
          totalSalary: 28200,
          period: period || "current",
          paymentStatus: "paid"
        };
        return mockSalary;
      }
      async getAllStaffSalaries(organizationId2, period) {
        const members = await db.select().from(staffMembers).where(eq2(staffMembers.organizationId, organizationId2));
        return members.map((member) => ({
          userId: member.userId || member.employeeId,
          userName: `${member.firstName} ${member.lastName}`,
          staffName: `${member.firstName} ${member.lastName}`,
          firstName: member.firstName,
          lastName: member.lastName,
          employeeId: member.employeeId,
          position: member.position,
          department: member.department,
          role: member.position,
          baseSalary: parseFloat(member.monthlySalary || member.hourlyRate || "0"),
          monthlySalary: member.monthlySalary,
          hourlyRate: member.hourlyRate,
          totalSalary: parseFloat(member.monthlySalary || member.hourlyRate || "0"),
          salaryType: member.salaryType,
          status: member.status,
          email: member.email,
          phone: member.phoneNumber,
          startDate: member.startDate,
          period: period || "current",
          paymentStatus: "active"
        }));
      }
      async createStaffSalary(salary) {
        const [newSalary] = await db.insert(staffSalaries).values(salary).returning();
        return newSalary;
      }
      async updateStaffSalary(id, salary) {
        const [updatedSalary] = await db.update(staffSalaries).set({ ...salary, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffSalaries.id, id)).returning();
        return updatedSalary;
      }
      // Commission earnings operations
      async getCommissionEarnings(userId, period) {
        const conditions = [eq2(commissionEarnings.userId, userId)];
        if (period) {
          conditions.push(eq2(commissionEarnings.period, period));
        }
        return await db.select().from(commissionEarnings).where(and3(...conditions)).orderBy(desc2(commissionEarnings.createdAt));
      }
      async createCommissionEarning(earning) {
        const [newEarning] = await db.insert(commissionEarnings).values(earning).returning();
        return newEarning;
      }
      async updateCommissionEarning(id, earning) {
        const [updatedEarning] = await db.update(commissionEarnings).set({ ...earning, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(commissionEarnings.id, id)).returning();
        return updatedEarning;
      }
      async getPortfolioManagerEarnings(managerId, period) {
        const currentPeriod = period || (/* @__PURE__ */ new Date()).toISOString().slice(0, 7);
        const assignments = await db.select({
          propertyId: portfolioAssignments.propertyId,
          commissionRate: portfolioAssignments.commissionRate,
          propertyName: properties.name
        }).from(portfolioAssignments).leftJoin(properties, eq2(portfolioAssignments.propertyId, properties.id)).where(and3(
          eq2(portfolioAssignments.managerId, managerId),
          eq2(portfolioAssignments.isActive, true)
        ));
        const earnings = await db.select().from(commissionEarnings).where(and3(
          eq2(commissionEarnings.userId, managerId),
          eq2(commissionEarnings.period, currentPeriod)
        ));
        const propertyIds = assignments.map((a) => a.propertyId).filter(Boolean);
        let rentalRevenue = 0;
        if (propertyIds.length > 0) {
          const { pool: pool2 } = await Promise.resolve().then(() => (init_db(), db_exports));
          const revenueQuery = `
        SELECT COALESCE(SUM(CAST(total_amount AS DECIMAL)), 0) as total_revenue
        FROM bookings 
        WHERE property_id = ANY($1)
        AND status = 'confirmed'
        AND DATE_TRUNC('month', check_in) = $2
      `;
          const result = await pool2.query(revenueQuery, [propertyIds, `${currentPeriod}-01`]);
          rentalRevenue = parseFloat(result.rows[0]?.total_revenue) || 0;
        }
        return {
          assignedProperties: assignments,
          currentPeriod,
          rentalRevenue,
          commissionEarnings: earnings,
          totalCommission: earnings.reduce((sum4, e) => sum4 + parseFloat(e.amount.toString()), 0)
        };
      }
      // Portfolio assignment operations
      async getPortfolioAssignments(managerId) {
        return await db.select().from(portfolioAssignments).where(and3(
          eq2(portfolioAssignments.managerId, managerId),
          eq2(portfolioAssignments.isActive, true)
        ));
      }
      async assignPortfolioProperty(assignment) {
        const [newAssignment] = await db.insert(portfolioAssignments).values(assignment).returning();
        return newAssignment;
      }
      async unassignPortfolioProperty(managerId, propertyId) {
        const result = await db.update(portfolioAssignments).set({ isActive: false, unassignedAt: /* @__PURE__ */ new Date() }).where(and3(
          eq2(portfolioAssignments.managerId, managerId),
          eq2(portfolioAssignments.propertyId, propertyId)
        ));
        return result.rowCount ? result.rowCount > 0 : false;
      }
      // ===== DOCUMENT CENTER & FILE VAULT OPERATIONS =====
      // Property Documents Operations
      async getPropertyDocuments(organizationId2, filters) {
        const conditions = [eq2(propertyDocuments.organizationId, organizationId2)];
        if (filters?.propertyId) {
          conditions.push(eq2(propertyDocuments.propertyId, filters.propertyId));
        }
        if (filters?.category) {
          conditions.push(eq2(propertyDocuments.category, filters.category));
        }
        if (filters?.visibility) {
          conditions.push(eq2(propertyDocuments.visibility, filters.visibility));
        }
        if (filters?.status) {
          conditions.push(eq2(propertyDocuments.status, filters.status));
        }
        let query = db.select().from(propertyDocuments).where(and3(...conditions)).orderBy(desc2(propertyDocuments.createdAt));
        const docs = await query;
        if (filters?.search) {
          const searchTerm = filters.search.toLowerCase();
          return docs.filter(
            (doc) => doc.title.toLowerCase().includes(searchTerm) || doc.description?.toLowerCase().includes(searchTerm) || doc.originalFilename.toLowerCase().includes(searchTerm) || doc.tags.some((tag) => tag.toLowerCase().includes(searchTerm))
          );
        }
        return docs;
      }
      async getPropertyDocument(id) {
        const [document] = await db.select().from(propertyDocuments).where(eq2(propertyDocuments.id, id));
        return document;
      }
      async updatePropertyDocument(id, updates) {
        const [updatedDocument] = await db.update(propertyDocuments).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyDocuments.id, id)).returning();
        return updatedDocument;
      }
      async deletePropertyDocument(id) {
        const result = await db.delete(propertyDocuments).where(eq2(propertyDocuments.id, id));
        return result.rowCount ? result.rowCount > 0 : false;
      }
      async getExpiringDocuments(organizationId2, days = 30) {
        const futureDate = /* @__PURE__ */ new Date();
        futureDate.setDate(futureDate.getDate() + days);
        return await db.select().from(propertyDocuments).where(and3(
          eq2(propertyDocuments.organizationId, organizationId2),
          eq2(propertyDocuments.hasExpiration, true),
          sql3`expiration_date <= ${futureDate.toISOString().split("T")[0]}`
        )).orderBy(propertyDocuments.expirationDate);
      }
      // Document Access Logs Operations
      async logDocumentAccess(accessLog) {
        const [newLog] = await db.insert(documentAccessLogs).values(accessLog).returning();
        return newLog;
      }
      async getDocumentAccessLogs(documentId, userId, limit = 100) {
        const conditions = [];
        if (documentId) {
          conditions.push(eq2(documentAccessLogs.documentId, documentId));
        }
        if (userId) {
          conditions.push(eq2(documentAccessLogs.userId, userId));
        }
        return await db.select().from(documentAccessLogs).where(conditions.length > 0 ? and3(...conditions) : void 0).orderBy(desc2(documentAccessLogs.createdAt)).limit(limit);
      }
      // Owner Onboarding Checklist Operations
      async getOwnerOnboardingChecklist(organizationId2, ownerId, propertyId) {
        const conditions = [
          eq2(ownerOnboardingChecklists.organizationId, organizationId2),
          eq2(ownerOnboardingChecklists.ownerId, ownerId)
        ];
        if (propertyId) {
          conditions.push(eq2(ownerOnboardingChecklists.propertyId, propertyId));
        }
        const [checklist] = await db.select().from(ownerOnboardingChecklists).where(and3(...conditions));
        return checklist;
      }
      async createOwnerOnboardingChecklist(checklist) {
        const [newChecklist] = await db.insert(ownerOnboardingChecklists).values(checklist).returning();
        return newChecklist;
      }
      async updateOwnerOnboardingChecklist(id, updates) {
        if (updates) {
          const totalTasks = 14;
          const completedTasks = Object.entries(updates).filter(
            ([key, value]) => key.endsWith("Uploaded") || key.endsWith("Completed") || key.endsWith("Provided") || key.endsWith("Set") || key.endsWith("Configured") || key.endsWith("Scheduled") || key.endsWith("Signed")
          ).filter(([_, value]) => value === true).length;
          if (completedTasks > 0) {
            updates.overallProgress = Math.round(completedTasks / totalTasks * 100);
            updates.isCompleted = updates.overallProgress === 100;
            if (updates.isCompleted && !updates.completedAt) {
              updates.completedAt = /* @__PURE__ */ new Date();
            }
          }
        }
        const [updatedChecklist] = await db.update(ownerOnboardingChecklists).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(ownerOnboardingChecklists.id, id)).returning();
        return updatedChecklist;
      }
      async getAllOnboardingChecklists(organizationId2) {
        return await db.select().from(ownerOnboardingChecklists).where(eq2(ownerOnboardingChecklists.organizationId, organizationId2)).orderBy(desc2(ownerOnboardingChecklists.createdAt));
      }
      // Document Categories Operations
      async getDocumentCategories(organizationId2) {
        return await db.select().from(documentCategories).where(and3(
          eq2(documentCategories.organizationId, organizationId2),
          eq2(documentCategories.isActive, true)
        )).orderBy(documentCategories.sortOrder, documentCategories.displayName);
      }
      async createDocumentCategory(category) {
        const [newCategory] = await db.insert(documentCategories).values(category).returning();
        return newCategory;
      }
      async updateDocumentCategory(id, updates) {
        const [updatedCategory] = await db.update(documentCategories).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(documentCategories.id, id)).returning();
        return updatedCategory;
      }
      // File Upload Session Operations
      async createFileUploadSession(session3) {
        const [newSession] = await db.insert(fileUploadSessions).values(session3).returning();
        return newSession;
      }
      async updateFileUploadSession(sessionId, updates) {
        const [updatedSession] = await db.update(fileUploadSessions).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(fileUploadSessions.sessionId, sessionId)).returning();
        return updatedSession;
      }
      async getFileUploadSession(sessionId) {
        const [session3] = await db.select().from(fileUploadSessions).where(eq2(fileUploadSessions.sessionId, sessionId));
        return session3;
      }
      // ===== ENHANCED GUEST DASHBOARD IMPLEMENTATION =====
      // Guest Booking Operations - Using Centralized Demo Configuration
      async getCurrentGuestBooking(organizationId2, guestId) {
        const bookingResult = await db.select().from(bookings).where(and3(
          eq2(bookings.organizationId, organizationId2)
        )).orderBy(desc2(bookings.checkIn)).limit(1);
        if (!bookingResult.length) {
          return null;
        }
        const booking = bookingResult[0];
        const propertyResult = await db.select().from(properties).where(eq2(properties.id, booking.propertyId)).limit(1);
        const property = propertyResult[0];
        return {
          id: booking.id,
          reservationId: booking.hostaway_id || booking.id.toString(),
          guestName: booking.guestName,
          guestEmail: booking.guestEmail,
          guestPhone: booking.guestPhone,
          numberOfGuests: booking.numberOfGuests || 1,
          checkInDate: booking.checkIn,
          checkOutDate: booking.checkOut,
          bookingStatus: booking.status,
          bookingChannel: booking.channel || "Direct",
          bookingReference: booking.hostaway_id || `#${booking.id}`,
          totalAmount: booking.totalPrice || 0,
          currency: "THB",
          property: property ? {
            id: property.id,
            name: property.name,
            address: property.address || "",
            imageUrl: property.imageUrl || ""
          } : null
        };
      }
      // Property Amenities Operations
      async getPropertyAmenities(organizationId2, propertyId) {
        const propertyResult = await db.select().from(properties).where(eq2(properties.id, propertyId)).limit(1);
        if (!propertyResult.length) {
          return [];
        }
        const property = propertyResult[0];
        return property.amenities ? property.amenities.map((amenity, index2) => ({
          id: index2 + 1,
          amenityName: amenity.name || amenity,
          amenityType: amenity.type || "general",
          description: `${amenity.name || amenity}`,
          isAvailable: true
        })) : [];
      }
      // AI Recommendations Operations
      async getAiRecommendations(organizationId2, propertyId) {
        return [
          // Restaurants
          {
            id: 1,
            recommendationType: "restaurant",
            title: "The Cliff Bar & Grill",
            description: "Oceanfront dining with spectacular sunset views and fresh seafood",
            location: "Chaweng Beach",
            distance: "2.3 km away",
            rating: 4.8,
            priceRange: "$$$",
            operatingHours: "11:00 AM - 11:00 PM",
            website: "https://thecliffsamui.com",
            phone: "+66-77-xxx-xxx",
            category: "seafood",
            aiConfidenceScore: 95.2
          },
          {
            id: 2,
            recommendationType: "restaurant",
            title: "Tree Tops Sky Dining",
            description: "Unique treetop dining experience with authentic Thai cuisine",
            location: "Koh Samui Highlands",
            distance: "4.1 km away",
            rating: 4.6,
            priceRange: "$$",
            operatingHours: "6:00 PM - 10:00 PM",
            category: "thai_food",
            aiConfidenceScore: 89.7
          },
          {
            id: 3,
            recommendationType: "restaurant",
            title: "Barracuda Restaurant",
            description: "Award-winning fine dining with international cuisine",
            location: "Bophut",
            distance: "1.8 km away",
            rating: 4.9,
            priceRange: "$$$$",
            operatingHours: "6:00 PM - 11:00 PM",
            category: "international",
            aiConfidenceScore: 93.4
          },
          // Attractions
          {
            id: 4,
            recommendationType: "attraction",
            title: "Big Buddha Temple",
            description: "Iconic 12-meter golden Buddha statue with panoramic island views",
            location: "Bang Rak",
            distance: "8.5 km away",
            rating: 4.5,
            operatingHours: "6:00 AM - 7:00 PM",
            category: "temple",
            aiConfidenceScore: 87.8
          },
          {
            id: 5,
            recommendationType: "attraction",
            title: "Chaweng Beach",
            description: "Main beach with white sand, clear water, and beach activities",
            location: "Chaweng",
            distance: "2.0 km away",
            rating: 4.4,
            operatingHours: "24 hours",
            category: "beach",
            aiConfidenceScore: 91.2
          },
          {
            id: 6,
            recommendationType: "attraction",
            title: "Secret Buddha Garden",
            description: "Hidden jungle garden with sculptures and waterfalls",
            location: "Central Samui",
            distance: "12.3 km away",
            rating: 4.3,
            operatingHours: "8:00 AM - 5:00 PM",
            category: "nature",
            aiConfidenceScore: 85.6
          },
          // Tours
          {
            id: 7,
            recommendationType: "tour",
            title: "Full Day Island Hopping Tour",
            description: "Visit Ang Thong Marine Park with snorkeling and kayaking",
            location: "Nathon Pier",
            distance: "15.2 km away",
            priceRange: "$$",
            operatingHours: "8:00 AM - 5:00 PM",
            category: "tour_company",
            aiConfidenceScore: 88.9
          },
          {
            id: 8,
            recommendationType: "tour",
            title: "Elephant Sanctuary Experience",
            description: "Ethical elephant interaction and feeding experience",
            location: "Hua Thanon",
            distance: "18.7 km away",
            priceRange: "$$$",
            operatingHours: "9:00 AM - 4:00 PM",
            category: "wildlife",
            aiConfidenceScore: 92.1
          },
          // Weather
          {
            id: 9,
            recommendationType: "weather",
            title: "Weekly Weather Forecast",
            description: "Sunny skies with occasional afternoon showers",
            weatherData: {
              current: { temp: 32, condition: "sunny", humidity: 65 },
              forecast: [
                { date: "2025-01-04", temp: 31, condition: "partly_cloudy" },
                { date: "2025-01-05", temp: 29, condition: "light_rain" },
                { date: "2025-01-06", temp: 33, condition: "sunny" }
              ]
            },
            aiConfidenceScore: 78.5
          }
        ];
      }
      // Service Timeline Operations - Using Centralized Demo Configuration
      async getGuestServiceTimeline(organizationId2, propertyId) {
        const taskResult = await db.select().from(tasks).where(and3(
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.propertyId, propertyId)
        )).orderBy(desc2(tasks.scheduledDate)).limit(10);
        return taskResult.map((task) => ({
          id: task.id,
          serviceType: task.category || "maintenance",
          serviceName: task.title,
          scheduledDate: task.scheduledDate,
          estimatedTime: task.estimatedDuration || "1 hour",
          status: task.status,
          notes: task.notes || "",
          guestVisible: true
        }));
      }
      // ===== OWNER ONBOARDING SYSTEM IMPLEMENTATION =====
      // Owner onboarding process operations
      async getOwnerOnboardingProcesses(organizationId2, filters) {
        const conditions = [eq2(ownerOnboardingProcesses.organizationId, organizationId2)];
        if (filters?.ownerId) {
          conditions.push(eq2(ownerOnboardingProcesses.ownerId, filters.ownerId));
        }
        if (filters?.status) {
          conditions.push(eq2(ownerOnboardingProcesses.status, filters.status));
        }
        if (filters?.propertyId) {
          conditions.push(eq2(ownerOnboardingProcesses.propertyId, filters.propertyId));
        }
        return await db.select().from(ownerOnboardingProcesses).where(and3(...conditions)).orderBy(desc2(ownerOnboardingProcesses.createdAt));
      }
      async getOwnerOnboardingProcess(id) {
        const [process2] = await db.select().from(ownerOnboardingProcesses).where(eq2(ownerOnboardingProcesses.id, id));
        return process2;
      }
      async createOwnerOnboardingProcess(process2) {
        const [newProcess] = await db.insert(ownerOnboardingProcesses).values(process2).returning();
        const defaultSteps = [
          { stepNumber: 1, stepName: "Owner Contact Info", status: "pending" },
          { stepNumber: 2, stepName: "Property Details", status: "pending" },
          { stepNumber: 3, stepName: "Location Setup", status: "pending" },
          { stepNumber: 4, stepName: "Photos Upload", status: "pending" },
          { stepNumber: 5, stepName: "Description & Features", status: "pending" },
          { stepNumber: 6, stepName: "Utilities Setup", status: "pending" },
          { stepNumber: 7, stepName: "Legal Documents", status: "pending" },
          { stepNumber: 8, stepName: "Security & Access", status: "pending" },
          { stepNumber: 9, stepName: "Services Setup", status: "pending" }
        ];
        for (const step of defaultSteps) {
          await db.insert(onboardingStepDetails).values({
            organizationId: process2.organizationId,
            processId: newProcess.id,
            stepNumber: step.stepNumber,
            stepName: step.stepName,
            status: step.status,
            completionData: {}
          });
        }
        return newProcess;
      }
      async updateOwnerOnboardingProcess(id, process2) {
        const [updated] = await db.update(ownerOnboardingProcesses).set({ ...process2, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(ownerOnboardingProcesses.id, id)).returning();
        return updated;
      }
      async deleteOwnerOnboardingProcess(id) {
        const result = await db.delete(ownerOnboardingProcesses).where(eq2(ownerOnboardingProcesses.id, id));
        return result.rowCount > 0;
      }
      // Owner documents operations
      async getOwnerDocuments(organizationId2, filters) {
        const conditions = [eq2(ownerDocuments.organizationId, organizationId2)];
        if (filters?.ownerId) {
          conditions.push(eq2(ownerDocuments.ownerId, filters.ownerId));
        }
        if (filters?.category) {
          conditions.push(eq2(ownerDocuments.category, filters.category));
        }
        if (filters?.processId) {
          conditions.push(eq2(ownerDocuments.processId, filters.processId));
        }
        return await db.select().from(ownerDocuments).where(and3(...conditions)).orderBy(desc2(ownerDocuments.createdAt));
      }
      async getOwnerDocument(id) {
        const [document] = await db.select().from(ownerDocuments).where(eq2(ownerDocuments.id, id));
        return document;
      }
      async createOwnerDocument(document) {
        const [newDocument] = await db.insert(ownerDocuments).values(document).returning();
        return newDocument;
      }
      async updateOwnerDocument(id, document) {
        const [updated] = await db.update(ownerDocuments).set({ ...document, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(ownerDocuments.id, id)).returning();
        return updated;
      }
      async deleteOwnerDocument(id) {
        const result = await db.delete(ownerDocuments).where(eq2(ownerDocuments.id, id));
        return result.rowCount > 0;
      }
      // Onboarding step details operations
      async getOnboardingStepDetails(organizationId2, filters) {
        const conditions = [eq2(onboardingStepDetails.organizationId, organizationId2)];
        if (filters?.processId) {
          conditions.push(eq2(onboardingStepDetails.processId, filters.processId));
        }
        if (filters?.stepNumber) {
          conditions.push(eq2(onboardingStepDetails.stepNumber, filters.stepNumber));
        }
        if (filters?.status) {
          conditions.push(eq2(onboardingStepDetails.status, filters.status));
        }
        return await db.select().from(onboardingStepDetails).where(and3(...conditions)).orderBy(onboardingStepDetails.stepNumber);
      }
      async getOnboardingStepDetail(id) {
        const [step] = await db.select().from(onboardingStepDetails).where(eq2(onboardingStepDetails.id, id));
        return step;
      }
      async createOnboardingStepDetail(detail) {
        const [newStep] = await db.insert(onboardingStepDetails).values(detail).returning();
        return newStep;
      }
      async updateOnboardingStepDetail(id, detail) {
        const [updated] = await db.update(onboardingStepDetails).set({ ...detail, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(onboardingStepDetails.id, id)).returning();
        return updated;
      }
      // Onboarding progress tracking
      async getOnboardingProgress(processId) {
        const steps = await db.select().from(onboardingStepDetails).where(eq2(onboardingStepDetails.processId, processId)).orderBy(onboardingStepDetails.stepNumber);
        const totalSteps = steps.length;
        const completedSteps = steps.filter((step) => step.status === "completed").length;
        const nextStep = steps.find((step) => step.status === "pending")?.stepName || null;
        const overallProgress = totalSteps > 0 ? Math.round(completedSteps / totalSteps * 100) : 0;
        return {
          completedSteps,
          totalSteps,
          nextStep,
          overallProgress
        };
      }
      async advanceOnboardingStep(processId, stepNumber, completionData) {
        const [updatedStep] = await db.update(onboardingStepDetails).set({
          status: "completed",
          completionData: completionData || {},
          completedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and3(
            eq2(onboardingStepDetails.processId, processId),
            eq2(onboardingStepDetails.stepNumber, stepNumber)
          )
        ).returning();
        const progress = await this.getOnboardingProgress(processId);
        let processStatus = "in_progress";
        if (progress.overallProgress === 100) {
          processStatus = "completed";
        } else if (progress.completedSteps > 0) {
          processStatus = "in_progress";
        }
        await db.update(ownerOnboardingProcesses).set({
          status: processStatus,
          currentStep: progress.nextStep,
          overallProgress: progress.overallProgress,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerOnboardingProcesses.id, processId));
        return updatedStep;
      }
      async getOverdueOnboardingProcesses(organizationId2) {
        const overdueDate = /* @__PURE__ */ new Date();
        overdueDate.setDate(overdueDate.getDate() - 7);
        return await db.select().from(ownerOnboardingProcesses).where(
          and3(
            eq2(ownerOnboardingProcesses.organizationId, organizationId2),
            inArray(ownerOnboardingProcesses.status, ["pending", "in_progress"]),
            lt(ownerOnboardingProcesses.createdAt, overdueDate)
          )
        ).orderBy(ownerOnboardingProcesses.createdAt);
      }
      groupBy(array, key) {
        const groups = array.reduce((result, item) => {
          const group = String(item[key]);
          if (!result[group]) {
            result[group] = [];
          }
          result[group].push(item);
          return result;
        }, {});
        return Object.entries(groups);
      }
      // Invoice operations
      async getInvoices(organizationId2, filters) {
        const conditions = [eq2(invoices.organizationId, organizationId2)];
        if (filters?.userId) {
          conditions.push(eq2(invoices.senderId, filters.userId));
        }
        if (filters?.type) {
          conditions.push(eq2(invoices.invoiceType, filters.type));
        }
        if (filters?.status) {
          conditions.push(eq2(invoices.status, filters.status));
        }
        return await db.select().from(invoices).where(and3(...conditions)).orderBy(desc2(invoices.createdAt));
      }
      async getInvoice(id) {
        const [invoice] = await db.select().from(invoices).where(eq2(invoices.id, id));
        return invoice;
      }
      async createInvoice(invoice, lineItems) {
        const [newInvoice] = await db.insert(invoices).values(invoice).returning();
        if (lineItems.length > 0) {
          const itemsWithInvoiceId = lineItems.map((item) => ({
            ...item,
            invoiceId: newInvoice.id
          }));
          await db.insert(invoiceLineItems).values(itemsWithInvoiceId);
        }
        return newInvoice;
      }
      async updateInvoice(id, invoice) {
        const [updatedInvoice] = await db.update(invoices).set({ ...invoice, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(invoices.id, id)).returning();
        return updatedInvoice;
      }
      async deleteInvoice(id) {
        const result = await db.delete(invoices).where(eq2(invoices.id, id));
        return result.rowCount ? result.rowCount > 0 : false;
      }
      async generateInvoiceNumber(organizationId2) {
        const today = /* @__PURE__ */ new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, "0");
        const count3 = await db.select().from(invoices).where(and3(
          eq2(invoices.organizationId, organizationId2),
          eq2(invoices.createdAt, new Date(year, today.getMonth(), 1))
        ));
        const sequence = String(count3.length + 1).padStart(4, "0");
        return `INV-${year}${month}-${sequence}`;
      }
      // Owner payout operations
      async getOwnerPayouts() {
        return await db.select().from(ownerPayouts).orderBy(desc2(ownerPayouts.createdAt));
      }
      async getOwnerPayoutsByOwner(ownerId) {
        return await db.select().from(ownerPayouts).where(eq2(ownerPayouts.ownerId, ownerId)).orderBy(desc2(ownerPayouts.createdAt));
      }
      async getOwnerPayoutsByProperty(propertyId) {
        return await db.select().from(ownerPayouts).where(eq2(ownerPayouts.propertyId, propertyId)).orderBy(desc2(ownerPayouts.createdAt));
      }
      async getOwnerPayoutsByStatus(status) {
        return await db.select().from(ownerPayouts).where(eq2(ownerPayouts.status, status)).orderBy(desc2(ownerPayouts.createdAt));
      }
      async getOwnerPayout(id) {
        const [payout] = await db.select().from(ownerPayouts).where(eq2(ownerPayouts.id, id));
        return payout;
      }
      async createOwnerPayout(payout) {
        const [newPayout] = await db.insert(ownerPayouts).values(payout).returning();
        return newPayout;
      }
      async updateOwnerPayout(id, payout) {
        const [updatedPayout] = await db.update(ownerPayouts).set({ ...payout, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(ownerPayouts.id, id)).returning();
        return updatedPayout;
      }
      async approveOwnerPayout(id, approvedBy, approvalNotes) {
        const [updatedPayout] = await db.update(ownerPayouts).set({
          status: "approved",
          approvedBy,
          approvedDate: /* @__PURE__ */ new Date(),
          approvalNotes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerPayouts.id, id)).returning();
        return updatedPayout;
      }
      async markOwnerPayoutPaid(id, paidBy, paymentMethod, paymentReference) {
        const [updatedPayout] = await db.update(ownerPayouts).set({
          status: "paid",
          paidBy,
          paymentMethod,
          paymentReference,
          paymentDate: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerPayouts.id, id)).returning();
        return updatedPayout;
      }
      async uploadOwnerPayoutReceipt(id, receiptUrl, uploadedBy) {
        const [updatedPayout] = await db.update(ownerPayouts).set({
          receiptUrl,
          receiptUploadedBy: uploadedBy,
          receiptUploadedDate: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerPayouts.id, id)).returning();
        return updatedPayout;
      }
      async confirmOwnerPayoutReceived(id, confirmedBy) {
        const [updatedPayout] = await db.update(ownerPayouts).set({
          status: "completed",
          confirmedBy,
          confirmedDate: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerPayouts.id, id)).returning();
        return updatedPayout;
      }
      async calculateOwnerBalance(ownerId, propertyId, startDate, endDate) {
        let whereConditions = [eq2(finances.ownerId, ownerId)];
        if (propertyId) {
          whereConditions.push(eq2(finances.propertyId, propertyId));
        }
        if (startDate && endDate) {
        }
        const incomeRecords = await db.select().from(finances).where(and3(...whereConditions, eq2(finances.type, "income")));
        const expenseRecords = await db.select().from(finances).where(and3(...whereConditions, eq2(finances.type, "expense")));
        const commissionRecords = await db.select().from(finances).where(and3(...whereConditions, eq2(finances.type, "commission")));
        let payoutConditions = [eq2(ownerPayouts.ownerId, ownerId), eq2(ownerPayouts.status, "pending")];
        if (propertyId) {
          payoutConditions.push(eq2(ownerPayouts.propertyId, propertyId));
        }
        const pendingPayouts = await db.select().from(ownerPayouts).where(and3(...payoutConditions));
        const totalIncome = incomeRecords.reduce((sum4, record) => sum4 + parseFloat(record.amount), 0);
        const totalExpenses = expenseRecords.reduce((sum4, record) => sum4 + parseFloat(record.amount), 0);
        const commissionDeductions = commissionRecords.reduce((sum4, record) => sum4 + parseFloat(record.amount), 0);
        const pendingPayoutAmount = pendingPayouts.reduce((sum4, payout) => sum4 + parseFloat(payout.requestedAmount), 0);
        return {
          totalIncome,
          totalExpenses,
          commissionDeductions,
          pendingPayouts: pendingPayoutAmount,
          netBalance: totalIncome - totalExpenses - commissionDeductions
        };
      }
      // Notification operations
      async getNotifications(userId) {
        const result = await db.select().from(notifications).where(eq2(notifications.userId, userId)).orderBy(desc2(notifications.createdAt));
        return result;
      }
      async getUnreadNotifications(userId) {
        const result = await db.select().from(notifications).where(and3(
          eq2(notifications.userId, userId),
          eq2(notifications.isRead, false)
        )).orderBy(desc2(notifications.createdAt));
        return result;
      }
      async getNotificationsByType(userId, type) {
        const result = await db.select().from(notifications).where(and3(
          eq2(notifications.userId, userId),
          eq2(notifications.type, type)
        )).orderBy(desc2(notifications.createdAt));
        return result;
      }
      async getNotification(id) {
        const [notification] = await db.select().from(notifications).where(eq2(notifications.id, id));
        return notification;
      }
      async createNotification(notification) {
        const [created] = await db.insert(notifications).values(notification).returning();
        return created;
      }
      async markNotificationRead(id) {
        const result = await db.update(notifications).set({
          isRead: true,
          readAt: /* @__PURE__ */ new Date()
        }).where(eq2(notifications.id, id));
        return result.rowCount > 0;
      }
      async markAllNotificationsRead(userId) {
        const result = await db.update(notifications).set({
          isRead: true,
          readAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(notifications.userId, userId),
          eq2(notifications.isRead, false)
        ));
        return result.rowCount > 0;
      }
      async deleteNotification(id) {
        const result = await db.delete(notifications).where(eq2(notifications.id, id));
        return result.rowCount > 0;
      }
      // Notification preferences operations
      async getUserNotificationPreferences(userId) {
        const [preferences] = await db.select().from(notificationPreferences).where(eq2(notificationPreferences.userId, userId));
        return preferences;
      }
      async upsertNotificationPreferences(preferences) {
        const [upserted] = await db.insert(notificationPreferences).values(preferences).onConflictDoUpdate({
          target: notificationPreferences.userId,
          set: {
            ...preferences,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return upserted;
      }
      // Live alerts methods for admin dashboard
      async getLiveAlerts(organizationId2) {
        try {
          const now = /* @__PURE__ */ new Date();
          const overdueTasks = await db.select().from(tasks).where(and3(
            eq2(tasks.organizationId, organizationId2),
            lt(tasks.dueDate, now),
            ne(tasks.status, "completed")
          )).limit(5);
          const unpaidBills = await db.select().from(utilityBills).where(and3(
            eq2(utilityBills.organizationId, organizationId2),
            eq2(utilityBills.status, "overdue")
          )).limit(5);
          const guestIssues = await db.select().from(tasks).where(and3(
            eq2(tasks.organizationId, organizationId2),
            eq2(tasks.priority, "high"),
            or(
              like(tasks.title, "%guest%"),
              like(tasks.title, "%check%"),
              like(tasks.title, "%cleaning%")
            )
          )).limit(3);
          return {
            overdueTasks,
            unpaidBills,
            guestIssues
          };
        } catch (error) {
          console.error("Error fetching live alerts:", error);
          return {
            overdueTasks: [],
            unpaidBills: [],
            guestIssues: []
          };
        }
      }
      async getKPIMetrics(organizationId2) {
        try {
          const now = /* @__PURE__ */ new Date();
          const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
          const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
          const revenueResult = await db.select({ total: sum(finances.amount) }).from(finances).where(and3(
            eq2(finances.organizationId, organizationId2),
            eq2(finances.type, "income"),
            gte2(finances.date, startOfMonth),
            lte2(finances.date, endOfMonth)
          ));
          const expenseResult = await db.select({ total: sum(finances.amount) }).from(finances).where(and3(
            eq2(finances.organizationId, organizationId2),
            eq2(finances.type, "expense"),
            gte2(finances.date, startOfMonth),
            lte2(finances.date, endOfMonth)
          ));
          const activeBookingsResult = await db.select({ count: count() }).from(bookings).where(and3(
            eq2(bookings.organizationId, organizationId2),
            or(
              eq2(bookings.status, "confirmed"),
              eq2(bookings.status, "checked_in")
            )
          ));
          const totalProperties = await db.select({ count: count() }).from(properties).where(eq2(properties.organizationId, organizationId2));
          const occupiedProperties = await db.select({ count: count() }).from(bookings).where(and3(
            eq2(bookings.organizationId, organizationId2),
            eq2(bookings.status, "checked_in"),
            lte2(bookings.checkInDate, now),
            gte2(bookings.checkOutDate, now)
          ));
          const occupancyPercent = totalProperties[0]?.count > 0 ? Math.round(occupiedProperties[0]?.count / totalProperties[0]?.count * 100) : 0;
          const topPropertyResult = await db.select({
            propertyId: finances.propertyId,
            totalRevenue: sum(finances.amount)
          }).from(finances).innerJoin(properties, eq2(finances.propertyId, properties.id)).where(and3(
            eq2(finances.organizationId, organizationId2),
            eq2(finances.type, "income"),
            gte2(finances.date, startOfMonth),
            lte2(finances.date, endOfMonth)
          )).groupBy(finances.propertyId).orderBy(desc2(sum(finances.amount))).limit(1);
          let topPerformingProperty = null;
          if (topPropertyResult.length > 0) {
            const property = await this.getProperty(topPropertyResult[0].propertyId);
            topPerformingProperty = {
              name: property?.name || "Unknown Property",
              revenue: parseFloat(topPropertyResult[0].totalRevenue || "0")
            };
          }
          return {
            monthlyRevenue: parseFloat(revenueResult[0]?.total || "0"),
            monthlyExpenses: parseFloat(expenseResult[0]?.total || "0"),
            occupancyPercent,
            activeBookings: activeBookingsResult[0]?.count || 0,
            topPerformingProperty
          };
        } catch (error) {
          console.error("Error fetching KPI metrics:", error);
          return {
            monthlyRevenue: 0,
            monthlyExpenses: 0,
            occupancyPercent: 0,
            activeBookings: 0,
            topPerformingProperty: null
          };
        }
      }
      // Notification trigger methods
      async notifyTaskAssignment(taskId, assigneeId, assignedBy) {
        const task = await this.getTask(taskId);
        if (!task) return;
        const property = await this.getProperty(task.propertyId);
        const notification = {
          organizationId: task.organizationId,
          userId: assigneeId,
          type: "task_assignment",
          title: "New Task Assigned",
          message: `You have been assigned a new ${task.type} task at ${property?.name || "Property"}: ${task.title}`,
          relatedEntityType: "task",
          relatedEntityId: taskId,
          priority: task.priority === "high" ? "high" : "normal",
          actionUrl: `/tasks`,
          actionLabel: "View Task",
          createdBy: assignedBy
        };
        await this.createNotification(notification);
      }
      async notifyBookingUpdate(bookingId, userIds, updateType, message) {
        const booking = await this.getBooking(bookingId);
        if (!booking) return;
        const property = await this.getProperty(booking.propertyId);
        for (const userId of userIds) {
          const notification = {
            organizationId: booking.organizationId,
            userId,
            type: "booking_update",
            title: `Booking ${updateType}`,
            message: `${message} for ${booking.guestName} at ${property?.name || "Property"}`,
            relatedEntityType: "booking",
            relatedEntityId: bookingId,
            priority: updateType === "cancelled" ? "high" : "normal",
            actionUrl: `/bookings`,
            actionLabel: "View Booking"
          };
          await this.createNotification(notification);
        }
      }
      async notifyPayoutAction(payoutId, userId, action, actionBy) {
        const payout = await this.getOwnerPayout(payoutId);
        if (!payout) return;
        const actionMessages = {
          approved: "Your payout request has been approved",
          paid: "Your payout has been processed",
          completed: "Your payout has been completed",
          rejected: "Your payout request has been rejected"
        };
        const notification = {
          organizationId: payout.organizationId,
          userId,
          type: "payout_action",
          title: `Payout ${action.charAt(0).toUpperCase() + action.slice(1)}`,
          message: actionMessages[action] || `Payout status changed to ${action}`,
          relatedEntityType: "payout",
          relatedEntityId: payoutId,
          priority: action === "rejected" ? "high" : "normal",
          actionUrl: `/payouts`,
          actionLabel: "View Payout",
          createdBy: actionBy
        };
        await this.createNotification(notification);
      }
      async notifyMaintenanceApproval(taskId, requesterId, approverIds) {
        const task = await this.getTask(taskId);
        if (!task) return;
        const property = await this.getProperty(task.propertyId);
        for (const approverId of approverIds) {
          const notification = {
            organizationId: task.organizationId,
            userId: approverId,
            type: "maintenance_approval",
            title: "Maintenance Approval Required",
            message: `${task.type} task at ${property?.name || "Property"} requires approval: ${task.title}`,
            relatedEntityType: "task",
            relatedEntityId: taskId,
            priority: "high",
            actionUrl: `/tasks`,
            actionLabel: "Review Task",
            createdBy: requesterId
          };
          await this.createNotification(notification);
        }
      }
      // Property utility accounts operations
      async getPropertyUtilityAccounts() {
        return await db.select().from(propertyUtilityAccounts);
      }
      async getPropertyUtilityAccountsByProperty(propertyId) {
        return await db.select().from(propertyUtilityAccounts).where(eq2(propertyUtilityAccounts.propertyId, propertyId));
      }
      async getPropertyUtilityAccount(id) {
        const [account] = await db.select().from(propertyUtilityAccounts).where(eq2(propertyUtilityAccounts.id, id));
        return account;
      }
      async createPropertyUtilityAccount(account) {
        const [created] = await db.insert(propertyUtilityAccounts).values(account).returning();
        return created;
      }
      async updatePropertyUtilityAccount(id, account) {
        const [updated] = await db.update(propertyUtilityAccounts).set({ ...account, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyUtilityAccounts.id, id)).returning();
        return updated;
      }
      async deletePropertyUtilityAccount(id) {
        const result = await db.delete(propertyUtilityAccounts).where(eq2(propertyUtilityAccounts.id, id));
        return result.rowCount > 0;
      }
      // Enhanced utility bills operations
      async getUtilityBillsByMonth(billingMonth) {
        return await db.select().from(utilityBills).where(eq2(utilityBills.billingMonth, billingMonth)).orderBy(utilityBills.dueDate);
      }
      async getOverdueUtilityBills() {
        const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        return await db.select().from(utilityBills).where(
          and3(
            lt(utilityBills.dueDate, today),
            eq2(utilityBills.status, "pending")
          )
        ).orderBy(utilityBills.dueDate);
      }
      async getPendingUtilityBills() {
        return await db.select().from(utilityBills).where(eq2(utilityBills.status, "pending")).orderBy(utilityBills.dueDate);
      }
      async uploadUtilityBillReceipt(id, receiptUrl, filename, uploadedBy) {
        const [updated] = await db.update(utilityBills).set({
          receiptUrl,
          receiptFilename: filename,
          uploadedBy,
          uploadedAt: /* @__PURE__ */ new Date(),
          status: "uploaded",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(utilityBills.id, id)).returning();
        return updated;
      }
      async markUtilityBillPaid(id, paidBy) {
        const [updated] = await db.update(utilityBills).set({
          status: "paid",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(utilityBills.id, id)).returning();
        return updated;
      }
      // Utility bill reminder operations
      async getUtilityBillReminders() {
        return await db.select().from(utilityBillReminders).orderBy(desc2(utilityBillReminders.sentAt));
      }
      async getUtilityBillRemindersByUser(userId) {
        return await db.select().from(utilityBillReminders).where(eq2(utilityBillReminders.sentTo, userId)).orderBy(desc2(utilityBillReminders.sentAt));
      }
      async getUnreadUtilityBillReminders(userId) {
        return await db.select().from(utilityBillReminders).where(
          and3(
            eq2(utilityBillReminders.sentTo, userId),
            eq2(utilityBillReminders.isRead, false)
          )
        ).orderBy(desc2(utilityBillReminders.sentAt));
      }
      async createUtilityBillReminder(reminder) {
        const [created] = await db.insert(utilityBillReminders).values(reminder).returning();
        return created;
      }
      async markUtilityBillReminderRead(id) {
        const [updated] = await db.update(utilityBillReminders).set({ isRead: true }).where(eq2(utilityBillReminders.id, id)).returning();
        return updated;
      }
      // Utility automation operations
      async generateUtilityBillReminders(organizationId2) {
        const today = /* @__PURE__ */ new Date();
        const fourDaysAgo = new Date(today);
        fourDaysAgo.setDate(today.getDate() - 4);
        const overdueBills = await db.select().from(utilityBills).where(
          and3(
            eq2(utilityBills.organizationId, organizationId2),
            eq2(utilityBills.status, "pending"),
            lt(utilityBills.dueDate, fourDaysAgo.toISOString().split("T")[0]),
            isNull2(utilityBills.receiptUrl)
          )
        );
        const reminders = [];
        const adminUsers = await db.select().from(users).where(
          and3(
            eq2(users.organizationId, organizationId2),
            eq2(users.role, "admin")
          )
        );
        for (const bill of overdueBills) {
          for (const admin of adminUsers) {
            const existingReminder = await db.select().from(utilityBillReminders).where(
              and3(
                eq2(utilityBillReminders.utilityBillId, bill.id),
                eq2(utilityBillReminders.sentTo, admin.id)
              )
            );
            if (existingReminder.length === 0) {
              const reminder = await this.createUtilityBillReminder({
                organizationId: organizationId2,
                utilityBillId: bill.id,
                reminderType: "missing_receipt",
                sentTo: admin.id,
                reminderMessage: `Utility bill for ${bill.type} at property ${bill.propertyId} is overdue by ${Math.ceil((today.getTime() - new Date(bill.dueDate).getTime()) / (1e3 * 60 * 60 * 24))} days. Please upload receipt.`,
                isRead: false
              });
              reminders.push(reminder);
            }
          }
        }
        return reminders;
      }
      async getUtilityExpensesByProperty(propertyId, fromDate, toDate) {
        let query = db.select({
          type: utilityBills.type,
          totalAmount: sql3`SUM(${utilityBills.amount})`,
          billCount: sql3`COUNT(*)`,
          avgAmount: sql3`AVG(${utilityBills.amount})`,
          responsibleParty: utilityBills.responsibleParty
        }).from(utilityBills).where(eq2(utilityBills.propertyId, propertyId)).groupBy(utilityBills.type, utilityBills.responsibleParty);
        if (fromDate) {
          query = query.where(gte2(utilityBills.billPeriodStart, fromDate.toISOString().split("T")[0]));
        }
        if (toDate) {
          query = query.where(lte2(utilityBills.billPeriodEnd, toDate.toISOString().split("T")[0]));
        }
        return await query;
      }
      async getUtilityExpensesByOwner(ownerId, fromDate, toDate) {
        let query = db.select({
          propertyName: properties.name,
          propertyId: properties.id,
          type: utilityBills.type,
          totalAmount: sql3`SUM(${utilityBills.amount})`,
          billCount: sql3`COUNT(*)`,
          responsibleParty: utilityBills.responsibleParty
        }).from(utilityBills).innerJoin(properties, eq2(utilityBills.propertyId, properties.id)).where(
          and3(
            eq2(properties.ownerId, ownerId),
            eq2(utilityBills.isOwnerBillable, true)
          )
        ).groupBy(properties.id, properties.name, utilityBills.type, utilityBills.responsibleParty);
        if (fromDate) {
          query = query.where(gte2(utilityBills.billPeriodStart, fromDate.toISOString().split("T")[0]));
        }
        if (toDate) {
          query = query.where(lte2(utilityBills.billPeriodEnd, toDate.toISOString().split("T")[0]));
        }
        return await query;
      }
      // ===== AI FEEDBACK SYSTEM METHODS =====
      // Guest feedback operations
      async getGuestFeedback(organizationId2, filters) {
        let query = db.select().from(guestFeedback).where(eq2(guestFeedback.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(guestFeedback.propertyId, filters.propertyId));
        }
        if (filters?.processed !== void 0) {
          query = query.where(eq2(guestFeedback.isProcessed, filters.processed));
        }
        if (filters?.requiresAction !== void 0) {
          query = query.where(eq2(guestFeedback.requiresAction, filters.requiresAction));
        }
        return await query.orderBy(desc2(guestFeedback.receivedAt));
      }
      async getGuestFeedbackById(id) {
        const [feedback] = await db.select().from(guestFeedback).where(eq2(guestFeedback.id, id));
        return feedback;
      }
      async createGuestFeedback(feedback) {
        const [newFeedback] = await db.insert(guestFeedback).values(feedback).returning();
        return newFeedback;
      }
      async processGuestFeedback(id, processedBy, processingNotes, assignedTaskId) {
        const [updatedFeedback] = await db.update(guestFeedback).set({
          isProcessed: true,
          processedBy,
          processingNotes,
          assignedTaskId,
          processedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(guestFeedback.id, id)).returning();
        return updatedFeedback;
      }
      async markFeedbackRequiresAction(id, requiresAction) {
        const [updatedFeedback] = await db.update(guestFeedback).set({
          requiresAction,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(guestFeedback.id, id)).returning();
        return updatedFeedback;
      }
      // AI Task Rules operations
      async getAiTaskRules(organizationId2, filters) {
        let query = db.select().from(aiTaskRules).where(eq2(aiTaskRules.organizationId, organizationId2));
        if (filters?.isActive !== void 0) {
          query = query.where(eq2(aiTaskRules.isActive, filters.isActive));
        }
        if (filters?.department) {
          query = query.where(eq2(aiTaskRules.assignToDepartment, filters.department));
        }
        return await query.orderBy(desc2(aiTaskRules.createdAt));
      }
      async getAiTaskRuleById(id) {
        const [rule] = await db.select().from(aiTaskRules).where(eq2(aiTaskRules.id, id));
        return rule;
      }
      async createAiTaskRule(rule) {
        const [newRule] = await db.insert(aiTaskRules).values(rule).returning();
        return newRule;
      }
      async updateAiTaskRule(id, rule) {
        const [updatedRule] = await db.update(aiTaskRules).set({ ...rule, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(aiTaskRules.id, id)).returning();
        return updatedRule;
      }
      async deleteAiTaskRule(id) {
        const result = await db.delete(aiTaskRules).where(eq2(aiTaskRules.id, id));
        return (result.rowCount || 0) > 0;
      }
      async incrementRuleTriggerCount(id) {
        await db.update(aiTaskRules).set({
          triggerCount: sql3`${aiTaskRules.triggerCount} + 1`,
          lastTriggered: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(aiTaskRules.id, id));
      }
      // Feedback processing operations
      async createProcessingLog(log2) {
        const [newLog] = await db.insert(feedbackProcessingLog).values(log2).returning();
        return newLog;
      }
      async getProcessingLogs(organizationId2, feedbackId) {
        let query = db.select().from(feedbackProcessingLog).where(eq2(feedbackProcessingLog.organizationId, organizationId2));
        if (feedbackId) {
          query = query.where(eq2(feedbackProcessingLog.feedbackId, feedbackId));
        }
        return await query.orderBy(desc2(feedbackProcessingLog.createdAt));
      }
      // Optimized Finance Hub methods
      async getFinances(filters) {
        try {
          let query = db.select().from(finances);
          const conditions = [];
          if (filters?.organizationId) {
            conditions.push(eq2(finances.organizationId, filters.organizationId));
          }
          if (filters?.type) {
            conditions.push(eq2(finances.type, filters.type));
          }
          if (conditions.length > 0) {
            query = query.where(and3(...conditions));
          }
          query = query.orderBy(desc2(finances.date));
          if (filters?.limit) {
            query = query.limit(filters.limit);
          }
          if (filters?.offset) {
            query = query.offset(filters.offset);
          }
          const result = await query;
          return result || [];
        } catch (error) {
          console.error("Error fetching finances:", error);
          return [];
        }
      }
      async getFinanceCount(filters) {
        try {
          let query = db.select({ count: count() }).from(finances);
          const conditions = [];
          if (filters?.organizationId) {
            conditions.push(eq2(finances.organizationId, filters.organizationId));
          }
          if (filters?.type) {
            conditions.push(eq2(finances.type, filters.type));
          }
          if (conditions.length > 0) {
            query = query.where(and3(...conditions));
          }
          const result = await query;
          return result[0]?.count || 0;
        } catch (error) {
          console.error("Error counting finances:", error);
          return 0;
        }
      }
      async getFinanceTrends(filters) {
        try {
          return [
            { date: "2024-01-01", revenue: 5e4, expenses: 3e4 },
            { date: "2024-01-02", revenue: 55e3, expenses: 32e3 },
            { date: "2024-01-03", revenue: 48e3, expenses: 28e3 },
            { date: "2024-01-04", revenue: 62e3, expenses: 35e3 },
            { date: "2024-01-05", revenue: 58e3, expenses: 33e3 },
            { date: "2024-01-06", revenue: 52e3, expenses: 31e3 },
            { date: "2024-01-07", revenue: 59e3, expenses: 34e3 }
          ];
        } catch (error) {
          console.error("Error fetching finance trends:", error);
          return [];
        }
      }
      async getFinanceAnalytics(filters) {
        try {
          const finances3 = await this.getFinances(filters);
          const totalRevenue = finances3.filter((f) => f.type === "income").reduce((sum4, f) => sum4 + (parseFloat(String(f.amount)) || 0), 0);
          const totalExpenses = finances3.filter((f) => f.type === "expense" || f.type === "commission" || f.type === "fees" || f.type === "payout").reduce((sum4, f) => sum4 + (parseFloat(String(f.amount)) || 0), 0);
          const expensesByType = {
            expense: finances3.filter((f) => f.type === "expense").reduce((sum4, f) => sum4 + (parseFloat(String(f.amount)) || 0), 0),
            commission: finances3.filter((f) => f.type === "commission").reduce((sum4, f) => sum4 + (parseFloat(String(f.amount)) || 0), 0),
            fees: finances3.filter((f) => f.type === "fees").reduce((sum4, f) => sum4 + (parseFloat(String(f.amount)) || 0), 0),
            payout: finances3.filter((f) => f.type === "payout").reduce((sum4, f) => sum4 + (parseFloat(String(f.amount)) || 0), 0)
          };
          return {
            totalRevenue,
            totalExpenses,
            netProfit: totalRevenue - totalExpenses,
            monthlyGrowth: 12.5,
            // Demo value
            transactionCount: finances3.length,
            expensesByType
            // Include breakdown
          };
        } catch (error) {
          console.error("Error calculating finance analytics:", error);
          return {
            totalRevenue: 0,
            totalExpenses: 0,
            netProfit: 0,
            monthlyGrowth: 0,
            transactionCount: 0,
            expensesByType: {
              expense: 0,
              commission: 0,
              fees: 0,
              payout: 0
            }
          };
        }
      }
      // Missing getUsers method that was causing crashes
      async getUsers(filters) {
        try {
          let query = db.select().from(users);
          if (filters?.organizationId) {
            query = query.where(eq2(users.organizationId, filters.organizationId));
          }
          return await query;
        } catch (error) {
          console.error("Error fetching users:", error);
          return [];
        }
      }
      // Create new user with hashed password
      async createUser(user) {
        try {
          const hashedPassword = await bcrypt.hash(user.password, 12);
          const [newUser] = await db.insert(users).values({
            ...user,
            password: hashedPassword,
            isActive: true
          }).returning();
          return newUser;
        } catch (error) {
          console.error("Error creating user:", error);
          throw new Error("Failed to create user");
        }
      }
      // System Hub methods
      async getUserStats(filters) {
        try {
          const allUsers = await this.getUsers(filters);
          const totalUsers = allUsers.length;
          const activeUsers = allUsers.filter((user) => user.status === "active" || !user.status).length;
          const usersByRole = allUsers.reduce((acc, user) => {
            acc[user.role] = (acc[user.role] || 0) + 1;
            return acc;
          }, {});
          return {
            totalUsers,
            activeUsers,
            newUsersThisMonth: Math.floor(totalUsers * 0.1),
            usersByRole
          };
        } catch (error) {
          console.error("Error fetching user stats:", error);
          return {
            totalUsers: 0,
            activeUsers: 0,
            newUsersThisMonth: 0,
            usersByRole: {}
          };
        }
      }
      async getSystemStats(filters) {
        try {
          const [propertiesCount, tasksCount] = await Promise.all([
            this.getProperties(filters).then((p) => p.length),
            this.getTasks(filters).then((t) => t.length)
          ]);
          return {
            totalProperties: propertiesCount,
            activeTasks: tasksCount,
            systemUptime: "99.8%",
            apiCallsToday: Math.floor(Math.random() * 1e4) + 5e3
          };
        } catch (error) {
          console.error("Error fetching system stats:", error);
          return {
            totalProperties: 0,
            activeTasks: 0,
            systemUptime: "99.9%",
            apiCallsToday: 0
          };
        }
      }
      async getRecentActivity(filters) {
        try {
          return [
            {
              id: "1",
              type: "User Login",
              description: "Admin user logged in",
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              userId: "admin"
            },
            {
              id: "2",
              type: "Task Created",
              description: "New maintenance task created",
              timestamp: new Date(Date.now() - 36e5).toISOString(),
              userId: "staff"
            },
            {
              id: "3",
              type: "Booking Updated",
              description: "Booking status updated to confirmed",
              timestamp: new Date(Date.now() - 72e5).toISOString(),
              userId: "manager"
            }
          ].slice(0, filters?.limit || 10);
        } catch (error) {
          console.error("Error fetching recent activity:", error);
          return [];
        }
      }
      async getSystemPerformance(filters) {
        try {
          const hours = 24;
          const data = [];
          for (let i = 0; i < hours; i++) {
            data.push({
              timestamp: new Date(Date.now() - i * 36e5).toISOString(),
              cpuUsage: Math.random() * 100,
              memoryUsage: Math.random() * 100,
              responseTime: Math.random() * 500
            });
          }
          return data.reverse();
        } catch (error) {
          console.error("Error fetching system performance:", error);
          return [];
        }
      }
      // Additional utility methods for optimized endpoints
      async getUtilities(filters) {
        try {
          let query = db.select().from(utilityBills);
          const conditions = [];
          if (filters?.organizationId) {
            conditions.push(eq2(utilityBills.organizationId, filters.organizationId));
          }
          if (filters?.status) {
            conditions.push(eq2(utilityBills.status, filters.status));
          }
          if (filters?.type) {
            conditions.push(eq2(utilityBills.type, filters.type));
          }
          if (conditions.length > 0) {
            query = query.where(and3(...conditions));
          }
          query = query.orderBy(desc2(utilityBills.dueDate));
          if (filters?.limit) {
            query = query.limit(filters.limit);
          }
          if (filters?.offset) {
            query = query.offset(filters.offset);
          }
          return await query;
        } catch (error) {
          console.error("Error fetching utilities:", error);
          return [];
        }
      }
      async getUtilityCount(filters) {
        try {
          let query = db.select({ count: count() }).from(utilityBills);
          const conditions = [];
          if (filters?.organizationId) {
            conditions.push(eq2(utilityBills.organizationId, filters.organizationId));
          }
          if (filters?.status) {
            conditions.push(eq2(utilityBills.status, filters.status));
          }
          if (filters?.type) {
            conditions.push(eq2(utilityBills.type, filters.type));
          }
          if (conditions.length > 0) {
            query = query.where(and3(...conditions));
          }
          const result = await query;
          return result[0]?.count || 0;
        } catch (error) {
          console.error("Error counting utilities:", error);
          return 0;
        }
      }
      async getUtilitySummary(filters) {
        try {
          const utilities = await this.getUtilities(filters);
          const summary = utilities.reduce((acc, bill) => {
            const amount = bill.amount || 0;
            switch (bill.status) {
              case "paid":
                acc.totalPaid += amount;
                break;
              case "pending":
                acc.totalPending += amount;
                break;
              case "overdue":
                acc.totalOverdue += amount;
                break;
            }
            return acc;
          }, { totalPaid: 0, totalPending: 0, totalOverdue: 0 });
          summary.monthlyAverage = utilities.length > 0 ? (summary.totalPaid + summary.totalPending + summary.totalOverdue) / Math.max(utilities.length, 1) : 0;
          return summary;
        } catch (error) {
          console.error("Error fetching utility summary:", error);
          return { totalPaid: 0, totalPending: 0, totalOverdue: 0, monthlyAverage: 0 };
        }
      }
      async getUtilityUsageTrends(filters) {
        try {
          return [
            { date: "2024-01-01", electricity: 1200, water: 80, gas: 450 },
            { date: "2024-01-02", electricity: 1180, water: 85, gas: 420 },
            { date: "2024-01-03", electricity: 1250, water: 78, gas: 480 },
            { date: "2024-01-04", electricity: 1300, water: 90, gas: 510 },
            { date: "2024-01-05", electricity: 1220, water: 82, gas: 460 }
          ];
        } catch (error) {
          console.error("Error fetching utility usage trends:", error);
          return [];
        }
      }
      async getInvoices(filters) {
        try {
          let query = db.select().from(ownerInvoices);
          const conditions = [];
          if (filters?.organizationId) {
            conditions.push(eq2(ownerInvoices.organizationId, filters.organizationId));
          }
          if (filters?.status) {
            conditions.push(eq2(ownerInvoices.paymentStatus, filters.status));
          }
          if (conditions.length > 0) {
            query = query.where(and3(...conditions));
          }
          query = query.orderBy(desc2(ownerInvoices.createdAt));
          if (filters?.limit) {
            query = query.limit(filters.limit);
          }
          if (filters?.offset) {
            query = query.offset(filters.offset);
          }
          return await query;
        } catch (error) {
          console.error("Error fetching invoices:", error);
          return [];
        }
      }
      async getInvoiceCount(filters) {
        try {
          let query = db.select({ count: count() }).from(ownerInvoices);
          const conditions = [];
          if (filters?.organizationId) {
            conditions.push(eq2(ownerInvoices.organizationId, filters.organizationId));
          }
          if (filters?.status) {
            conditions.push(eq2(ownerInvoices.paymentStatus, filters.status));
          }
          if (conditions.length > 0) {
            query = query.where(and3(...conditions));
          }
          const result = await query;
          return result[0]?.count || 0;
        } catch (error) {
          console.error("Error counting invoices:", error);
          return 0;
        }
      }
      async getInvoiceSummary(filters) {
        try {
          const invoices2 = await this.getInvoices(filters);
          const summary = invoices2.reduce((acc, invoice) => {
            const amount = invoice.totalAmount || 0;
            switch (invoice.paymentStatus) {
              case "paid":
                acc.totalPaid += amount;
                break;
              case "pending":
                acc.totalPending += amount;
                break;
              case "overdue":
                acc.totalOverdue += amount;
                break;
            }
            acc.totalAmount += amount;
            return acc;
          }, { totalPaid: 0, totalPending: 0, totalOverdue: 0, totalAmount: 0 });
          summary.averageValue = invoices2.length > 0 ? summary.totalAmount / invoices2.length : 0;
          return summary;
        } catch (error) {
          console.error("Error fetching invoice summary:", error);
          return { totalPaid: 0, totalPending: 0, totalOverdue: 0, averageValue: 0 };
        }
      }
      // AI Configuration operations
      async getAiConfiguration(organizationId2) {
        const [config] = await db.select().from(aiConfiguration).where(eq2(aiConfiguration.organizationId, organizationId2));
        return config;
      }
      async upsertAiConfiguration(config) {
        const [newConfig] = await db.insert(aiConfiguration).values(config).onConflictDoUpdate({
          target: aiConfiguration.organizationId,
          set: {
            ...config,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return newConfig;
      }
      // Core AI processing methods
      async processMessageForKeywords(message, organizationId2) {
        const activeRules = await this.getAiTaskRules(organizationId2, { isActive: true });
        const matchedRules = [];
        const detectedKeywords = [];
        const recommendedActions = [];
        const lowerMessage = message.toLowerCase();
        for (const rule of activeRules) {
          const keywords = rule.keywords || [];
          const matchedKeywords = keywords.filter(
            (keyword) => lowerMessage.includes(keyword.toLowerCase())
          );
          if (matchedKeywords.length > 0) {
            matchedRules.push(rule);
            detectedKeywords.push(...matchedKeywords);
            const actionDescription = `Create ${rule.taskType} task: ${rule.taskTitle}`;
            if (rule.assignToDepartment) {
              recommendedActions.push(`${actionDescription} (${rule.assignToDepartment} department)`);
            } else {
              recommendedActions.push(actionDescription);
            }
          }
        }
        return {
          matchedRules,
          detectedKeywords: [...new Set(detectedKeywords)],
          // Remove duplicates
          recommendedActions
        };
      }
      async createTaskFromFeedback(feedbackId, ruleId, assignedTo) {
        const feedback = await this.getGuestFeedbackById(feedbackId);
        const rule = await this.getAiTaskRuleById(ruleId);
        if (!feedback || !rule) {
          throw new Error("Feedback or rule not found");
        }
        const taskData = {
          organizationId: feedback.organizationId,
          propertyId: feedback.propertyId,
          title: rule.taskTitle.replace("{guest_name}", feedback.guestName),
          description: `${rule.taskDescription || ""}

Original guest message: "${feedback.originalMessage}"`,
          type: rule.taskType,
          department: rule.assignToDepartment || "maintenance",
          priority: rule.priority,
          status: "pending",
          assignedTo: assignedTo || rule.defaultAssignee || void 0,
          createdBy: "AI_SYSTEM",
          dueDate: new Date(Date.now() + 24 * 60 * 60 * 1e3)
          // 24 hours from now
        };
        const task = await this.createTask(taskData);
        await this.processGuestFeedback(
          feedbackId,
          "AI_SYSTEM",
          `Task automatically created from AI rule: ${rule.ruleName}`,
          task.id
        );
        await this.incrementRuleTriggerCount(ruleId);
        await this.createProcessingLog({
          organizationId: feedback.organizationId,
          feedbackId,
          processingType: "auto",
          triggeredRuleId: ruleId,
          matchedKeywords: feedback.detectedKeywords || [],
          confidenceScore: 0.85,
          // Default confidence for keyword matching
          actionTaken: "task_created",
          createdTaskId: task.id,
          processedBy: "AI_SYSTEM",
          processingTime: 100
          // milliseconds (simulated)
        });
        return task;
      }
      // Guest Dashboard Extended Modules operations
      async getGuestBookingOverview(organizationId2, guestId) {
        return {
          id: 1,
          guestName: "Sarah Johnson",
          guestEmail: "sarah.johnson@example.com",
          guestPhone: "+1-555-0123",
          numberOfGuests: 2,
          checkInDate: "2024-07-01T15:00:00Z",
          checkOutDate: "2024-07-08T11:00:00Z",
          bookingStatus: "confirmed",
          totalAmount: 2800,
          currency: "USD",
          depositPaid: 500,
          depositStatus: "paid",
          specialRequests: "Late check-in requested, vegetarian welcome basket",
          platform: "Airbnb",
          propertyName: "Property",
          propertyAddress: "123 Coconut Grove, Koh Samui, Thailand"
        };
      }
      async getGuestServicesOrdered(organizationId2, bookingId) {
        return [
          {
            id: 1,
            serviceName: "Private Chef Dinner",
            serviceCategory: "catering",
            serviceDate: "2025-01-05",
            serviceTime: "19:00",
            totalCost: 2500,
            currency: "THB",
            status: "completed",
            paymentStatus: "paid",
            bookingDate: "2025-01-03T14:00:00Z",
            guestNotes: "Thai cuisine for 2 guests. No spicy food for Sarah."
          },
          {
            id: 2,
            serviceName: "Airport Pickup",
            serviceCategory: "transport",
            serviceDate: "2025-01-03",
            serviceTime: "14:30",
            totalCost: 900,
            currency: "THB",
            status: "completed",
            paymentStatus: "paid",
            bookingDate: "2024-12-28T09:15:00Z",
            guestNotes: "Flight TG 103 from Bangkok. 2 passengers with 4 suitcases."
          },
          {
            id: 3,
            serviceName: "Daily Breakfasts (3x)",
            serviceCategory: "catering",
            serviceDate: "2025-01-04",
            serviceTime: "08:00",
            totalCost: 1200,
            currency: "THB",
            status: "confirmed",
            paymentStatus: "paid",
            bookingDate: "2025-01-03T16:30:00Z",
            guestNotes: "Continental breakfast for 3 days. Include fresh fruit and coffee."
          }
        ];
      }
      async getGuestElectricityBilling(organizationId2, bookingId) {
        const billResult = await db.select().from(utilityBills).where(and3(
          eq2(utilityBills.organizationId, organizationId2),
          eq2(utilityBills.bookingId, bookingId),
          eq2(utilityBills.utilityType, "electricity")
        )).limit(1);
        return billResult.length ? billResult[0] : null;
      }
      async getGuestDepositOverview(organizationId2, bookingId) {
        const bookingResult = await db.select().from(bookings).where(and3(
          eq2(bookings.organizationId, organizationId2),
          eq2(bookings.id, bookingId)
        )).limit(1);
        if (!bookingResult.length) {
          return null;
        }
        const booking = bookingResult[0];
        return {
          depositAmount: booking.securityDeposit || 0,
          depositStatus: booking.depositStatus || "pending",
          depositMethod: booking.depositMethod || "cash"
        };
      }
      // ==================== ENHANCED SERVICE REQUEST CONFIRMATION SYSTEM ====================
      // Service Request with Enhanced Confirmation Workflow
      async createServiceRequestWithConfirmation(organizationId2, serviceRequest) {
        const requestData = {
          id: Date.now(),
          // Mock ID generation
          organizationId: organizationId2,
          reservationId: serviceRequest.reservationId || "Demo1234",
          guestId: serviceRequest.guestId || "demo-guest",
          propertyId: serviceRequest.propertyId || 1,
          // Request details
          requestType: serviceRequest.requestType || "service_booking",
          serviceCategory: serviceRequest.serviceCategory || "general",
          title: serviceRequest.title,
          description: serviceRequest.description,
          // Pricing and billing
          estimatedCost: serviceRequest.estimatedCost || 0,
          billingType: serviceRequest.billingType || "guest_billable",
          awaitingConfirmation: serviceRequest.awaitingConfirmation !== void 0 ? serviceRequest.awaitingConfirmation : true,
          // Status workflow
          status: serviceRequest.status || "pending",
          priority: serviceRequest.priority || "normal",
          urgency: serviceRequest.urgency || "normal",
          // Timing
          preferredDate: serviceRequest.preferredDate,
          preferredTime: serviceRequest.preferredTime,
          // Assignment
          assignedDepartment: serviceRequest.assignedDepartment,
          assignedTo: serviceRequest.assignedTo,
          // Confirmation tokens
          confirmationToken: serviceRequest.confirmationToken || `conf_${Date.now()}`,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (requestData.awaitingConfirmation) {
          await this.createServiceRequestNotification(organizationId2, {
            serviceRequestId: requestData.id,
            reservationId: requestData.reservationId,
            propertyId: requestData.propertyId,
            notificationType: "confirmation_needed",
            title: `New Service Request: ${requestData.title}`,
            message: `Guest has requested: ${requestData.description}. Review and confirm pricing.`,
            priority: requestData.urgency === "urgent" ? "high" : "normal",
            notifyRoles: ["admin", "portfolio-manager"],
            actionUrl: `/service-requests/review/${requestData.id}`,
            actionLabel: "Review & Confirm"
          });
        }
        return requestData;
      }
      // Service Request Notifications Management
      async createServiceRequestNotification(organizationId2, notification) {
        const notificationData = {
          id: Date.now(),
          organizationId: organizationId2,
          serviceRequestId: notification.serviceRequestId,
          reservationId: notification.reservationId,
          propertyId: notification.propertyId,
          // Notification details
          notificationType: notification.notificationType,
          title: notification.title,
          message: notification.message,
          priority: notification.priority || "normal",
          // Recipients
          notifyRoles: notification.notifyRoles || ["admin"],
          notifySpecificUsers: notification.notifySpecificUsers || [],
          // Status
          status: "unread",
          readBy: [],
          actionRequired: notification.actionRequired !== void 0 ? notification.actionRequired : true,
          actionUrl: notification.actionUrl,
          actionLabel: notification.actionLabel || "Review",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return notificationData;
      }
      // Get pending notifications for admin/host review
      async getPendingServiceRequestNotifications(organizationId2, userRole) {
        const notifications2 = [
          {
            id: 1,
            serviceRequestId: 101,
            reservationId: "Demo1234",
            propertyId: 1,
            propertyName: "Villa Aruna",
            guestName: "Liam Andersen",
            notificationType: "confirmation_needed",
            title: "New Service Request: Private Spa Massage",
            message: "Guest has requested a couples massage for Thursday evening. Review and confirm pricing.",
            priority: "normal",
            status: "unread",
            actionRequired: true,
            actionUrl: "/service-requests/review/101",
            actionLabel: "Review & Confirm",
            // Service request details
            serviceDetails: {
              serviceCategory: "spa",
              description: "Couples massage for 2 people, Thursday evening around 7 PM",
              estimatedCost: 3500,
              currency: "THB",
              preferredDate: "2025-07-10",
              preferredTime: "19:00",
              guestCount: 2
            },
            createdAt: /* @__PURE__ */ new Date("2025-07-04T15:30:00Z")
          },
          {
            id: 2,
            serviceRequestId: 102,
            reservationId: "Demo1234",
            propertyId: 1,
            propertyName: "Villa Aruna",
            guestName: "Liam Andersen",
            notificationType: "urgent",
            title: "Urgent Request: Extra Pool Towels",
            message: "Guest needs additional pool towels delivered today. Quick approval needed.",
            priority: "high",
            status: "unread",
            actionRequired: true,
            actionUrl: "/service-requests/review/102",
            actionLabel: "Approve Now",
            // Service request details
            serviceDetails: {
              serviceCategory: "housekeeping",
              description: "Need 4 extra pool towels delivered to villa today",
              estimatedCost: 0,
              currency: "THB",
              preferredDate: "2025-07-04",
              preferredTime: "16:00",
              billingType: "complimentary"
            },
            createdAt: /* @__PURE__ */ new Date("2025-07-04T14:45:00Z")
          }
        ];
        const roleBasedNotifications = notifications2.filter((notification) => {
          const allowedRoles = ["admin", "portfolio-manager"];
          if (userRole === "staff") {
            allowedRoles.push("staff");
          }
          return allowedRoles.includes(userRole);
        });
        return roleBasedNotifications;
      }
      // Confirm service request with pricing and assignment
      async confirmServiceRequest(organizationId2, serviceRequestId, confirmationData) {
        const confirmation = {
          serviceRequestId,
          organizationId: organizationId2,
          // Confirmation details
          confirmedBy: confirmationData.confirmedBy,
          confirmedAt: /* @__PURE__ */ new Date(),
          // Updated pricing and billing
          finalCost: confirmationData.finalCost || confirmationData.estimatedCost,
          billingType: confirmationData.billingType || "guest_billable",
          // Assignment
          assignedDepartment: confirmationData.assignedDepartment,
          assignedTo: confirmationData.assignedTo,
          assignedAt: /* @__PURE__ */ new Date(),
          // Scheduling
          scheduledDate: confirmationData.scheduledDate,
          scheduledTime: confirmationData.scheduledTime,
          // Admin notes
          adminNotes: confirmationData.adminNotes,
          specialInstructions: confirmationData.specialInstructions,
          // Updated status
          status: "approved",
          awaitingConfirmation: false,
          // Generate task if needed
          autoCreateTask: confirmationData.autoCreateTask !== void 0 ? confirmationData.autoCreateTask : true,
          updatedAt: /* @__PURE__ */ new Date()
        };
        await this.markNotificationAsResolved(organizationId2, serviceRequestId, confirmationData.confirmedBy);
        if (confirmation.autoCreateTask) {
          await this.createTaskFromServiceRequest(organizationId2, serviceRequestId, confirmation);
        }
        return confirmation;
      }
      // Mark notification as resolved
      async markNotificationAsResolved(organizationId2, serviceRequestId, resolvedBy) {
        console.log(`Notification for service request ${serviceRequestId} marked as resolved by ${resolvedBy}`);
      }
      // Create task from confirmed service request
      async createTaskFromServiceRequest(organizationId2, serviceRequestId, confirmationData) {
        const task = {
          id: Date.now(),
          organizationId: organizationId2,
          serviceRequestId,
          // Task details
          title: `Service Delivery: ${confirmationData.serviceCategory || "Guest Request"}`,
          description: `Deliver confirmed service for guest. Reference: SR-${serviceRequestId}`,
          // Assignment
          assignedTo: confirmationData.assignedTo,
          department: confirmationData.assignedDepartment || "general",
          // Scheduling
          dueDate: confirmationData.scheduledDate,
          priority: "normal",
          status: "pending",
          // Service reference
          relatedServiceRequestId: serviceRequestId,
          specialInstructions: confirmationData.specialInstructions,
          createdAt: /* @__PURE__ */ new Date()
        };
        return task;
      }
      // Decline service request with reason
      async declineServiceRequest(organizationId2, serviceRequestId, declineData) {
        const decline = {
          serviceRequestId,
          organizationId: organizationId2,
          // Decline details
          declinedBy: declineData.declinedBy,
          declinedAt: /* @__PURE__ */ new Date(),
          declineReason: declineData.declineReason,
          // Alternative suggestions
          alternativeSuggestions: declineData.alternativeSuggestions,
          // Updated status
          status: "declined",
          updatedAt: /* @__PURE__ */ new Date()
        };
        await this.markNotificationAsResolved(organizationId2, serviceRequestId, declineData.declinedBy);
        return decline;
      }
      // Get service request by ID with full details
      async getServiceRequestDetails(organizationId2, serviceRequestId) {
        const requestDetails = {
          id: serviceRequestId,
          organizationId: organizationId2,
          reservationId: "Demo1234",
          guestId: "demo-guest",
          propertyId: 1,
          // Request details
          requestType: "service_booking",
          serviceCategory: serviceRequestId === 101 ? "spa" : "housekeeping",
          title: serviceRequestId === 101 ? "Private Spa Massage" : "Extra Pool Towels",
          description: serviceRequestId === 101 ? "Couples massage for 2 people, Thursday evening around 7 PM" : "Need 4 extra pool towels delivered to villa today",
          // Pricing
          estimatedCost: serviceRequestId === 101 ? 3500 : 0,
          billingType: serviceRequestId === 101 ? "guest_billable" : "complimentary",
          currency: "THB",
          // Timing
          preferredDate: serviceRequestId === 101 ? "2025-07-10" : "2025-07-04",
          preferredTime: serviceRequestId === 101 ? "19:00" : "16:00",
          guestCount: serviceRequestId === 101 ? 2 : 1,
          // Status
          status: "pending",
          priority: serviceRequestId === 101 ? "normal" : "high",
          awaitingConfirmation: true,
          // Guest info
          guestName: "Liam Andersen",
          guestEmail: "liam.andersen@example.com",
          propertyName: "Villa Aruna",
          // History
          createdAt: /* @__PURE__ */ new Date("2025-07-04T15:30:00Z"),
          updatedAt: /* @__PURE__ */ new Date("2025-07-04T15:30:00Z")
        };
        return requestDetails;
      }
      // Guest Add-On Service Booking Platform operations
      async getGuestAddonServices(organizationId2, filters) {
        let query = db.select().from(guestAddonServices).where(eq2(guestAddonServices.organizationId, organizationId2));
        if (filters?.category) {
          query = query.where(eq2(guestAddonServices.category, filters.category));
        }
        if (filters?.isActive !== void 0) {
          query = query.where(eq2(guestAddonServices.isActive, filters.isActive));
        }
        return await query.orderBy(asc(guestAddonServices.serviceName));
      }
      async getGuestAddonServiceById(id) {
        const [service] = await db.select().from(guestAddonServices).where(eq2(guestAddonServices.id, id));
        return service;
      }
      async createGuestAddonService(service) {
        const [newService] = await db.insert(guestAddonServices).values(service).returning();
        return newService;
      }
      async updateGuestAddonService(id, service) {
        const [updatedService] = await db.update(guestAddonServices).set({ ...service, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(guestAddonServices.id, id)).returning();
        return updatedService;
      }
      async deleteGuestAddonService(id) {
        const result = await db.delete(guestAddonServices).where(eq2(guestAddonServices.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Guest add-on booking operations
      async getGuestAddonBookings(organizationId2, filters) {
        let query = db.select().from(guestAddonBookings).where(eq2(guestAddonBookings.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(guestAddonBookings.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          query = query.where(eq2(guestAddonBookings.status, filters.status));
        }
        if (filters?.billingRoute) {
          query = query.where(eq2(guestAddonBookings.billingRoute, filters.billingRoute));
        }
        return await query.orderBy(desc2(guestAddonBookings.bookingDate));
      }
      async getGuestAddonBookingById(id) {
        const [booking] = await db.select().from(guestAddonBookings).where(eq2(guestAddonBookings.id, id));
        return booking;
      }
      async createGuestAddonBooking(booking) {
        const [newBooking] = await db.insert(guestAddonBookings).values(booking).returning();
        if (booking.assignedTaskId) {
          const service = await this.getGuestAddonServiceById(booking.serviceId);
          if (service?.autoCreateTask) {
            const task = await this.createTask({
              organizationId: booking.organizationId,
              type: service.taskType || "addon_service",
              title: `${service.serviceName} - ${booking.guestName}`,
              description: `Service: ${service.serviceName}
Guest: ${booking.guestName}
Date: ${booking.serviceDate}
Property: ${booking.propertyId}`,
              status: "pending",
              priority: service.taskPriority || "medium",
              propertyId: booking.propertyId,
              assignedTo: null,
              // Will be assigned by manager
              department: service.taskType
            });
            await db.update(guestAddonBookings).set({ assignedTaskId: task.id }).where(eq2(guestAddonBookings.id, newBooking.id));
            newBooking.assignedTaskId = task.id;
          }
        }
        return newBooking;
      }
      async updateGuestAddonBooking(id, booking) {
        const [updatedBooking] = await db.update(guestAddonBookings).set(booking).where(eq2(guestAddonBookings.id, id)).returning();
        return updatedBooking;
      }
      async confirmGuestAddonBooking(id, confirmedBy) {
        const [updatedBooking] = await db.update(guestAddonBookings).set({
          status: "confirmed",
          internalNotes: `Confirmed by ${confirmedBy} at ${(/* @__PURE__ */ new Date()).toISOString()}`
        }).where(eq2(guestAddonBookings.id, id)).returning();
        return updatedBooking;
      }
      async cancelGuestAddonBooking(id, cancelledBy, reason) {
        const [updatedBooking] = await db.update(guestAddonBookings).set({
          status: "cancelled",
          internalNotes: `Cancelled by ${cancelledBy}: ${reason || "No reason provided"}`
        }).where(eq2(guestAddonBookings.id, id)).returning();
        return updatedBooking;
      }
      async updateBookingPaymentStatus(id, paymentStatus, paymentMethod, stripePaymentIntentId) {
        const updateData = { paymentStatus };
        if (paymentMethod) updateData.paymentMethod = paymentMethod;
        if (stripePaymentIntentId) updateData.stripePaymentIntentId = stripePaymentIntentId;
        const [updatedBooking] = await db.update(guestAddonBookings).set(updateData).where(eq2(guestAddonBookings.id, id)).returning();
        return updatedBooking;
      }
      // Guest portal access operations
      async getGuestPortalAccess(accessToken) {
        const [access] = await db.select().from(guestPortalAccess).where(eq2(guestPortalAccess.accessToken, accessToken));
        return access;
      }
      async createGuestPortalAccess(access) {
        const [newAccess] = await db.insert(guestPortalAccess).values(access).returning();
        return newAccess;
      }
      async updateGuestPortalAccessActivity(accessToken) {
        await db.update(guestPortalAccess).set({ lastAccessedAt: /* @__PURE__ */ new Date() }).where(eq2(guestPortalAccess.accessToken, accessToken));
      }
      async deactivateGuestPortalAccess(accessToken) {
        const result = await db.update(guestPortalAccess).set({ isActive: false }).where(eq2(guestPortalAccess.accessToken, accessToken));
        return (result.rowCount || 0) > 0;
      }
      // Guest add-on service analytics
      async getGuestAddonServiceAnalytics(organizationId2, filters) {
        let bookingQuery = db.select().from(guestAddonBookings).where(eq2(guestAddonBookings.organizationId, organizationId2));
        if (filters?.fromDate) {
          bookingQuery = bookingQuery.where(gte2(guestAddonBookings.bookingDate, filters.fromDate));
        }
        if (filters?.toDate) {
          bookingQuery = bookingQuery.where(lte2(guestAddonBookings.bookingDate, filters.toDate));
        }
        const bookings3 = await bookingQuery;
        const totalBookings = bookings3.length;
        const totalRevenue = bookings3.reduce((sum4, booking) => sum4 + parseFloat(booking.totalAmount.toString()), 0);
        const serviceStats = /* @__PURE__ */ new Map();
        const billingRouteBreakdown = {};
        const monthlyStatsMap = /* @__PURE__ */ new Map();
        for (const booking of bookings3) {
          const service = await this.getGuestAddonServiceById(booking.serviceId);
          const serviceName = service?.serviceName || "Unknown Service";
          const existing = serviceStats.get(serviceName) || { bookingCount: 0, revenue: 0 };
          existing.bookingCount++;
          existing.revenue += parseFloat(booking.totalAmount.toString());
          serviceStats.set(serviceName, existing);
          billingRouteBreakdown[booking.billingRoute] = (billingRouteBreakdown[booking.billingRoute] || 0) + 1;
          const month = booking.bookingDate.toISOString().slice(0, 7);
          const monthlyExisting = monthlyStatsMap.get(month) || { bookings: 0, revenue: 0 };
          monthlyExisting.bookings++;
          monthlyExisting.revenue += parseFloat(booking.totalAmount.toString());
          monthlyStatsMap.set(month, monthlyExisting);
        }
        const popularServices = Array.from(serviceStats.entries()).map(([serviceName, stats]) => ({ serviceName, ...stats })).sort((a, b) => b.bookingCount - a.bookingCount);
        const monthlyStats = Array.from(monthlyStatsMap.entries()).map(([month, stats]) => ({ month, ...stats })).sort((a, b) => a.month.localeCompare(b.month));
        return {
          totalBookings,
          totalRevenue,
          popularServices,
          billingRouteBreakdown,
          monthlyStats
        };
      }
      // ==================== BALANCE RESET OPERATIONS (ADMIN ONLY) ====================
      async getUsersForBalanceReset(organizationId2, userType) {
        let query = db.select().from(users).where(eq2(users.organizationId, organizationId2));
        if (userType) {
          query = query.where(eq2(users.role, userType));
        } else {
          query = query.where(
            or(
              eq2(users.role, "owner"),
              eq2(users.role, "portfolio-manager"),
              eq2(users.role, "referral-agent"),
              eq2(users.role, "retail-agent")
            )
          );
        }
        return await query.orderBy(asc(users.email));
      }
      async getUserBalanceSummary(userId) {
        const user = await this.getUser(userId);
        if (!user) {
          throw new Error("User not found");
        }
        let currentBalance = 0;
        if (user.role === "owner") {
          const ownerPayouts2 = await db.select().from(ownerPayouts2).where(and3(
            eq2(ownerPayouts2.ownerId, userId),
            eq2(ownerPayouts2.status, "pending")
          ));
          currentBalance = ownerPayouts2.reduce((sum4, payout) => sum4 + parseFloat(payout.amount.toString()), 0);
        } else if (user.role === "referral-agent" || user.role === "retail-agent") {
          const agentPayouts2 = await db.select().from(agentPayouts2).where(and3(
            eq2(agentPayouts2.agentId, userId),
            eq2(agentPayouts2.status, "pending")
          ));
          currentBalance = agentPayouts2.reduce((sum4, payout) => sum4 + parseFloat(payout.amount.toString()), 0);
        } else if (user.role === "portfolio-manager") {
          const commissions = await db.select().from(commissionEarnings).where(and3(
            eq2(commissionEarnings.userId, userId),
            eq2(commissionEarnings.status, "pending")
          ));
          currentBalance = commissions.reduce((sum4, comm) => sum4 + parseFloat(comm.amount.toString()), 0);
        }
        return {
          currentBalance,
          userType: user.role
        };
      }
      async resetUserBalance(userId, adminUserId, resetReason, propertyId) {
        const user = await this.getUser(userId);
        if (!user) {
          throw new Error("User not found");
        }
        const balanceSummary = await this.getUserBalanceSummary(userId);
        const previousBalance = balanceSummary.currentBalance;
        if (user.role === "owner") {
          await db.update(ownerPayouts).set({
            status: "reset",
            adminNotes: `Balance reset by admin: ${resetReason || "No reason provided"}`,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(and3(
            eq2(ownerPayouts.ownerId, userId),
            eq2(ownerPayouts.status, "pending")
          ));
        } else if (user.role === "referral-agent" || user.role === "retail-agent") {
          await db.update(agentPayouts).set({
            status: "reset",
            notes: `Balance reset by admin: ${resetReason || "No reason provided"}`,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(and3(
            eq2(agentPayouts.agentId, userId),
            eq2(agentPayouts.status, "pending")
          ));
        } else if (user.role === "portfolio-manager") {
          await db.update(commissionEarnings).set({
            status: "reset",
            updatedAt: /* @__PURE__ */ new Date()
          }).where(and3(
            eq2(commissionEarnings.userId, userId),
            eq2(commissionEarnings.status, "pending")
          ));
        }
        const auditData = {
          organizationId: user.organizationId,
          userId,
          userType: user.role,
          previousBalance: previousBalance.toString(),
          newBalance: "0.00",
          resetReason,
          adminUserId,
          propertyId
        };
        const [auditRecord] = await db.insert(balanceResetAudit).values(auditData).returning();
        return auditRecord;
      }
      async getBalanceResetAuditLog(organizationId2, filters) {
        const adminUsers = users.as("adminUsers");
        let query = db.select({
          id: balanceResetAudit.id,
          organizationId: balanceResetAudit.organizationId,
          userId: balanceResetAudit.userId,
          userType: balanceResetAudit.userType,
          previousBalance: balanceResetAudit.previousBalance,
          newBalance: balanceResetAudit.newBalance,
          resetReason: balanceResetAudit.resetReason,
          adminUserId: balanceResetAudit.adminUserId,
          propertyId: balanceResetAudit.propertyId,
          createdAt: balanceResetAudit.createdAt,
          // Include related user information
          userEmail: users.email,
          userFirstName: users.firstName,
          userLastName: users.lastName,
          adminEmail: adminUsers.email,
          adminFirstName: adminUsers.firstName,
          adminLastName: adminUsers.lastName
        }).from(balanceResetAudit).leftJoin(users, eq2(balanceResetAudit.userId, users.id)).leftJoin(adminUsers, eq2(balanceResetAudit.adminUserId, adminUsers.id)).where(eq2(balanceResetAudit.organizationId, organizationId2));
        if (filters?.userId) {
          query = query.where(eq2(balanceResetAudit.userId, filters.userId));
        }
        if (filters?.fromDate) {
          query = query.where(gte2(balanceResetAudit.createdAt, filters.fromDate));
        }
        if (filters?.toDate) {
          query = query.where(lte2(balanceResetAudit.createdAt, filters.toDate));
        }
        return await query.orderBy(desc2(balanceResetAudit.createdAt));
      }
      // ==================== RECURRING SERVICES & BILLS MANAGEMENT ====================
      // Recurring Services Operations
      async getRecurringServices(organizationId2, filters) {
        let query = db.select().from(recurringServices).where(eq2(recurringServices.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(recurringServices.propertyId, filters.propertyId));
        }
        if (filters?.serviceCategory) {
          query = query.where(eq2(recurringServices.serviceCategory, filters.serviceCategory));
        }
        if (filters?.isActive !== void 0) {
          query = query.where(eq2(recurringServices.isActive, filters.isActive));
        }
        return query.orderBy(recurringServices.nextBillingDate);
      }
      async getRecurringService(id) {
        const [service] = await db.select().from(recurringServices).where(eq2(recurringServices.id, id));
        return service;
      }
      async createRecurringService(service) {
        const [newService] = await db.insert(recurringServices).values(service).returning();
        return newService;
      }
      async updateRecurringService(id, updates) {
        const [updated] = await db.update(recurringServices).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(recurringServices.id, id)).returning();
        return updated;
      }
      async deleteRecurringService(id) {
        const result = await db.delete(recurringServices).where(eq2(recurringServices.id, id));
        return result.rowCount > 0;
      }
      // Recurring Service Bills Operations
      async getRecurringServiceBills(organizationId2, filters) {
        let query = db.select().from(recurringServiceBills).where(eq2(recurringServiceBills.organizationId, organizationId2));
        if (filters?.serviceId) {
          query = query.where(eq2(recurringServiceBills.serviceId, filters.serviceId));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(recurringServiceBills.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          query = query.where(eq2(recurringServiceBills.status, filters.status));
        }
        if (filters?.billingRoute) {
          query = query.where(eq2(recurringServiceBills.billingRoute, filters.billingRoute));
        }
        if (filters?.fromDate) {
          query = query.where(gte2(recurringServiceBills.billDate, filters.fromDate));
        }
        if (filters?.toDate) {
          query = query.where(lte2(recurringServiceBills.billDate, filters.toDate));
        }
        return query.orderBy(desc2(recurringServiceBills.billDate));
      }
      async getRecurringServiceBill(id) {
        const [bill] = await db.select().from(recurringServiceBills).where(eq2(recurringServiceBills.id, id));
        return bill;
      }
      async createRecurringServiceBill(bill) {
        const [newBill] = await db.insert(recurringServiceBills).values(bill).returning();
        return newBill;
      }
      async updateRecurringServiceBill(id, updates) {
        const [updated] = await db.update(recurringServiceBills).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(recurringServiceBills.id, id)).returning();
        return updated;
      }
      async markBillAsPaid(billId, paymentDetails) {
        const [updated] = await db.update(recurringServiceBills).set({
          status: "paid",
          paidAmount: paymentDetails.paidAmount.toString(),
          paymentDate: paymentDetails.paymentDate,
          paymentMethod: paymentDetails.paymentMethod,
          paymentReference: paymentDetails.paymentReference,
          processedBy: paymentDetails.processedBy,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(recurringServiceBills.id, billId)).returning();
        return updated;
      }
      // Bill Reminders Operations
      async getBillReminders(organizationId2, filters) {
        let query = db.select().from(billReminders).where(eq2(billReminders.organizationId, organizationId2));
        if (filters?.reminderType) {
          query = query.where(eq2(billReminders.reminderType, filters.reminderType));
        }
        if (filters?.status) {
          query = query.where(eq2(billReminders.status, filters.status));
        }
        if (filters?.recipientUser) {
          query = query.where(eq2(billReminders.recipientUser, filters.recipientUser));
        }
        return query.orderBy(billReminders.reminderDate);
      }
      async createBillReminder(reminder) {
        const [newReminder] = await db.insert(billReminders).values(reminder).returning();
        return newReminder;
      }
      async markReminderAsSent(reminderId) {
        const [updated] = await db.update(billReminders).set({
          status: "sent",
          sentAt: /* @__PURE__ */ new Date()
        }).where(eq2(billReminders.id, reminderId)).returning();
        return updated;
      }
      async getOverdueBills(organizationId2) {
        const today = /* @__PURE__ */ new Date();
        return db.select().from(recurringServiceBills).where(
          and3(
            eq2(recurringServiceBills.organizationId, organizationId2),
            eq2(recurringServiceBills.status, "pending"),
            lt(recurringServiceBills.dueDate, today)
          )
        ).orderBy(recurringServiceBills.dueDate);
      }
      async getUpcomingBills(organizationId2, daysAhead = 7) {
        const today = /* @__PURE__ */ new Date();
        const futureDate = /* @__PURE__ */ new Date();
        futureDate.setDate(today.getDate() + daysAhead);
        return db.select().from(recurringServiceBills).where(
          and3(
            eq2(recurringServiceBills.organizationId, organizationId2),
            eq2(recurringServiceBills.status, "pending"),
            gte2(recurringServiceBills.dueDate, today),
            lte2(recurringServiceBills.dueDate, futureDate)
          )
        ).orderBy(recurringServiceBills.dueDate);
      }
      // Service Performance Operations
      async getServicePerformance(organizationId2, filters) {
        let query = db.select().from(servicePerformance).where(eq2(servicePerformance.organizationId, organizationId2));
        if (filters?.serviceId) {
          query = query.where(eq2(servicePerformance.serviceId, filters.serviceId));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(servicePerformance.propertyId, filters.propertyId));
        }
        if (filters?.performanceMonth) {
          query = query.where(eq2(servicePerformance.performanceMonth, filters.performanceMonth));
        }
        return query.orderBy(desc2(servicePerformance.performanceMonth));
      }
      async createServicePerformance(performance) {
        const [newPerformance] = await db.insert(servicePerformance).values(performance).returning();
        return newPerformance;
      }
      async updateServicePerformance(id, updates) {
        const [updated] = await db.update(servicePerformance).set(updates).where(eq2(servicePerformance.id, id)).returning();
        return updated;
      }
      // Analytics for Recurring Services
      async getRecurringServicesAnalytics(organizationId2, filters) {
        const [totalServices] = await db.select({ count: count() }).from(recurringServices).where(
          and3(
            eq2(recurringServices.organizationId, organizationId2),
            eq2(recurringServices.isActive, true),
            filters?.propertyId ? eq2(recurringServices.propertyId, filters.propertyId) : void 0
          )
        );
        const [totalMonthlyBilling] = await db.select({ total: sum(recurringServices.billingAmount) }).from(recurringServices).where(
          and3(
            eq2(recurringServices.organizationId, organizationId2),
            eq2(recurringServices.isActive, true),
            eq2(recurringServices.billingFrequency, "monthly"),
            filters?.propertyId ? eq2(recurringServices.propertyId, filters.propertyId) : void 0
          )
        );
        const servicesByCategory = await db.select({
          category: recurringServices.serviceCategory,
          count: count(),
          totalBilling: sum(recurringServices.billingAmount)
        }).from(recurringServices).where(
          and3(
            eq2(recurringServices.organizationId, organizationId2),
            eq2(recurringServices.isActive, true),
            filters?.propertyId ? eq2(recurringServices.propertyId, filters.propertyId) : void 0
          )
        ).groupBy(recurringServices.serviceCategory);
        const today = /* @__PURE__ */ new Date();
        const next7Days = /* @__PURE__ */ new Date();
        next7Days.setDate(today.getDate() + 7);
        const [upcomingBills] = await db.select({
          count: count(),
          totalAmount: sum(recurringServiceBills.billAmount)
        }).from(recurringServiceBills).where(
          and3(
            eq2(recurringServiceBills.organizationId, organizationId2),
            eq2(recurringServiceBills.status, "pending"),
            gte2(recurringServiceBills.dueDate, today),
            lte2(recurringServiceBills.dueDate, next7Days)
          )
        );
        const [overdueBills] = await db.select({
          count: count(),
          totalAmount: sum(recurringServiceBills.billAmount)
        }).from(recurringServiceBills).where(
          and3(
            eq2(recurringServiceBills.organizationId, organizationId2),
            eq2(recurringServiceBills.status, "pending"),
            lt(recurringServiceBills.dueDate, today)
          )
        );
        const billingRouteBreakdown = await db.select({
          route: recurringServiceBills.billingRoute,
          count: count(),
          totalAmount: sum(recurringServiceBills.billAmount)
        }).from(recurringServiceBills).where(eq2(recurringServiceBills.organizationId, organizationId2)).groupBy(recurringServiceBills.billingRoute);
        const [performanceAverages] = await db.select({
          qualityRating: avg(servicePerformance.qualityRating),
          timelinessRating: avg(servicePerformance.timelinessRating),
          costEffectiveness: avg(servicePerformance.costEffectiveness),
          customerSatisfaction: avg(servicePerformance.customerSatisfaction)
        }).from(servicePerformance).where(eq2(servicePerformance.organizationId, organizationId2));
        return {
          totalServices: totalServices.count || 0,
          totalMonthlyBilling: parseFloat(totalMonthlyBilling.total || "0"),
          servicesByCategory: servicesByCategory.map((cat) => ({
            category: cat.category,
            count: cat.count,
            totalBilling: parseFloat(cat.totalBilling || "0")
          })),
          upcomingBills: {
            count: upcomingBills.count || 0,
            totalAmount: parseFloat(upcomingBills.totalAmount || "0")
          },
          overdueBills: {
            count: overdueBills.count || 0,
            totalAmount: parseFloat(overdueBills.totalAmount || "0")
          },
          billingRouteBreakdown: billingRouteBreakdown.map((route) => ({
            route: route.route,
            count: route.count,
            totalAmount: parseFloat(route.totalAmount || "0")
          })),
          performanceAverages: {
            qualityRating: parseFloat(performanceAverages.qualityRating || "0"),
            timelinessRating: parseFloat(performanceAverages.timelinessRating || "0"),
            costEffectiveness: parseFloat(performanceAverages.costEffectiveness || "0"),
            customerSatisfaction: parseFloat(performanceAverages.customerSatisfaction || "0")
          }
        };
      }
      // ==================== PROPERTY MEDIA LIBRARY ====================
      // Property Media Operations
      async getPropertyMedia(organizationId2, filters) {
        let query = db.select().from(propertyMedia).where(eq2(propertyMedia.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(propertyMedia.propertyId, filters.propertyId));
        }
        if (filters?.mediaType) {
          query = query.where(eq2(propertyMedia.mediaType, filters.mediaType));
        }
        if (filters?.isAgentApproved !== void 0) {
          query = query.where(eq2(propertyMedia.isAgentApproved, filters.isAgentApproved));
        }
        return query.orderBy(propertyMedia.displayOrder, propertyMedia.createdAt);
      }
      async getPropertyMediaById(id) {
        const [media] = await db.select().from(propertyMedia).where(eq2(propertyMedia.id, id));
        return media;
      }
      async createPropertyMedia(media) {
        const [newMedia] = await db.insert(propertyMedia).values(media).returning();
        return newMedia;
      }
      async updatePropertyMedia(id, updates) {
        const [updated] = await db.update(propertyMedia).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyMedia.id, id)).returning();
        return updated;
      }
      async deletePropertyMedia(id) {
        await db.delete(propertyMedia).where(eq2(propertyMedia.id, id));
      }
      async approveMediaForAgents(id, approvedBy) {
        const [updated] = await db.update(propertyMedia).set({
          isAgentApproved: true,
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(propertyMedia.id, id)).returning();
        return updated;
      }
      // Property Internal Notes Operations
      async getPropertyInternalNotes(organizationId2, filters) {
        let query = db.select().from(propertyInternalNotes).where(eq2(propertyInternalNotes.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(propertyInternalNotes.propertyId, filters.propertyId));
        }
        if (filters?.category) {
          query = query.where(eq2(propertyInternalNotes.category, filters.category));
        }
        if (filters?.isVisibleToAgents !== void 0) {
          query = query.where(eq2(propertyInternalNotes.isVisibleToAgents, filters.isVisibleToAgents));
        }
        return query.orderBy(desc2(propertyInternalNotes.createdAt));
      }
      async createPropertyInternalNote(note) {
        const [newNote] = await db.insert(propertyInternalNotes).values(note).returning();
        return newNote;
      }
      async updatePropertyInternalNote(id, updates) {
        const [updated] = await db.update(propertyInternalNotes).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyInternalNotes.id, id)).returning();
        return updated;
      }
      async deletePropertyInternalNote(id) {
        await db.delete(propertyInternalNotes).where(eq2(propertyInternalNotes.id, id));
      }
      // Agent Media Access Operations
      async trackAgentMediaAccess(access) {
        const [newAccess] = await db.insert(agentMediaAccess).values(access).returning();
        return newAccess;
      }
      async updateAgentMediaLastViewed(agentId, mediaId) {
        await db.update(agentMediaAccess).set({ lastViewedAt: /* @__PURE__ */ new Date() }).where(and3(
          eq2(agentMediaAccess.agentId, agentId),
          eq2(agentMediaAccess.mediaId, mediaId)
        ));
      }
      async incrementCopyCount(agentId, mediaId) {
        const existing = await db.select().from(agentMediaAccess).where(and3(
          eq2(agentMediaAccess.agentId, agentId),
          eq2(agentMediaAccess.mediaId, mediaId)
        )).limit(1);
        if (existing.length > 0) {
          await db.update(agentMediaAccess).set({ copyCount: existing[0].copyCount + 1 }).where(eq2(agentMediaAccess.id, existing[0].id));
        }
      }
      // Agent Media Library Dashboard
      async getAgentMediaLibraryData(organizationId2, agentId, filters) {
        const user = await this.getUser(agentId);
        let propertiesQuery;
        if (user?.role === "retail-agent" || user?.role === "referral-agent") {
          propertiesQuery = db.select({
            id: properties.id,
            name: properties.name,
            status: properties.status,
            bedrooms: properties.bedrooms,
            bathrooms: properties.bathrooms,
            maxGuests: properties.maxGuests,
            pricePerNight: properties.pricePerNight,
            commissionRate: properties.commissionRate
          }).from(properties).where(eq2(properties.organizationId, organizationId2));
          if (filters?.propertyStatus) {
            propertiesQuery = propertiesQuery.where(eq2(properties.status, filters.propertyStatus));
          }
        } else {
          propertiesQuery = db.select({
            id: properties.id,
            name: properties.name,
            status: properties.status,
            bedrooms: properties.bedrooms,
            bathrooms: properties.bathrooms,
            maxGuests: properties.maxGuests,
            pricePerNight: properties.pricePerNight,
            commissionRate: properties.commissionRate
          }).from(properties).where(eq2(properties.organizationId, organizationId2));
        }
        const propertiesList = await propertiesQuery;
        const mediaData = await Promise.all(
          propertiesList.map(async (property) => {
            let mediaQuery = db.select().from(propertyMedia).where(and3(
              eq2(propertyMedia.organizationId, organizationId2),
              eq2(propertyMedia.propertyId, property.id),
              eq2(propertyMedia.isAgentApproved, true)
            ));
            if (filters?.mediaType) {
              mediaQuery = mediaQuery.where(eq2(propertyMedia.mediaType, filters.mediaType));
            }
            const media = await mediaQuery.orderBy(propertyMedia.displayOrder);
            const notes = await db.select().from(propertyInternalNotes).where(and3(
              eq2(propertyInternalNotes.organizationId, organizationId2),
              eq2(propertyInternalNotes.propertyId, property.id),
              eq2(propertyInternalNotes.isVisibleToAgents, true)
            )).orderBy(desc2(propertyInternalNotes.createdAt));
            return {
              property,
              media,
              notes
            };
          })
        );
        return mediaData;
      }
      // ===== OWNER DASHBOARD PLATFORM =====
      // Owner Activity Timeline Operations
      async createOwnerActivityTimeline(activity) {
        const [newActivity] = await db.insert(ownerActivityTimeline).values(activity).returning();
        return newActivity;
      }
      async getOwnerActivityTimeline(organizationId2, ownerId, filters) {
        let query = db.select({
          id: ownerActivityTimeline.id,
          organizationId: ownerActivityTimeline.organizationId,
          propertyId: ownerActivityTimeline.propertyId,
          ownerId: ownerActivityTimeline.ownerId,
          activityType: ownerActivityTimeline.activityType,
          title: ownerActivityTimeline.title,
          description: ownerActivityTimeline.description,
          metadata: ownerActivityTimeline.metadata,
          referenceId: ownerActivityTimeline.referenceId,
          referenceType: ownerActivityTimeline.referenceType,
          createdAt: ownerActivityTimeline.createdAt,
          createdBy: ownerActivityTimeline.createdBy,
          propertyName: properties.name
        }).from(ownerActivityTimeline).leftJoin(properties, eq2(ownerActivityTimeline.propertyId, properties.id)).where(and3(
          eq2(ownerActivityTimeline.organizationId, organizationId2),
          eq2(ownerActivityTimeline.ownerId, ownerId)
        ));
        if (filters?.propertyId) {
          query = query.where(eq2(ownerActivityTimeline.propertyId, filters.propertyId));
        }
        if (filters?.activityType) {
          query = query.where(eq2(ownerActivityTimeline.activityType, filters.activityType));
        }
        if (filters?.startDate) {
          query = query.where(gte2(ownerActivityTimeline.createdAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(ownerActivityTimeline.createdAt, new Date(filters.endDate)));
        }
        const result = await query.orderBy(desc2(ownerActivityTimeline.createdAt)).limit(filters?.limit || 50);
        return result;
      }
      // Owner Payout Request Operations
      async createOwnerPayoutRequest(request) {
        const [newRequest] = await db.insert(ownerPayoutRequests).values(request).returning();
        return newRequest;
      }
      async getOwnerPayoutRequests(organizationId2, ownerId, filters) {
        let query = db.select().from(ownerPayoutRequests).where(and3(
          eq2(ownerPayoutRequests.organizationId, organizationId2),
          eq2(ownerPayoutRequests.ownerId, ownerId)
        ));
        if (filters?.status) {
          query = query.where(eq2(ownerPayoutRequests.status, filters.status));
        }
        if (filters?.startDate) {
          query = query.where(gte2(ownerPayoutRequests.requestedAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(ownerPayoutRequests.requestedAt, new Date(filters.endDate)));
        }
        return query.orderBy(desc2(ownerPayoutRequests.requestedAt));
      }
      async updateOwnerPayoutRequest(id, updates) {
        const [updated] = await db.update(ownerPayoutRequests).set(updates).where(eq2(ownerPayoutRequests.id, id)).returning();
        return updated;
      }
      async approvePayoutRequest(id, approvedBy, notes) {
        const [updated] = await db.update(ownerPayoutRequests).set({
          status: "approved",
          approvedAt: /* @__PURE__ */ new Date(),
          approvedBy,
          adminNotes: notes
        }).where(eq2(ownerPayoutRequests.id, id)).returning();
        return updated;
      }
      async completePayoutRequest(id, completedBy, paymentData) {
        const [updated] = await db.update(ownerPayoutRequests).set({
          status: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          completedBy,
          paymentUploadedAt: /* @__PURE__ */ new Date(),
          paymentUploadedBy: completedBy,
          ...paymentData
        }).where(eq2(ownerPayoutRequests.id, id)).returning();
        return updated;
      }
      // Owner Invoice Operations
      async createOwnerInvoice(invoice) {
        const [newInvoice] = await db.insert(ownerInvoices).values(invoice).returning();
        return newInvoice;
      }
      async getOwnerInvoices(organizationId2, ownerId, filters) {
        let query = db.select({
          ...ownerInvoices,
          propertyName: properties.name
        }).from(ownerInvoices).leftJoin(properties, eq2(ownerInvoices.propertyId, properties.id)).where(and3(
          eq2(ownerInvoices.organizationId, organizationId2),
          eq2(ownerInvoices.ownerId, ownerId)
        ));
        if (filters?.propertyId) {
          query = query.where(eq2(ownerInvoices.propertyId, filters.propertyId));
        }
        if (filters?.invoiceType) {
          query = query.where(eq2(ownerInvoices.invoiceType, filters.invoiceType));
        }
        if (filters?.status) {
          query = query.where(eq2(ownerInvoices.status, filters.status));
        }
        if (filters?.startDate) {
          query = query.where(gte2(ownerInvoices.createdAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(ownerInvoices.createdAt, new Date(filters.endDate)));
        }
        return query.orderBy(desc2(ownerInvoices.createdAt));
      }
      async updateOwnerInvoice(id, updates) {
        const [updated] = await db.update(ownerInvoices).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(ownerInvoices.id, id)).returning();
        return updated;
      }
      // Owner Preferences Operations
      async getOwnerPreferences(organizationId2, ownerId) {
        const [preferences] = await db.select().from(ownerPreferences).where(and3(
          eq2(ownerPreferences.organizationId, organizationId2),
          eq2(ownerPreferences.ownerId, ownerId)
        ));
        return preferences;
      }
      async upsertOwnerPreferences(preferences) {
        const [result] = await db.insert(ownerPreferences).values(preferences).onConflictDoUpdate({
          target: ownerPreferences.ownerId,
          set: {
            ...preferences,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return result;
      }
      // Owner Settings Operations (with Custom Branding)
      async getOwnerSettings(organizationId2, ownerId) {
        const [settings] = await db.select().from(ownerSettings).where(and3(
          eq2(ownerSettings.organizationId, organizationId2),
          eq2(ownerSettings.ownerId, ownerId)
        ));
        return settings;
      }
      async upsertOwnerSettings(settings) {
        const [result] = await db.insert(ownerSettings).values(settings).onConflictDoUpdate({
          target: ownerSettings.ownerId,
          set: {
            ...settings,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return result;
      }
      async updateOwnerBranding(organizationId2, ownerId, branding) {
        const [updated] = await db.update(ownerSettings).set({
          customBranding: branding,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(ownerSettings.organizationId, organizationId2),
          eq2(ownerSettings.ownerId, ownerId)
        )).returning();
        return updated;
      }
      async updateOwnerTransparencyMode(organizationId2, ownerId, mode) {
        const [updated] = await db.update(ownerSettings).set({
          transparencyMode: mode,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(ownerSettings.organizationId, organizationId2),
          eq2(ownerSettings.ownerId, ownerId)
        )).returning();
        return updated;
      }
      // Owner Dashboard Analytics
      async getOwnerDashboardStats(organizationId2, ownerId, filters) {
        const ownerProperties = await db.select().from(properties).where(and3(
          eq2(properties.organizationId, organizationId2),
          eq2(properties.ownerId, ownerId)
        ));
        const propertyIds = ownerProperties.map((p) => p.id);
        if (propertyIds.length === 0) {
          return {
            totalRevenue: 0,
            totalBookings: 0,
            upcomingBookings: 0,
            completedTasks: 0,
            pendingPayouts: 0,
            recentActivity: []
          };
        }
        let bookingsQuery = db.select({
          count: count(),
          totalAmount: sum(finances.amount)
        }).from(bookings).leftJoin(finances, eq2(bookings.id, finances.bookingId)).where(and3(
          eq2(bookings.organizationId, organizationId2),
          inArray(bookings.propertyId, propertyIds)
        ));
        if (filters?.startDate) {
          bookingsQuery = bookingsQuery.where(gte2(bookings.startDate, filters.startDate));
        }
        if (filters?.endDate) {
          bookingsQuery = bookingsQuery.where(lte2(bookings.endDate, filters.endDate));
        }
        const [bookingStats] = await bookingsQuery;
        const [taskStats] = await db.select({ count: count() }).from(tasks).where(and3(
          eq2(tasks.organizationId, organizationId2),
          inArray(tasks.propertyId, propertyIds),
          eq2(tasks.status, "completed")
        ));
        const [payoutStats] = await db.select({
          count: count(),
          totalAmount: sum(ownerPayoutRequests.amount)
        }).from(ownerPayoutRequests).where(and3(
          eq2(ownerPayoutRequests.organizationId, organizationId2),
          eq2(ownerPayoutRequests.ownerId, ownerId),
          eq2(ownerPayoutRequests.status, "pending")
        ));
        const thirtyDaysFromNow = /* @__PURE__ */ new Date();
        thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
        const [upcomingStats] = await db.select({ count: count() }).from(bookings).where(and3(
          eq2(bookings.organizationId, organizationId2),
          inArray(bookings.propertyId, propertyIds),
          gte2(bookings.startDate, (/* @__PURE__ */ new Date()).toISOString()),
          lte2(bookings.startDate, thirtyDaysFromNow.toISOString())
        ));
        return {
          totalRevenue: Number(bookingStats?.totalAmount || 0),
          totalBookings: bookingStats?.count || 0,
          upcomingBookings: upcomingStats?.count || 0,
          completedTasks: taskStats?.count || 0,
          pendingPayouts: payoutStats?.count || 0,
          pendingPayoutAmount: Number(payoutStats?.totalAmount || 0),
          properties: ownerProperties
        };
      }
      // Financial Summary for Owner
      async getOwnerFinancialSummary(organizationId2, ownerId, filters) {
        const ownerProperties = await db.select().from(properties).where(and3(
          eq2(properties.organizationId, organizationId2),
          eq2(properties.ownerId, ownerId)
        ));
        const propertyIds = ownerProperties.map((p) => p.id);
        if (propertyIds.length === 0) {
          return {
            rentalIncome: 0,
            managementFees: 0,
            addonRevenue: 0,
            utilityDeductions: 0,
            serviceDeductions: 0,
            netBalance: 0,
            breakdown: []
          };
        }
        let financeQuery = db.select({
          type: finances.type,
          source: finances.source,
          category: finances.category,
          totalAmount: sum(finances.amount),
          count: count()
        }).from(finances).where(and3(
          eq2(finances.organizationId, organizationId2),
          inArray(finances.propertyId, propertyIds)
        ));
        if (filters?.startDate) {
          financeQuery = financeQuery.where(gte2(finances.date, filters.startDate));
        }
        if (filters?.endDate) {
          financeQuery = financeQuery.where(lte2(finances.date, filters.endDate));
        }
        if (filters?.propertyId) {
          financeQuery = financeQuery.where(eq2(finances.propertyId, filters.propertyId));
        }
        const breakdown = await financeQuery.groupBy(finances.type, finances.source, finances.category).orderBy(finances.type, finances.category);
        let rentalIncome = 0;
        let managementFees = 0;
        let addonRevenue = 0;
        let utilityDeductions = 0;
        let serviceDeductions = 0;
        breakdown.forEach((item) => {
          const amount = Number(item.totalAmount || 0);
          if (item.type === "income") {
            if (item.source === "booking_payment") {
              rentalIncome += amount;
            } else if (item.category?.startsWith("addon_")) {
              addonRevenue += amount;
            }
          } else if (item.type === "expense") {
            if (item.category === "management_fee") {
              managementFees += amount;
            } else if (item.category?.startsWith("utility_")) {
              utilityDeductions += amount;
            } else if (item.category?.includes("service")) {
              serviceDeductions += amount;
            }
          }
        });
        const netBalance = rentalIncome + addonRevenue - managementFees - utilityDeductions - serviceDeductions;
        return {
          rentalIncome,
          managementFees,
          addonRevenue,
          utilityDeductions,
          serviceDeductions,
          netBalance,
          breakdown: breakdown.map((item) => ({
            ...item,
            totalAmount: Number(item.totalAmount || 0)
          }))
        };
      }
      // ===== PORTFOLIO MANAGER DASHBOARD PLATFORM =====
      // PM Commission Balance Operations
      async getPMCommissionBalance(organizationId2, managerId) {
        const [balance] = await db.select().from(pmCommissionBalance).where(and3(
          eq2(pmCommissionBalance.organizationId, organizationId2),
          eq2(pmCommissionBalance.managerId, managerId)
        ));
        return balance;
      }
      async updatePMCommissionBalance(organizationId2, managerId, updates) {
        const [updated] = await db.insert(pmCommissionBalance).values({
          organizationId: organizationId2,
          managerId,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).onConflictDoUpdate({
          target: [pmCommissionBalance.organizationId, pmCommissionBalance.managerId],
          set: {
            ...updates,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return updated;
      }
      // PM Payout Request Operations
      async createPMPayoutRequest(request) {
        const [newRequest] = await db.insert(pmPayoutRequests).values(request).returning();
        return newRequest;
      }
      async getPMPayoutRequests(organizationId2, managerId, filters) {
        let query = db.select().from(pmPayoutRequests).where(and3(
          eq2(pmPayoutRequests.organizationId, organizationId2),
          eq2(pmPayoutRequests.managerId, managerId)
        ));
        if (filters?.status) {
          query = query.where(eq2(pmPayoutRequests.status, filters.status));
        }
        if (filters?.startDate) {
          query = query.where(gte2(pmPayoutRequests.requestedAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(pmPayoutRequests.requestedAt, new Date(filters.endDate)));
        }
        return query.orderBy(desc2(pmPayoutRequests.requestedAt));
      }
      async updatePMPayoutRequest(id, updates) {
        const [updated] = await db.update(pmPayoutRequests).set(updates).where(eq2(pmPayoutRequests.id, id)).returning();
        return updated;
      }
      async markPMPaymentReceived(id, managerId) {
        const [updated] = await db.update(pmPayoutRequests).set({
          status: "paid",
          paidAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(pmPayoutRequests.id, id),
          eq2(pmPayoutRequests.managerId, managerId)
        )).returning();
        return updated;
      }
      // PM Task Logs Operations
      async createPMTaskLog(log2) {
        const [newLog] = await db.insert(pmTaskLogs).values(log2).returning();
        return newLog;
      }
      async getPMTaskLogs(organizationId2, managerId, filters) {
        let query = db.select({
          ...pmTaskLogs,
          propertyName: properties.name
        }).from(pmTaskLogs).leftJoin(properties, eq2(pmTaskLogs.propertyId, properties.id)).where(and3(
          eq2(pmTaskLogs.organizationId, organizationId2),
          eq2(pmTaskLogs.managerId, managerId)
        ));
        if (filters?.propertyId) {
          query = query.where(eq2(pmTaskLogs.propertyId, filters.propertyId));
        }
        if (filters?.department) {
          query = query.where(eq2(pmTaskLogs.department, filters.department));
        }
        if (filters?.status) {
          query = query.where(eq2(pmTaskLogs.status, filters.status));
        }
        if (filters?.startDate) {
          query = query.where(gte2(pmTaskLogs.createdAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(pmTaskLogs.createdAt, new Date(filters.endDate)));
        }
        const result = await query.orderBy(desc2(pmTaskLogs.createdAt)).limit(filters?.limit || 100);
        return result;
      }
      // PM Property Performance Operations
      async getPMPropertyPerformance(organizationId2, managerId, filters) {
        let query = db.select({
          ...pmPropertyPerformance,
          propertyName: properties.name
        }).from(pmPropertyPerformance).leftJoin(properties, eq2(pmPropertyPerformance.propertyId, properties.id)).where(and3(
          eq2(pmPropertyPerformance.organizationId, organizationId2),
          eq2(pmPropertyPerformance.managerId, managerId)
        ));
        if (filters?.propertyId) {
          query = query.where(eq2(pmPropertyPerformance.propertyId, filters.propertyId));
        }
        if (filters?.period) {
          query = query.where(eq2(pmPropertyPerformance.period, filters.period));
        }
        if (filters?.startPeriod) {
          query = query.where(gte2(pmPropertyPerformance.period, filters.startPeriod));
        }
        if (filters?.endPeriod) {
          query = query.where(lte2(pmPropertyPerformance.period, filters.endPeriod));
        }
        return query.orderBy(desc2(pmPropertyPerformance.period));
      }
      async upsertPMPropertyPerformance(performance) {
        const [result] = await db.insert(pmPropertyPerformance).values(performance).onConflictDoUpdate({
          target: [pmPropertyPerformance.organizationId, pmPropertyPerformance.managerId, pmPropertyPerformance.propertyId, pmPropertyPerformance.period],
          set: {
            ...performance,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return result;
      }
      // PM Notifications Operations
      async createPMNotification(notification) {
        const [newNotification] = await db.insert(pmNotifications).values(notification).returning();
        return newNotification;
      }
      async getPMNotifications(organizationId2, managerId, filters) {
        let query = db.select().from(pmNotifications).where(and3(
          eq2(pmNotifications.organizationId, organizationId2),
          eq2(pmNotifications.managerId, managerId)
        ));
        if (filters?.type) {
          query = query.where(eq2(pmNotifications.type, filters.type));
        }
        if (filters?.severity) {
          query = query.where(eq2(pmNotifications.severity, filters.severity));
        }
        if (filters?.isRead !== void 0) {
          query = query.where(eq2(pmNotifications.isRead, filters.isRead));
        }
        if (filters?.actionRequired !== void 0) {
          query = query.where(eq2(pmNotifications.actionRequired, filters.actionRequired));
        }
        return query.orderBy(desc2(pmNotifications.createdAt)).limit(filters?.limit || 50);
      }
      async markPMNotificationAsRead(id, managerId) {
        const [updated] = await db.update(pmNotifications).set({ isRead: true }).where(and3(
          eq2(pmNotifications.id, id),
          eq2(pmNotifications.managerId, managerId)
        )).returning();
        return updated;
      }
      async markAllPMNotificationsAsRead(organizationId2, managerId) {
        await db.update(pmNotifications).set({ isRead: true }).where(and3(
          eq2(pmNotifications.organizationId, organizationId2),
          eq2(pmNotifications.managerId, managerId),
          eq2(pmNotifications.isRead, false)
        ));
      }
      // PM Portfolio Operations
      async getPMPortfolioProperties(organizationId2, managerId) {
        const result = await db.select({
          ...properties,
          commissionRate: portfolioAssignments.commissionRate,
          assignedAt: portfolioAssignments.assignedAt
        }).from(properties).innerJoin(portfolioAssignments, and3(
          eq2(portfolioAssignments.propertyId, properties.id),
          eq2(portfolioAssignments.managerId, managerId),
          eq2(portfolioAssignments.isActive, true)
        )).where(eq2(properties.organizationId, organizationId2));
        return result;
      }
      async assignPMToProperty(organizationId2, managerId, propertyId, commissionRate = 50) {
        await db.update(portfolioAssignments).set({
          isActive: false,
          unassignedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(portfolioAssignments.propertyId, propertyId),
          eq2(portfolioAssignments.isActive, true)
        ));
        const [assignment] = await db.insert(portfolioAssignments).values({
          organizationId: organizationId2,
          managerId,
          propertyId,
          commissionRate
        }).returning();
        return assignment;
      }
      // PM Financial Overview
      async getPMFinancialOverview(organizationId2, managerId, filters) {
        const portfolioProperties = await this.getPMPortfolioProperties(organizationId2, managerId);
        const propertyIds = portfolioProperties.map((p) => p.id);
        if (propertyIds.length === 0) {
          return {
            totalCommissionEarnings: 0,
            propertyBreakdown: [],
            monthlyTrend: [],
            pendingBalance: 0
          };
        }
        let commissionsQuery = db.select({
          propertyId: finances.propertyId,
          propertyName: properties.name,
          totalRevenue: sum(finances.amount),
          count: count(),
          period: sql3`TO_CHAR(${finances.date}, 'YYYY-MM')`.as("period")
        }).from(finances).leftJoin(properties, eq2(finances.propertyId, properties.id)).where(and3(
          eq2(finances.organizationId, organizationId2),
          inArray(finances.propertyId, propertyIds),
          eq2(finances.type, "income"),
          eq2(finances.source, "booking_payment")
        ));
        if (filters?.startDate) {
          commissionsQuery = commissionsQuery.where(gte2(finances.date, filters.startDate));
        }
        if (filters?.endDate) {
          commissionsQuery = commissionsQuery.where(lte2(finances.date, filters.endDate));
        }
        if (filters?.propertyId) {
          commissionsQuery = commissionsQuery.where(eq2(finances.propertyId, filters.propertyId));
        }
        const revenueData = await commissionsQuery.groupBy(finances.propertyId, properties.name, sql3`TO_CHAR(${finances.date}, 'YYYY-MM')`).orderBy(sql3`TO_CHAR(${finances.date}, 'YYYY-MM')`, properties.name);
        const propertyBreakdown = /* @__PURE__ */ new Map();
        const monthlyTrend = /* @__PURE__ */ new Map();
        let totalCommissionEarnings = 0;
        revenueData.forEach((item) => {
          const revenue = Number(item.totalRevenue || 0);
          const managementFee = revenue * 0.2;
          const commission = managementFee * 0.1;
          totalCommissionEarnings += commission;
          const propertyKey = `${item.propertyId}-${item.propertyName}`;
          if (!propertyBreakdown.has(propertyKey)) {
            propertyBreakdown.set(propertyKey, {
              propertyId: item.propertyId,
              propertyName: item.propertyName,
              totalRevenue: 0,
              commissionEarned: 0,
              bookingCount: 0
            });
          }
          const propertyData = propertyBreakdown.get(propertyKey);
          propertyData.totalRevenue += revenue;
          propertyData.commissionEarned += commission;
          propertyData.bookingCount += Number(item.count || 0);
          if (!monthlyTrend.has(item.period)) {
            monthlyTrend.set(item.period, 0);
          }
          monthlyTrend.set(item.period, monthlyTrend.get(item.period) + commission);
        });
        const balance = await this.getPMCommissionBalance(organizationId2, managerId);
        return {
          totalCommissionEarnings,
          propertyBreakdown: Array.from(propertyBreakdown.values()),
          monthlyTrend: Array.from(monthlyTrend.entries()).map(([period, earnings]) => ({
            period,
            earnings
          })),
          pendingBalance: Number(balance?.currentBalance || 0)
        };
      }
      // ====== RETAIL AGENT INTERFACE OPERATIONS ======
      // Agent Bookings Operations  
      async createAgentBooking(booking) {
        const mainBookingData = {
          organizationId: booking.organizationId,
          propertyId: booking.propertyId,
          guestName: booking.guestName,
          guestEmail: booking.guestEmail,
          guestPhone: booking.guestPhone,
          checkIn: booking.checkIn,
          // Already in date format
          checkOut: booking.checkOut,
          // Already in date format
          guests: booking.guests,
          totalAmount: booking.totalAmount.toString(),
          platformPayout: booking.totalAmount.toString(),
          // For dual pricing tracking
          currency: booking.currency || "THB",
          status: "confirmed",
          // Agent bookings are confirmed by default
          bookingPlatform: "retail-agent",
          // Mark as retail agent booking
          specialRequests: booking.notes || null,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        const [mainBooking] = await db.insert(bookings).values(mainBookingData).returning();
        const agentBookingData = {
          ...booking,
          bookingId: mainBooking.id
          // Link to main booking
        };
        const [newAgentBooking] = await db.insert(agentBookings).values(agentBookingData).returning();
        return {
          ...newAgentBooking,
          mainBookingId: mainBooking.id
        };
      }
      async getAgentBookings(organizationId2, agentId, filters) {
        let query = db.select({
          id: agentBookings.id,
          organizationId: agentBookings.organizationId,
          retailAgentId: agentBookings.retailAgentId,
          propertyId: agentBookings.propertyId,
          bookingId: agentBookings.bookingId,
          guestName: agentBookings.guestName,
          guestEmail: agentBookings.guestEmail,
          guestPhone: agentBookings.guestPhone,
          checkIn: agentBookings.checkIn,
          checkOut: agentBookings.checkOut,
          totalAmount: agentBookings.totalAmount,
          commissionRate: agentBookings.commissionRate,
          commissionAmount: agentBookings.commissionAmount,
          bookingStatus: agentBookings.bookingStatus,
          commissionStatus: agentBookings.commissionStatus,
          hostawayBookingId: agentBookings.hostawayBookingId,
          notes: agentBookings.notes,
          createdAt: agentBookings.createdAt,
          updatedAt: agentBookings.updatedAt,
          propertyName: properties.name
        }).from(agentBookings).leftJoin(properties, eq2(agentBookings.propertyId, properties.id)).where(eq2(agentBookings.organizationId, organizationId2));
        if (agentId) {
          query = query.where(eq2(agentBookings.retailAgentId, agentId));
        }
        if (filters?.status) {
          query = query.where(eq2(agentBookings.bookingStatus, filters.status));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(agentBookings.propertyId, filters.propertyId));
        }
        if (filters?.startDate) {
          query = query.where(gte2(agentBookings.checkIn, filters.startDate));
        }
        if (filters?.endDate) {
          query = query.where(lte2(agentBookings.checkOut, filters.endDate));
        }
        return query.orderBy(desc2(agentBookings.createdAt));
      }
      async updateAgentBooking(id, updates) {
        const [updated] = await db.update(agentBookings).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(agentBookings.id, id)).returning();
        return updated;
      }
      // Agent Payouts Operations
      async createAgentPayout(payout) {
        const [newPayout] = await db.insert(agentPayouts).values(payout).returning();
        return newPayout;
      }
      async getAgentPayouts(organizationId2, agentId, filters) {
        let query = db.select().from(agentPayouts).where(eq2(agentPayouts.organizationId, organizationId2));
        if (agentId) {
          query = query.where(eq2(agentPayouts.agentId, agentId));
        }
        if (filters?.status) {
          query = query.where(eq2(agentPayouts.payoutStatus, filters.status));
        }
        if (filters?.agentType) {
          query = query.where(eq2(agentPayouts.agentType, filters.agentType));
        }
        if (filters?.startDate) {
          query = query.where(gte2(agentPayouts.requestedAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(agentPayouts.requestedAt, new Date(filters.endDate)));
        }
        return query.orderBy(desc2(agentPayouts.requestedAt));
      }
      async updateAgentPayout(id, updates) {
        const [updated] = await db.update(agentPayouts).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(agentPayouts.id, id)).returning();
        return updated;
      }
      // Property Commission Rules Operations
      async getPropertyCommissionRules(organizationId2, propertyId) {
        let query = db.select().from(propertyCommissionRules).where(eq2(propertyCommissionRules.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(propertyCommissionRules.propertyId, propertyId));
        }
        return query.where(eq2(propertyCommissionRules.isActive, true));
      }
      async createPropertyCommissionRule(rule) {
        const [newRule] = await db.insert(propertyCommissionRules).values(rule).returning();
        return newRule;
      }
      async updatePropertyCommissionRule(id, updates) {
        const [updated] = await db.update(propertyCommissionRules).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyCommissionRules.id, id)).returning();
        return updated;
      }
      // Property Marketing Media Operations
      async getPropertyMarketingMedia(organizationId2, propertyId, filters) {
        let query = db.select().from(propertyMarketingMedia).where(eq2(propertyMarketingMedia.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(propertyMarketingMedia.propertyId, propertyId));
        }
        if (filters?.mediaType) {
          query = query.where(eq2(propertyMarketingMedia.mediaType, filters.mediaType));
        }
        if (filters?.category) {
          query = query.where(eq2(propertyMarketingMedia.category, filters.category));
        }
        if (filters?.agentAccessLevel) {
          query = query.where(eq2(propertyMarketingMedia.agentAccessLevel, filters.agentAccessLevel));
        }
        return query.where(eq2(propertyMarketingMedia.isPublic, true)).orderBy(propertyMarketingMedia.sortOrder, propertyMarketingMedia.createdAt);
      }
      async createPropertyMarketingMedia(media) {
        const [newMedia] = await db.insert(propertyMarketingMedia).values(media).returning();
        return newMedia;
      }
      async updatePropertyMarketingMedia(id, updates) {
        const [updated] = await db.update(propertyMarketingMedia).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyMarketingMedia.id, id)).returning();
        return updated;
      }
      // Agent Booking Requests Operations
      async createAgentBookingRequest(request) {
        const [newRequest] = await db.insert(agentBookingRequests).values(request).returning();
        return newRequest;
      }
      async getAgentBookingRequests(organizationId2, agentId, filters) {
        let query = db.select({
          ...agentBookingRequests,
          propertyName: properties.name
        }).from(agentBookingRequests).leftJoin(properties, eq2(agentBookingRequests.propertyId, properties.id)).where(eq2(agentBookingRequests.organizationId, organizationId2));
        if (agentId) {
          query = query.where(eq2(agentBookingRequests.agentId, agentId));
        }
        if (filters?.status) {
          query = query.where(eq2(agentBookingRequests.status, filters.status));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(agentBookingRequests.propertyId, filters.propertyId));
        }
        if (filters?.urgencyLevel) {
          query = query.where(eq2(agentBookingRequests.urgencyLevel, filters.urgencyLevel));
        }
        return query.orderBy(desc2(agentBookingRequests.submittedAt));
      }
      async updateAgentBookingRequest(id, updates) {
        const [updated] = await db.update(agentBookingRequests).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(agentBookingRequests.id, id)).returning();
        return updated;
      }
      // Agent Commission Summary Operations
      async getAgentCommissionSummary(organizationId2, agentId) {
        const [commissionStats] = await db.select({
          totalEarned: sum(agentBookings.commissionAmount),
          totalBookings: count(agentBookings.id),
          avgCommission: avg(agentBookings.commissionAmount)
        }).from(agentBookings).where(and3(
          eq2(agentBookings.organizationId, organizationId2),
          eq2(agentBookings.retailAgentId, agentId),
          eq2(agentBookings.commissionStatus, "approved")
        ));
        const [payoutStats] = await db.select({
          totalPaid: sum(agentPayouts.payoutAmount),
          totalPayouts: count(agentPayouts.id)
        }).from(agentPayouts).where(and3(
          eq2(agentPayouts.organizationId, organizationId2),
          eq2(agentPayouts.agentId, agentId),
          eq2(agentPayouts.payoutStatus, "paid")
        ));
        const [pendingStats] = await db.select({
          pendingCommissions: sum(agentBookings.commissionAmount),
          pendingBookings: count(agentBookings.id)
        }).from(agentBookings).where(and3(
          eq2(agentBookings.organizationId, organizationId2),
          eq2(agentBookings.retailAgentId, agentId),
          eq2(agentBookings.commissionStatus, "pending")
        ));
        return {
          totalEarned: commissionStats?.totalEarned || 0,
          totalPaid: payoutStats?.totalPaid || 0,
          currentBalance: (commissionStats?.totalEarned || 0) - (payoutStats?.totalPaid || 0),
          pendingCommissions: pendingStats?.pendingCommissions || 0,
          totalBookings: commissionStats?.totalBookings || 0,
          totalPayouts: payoutStats?.totalPayouts || 0,
          avgCommissionPerBooking: commissionStats?.avgCommission || 0
        };
      }
      // Agent Properties with Live Data (for booking engine)
      async getAgentAvailableProperties(organizationId2, filters) {
        let query = db.select({
          id: properties.id,
          organizationId: properties.organizationId,
          name: properties.name,
          description: properties.description,
          address: properties.address,
          bedrooms: properties.bedrooms,
          bathrooms: properties.bathrooms,
          maxGuests: properties.maxGuests,
          pricePerNight: properties.pricePerNight,
          currency: properties.currency,
          status: properties.status,
          amenities: properties.amenities,
          images: properties.images
        }).from(properties);
        const conditions = [
          eq2(properties.organizationId, organizationId2),
          eq2(properties.status, "active")
        ];
        if (filters?.guests) {
          conditions.push(gte2(properties.maxGuests, filters.guests));
        }
        if (filters?.bedrooms) {
          conditions.push(gte2(properties.bedrooms, filters.bedrooms));
        }
        if (filters?.priceMin) {
          conditions.push(gte2(properties.pricePerNight, filters.priceMin.toString()));
        }
        if (filters?.priceMax) {
          conditions.push(lte2(properties.pricePerNight, filters.priceMax.toString()));
        }
        query = query.where(and3(...conditions));
        const propertiesResult = await query.orderBy(properties.name);
        const propertiesWithAvailability = await Promise.all(
          propertiesResult.map(async (property) => {
            let isAvailable = true;
            if (filters?.checkIn && filters?.checkOut) {
              const conflictingBookings = await db.select().from(bookings).where(and3(
                eq2(bookings.propertyId, property.id),
                eq2(bookings.status, "confirmed"),
                or(
                  and3(
                    lte2(bookings.startDate, filters.checkIn),
                    gte2(bookings.endDate, filters.checkIn)
                  ),
                  and3(
                    lte2(bookings.startDate, filters.checkOut),
                    gte2(bookings.endDate, filters.checkOut)
                  ),
                  and3(
                    gte2(bookings.startDate, filters.checkIn),
                    lte2(bookings.endDate, filters.checkOut)
                  )
                )
              ));
              isAvailable = conflictingBookings.length === 0;
            }
            return {
              ...property,
              isAvailable,
              commission: 15,
              // Default 15% commission
              commissionRate: 15,
              marketingMedia: []
            };
          })
        );
        return propertiesWithAvailability.filter(
          (property) => !filters?.checkIn || property.isAvailable
        );
      }
      // ===== REFERRAL AGENT OPERATIONS =====
      // Get referral agent's assigned properties
      async getReferralAgentProperties(organizationId2, referralAgentId) {
        const referralProperties = await db.select({
          id: propertyReferrals.id,
          propertyId: propertyReferrals.propertyId,
          propertyName: properties.name,
          portfolioManagerId: propertyReferrals.portfolioManagerId,
          portfolioManagerName: users.firstName,
          commissionRate: propertyReferrals.commissionRate,
          referralDate: propertyReferrals.referralDate,
          isActive: propertyReferrals.isActive,
          notes: propertyReferrals.notes
        }).from(propertyReferrals).leftJoin(properties, eq2(propertyReferrals.propertyId, properties.id)).leftJoin(users, eq2(propertyReferrals.portfolioManagerId, users.id)).where(and3(
          eq2(propertyReferrals.organizationId, organizationId2),
          eq2(propertyReferrals.referralAgentId, referralAgentId),
          eq2(propertyReferrals.isActive, true)
        )).orderBy(propertyReferrals.referralDate);
        return referralProperties;
      }
      // Get referral earnings for specific month/year
      async getReferralEarnings(organizationId2, referralAgentId, filters) {
        let query = db.select({
          id: referralEarnings.id,
          propertyId: referralEarnings.propertyId,
          propertyName: properties.name,
          month: referralEarnings.month,
          year: referralEarnings.year,
          grossRentalIncome: referralEarnings.grossRentalIncome,
          managementFeeTotal: referralEarnings.managementFeeTotal,
          referralCommissionEarned: referralEarnings.referralCommissionEarned,
          occupancyRate: referralEarnings.occupancyRate,
          averageReviewScore: referralEarnings.averageReviewScore,
          totalBookings: referralEarnings.totalBookings,
          status: referralEarnings.status,
          calculatedAt: referralEarnings.calculatedAt,
          paidAt: referralEarnings.paidAt
        }).from(referralEarnings).leftJoin(properties, eq2(referralEarnings.propertyId, properties.id)).where(and3(
          eq2(referralEarnings.organizationId, organizationId2),
          eq2(referralEarnings.referralAgentId, referralAgentId)
        ));
        if (filters?.month) {
          query = query.where(eq2(referralEarnings.month, filters.month));
        }
        if (filters?.year) {
          query = query.where(eq2(referralEarnings.year, filters.year));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(referralEarnings.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          query = query.where(eq2(referralEarnings.status, filters.status));
        }
        return query.orderBy(desc2(referralEarnings.year), desc2(referralEarnings.month));
      }
      // Create referral earnings record
      async createReferralEarnings(earnings) {
        const [newEarnings] = await db.insert(referralEarnings).values(earnings).returning();
        return newEarnings;
      }
      // Update referral earnings
      async updateReferralEarnings(id, updates) {
        const [updated] = await db.update(referralEarnings).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(referralEarnings.id, id)).returning();
        return updated;
      }
      // Get referral agent commission summary
      async getReferralCommissionSummary(organizationId2, referralAgentId) {
        const [totalEarnings] = await db.select({
          totalEarned: sum(referralEarnings.referralCommissionEarned),
          totalPaidAmount: sum(sql3`CASE WHEN ${referralEarnings.status} = 'paid' THEN ${referralEarnings.referralCommissionEarned} ELSE 0 END`),
          totalPendingAmount: sum(sql3`CASE WHEN ${referralEarnings.status} = 'pending' THEN ${referralEarnings.referralCommissionEarned} ELSE 0 END`),
          totalProperties: count(sql3`DISTINCT ${referralEarnings.propertyId}`)
        }).from(referralEarnings).where(and3(
          eq2(referralEarnings.organizationId, organizationId2),
          eq2(referralEarnings.referralAgentId, referralAgentId)
        ));
        const [payoutSummary] = await db.select({
          totalPaidOut: sum(agentPayouts.payoutAmount),
          lastPayoutDate: max(agentPayouts.paidAt)
        }).from(agentPayouts).where(and3(
          eq2(agentPayouts.organizationId, organizationId2),
          eq2(agentPayouts.agentId, referralAgentId),
          eq2(agentPayouts.agentType, "referral-agent"),
          eq2(agentPayouts.payoutStatus, "paid")
        ));
        const totalEarned = Number(totalEarnings?.totalEarned || 0);
        const totalPaid = Number(payoutSummary?.totalPaidOut || 0);
        const currentBalance = totalEarned - totalPaid;
        return {
          totalEarned,
          totalPaid,
          currentBalance,
          totalPendingCommissions: Number(totalEarnings?.totalPendingAmount || 0),
          totalProperties: totalEarnings?.totalProperties || 0,
          lastPayoutDate: payoutSummary?.lastPayoutDate
        };
      }
      // Get referral agent payouts
      async getReferralPayouts(organizationId2, referralAgentId, filters) {
        let query = db.select().from(agentPayouts).where(and3(
          eq2(agentPayouts.organizationId, organizationId2),
          eq2(agentPayouts.agentId, referralAgentId),
          eq2(agentPayouts.agentType, "referral-agent")
        ));
        if (filters?.status) {
          query = query.where(eq2(agentPayouts.payoutStatus, filters.status));
        }
        if (filters?.startDate) {
          query = query.where(gte2(agentPayouts.requestedAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(agentPayouts.requestedAt, new Date(filters.endDate)));
        }
        return query.orderBy(desc2(agentPayouts.requestedAt));
      }
      // Create referral payout request
      async createReferralPayout(payout) {
        const [newPayout] = await db.insert(agentPayouts).values(payout).returning();
        return newPayout;
      }
      // Get referral program rules
      async getReferralProgramRules(organizationId2, filters) {
        let query = db.select({
          id: referralProgramRules.id,
          title: referralProgramRules.title,
          description: referralProgramRules.description,
          ruleType: referralProgramRules.ruleType,
          ruleContent: referralProgramRules.ruleContent,
          isActive: referralProgramRules.isActive,
          effectiveDate: referralProgramRules.effectiveDate,
          createdAt: referralProgramRules.createdAt,
          createdByName: users.firstName
        }).from(referralProgramRules).leftJoin(users, eq2(referralProgramRules.createdBy, users.id)).where(eq2(referralProgramRules.organizationId, organizationId2));
        if (filters?.ruleType) {
          query = query.where(eq2(referralProgramRules.ruleType, filters.ruleType));
        }
        if (filters?.isActive !== void 0) {
          query = query.where(eq2(referralProgramRules.isActive, filters.isActive));
        }
        return query.orderBy(referralProgramRules.effectiveDate, referralProgramRules.createdAt);
      }
      // Create referral program rule
      async createReferralProgramRule(rule) {
        const [newRule] = await db.insert(referralProgramRules).values(rule).returning();
        return newRule;
      }
      // Update referral program rule
      async updateReferralProgramRule(id, updates) {
        const [updated] = await db.update(referralProgramRules).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(referralProgramRules.id, id)).returning();
        return updated;
      }
      // Get property performance analytics for referral agent
      async getPropertyPerformanceAnalytics(organizationId2, referralAgentId, filters) {
        let query = db.select({
          propertyId: referralEarnings.propertyId,
          propertyName: properties.name,
          month: referralEarnings.month,
          year: referralEarnings.year,
          grossRentalIncome: referralEarnings.grossRentalIncome,
          managementFeeTotal: referralEarnings.managementFeeTotal,
          referralCommissionEarned: referralEarnings.referralCommissionEarned,
          occupancyRate: referralEarnings.occupancyRate,
          averageReviewScore: referralEarnings.averageReviewScore,
          totalBookings: referralEarnings.totalBookings
        }).from(referralEarnings).leftJoin(properties, eq2(referralEarnings.propertyId, properties.id)).where(and3(
          eq2(referralEarnings.organizationId, organizationId2),
          eq2(referralEarnings.referralAgentId, referralAgentId)
        ));
        if (filters?.propertyId) {
          query = query.where(eq2(referralEarnings.propertyId, filters.propertyId));
        }
        if (filters?.startYear && filters?.startMonth) {
          query = query.where(
            or(
              gt(referralEarnings.year, filters.startYear),
              and3(
                eq2(referralEarnings.year, filters.startYear),
                gte2(referralEarnings.month, filters.startMonth)
              )
            )
          );
        }
        if (filters?.endYear && filters?.endMonth) {
          query = query.where(
            or(
              lt(referralEarnings.year, filters.endYear),
              and3(
                eq2(referralEarnings.year, filters.endYear),
                lte2(referralEarnings.month, filters.endMonth)
              )
            )
          );
        }
        return query.orderBy(referralEarnings.year, referralEarnings.month, properties.name);
      }
      // Add property referral
      async addPropertyReferral(referral) {
        const [newReferral] = await db.insert(propertyReferrals).values(referral).returning();
        return newReferral;
      }
      // Update property referral
      async updatePropertyReferral(id, updates) {
        const [updated] = await db.update(propertyReferrals).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyReferrals.id, id)).returning();
        return updated;
      }
      // ===== STAFF CLOCK ENTRIES METHODS (GPS TRACKING) =====
      // Get staff clock entries with filtering
      async getStaffClockEntries(organizationId2, filters) {
        let query = db.select().from(staffClockEntries).where(eq2(staffClockEntries.organizationId, organizationId2));
        if (filters?.staffId) {
          query = query.where(eq2(staffClockEntries.staffId, filters.staffId));
        }
        if (filters?.workDate) {
          query = query.where(eq2(staffClockEntries.workDate, filters.workDate));
        }
        if (filters?.status) {
          query = query.where(eq2(staffClockEntries.status, filters.status));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(staffClockEntries.propertyId, filters.propertyId));
        }
        if (filters?.taskId) {
          query = query.where(eq2(staffClockEntries.taskId, filters.taskId));
        }
        return query.orderBy(desc2(staffClockEntries.workDate), desc2(staffClockEntries.clockInTime));
      }
      // Get a specific clock entry
      async getStaffClockEntry(id) {
        const [entry] = await db.select().from(staffClockEntries).where(eq2(staffClockEntries.id, id));
        return entry;
      }
      // Create new clock entry (clock in)
      async createStaffClockEntry(entry) {
        const [newEntry] = await db.insert(staffClockEntries).values(entry).returning();
        return newEntry;
      }
      // Update clock entry (clock out or other updates)
      async updateStaffClockEntry(id, updates) {
        const [updated] = await db.update(staffClockEntries).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffClockEntries.id, id)).returning();
        return updated;
      }
      // Clock out - complete clock entry
      async clockOutStaffEntry(id, clockOutTime, gpsLocationOut, photoEvidence, totalHours, overtimeHours) {
        const updates = {
          clockOutTime,
          gpsLocationOut,
          photoEvidence,
          totalHours,
          overtimeHours,
          status: overtimeHours && overtimeHours > 0 ? "emergency" : "completed",
          completedAt: /* @__PURE__ */ new Date()
        };
        if (overtimeHours && overtimeHours > 0) {
          updates.isOvertime = true;
        }
        return this.updateStaffClockEntry(id, updates);
      }
      // Get active clock entry for staff (currently clocked in)
      async getActiveStaffClockEntry(organizationId2, staffId) {
        const [entry] = await db.select().from(staffClockEntries).where(and3(
          eq2(staffClockEntries.organizationId, organizationId2),
          eq2(staffClockEntries.staffId, staffId),
          eq2(staffClockEntries.status, "active")
        )).orderBy(desc2(staffClockEntries.createdAt)).limit(1);
        return entry;
      }
      // Get today's clock entries for staff
      async getTodayClockEntries(organizationId2, staffId) {
        const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        return this.getStaffClockEntries(organizationId2, {
          staffId,
          workDate: today
        });
      }
      // Approve overtime for clock entry
      async approveOvertimeClockEntry(id, approvedBy) {
        return this.updateStaffClockEntry(id, {
          supervisorApproved: true,
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date()
        });
      }
      // ===== STAFF DASHBOARD STORAGE METHODS =====
      // Staff Dashboard Overview
      async getStaffDashboardOverview(organizationId2, staffId, department) {
        const today = /* @__PURE__ */ new Date();
        const todayStr = today.toISOString().split("T")[0];
        let todayTasksQuery = db.select().from(tasks).where(and3(
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.assignedTo, staffId),
          eq2(tasks.dueDate, new Date(todayStr)),
          or(
            eq2(tasks.status, "pending"),
            eq2(tasks.status, "in-progress")
          )
        ));
        if (department) {
          todayTasksQuery = todayTasksQuery.where(eq2(tasks.department, department));
        }
        const todayTasks = await todayTasksQuery;
        let overdueTasksQuery = db.select().from(tasks).where(and3(
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.assignedTo, staffId),
          lt(tasks.dueDate, new Date(todayStr)),
          or(
            eq2(tasks.status, "pending"),
            eq2(tasks.status, "in-progress")
          )
        ));
        if (department) {
          overdueTasksQuery = overdueTasksQuery.where(eq2(tasks.department, department));
        }
        const overdueTasks = await overdueTasksQuery;
        const nextWeek = /* @__PURE__ */ new Date();
        nextWeek.setDate(nextWeek.getDate() + 7);
        let upcomingTasksQuery = db.select().from(tasks).where(and3(
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.assignedTo, staffId),
          gt(tasks.dueDate, new Date(todayStr)),
          lte2(tasks.dueDate, nextWeek),
          eq2(tasks.status, "pending")
        ));
        if (department) {
          upcomingTasksQuery = upcomingTasksQuery.where(eq2(tasks.department, department));
        }
        const upcomingTasks = await upcomingTasksQuery;
        const thirtyDaysAgo = /* @__PURE__ */ new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        let completedTasksQuery = db.select().from(tasks).where(and3(
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.assignedTo, staffId),
          gte2(tasks.dueDate, thirtyDaysAgo),
          eq2(tasks.status, "completed")
        ));
        let totalTasksQuery = db.select().from(tasks).where(and3(
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.assignedTo, staffId),
          gte2(tasks.dueDate, thirtyDaysAgo)
        ));
        if (department) {
          completedTasksQuery = completedTasksQuery.where(eq2(tasks.department, department));
          totalTasksQuery = totalTasksQuery.where(eq2(tasks.department, department));
        }
        const completedTasks = await completedTasksQuery;
        const totalTasks = await totalTasksQuery;
        const completionRate = totalTasks.length > 0 ? completedTasks.length / totalTasks.length * 100 : 0;
        return {
          todayTasks: todayTasks.length,
          overdueTasks: overdueTasks.length,
          upcomingTasks: upcomingTasks.length,
          completionRate: Math.round(completionRate),
          todayTasksList: todayTasks,
          overdueTasksList: overdueTasks,
          upcomingTasksList: upcomingTasks
        };
      }
      // Get staff tasks with optional filtering
      async getStaffTasks(organizationId2, staffId, filters) {
        let query = db.select({
          id: tasks.id,
          title: tasks.title,
          description: tasks.description,
          type: tasks.type,
          department: tasks.department,
          status: tasks.status,
          priority: tasks.priority,
          dueDate: tasks.dueDate,
          completedAt: tasks.completedAt,
          estimatedCost: tasks.estimatedCost,
          actualCost: tasks.actualCost,
          completionNotes: tasks.completionNotes,
          evidencePhotos: tasks.evidencePhotos,
          issuesFound: tasks.issuesFound,
          propertyId: tasks.propertyId,
          propertyName: properties.name,
          createdAt: tasks.createdAt,
          updatedAt: tasks.updatedAt
        }).from(tasks).leftJoin(properties, eq2(tasks.propertyId, properties.id)).where(and3(
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.assignedTo, staffId)
        ));
        if (filters?.department) {
          query = query.where(eq2(tasks.department, filters.department));
        }
        if (filters?.status) {
          query = query.where(eq2(tasks.status, filters.status));
        }
        if (filters?.priority) {
          query = query.where(eq2(tasks.priority, filters.priority));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(tasks.propertyId, filters.propertyId));
        }
        if (filters?.startDate) {
          query = query.where(gte2(tasks.dueDate, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(tasks.dueDate, new Date(filters.endDate)));
        }
        return query.orderBy(desc2(tasks.dueDate));
      }
      // Get task checklist for a specific task type
      async getTaskChecklist(organizationId2, taskType, propertyId) {
        let query = db.select().from(taskChecklists).where(and3(
          eq2(taskChecklists.organizationId, organizationId2),
          eq2(taskChecklists.taskType, taskType),
          eq2(taskChecklists.isActive, true)
        ));
        if (propertyId) {
          const propertySpecific = await query.where(eq2(taskChecklists.propertyId, propertyId)).limit(1);
          if (propertySpecific.length > 0) {
            return propertySpecific[0];
          }
        }
        const defaultChecklist = await query.where(isNull2(taskChecklists.propertyId)).limit(1);
        return defaultChecklist.length > 0 ? defaultChecklist[0] : null;
      }
      // Start a task (update status and record start time)
      async startTask(organizationId2, taskId, staffId) {
        const [updatedTask] = await db.update(tasks).set({
          status: "in-progress",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(tasks.id, taskId),
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.assignedTo, staffId)
        )).returning();
        await db.insert(taskHistory).values({
          organizationId: organizationId2,
          taskId,
          propertyId: updatedTask.propertyId,
          action: "started",
          previousStatus: "pending",
          newStatus: "in-progress",
          performedBy: staffId,
          notes: "Task started by staff member"
        });
        return updatedTask;
      }
      // Complete task with all evidence and completion data
      async completeTask(organizationId2, taskId, staffId, completionData) {
        const totalExpenseAmount = completionData.expenses?.reduce((sum4, expense) => sum4 + parseFloat(expense.amount || "0"), 0) || 0;
        const [updatedTask] = await db.update(tasks).set({
          status: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          completionNotes: completionData.completionNotes,
          evidencePhotos: completionData.evidencePhotos || [],
          issuesFound: completionData.issuesFound || [],
          actualCost: totalExpenseAmount.toString(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(tasks.id, taskId),
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.assignedTo, staffId)
        )).returning();
        await db.insert(taskCompletions).values({
          organizationId: organizationId2,
          taskId,
          staffId,
          propertyId: updatedTask.propertyId,
          completedAt: /* @__PURE__ */ new Date(),
          duration: completionData.duration,
          checklistId: completionData.checklistId,
          completedItems: completionData.completedItems,
          evidencePhotos: completionData.evidencePhotos || [],
          completionNotes: completionData.completionNotes,
          issuesFound: completionData.issuesFound || [],
          expenses: completionData.expenses,
          totalExpenseAmount: totalExpenseAmount.toString()
        });
        if (completionData.expenses && completionData.expenses.length > 0) {
          for (const expense of completionData.expenses) {
            await db.insert(staffExpenses).values({
              organizationId: organizationId2,
              staffId,
              taskId,
              propertyId: updatedTask.propertyId,
              item: expense.item,
              amount: expense.amount,
              currency: expense.currency || "THB",
              category: expense.category,
              description: expense.description
            });
          }
        }
        await db.insert(taskHistory).values({
          organizationId: organizationId2,
          taskId,
          propertyId: updatedTask.propertyId,
          action: "completed",
          previousStatus: "in-progress",
          newStatus: "completed",
          performedBy: staffId,
          notes: completionData.completionNotes || "Task completed by staff member",
          evidencePhotos: completionData.evidencePhotos || [],
          issuesFound: completionData.issuesFound || []
        });
        await this.createNotification({
          organizationId: organizationId2,
          title: "Task Completed",
          message: `Task "${updatedTask.title}" has been completed by staff member`,
          type: "task_completion",
          userId: updatedTask.createdBy || "admin",
          relatedEntityType: "task",
          relatedEntityId: taskId,
          priority: "medium"
        });
        return updatedTask;
      }
      // Staff salary methods
      async getStaffSalary(organizationId2, staffId, period) {
        let query = db.select().from(staffSalaries).where(and3(
          eq2(staffSalaries.organizationId, organizationId2),
          eq2(staffSalaries.staffId, staffId)
        ));
        if (period) {
          query = query.where(eq2(staffSalaries.salaryPeriod, period));
        }
        return query.orderBy(desc2(staffSalaries.salaryPeriod));
      }
      async createStaffSalary(salaryData) {
        const [newSalary] = await db.insert(staffSalaries).values(salaryData).returning();
        return newSalary;
      }
      // Staff expenses methods
      async getStaffExpenses(organizationId2, staffId, filters) {
        let query = db.select({
          id: staffExpenses.id,
          item: staffExpenses.item,
          amount: staffExpenses.amount,
          currency: staffExpenses.currency,
          category: staffExpenses.category,
          description: staffExpenses.description,
          receiptUrl: staffExpenses.receiptUrl,
          isApproved: staffExpenses.isApproved,
          reimbursementStatus: staffExpenses.reimbursementStatus,
          taskId: staffExpenses.taskId,
          taskTitle: tasks.title,
          propertyId: staffExpenses.propertyId,
          propertyName: properties.name,
          createdAt: staffExpenses.createdAt
        }).from(staffExpenses).leftJoin(tasks, eq2(staffExpenses.taskId, tasks.id)).leftJoin(properties, eq2(staffExpenses.propertyId, properties.id)).where(and3(
          eq2(staffExpenses.organizationId, organizationId2),
          eq2(staffExpenses.staffId, staffId)
        ));
        if (filters?.taskId) {
          query = query.where(eq2(staffExpenses.taskId, filters.taskId));
        }
        if (filters?.category) {
          query = query.where(eq2(staffExpenses.category, filters.category));
        }
        if (filters?.approved !== void 0) {
          query = query.where(eq2(staffExpenses.isApproved, filters.approved));
        }
        if (filters?.startDate) {
          query = query.where(gte2(staffExpenses.createdAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(staffExpenses.createdAt, new Date(filters.endDate)));
        }
        return query.orderBy(desc2(staffExpenses.createdAt));
      }
      async createStaffExpense(expenseData) {
        const [newExpense] = await db.insert(staffExpenses).values(expenseData).returning();
        return newExpense;
      }
      // Get staff task completion history
      async getStaffTaskHistory(organizationId2, staffId, filters) {
        let query = db.select({
          id: taskCompletions.id,
          taskId: taskCompletions.taskId,
          taskTitle: tasks.title,
          taskType: tasks.type,
          department: tasks.department,
          propertyId: taskCompletions.propertyId,
          propertyName: properties.name,
          startedAt: taskCompletions.startedAt,
          completedAt: taskCompletions.completedAt,
          duration: taskCompletions.duration,
          evidencePhotos: taskCompletions.evidencePhotos,
          completionNotes: taskCompletions.completionNotes,
          issuesFound: taskCompletions.issuesFound,
          totalExpenseAmount: taskCompletions.totalExpenseAmount,
          qualityRating: taskCompletions.qualityRating,
          managerNotes: taskCompletions.managerNotes,
          createdAt: taskCompletions.createdAt
        }).from(taskCompletions).leftJoin(tasks, eq2(taskCompletions.taskId, tasks.id)).leftJoin(properties, eq2(taskCompletions.propertyId, properties.id)).where(and3(
          eq2(taskCompletions.organizationId, organizationId2),
          eq2(taskCompletions.staffId, staffId)
        ));
        if (filters?.startDate) {
          query = query.where(gte2(taskCompletions.completedAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(taskCompletions.completedAt, new Date(filters.endDate)));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(taskCompletions.propertyId, filters.propertyId));
        }
        return query.orderBy(desc2(taskCompletions.completedAt));
      }
      // Skip task with reason
      async skipTask(organizationId2, taskId, staffId, reason) {
        const [updatedTask] = await db.update(tasks).set({
          status: "skipped",
          skipReason: reason,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(tasks.id, taskId),
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.assignedTo, staffId)
        )).returning();
        await db.insert(taskHistory).values({
          organizationId: organizationId2,
          taskId,
          propertyId: updatedTask.propertyId,
          action: "skipped",
          previousStatus: "pending",
          newStatus: "skipped",
          performedBy: staffId,
          notes: reason
        });
        return updatedTask;
      }
      // Reschedule task
      async rescheduleTask(organizationId2, taskId, staffId, newDate, reason) {
        const [updatedTask] = await db.update(tasks).set({
          status: "rescheduled",
          rescheduleReason: reason,
          rescheduledDate: newDate,
          dueDate: newDate,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(tasks.id, taskId),
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.assignedTo, staffId)
        )).returning();
        await db.insert(taskHistory).values({
          organizationId: organizationId2,
          taskId,
          propertyId: updatedTask.propertyId,
          action: "rescheduled",
          previousStatus: "pending",
          newStatus: "rescheduled",
          performedBy: staffId,
          notes: `Rescheduled to ${newDate.toISOString().split("T")[0]}: ${reason}`
        });
        return updatedTask;
      }
      // Enhanced Owner Dashboard Features - AI Suggestions
      async getOwnerAISuggestions(organizationId2, ownerId, filters) {
        const suggestions = [
          {
            id: 1,
            type: "maintenance",
            title: "Pool Cleaning Improvement",
            description: "Multiple guests mentioned pool cleanliness issues. Consider increasing cleaning frequency.",
            estimatedCost: 250,
            priority: "high",
            confidence: 0.85,
            sourceType: "guest_reviews",
            sourceCount: 3,
            propertyId: filters?.propertyId || 1,
            createdAt: /* @__PURE__ */ new Date(),
            status: "pending",
            aiAnalysis: 'Analyzed 5 recent reviews with keywords: "pool", "dirty", "maintenance"'
          },
          {
            id: 2,
            type: "amenity",
            title: "WiFi Speed Upgrade",
            description: "Guests frequently complain about slow internet. Upgrade to fiber recommended.",
            estimatedCost: 150,
            priority: "medium",
            confidence: 0.75,
            sourceType: "guest_reviews",
            sourceCount: 7,
            propertyId: filters?.propertyId || 1,
            createdAt: /* @__PURE__ */ new Date(),
            status: "pending",
            aiAnalysis: "Analyzed 7 reviews mentioning WiFi speed issues"
          }
        ];
        return suggestions;
      }
      async respondToAISuggestion(suggestionId, action, notes, userId) {
        return {
          id: suggestionId,
          action,
          notes,
          respondedBy: userId,
          respondedAt: /* @__PURE__ */ new Date(),
          status: action === "approve" ? "approved" : action === "reject" ? "rejected" : "quote_requested"
        };
      }
      async getOwnerBookingInsights(organizationId2, ownerId, filters) {
        return {
          totalBookings: 24,
          revenue: {
            thisMonth: 12500,
            lastMonth: 11200,
            growth: 11.6
          },
          sources: {
            airbnb: { bookings: 12, revenue: 6800, syncStatus: "connected" },
            vrbo: { bookings: 8, revenue: 4200, syncStatus: "connected" },
            direct: { bookings: 4, revenue: 1500, syncStatus: "n/a" }
          },
          occupancyRate: 78,
          averageRating: 4.7,
          responseRate: 95,
          otaConnectionStatus: {
            hostaway: "connected",
            lastSync: /* @__PURE__ */ new Date(),
            errorCount: 0
          }
        };
      }
      // Enhanced Activity Timeline with Photos and AI Insights
      async getOwnerActivityTimeline(organizationId2, ownerId, filters) {
        const activities = [
          {
            id: 1,
            activityType: "check_in",
            title: "Guest Check-in",
            description: "Sarah & Mike Johnson checked into Villa Serena",
            propertyName: "Villa Serena",
            createdAt: new Date(Date.now() - 2 * 60 * 60 * 1e3).toISOString(),
            metadata: {
              guestName: "Sarah Johnson",
              photos: ["/api/placeholder-checkin-1.jpg"]
            }
          },
          {
            id: 2,
            activityType: "ai_suggestion",
            title: "AI Maintenance Suggestion",
            description: "Pool cleaning frequency should be increased based on guest feedback",
            propertyName: "Villa Serena",
            createdAt: new Date(Date.now() - 4 * 60 * 60 * 1e3).toISOString(),
            metadata: {
              aiConfidence: 0.85,
              cost: 250
            }
          },
          {
            id: 3,
            activityType: "task_completed",
            title: "Maintenance Task Completed",
            description: "Pool skimmer repair completed by maintenance team",
            propertyName: "Villa Serena",
            createdAt: new Date(Date.now() - 6 * 60 * 60 * 1e3).toISOString(),
            metadata: {
              taskId: 15,
              photos: ["/api/placeholder-pool-1.jpg", "/api/placeholder-pool-2.jpg"]
            }
          },
          {
            id: 4,
            activityType: "guest_feedback",
            title: "New Guest Review",
            description: '5-star review: "Beautiful property with amazing pool!"',
            propertyName: "Villa Serena",
            createdAt: new Date(Date.now() - 12 * 60 * 60 * 1e3).toISOString(),
            metadata: {
              reviewSource: "Airbnb",
              guestName: "Emma Davis"
            }
          },
          {
            id: 5,
            activityType: "check_out",
            title: "Guest Check-out",
            description: "Emma Davis checked out of Villa Serena",
            propertyName: "Villa Serena",
            createdAt: new Date(Date.now() - 18 * 60 * 60 * 1e3).toISOString(),
            metadata: {
              guestName: "Emma Davis",
              photos: ["/api/placeholder-checkout-1.jpg"]
            }
          }
        ];
        return activities;
      }
      // ==================== UTILITY PROVIDERS & CUSTOM EXPENSE MANAGEMENT ====================
      async getUtilityProviders(organizationId2, utilityType) {
        let query = db.select().from(utilityProviders).where(eq2(utilityProviders.organizationId, organizationId2));
        if (utilityType) {
          query = query.where(eq2(utilityProviders.utilityType, utilityType));
        }
        return await query.orderBy(asc(utilityProviders.displayOrder), asc(utilityProviders.providerName));
      }
      async createUtilityProvider(data) {
        const [provider] = await db.insert(utilityProviders).values(data).returning();
        return provider;
      }
      async updateUtilityProvider(id, data) {
        const [provider] = await db.update(utilityProviders).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(utilityProviders.id, id)).returning();
        return provider;
      }
      async deleteUtilityProvider(id) {
        await db.delete(utilityProviders).where(eq2(utilityProviders.id, id));
      }
      async getCustomExpenseCategories(organizationId2) {
        return await db.select().from(customExpenseCategories).where(eq2(customExpenseCategories.organizationId, organizationId2)).orderBy(asc(customExpenseCategories.displayOrder), asc(customExpenseCategories.categoryName));
      }
      async createCustomExpenseCategory(data) {
        const [category] = await db.insert(customExpenseCategories).values(data).returning();
        return category;
      }
      async updateCustomExpenseCategory(id, data) {
        const [category] = await db.update(customExpenseCategories).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(customExpenseCategories.id, id)).returning();
        return category;
      }
      async deleteCustomExpenseCategory(id) {
        await db.delete(customExpenseCategories).where(eq2(customExpenseCategories.id, id));
      }
      async getPropertyUtilitySettings(organizationId2, propertyId) {
        let query = db.select().from(propertyUtilitySettings).where(eq2(propertyUtilitySettings.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(propertyUtilitySettings.propertyId, propertyId));
        }
        return await query.orderBy(asc(propertyUtilitySettings.utilityType));
      }
      async createPropertyUtilitySettings(data) {
        const [settings] = await db.insert(propertyUtilitySettings).values(data).returning();
        return settings;
      }
      async updatePropertyUtilitySettings(id, data) {
        const [settings] = await db.update(propertyUtilitySettings).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyUtilitySettings.id, id)).returning();
        return settings;
      }
      async deletePropertyUtilitySettings(id) {
        await db.delete(propertyUtilitySettings).where(eq2(propertyUtilitySettings.id, id));
      }
      async getPropertyCustomExpenses(organizationId2, propertyId) {
        let query = db.select().from(propertyCustomExpenses).where(eq2(propertyCustomExpenses.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(propertyCustomExpenses.propertyId, propertyId));
        }
        return await query.orderBy(asc(propertyCustomExpenses.propertyId));
      }
      async createPropertyCustomExpenses(data) {
        const [expense] = await db.insert(propertyCustomExpenses).values(data).returning();
        return expense;
      }
      async updatePropertyCustomExpenses(id, data) {
        const [expense] = await db.update(propertyCustomExpenses).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyCustomExpenses.id, id)).returning();
        return expense;
      }
      async deletePropertyCustomExpenses(id) {
        await db.delete(propertyCustomExpenses).where(eq2(propertyCustomExpenses.id, id));
      }
      async seedDefaultUtilityProviders(organizationId2, createdBy) {
        const defaultProviders = [
          // Internet providers (Thailand)
          { utilityType: "internet", providerName: "True Online", country: "Thailand", isDefault: true, displayOrder: 1 },
          { utilityType: "internet", providerName: "3BB", country: "Thailand", displayOrder: 2 },
          { utilityType: "internet", providerName: "NT", country: "Thailand", displayOrder: 3 },
          { utilityType: "internet", providerName: "CAT", country: "Thailand", displayOrder: 4 },
          { utilityType: "internet", providerName: "TOT", country: "Thailand", displayOrder: 5 },
          { utilityType: "internet", providerName: "AIS", country: "Thailand", displayOrder: 6 },
          // Electric providers (Thailand)
          { utilityType: "electricity", providerName: "PEA", country: "Thailand", isDefault: true, displayOrder: 1 },
          // Water providers (Thailand)
          { utilityType: "water", providerName: "Government", country: "Thailand", isDefault: true, displayOrder: 1 },
          { utilityType: "water", providerName: "Deepwell", country: "Thailand", displayOrder: 2 }
        ];
        for (const provider of defaultProviders) {
          await this.createUtilityProvider({
            organizationId: organizationId2,
            createdBy,
            ...provider
          });
        }
      }
      async seedDefaultCustomExpenseCategories(organizationId2, createdBy) {
        const defaultCategories = [
          { categoryName: "Gas", description: "Cooking gas and propane cylinders", billingCycle: "monthly", defaultAmount: "500", currency: "THB", displayOrder: 1 },
          { categoryName: "Pest Control", description: "Regular pest control services", billingCycle: "monthly", defaultAmount: "800", currency: "THB", displayOrder: 2 },
          { categoryName: "Residence Fee", description: "Building or community fees", billingCycle: "monthly", defaultAmount: "1200", currency: "THB", displayOrder: 3 },
          { categoryName: "Security Service", description: "Security guard or monitoring service", billingCycle: "monthly", defaultAmount: "2000", currency: "THB", displayOrder: 4 },
          { categoryName: "Landscaping", description: "Garden maintenance and landscaping", billingCycle: "monthly", defaultAmount: "1500", currency: "THB", displayOrder: 5 }
        ];
        for (const category of defaultCategories) {
          await this.createCustomExpenseCategory({
            organizationId: organizationId2,
            createdBy,
            ...category
          });
        }
      }
      // ===== ENHANCED COMMISSION MANAGEMENT SYSTEM =====
      // Commission Log Operations
      async createCommissionLog(commission) {
        const [newCommission] = await db.insert(commissionLog).values(commission).returning();
        return newCommission;
      }
      async getCommissionLog(organizationId2, filters) {
        let query = db.select({
          ...commissionLog,
          propertyName: properties.name,
          agentName: sql3`CONCAT(${users.firstName}, ' ', ${users.lastName})`,
          agentEmail: users.email
        }).from(commissionLog).leftJoin(properties, eq2(commissionLog.propertyId, properties.id)).leftJoin(users, eq2(commissionLog.agentId, users.id)).where(eq2(commissionLog.organizationId, organizationId2));
        if (filters?.agentId) {
          query = query.where(eq2(commissionLog.agentId, filters.agentId));
        }
        if (filters?.agentType) {
          query = query.where(eq2(commissionLog.agentType, filters.agentType));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(commissionLog.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          query = query.where(eq2(commissionLog.status, filters.status));
        }
        if (filters?.startDate) {
          query = query.where(gte2(commissionLog.createdAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(commissionLog.createdAt, new Date(filters.endDate)));
        }
        return query.orderBy(desc2(commissionLog.createdAt)).limit(filters?.limit || 100);
      }
      async updateCommissionLog(id, updates) {
        const [updated] = await db.update(commissionLog).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(commissionLog.id, id)).returning();
        return updated;
      }
      // Agent Commission Summary with KPIs
      async getAgentCommissionSummary(organizationId2, agentId, agentType) {
        const [commissionStats] = await db.select({
          totalEarned: sum(commissionLog.commissionAmount),
          pendingAmount: sum(sql3`CASE WHEN ${commissionLog.status} = 'pending' THEN ${commissionLog.commissionAmount} ELSE 0 END`),
          paidAmount: sum(sql3`CASE WHEN ${commissionLog.status} = 'paid' THEN ${commissionLog.commissionAmount} ELSE 0 END`),
          avgRate: avg(commissionLog.commissionRate),
          totalTransactions: count(commissionLog.id)
        }).from(commissionLog).where(and3(
          eq2(commissionLog.organizationId, organizationId2),
          eq2(commissionLog.agentId, agentId),
          eq2(commissionLog.agentType, agentType)
        ));
        const startOfMonth = /* @__PURE__ */ new Date();
        startOfMonth.setDate(1);
        startOfMonth.setHours(0, 0, 0, 0);
        const [thisMonthStats] = await db.select({
          thisMonthEarnings: sum(commissionLog.commissionAmount)
        }).from(commissionLog).where(and3(
          eq2(commissionLog.organizationId, organizationId2),
          eq2(commissionLog.agentId, agentId),
          eq2(commissionLog.agentType, agentType),
          gte2(commissionLog.createdAt, startOfMonth)
        ));
        const [lastPayment] = await db.select({ lastPaymentDate: max(agentPayouts.paidAt) }).from(agentPayouts).where(and3(
          eq2(agentPayouts.organizationId, organizationId2),
          eq2(agentPayouts.agentId, agentId),
          eq2(agentPayouts.agentType, agentType),
          eq2(agentPayouts.payoutStatus, "paid")
        ));
        let totalBookings = 0;
        if (agentType === "retail-agent") {
          const [bookingStats] = await db.select({ count: count() }).from(agentBookings).where(and3(
            eq2(agentBookings.organizationId, organizationId2),
            eq2(agentBookings.retailAgentId, agentId)
          ));
          totalBookings = bookingStats?.count || 0;
        }
        return {
          totalEarned: Number(commissionStats?.totalEarned || 0),
          pendingCommissions: Number(commissionStats?.pendingAmount || 0),
          paidCommissions: Number(commissionStats?.paidAmount || 0),
          currentBalance: Number(commissionStats?.totalEarned || 0) - Number(commissionStats?.paidAmount || 0),
          totalBookings: agentType === "retail-agent" ? totalBookings : void 0,
          thisMonthEarnings: Number(thisMonthStats?.thisMonthEarnings || 0),
          averageCommissionRate: Number(commissionStats?.avgRate || 0),
          lastPaymentDate: lastPayment?.lastPaymentDate
        };
      }
      // Admin Commission Management Functions
      async markCommissionAsPaid(id, adminId, notes) {
        const [updated] = await db.update(commissionLog).set({
          status: "paid",
          processedBy: adminId,
          processedAt: /* @__PURE__ */ new Date(),
          adminNotes: notes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(commissionLog.id, id)).returning();
        return updated;
      }
      async adjustCommissionAmount(id, newAmount, adminId, reason) {
        const [original] = await db.select().from(commissionLog).where(eq2(commissionLog.id, id));
        if (!original) {
          throw new Error("Commission not found");
        }
        const [updatedOriginal] = await db.update(commissionLog).set({
          status: "cancelled",
          processedBy: adminId,
          processedAt: /* @__PURE__ */ new Date(),
          adminNotes: `Original commission cancelled due to adjustment: ${reason}`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(commissionLog.id, id)).returning();
        const [adjustment] = await db.insert(commissionLog).values({
          organizationId: original.organizationId,
          agentId: original.agentId,
          agentType: original.agentType,
          propertyId: original.propertyId,
          bookingId: original.bookingId,
          referenceNumber: original.referenceNumber,
          baseAmount: original.baseAmount,
          commissionRate: original.commissionRate,
          commissionAmount: newAmount.toString(),
          currency: original.currency,
          status: "pending",
          isAdjustment: true,
          originalCommissionId: original.id,
          adjustmentReason: reason,
          processedBy: adminId,
          processedAt: /* @__PURE__ */ new Date(),
          commissionMonth: original.commissionMonth,
          commissionYear: original.commissionYear
        }).returning();
        return { original: updatedOriginal, adjustment };
      }
      // Commission Invoice Operations
      async createCommissionInvoice(invoice) {
        const [newInvoice] = await db.insert(commissionInvoices).values(invoice).returning();
        return newInvoice;
      }
      async getAgentInvoices(organizationId2, agentId, filters) {
        let query = db.select().from(commissionInvoices).where(and3(
          eq2(commissionInvoices.organizationId, organizationId2),
          eq2(commissionInvoices.agentId, agentId)
        ));
        if (filters?.status) {
          query = query.where(eq2(commissionInvoices.status, filters.status));
        }
        if (filters?.startDate) {
          query = query.where(gte2(commissionInvoices.invoiceDate, filters.startDate));
        }
        if (filters?.endDate) {
          query = query.where(lte2(commissionInvoices.invoiceDate, filters.endDate));
        }
        return query.orderBy(desc2(commissionInvoices.createdAt));
      }
      async generateInvoiceNumber(organizationId2, agentType) {
        const prefix = agentType === "retail-agent" ? "INV-RA" : "INV-RF";
        const date3 = /* @__PURE__ */ new Date();
        const year = date3.getFullYear().toString().slice(-2);
        const month = (date3.getMonth() + 1).toString().padStart(2, "0");
        const startOfMonth = new Date(date3.getFullYear(), date3.getMonth(), 1);
        const endOfMonth = new Date(date3.getFullYear(), date3.getMonth() + 1, 0);
        const [count3] = await db.select({ count: count3() }).from(commissionInvoices).where(and3(
          eq2(commissionInvoices.organizationId, organizationId2),
          eq2(commissionInvoices.agentType, agentType),
          gte2(commissionInvoices.createdAt, startOfMonth),
          lte2(commissionInvoices.createdAt, endOfMonth)
        ));
        const sequence = ((count3?.count || 0) + 1).toString().padStart(3, "0");
        return `${prefix}-${year}${month}-${sequence}`;
      }
      async submitInvoiceForApproval(id, agentId) {
        const [updated] = await db.update(commissionInvoices).set({
          status: "submitted",
          submittedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(commissionInvoices.id, id),
          eq2(commissionInvoices.agentId, agentId)
        )).returning();
        return updated;
      }
      async approveInvoice(id, adminId, notes) {
        const [updated] = await db.update(commissionInvoices).set({
          status: "approved",
          approvedBy: adminId,
          approvedAt: /* @__PURE__ */ new Date(),
          adminNotes: notes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(commissionInvoices.id, id)).returning();
        return updated;
      }
      async rejectInvoice(id, adminId, reason) {
        const [updated] = await db.update(commissionInvoices).set({
          status: "rejected",
          rejectedReason: reason,
          adminNotes: reason,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(commissionInvoices.id, id)).returning();
        return updated;
      }
      // Commission Invoice Line Items
      async createInvoiceLineItem(item) {
        const [newItem] = await db.insert(commissionInvoiceItems).values(item).returning();
        return newItem;
      }
      async getInvoiceLineItems(invoiceId) {
        return db.select().from(commissionInvoiceItems).where(eq2(commissionInvoiceItems.invoiceId, invoiceId)).orderBy(commissionInvoiceItems.commissionDate);
      }
      // Admin Commission Overview for CSV Export
      async getCommissionOverviewForExport(organizationId2, filters) {
        let query = db.select({
          organizationId: commissionLog.organizationId,
          agentId: commissionLog.agentId,
          agentName: sql3`CONCAT(${users.firstName}, ' ', ${users.lastName})`,
          agentEmail: users.email,
          agentType: commissionLog.agentType,
          propertyName: properties.name,
          referenceNumber: commissionLog.referenceNumber,
          commissionDate: commissionLog.createdAt,
          baseAmount: commissionLog.baseAmount,
          commissionRate: commissionLog.commissionRate,
          commissionAmount: commissionLog.commissionAmount,
          currency: commissionLog.currency,
          status: commissionLog.status,
          processedBy: commissionLog.processedBy,
          processedAt: commissionLog.processedAt
        }).from(commissionLog).leftJoin(users, eq2(commissionLog.agentId, users.id)).leftJoin(properties, eq2(commissionLog.propertyId, properties.id)).where(eq2(commissionLog.organizationId, organizationId2));
        if (filters?.agentType) {
          query = query.where(eq2(commissionLog.agentType, filters.agentType));
        }
        if (filters?.startDate) {
          query = query.where(gte2(commissionLog.createdAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(commissionLog.createdAt, new Date(filters.endDate)));
        }
        if (filters?.status) {
          query = query.where(eq2(commissionLog.status, filters.status));
        }
        return query.orderBy(desc2(commissionLog.createdAt));
      }
      // Trigger Payout Process
      async triggerCommissionPayout(agentId, organizationId2, amount, agentType, adminId) {
        const [payout] = await db.insert(agentPayouts).values({
          organizationId: organizationId2,
          agentId,
          agentType,
          payoutAmount: amount.toString(),
          payoutStatus: "pending",
          requestedAt: /* @__PURE__ */ new Date(),
          requestedBy: adminId,
          currency: "THB"
        }).returning();
        await db.update(commissionLog).set({
          payoutId: payout.id,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(commissionLog.organizationId, organizationId2),
          eq2(commissionLog.agentId, agentId),
          eq2(commissionLog.agentType, agentType),
          eq2(commissionLog.status, "pending")
        ));
        return payout;
      }
      // Agent-specific commission methods
      async getRetailAgentBookingCommissions(organizationId2, agentId, filters) {
        let query = db.select({
          ...agentBookings,
          propertyName: properties.name
        }).from(agentBookings).leftJoin(properties, eq2(agentBookings.propertyId, properties.id)).where(and3(
          eq2(agentBookings.organizationId, organizationId2),
          eq2(agentBookings.retailAgentId, agentId)
        ));
        if (filters?.propertyId) {
          query = query.where(eq2(agentBookings.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          query = query.where(eq2(agentBookings.commissionStatus, filters.status));
        }
        if (filters?.startDate) {
          query = query.where(gte2(agentBookings.checkIn, filters.startDate));
        }
        if (filters?.endDate) {
          query = query.where(lte2(agentBookings.checkOut, filters.endDate));
        }
        return query.orderBy(desc2(agentBookings.createdAt));
      }
      async getReferralAgentCommissions(organizationId2, agentId, filters) {
        let query = db.select({
          ...referralEarnings,
          propertyName: properties.name
        }).from(referralEarnings).leftJoin(properties, eq2(referralEarnings.propertyId, properties.id)).where(and3(
          eq2(referralEarnings.organizationId, organizationId2),
          eq2(referralEarnings.referralAgentId, agentId)
        ));
        if (filters?.propertyId) {
          query = query.where(eq2(referralEarnings.propertyId, filters.propertyId));
        }
        if (filters?.year) {
          query = query.where(eq2(referralEarnings.year, filters.year));
        }
        if (filters?.month) {
          query = query.where(eq2(referralEarnings.month, filters.month));
        }
        if (filters?.status) {
          query = query.where(eq2(referralEarnings.status, filters.status));
        }
        return query.orderBy(desc2(referralEarnings.year), desc2(referralEarnings.month));
      }
      // Guest Add-On Service operations
      async getGuestAddonServices(organizationId2) {
        return await db.select().from(guestAddonServices).where(eq2(guestAddonServices.organizationId, organizationId2)).orderBy(desc2(guestAddonServices.createdAt));
      }
      async getActiveGuestAddonServices(organizationId2) {
        return await db.select().from(guestAddonServices).where(
          and3(
            eq2(guestAddonServices.organizationId, organizationId2),
            eq2(guestAddonServices.isActive, true)
          )
        ).orderBy(desc2(guestAddonServices.createdAt));
      }
      async createGuestAddonService(service) {
        const [created] = await db.insert(guestAddonServices).values(service).returning();
        return created;
      }
      async updateGuestAddonService(id, organizationId2, updates) {
        const [updated] = await db.update(guestAddonServices).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and3(
            eq2(guestAddonServices.id, id),
            eq2(guestAddonServices.organizationId, organizationId2)
          )
        ).returning();
        return updated;
      }
      // Guest Add-On Booking operations
      async getGuestAddonBookings(organizationId2) {
        return await db.select({
          id: guestAddonBookings.id,
          serviceId: guestAddonBookings.serviceId,
          propertyId: guestAddonBookings.propertyId,
          guestName: guestAddonBookings.guestName,
          guestEmail: guestAddonBookings.guestEmail,
          guestPhone: guestAddonBookings.guestPhone,
          bookingDate: guestAddonBookings.bookingDate,
          serviceDate: guestAddonBookings.serviceDate,
          specialRequests: guestAddonBookings.specialRequests,
          totalAmount: guestAddonBookings.totalAmount,
          currency: guestAddonBookings.currency,
          status: guestAddonBookings.status,
          billingRoute: guestAddonBookings.billingRoute,
          complimentaryType: guestAddonBookings.complimentaryType,
          paymentStatus: guestAddonBookings.paymentStatus,
          paymentMethod: guestAddonBookings.paymentMethod,
          internalNotes: guestAddonBookings.internalNotes,
          bookedBy: guestAddonBookings.bookedBy,
          confirmedBy: guestAddonBookings.confirmedBy,
          cancelledBy: guestAddonBookings.cancelledBy,
          cancellationReason: guestAddonBookings.cancellationReason,
          organizationId: guestAddonBookings.organizationId,
          createdAt: guestAddonBookings.createdAt,
          updatedAt: guestAddonBookings.updatedAt,
          serviceName: guestAddonServices.serviceName,
          propertyName: properties.name
        }).from(guestAddonBookings).leftJoin(guestAddonServices, eq2(guestAddonBookings.serviceId, guestAddonServices.id)).leftJoin(properties, eq2(guestAddonBookings.propertyId, properties.id)).where(eq2(guestAddonBookings.organizationId, organizationId2)).orderBy(desc2(guestAddonBookings.createdAt));
      }
      async createGuestAddonBooking(booking) {
        const [created] = await db.insert(guestAddonBookings).values(booking).returning();
        return created;
      }
      async updateGuestAddonBooking(id, organizationId2, updates) {
        const [updated] = await db.update(guestAddonBookings).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and3(
            eq2(guestAddonBookings.id, id),
            eq2(guestAddonBookings.organizationId, organizationId2)
          )
        ).returning();
        return updated;
      }
      async getGuestAddonBookingById(id, organizationId2) {
        const [booking] = await db.select().from(guestAddonBookings).where(
          and3(
            eq2(guestAddonBookings.id, id),
            eq2(guestAddonBookings.organizationId, organizationId2)
          )
        );
        return booking;
      }
      // ===== LOYALTY & REPEAT GUEST TRACKER + SMART MESSAGING SYSTEM =====
      // Guest Loyalty Profile operations
      async getGuestLoyaltyProfile(organizationId2, guestEmail) {
        const [profile] = await db.select().from(guestLoyaltyProfiles).where(
          and3(
            eq2(guestLoyaltyProfiles.organizationId, organizationId2),
            eq2(guestLoyaltyProfiles.guestEmail, guestEmail)
          )
        );
        return profile;
      }
      async createOrUpdateGuestLoyaltyProfile(profile) {
        const existingProfile = await this.getGuestLoyaltyProfile(profile.organizationId, profile.guestEmail);
        if (existingProfile) {
          const [updated] = await db.update(guestLoyaltyProfiles).set({
            ...profile,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq2(guestLoyaltyProfiles.id, existingProfile.id)).returning();
          return updated;
        } else {
          const [created] = await db.insert(guestLoyaltyProfiles).values(profile).returning();
          return created;
        }
      }
      async getAllGuestLoyaltyProfiles(organizationId2) {
        return await db.select().from(guestLoyaltyProfiles).where(eq2(guestLoyaltyProfiles.organizationId, organizationId2)).orderBy(desc2(guestLoyaltyProfiles.lastStayDate));
      }
      async getRepeatGuests(organizationId2) {
        return await db.select().from(guestLoyaltyProfiles).where(
          and3(
            eq2(guestLoyaltyProfiles.organizationId, organizationId2),
            gt(guestLoyaltyProfiles.totalStays, 1)
          )
        ).orderBy(desc2(guestLoyaltyProfiles.totalStays));
      }
      // Loyalty Tier operations
      async getLoyaltyTiers(organizationId2) {
        return await db.select().from(loyaltyTiers).where(
          and3(
            eq2(loyaltyTiers.organizationId, organizationId2),
            eq2(loyaltyTiers.isActive, true)
          )
        ).orderBy(loyaltyTiers.minStays);
      }
      async createLoyaltyTier(tier) {
        const [created] = await db.insert(loyaltyTiers).values(tier).returning();
        return created;
      }
      // Guest Messages operations
      async getGuestMessages(organizationId2, threadId) {
        let query = db.select().from(guestMessages).where(eq2(guestMessages.organizationId, organizationId2));
        if (threadId) {
          query = query.where(eq2(guestMessages.threadId, threadId));
        }
        return await query.orderBy(desc2(guestMessages.createdAt));
      }
      async createGuestMessage(message) {
        const [created] = await db.insert(guestMessages).values(message).returning();
        return created;
      }
      async markMessageAsRead(messageId, readBy) {
        await db.update(guestMessages).set({
          isRead: true,
          readAt: /* @__PURE__ */ new Date(),
          readBy
        }).where(eq2(guestMessages.id, messageId));
      }
      async getUnreadMessagesCount(organizationId2) {
        const result = await db.select({ count: count() }).from(guestMessages).where(
          and3(
            eq2(guestMessages.organizationId, organizationId2),
            eq2(guestMessages.isRead, false),
            ne(guestMessages.senderType, "system")
          )
        );
        return result[0]?.count || 0;
      }
      // Messaging Triggers operations
      async getMessagingTriggers(organizationId2) {
        return await db.select().from(messagingTriggers).where(
          and3(
            eq2(messagingTriggers.organizationId, organizationId2),
            eq2(messagingTriggers.isActive, true)
          )
        );
      }
      async createMessagingTrigger(trigger) {
        const [created] = await db.insert(messagingTriggers).values(trigger).returning();
        return created;
      }
      // Smart Reply Suggestions operations
      async getSmartReplySuggestions(organizationId2, category) {
        let query = db.select().from(smartReplySuggestions).where(
          and3(
            eq2(smartReplySuggestions.organizationId, organizationId2),
            eq2(smartReplySuggestions.isActive, true)
          )
        );
        if (category) {
          query = query.where(eq2(smartReplySuggestions.category, category));
        }
        return await query.orderBy(desc2(smartReplySuggestions.useCount));
      }
      async createSmartReplySuggestion(suggestion) {
        const [created] = await db.insert(smartReplySuggestions).values(suggestion).returning();
        return created;
      }
      async incrementSmartReplyUsage(suggestionId) {
        await db.update(smartReplySuggestions).set({
          useCount: sql3`${smartReplySuggestions.useCount} + 1`,
          lastUsed: /* @__PURE__ */ new Date()
        }).where(eq2(smartReplySuggestions.id, suggestionId));
      }
      // AI Message Analysis operations
      async createAiMessageAnalysis(analysis) {
        const [created] = await db.insert(aiMessageAnalysis).values(analysis).returning();
        return created;
      }
      async getAiMessageAnalysis(organizationId2, messageId) {
        return await db.select().from(aiMessageAnalysis).where(
          and3(
            eq2(aiMessageAnalysis.organizationId, organizationId2),
            eq2(aiMessageAnalysis.messageId, messageId)
          )
        );
      }
      // Message Delivery Tracking operations
      async createMessageDelivery(delivery) {
        const [created] = await db.insert(messageDeliveries).values(delivery).returning();
        return created;
      }
      async updateMessageDeliveryStatus(deliveryId, status, failureReason) {
        await db.update(messageDeliveries).set({
          deliveryStatus: status,
          deliveredAt: status === "delivered" ? /* @__PURE__ */ new Date() : void 0,
          failureReason
        }).where(eq2(messageDeliveries.id, deliveryId));
      }
      // Utility methods for repeat guest identification
      async identifyRepeatGuest(organizationId2, guestEmail, guestName, guestPhone) {
        let profile = await this.getGuestLoyaltyProfile(organizationId2, guestEmail);
        if (!profile && guestPhone) {
          const [phoneProfile] = await db.select().from(guestLoyaltyProfiles).where(
            and3(
              eq2(guestLoyaltyProfiles.organizationId, organizationId2),
              eq2(guestLoyaltyProfiles.guestPhone, guestPhone)
            )
          );
          profile = phoneProfile;
        }
        if (!profile) {
          const [nameProfile] = await db.select().from(guestLoyaltyProfiles).where(
            and3(
              eq2(guestLoyaltyProfiles.organizationId, organizationId2),
              ilike(guestLoyaltyProfiles.guestName, `%${guestName}%`)
            )
          );
          profile = nameProfile;
        }
        return {
          isRepeat: !!profile && profile.totalStays > 0,
          profile
        };
      }
      // Update guest loyalty on new booking
      async updateGuestLoyaltyOnBooking(organizationId2, guestEmail, guestName, guestPhone, propertyId, bookingAmount, checkInDate, checkOutDate) {
        const { profile } = await this.identifyRepeatGuest(organizationId2, guestEmail, guestName, guestPhone);
        const stayDuration = Math.ceil((checkOutDate.getTime() - checkInDate.getTime()) / (1e3 * 60 * 60 * 24));
        if (profile) {
          const newTotalStays = profile.totalStays + 1;
          const newTotalSpent = parseFloat(profile.totalSpent) + bookingAmount;
          const newAverageStayDuration = Math.round(
            ((profile.averageStayDuration || 0) * profile.totalStays + stayDuration) / newTotalStays
          );
          const tiers = await this.getLoyaltyTiers(organizationId2);
          let newTier = "new";
          for (const tier of tiers.reverse()) {
            if (newTotalStays >= tier.minStays) {
              newTier = tier.tierName.toLowerCase();
              break;
            }
          }
          const [updated] = await db.update(guestLoyaltyProfiles).set({
            totalStays: newTotalStays,
            totalSpent: newTotalSpent.toString(),
            averageStayDuration: newAverageStayDuration,
            lastStayDate: checkInDate,
            loyaltyTier: newTier,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq2(guestLoyaltyProfiles.id, profile.id)).returning();
          return updated;
        } else {
          const newProfile = {
            organizationId: organizationId2,
            guestEmail,
            guestName,
            guestPhone,
            totalStays: 1,
            firstStayDate: checkInDate,
            lastStayDate: checkInDate,
            loyaltyTier: "new",
            totalSpent: bookingAmount.toString(),
            averageStayDuration: stayDuration,
            preferredProperties: [propertyId.toString()],
            loyaltyPoints: 0,
            isVip: false
          };
          return await this.createOrUpdateGuestLoyaltyProfile(newProfile);
        }
      }
      // ===== COMPREHENSIVE PAYROLL, COMMISSION & INVOICE MANAGEMENT SYSTEM =====
      // ===== STAFF PAYROLL MANAGEMENT =====
      // Create payroll record for staff
      async createStaffPayrollRecord(record) {
        const [newRecord] = await db.insert(staffPayrollRecords).values(record).returning();
        return newRecord;
      }
      // Get staff payroll records with filters
      async getStaffPayrollRecords(organizationId2, filters) {
        let query = db.select().from(staffPayrollRecords).where(eq2(staffPayrollRecords.organizationId, organizationId2));
        if (filters?.staffId) {
          query = query.where(eq2(staffPayrollRecords.staffId, filters.staffId));
        }
        if (filters?.payrollPeriod) {
          query = query.where(eq2(staffPayrollRecords.payrollPeriod, filters.payrollPeriod));
        }
        if (filters?.paymentStatus) {
          query = query.where(eq2(staffPayrollRecords.paymentStatus, filters.paymentStatus));
        }
        if (filters?.year) {
          query = query.where(eq2(staffPayrollRecords.payrollYear, filters.year));
        }
        if (filters?.month) {
          query = query.where(eq2(staffPayrollRecords.payrollMonth, filters.month));
        }
        return query.orderBy(desc2(staffPayrollRecords.payrollYear), desc2(staffPayrollRecords.payrollMonth));
      }
      // Update staff payroll record
      async updateStaffPayrollRecord(id, updates) {
        const [updated] = await db.update(staffPayrollRecords).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffPayrollRecords.id, id)).returning();
        return updated;
      }
      // Mark payroll as paid
      async markPayrollAsPaid(id, adminId, paymentDetails) {
        const [updated] = await db.update(staffPayrollRecords).set({
          paymentStatus: "paid",
          paymentDate: /* @__PURE__ */ new Date(),
          paymentMethod: paymentDetails.paymentMethod,
          paymentReference: paymentDetails.paymentReference,
          paymentSlipUrl: paymentDetails.paymentSlipUrl,
          processedBy: adminId,
          notes: paymentDetails.notes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(staffPayrollRecords.id, id)).returning();
        return updated;
      }
      // Get staff payroll summary
      async getStaffPayrollSummary(organizationId2, staffId, year) {
        let query = db.select().from(staffPayrollRecords).where(and3(
          eq2(staffPayrollRecords.organizationId, organizationId2),
          eq2(staffPayrollRecords.staffId, staffId)
        ));
        if (year) {
          query = query.where(eq2(staffPayrollRecords.payrollYear, year));
        }
        const records = await query;
        const totalPaid = records.filter((r) => r.paymentStatus === "paid").reduce((sum4, r) => sum4 + parseFloat(r.netPay), 0);
        const totalPending = records.filter((r) => r.paymentStatus === "pending").reduce((sum4, r) => sum4 + parseFloat(r.netPay), 0);
        const averageMonthly = records.length > 0 ? totalPaid / records.length : 0;
        const latestPayment = records.filter((r) => r.paymentStatus === "paid").sort((a, b) => new Date(b.paymentDate || 0).getTime() - new Date(a.paymentDate || 0).getTime())[0];
        return {
          totalPaid,
          totalPending,
          averageMonthly,
          latestPayment
        };
      }
      // ===== PORTFOLIO MANAGER COMMISSION TRACKING =====
      // Create portfolio manager commission record
      async createPortfolioManagerCommission(commission) {
        const [newCommission] = await db.insert(portfolioManagerCommissions).values(commission).returning();
        return newCommission;
      }
      // Get portfolio manager commissions
      async getPortfolioManagerCommissions(organizationId2, managerId, filters) {
        let query = db.select().from(portfolioManagerCommissions).where(eq2(portfolioManagerCommissions.organizationId, organizationId2));
        if (managerId) {
          query = query.where(eq2(portfolioManagerCommissions.managerId, managerId));
        }
        if (filters?.year) {
          query = query.where(eq2(portfolioManagerCommissions.commissionYear, filters.year));
        }
        if (filters?.month) {
          query = query.where(eq2(portfolioManagerCommissions.commissionMonth, filters.month));
        }
        if (filters?.payoutStatus) {
          query = query.where(eq2(portfolioManagerCommissions.payoutStatus, filters.payoutStatus));
        }
        return query.orderBy(desc2(portfolioManagerCommissions.commissionYear), desc2(portfolioManagerCommissions.commissionMonth));
      }
      // Request portfolio manager payout
      async requestPortfolioManagerPayout(commissionId) {
        const [updated] = await db.update(portfolioManagerCommissions).set({
          payoutStatus: "pending",
          payoutRequestedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(portfolioManagerCommissions.id, commissionId)).returning();
        return updated;
      }
      // Approve portfolio manager payout
      async approvePortfolioManagerPayout(commissionId, adminId, notes) {
        const [updated] = await db.update(portfolioManagerCommissions).set({
          payoutStatus: "approved",
          payoutApprovedAt: /* @__PURE__ */ new Date(),
          approvedBy: adminId,
          notes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(portfolioManagerCommissions.id, commissionId)).returning();
        return updated;
      }
      // Generate invoice for portfolio manager commission
      async generatePortfolioManagerInvoice(commissionId, invoiceNumber, invoicePdfUrl) {
        const [updated] = await db.update(portfolioManagerCommissions).set({
          invoiceGenerated: true,
          invoiceNumber,
          invoicePdfUrl,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(portfolioManagerCommissions.id, commissionId)).returning();
        return updated;
      }
      // ===== REFERRAL AGENT COMMISSION LOGS =====
      // Create referral agent commission log
      async createReferralAgentCommissionLog(log2) {
        const [newLog] = await db.insert(referralAgentCommissionLogs).values(log2).returning();
        return newLog;
      }
      // Get referral agent commission logs
      async getReferralAgentCommissionLogs(organizationId2, agentId, filters) {
        let query = db.select().from(referralAgentCommissionLogs).where(eq2(referralAgentCommissionLogs.organizationId, organizationId2));
        if (agentId) {
          query = query.where(eq2(referralAgentCommissionLogs.agentId, agentId));
        }
        if (filters?.year) {
          query = query.where(eq2(referralAgentCommissionLogs.commissionYear, filters.year));
        }
        if (filters?.month) {
          query = query.where(eq2(referralAgentCommissionLogs.commissionMonth, filters.month));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(referralAgentCommissionLogs.propertyId, filters.propertyId));
        }
        if (filters?.paymentStatus) {
          query = query.where(eq2(referralAgentCommissionLogs.paymentStatus, filters.paymentStatus));
        }
        return query.orderBy(desc2(referralAgentCommissionLogs.commissionYear), desc2(referralAgentCommissionLogs.commissionMonth));
      }
      // Request referral agent payment
      async requestReferralAgentPayment(logId) {
        const [updated] = await db.update(referralAgentCommissionLogs).set({
          paymentStatus: "requested",
          paymentRequestedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(referralAgentCommissionLogs.id, logId)).returning();
        return updated;
      }
      // Confirm referral agent payment
      async confirmReferralAgentPayment(logId, adminId, paymentSlipUrl, notes) {
        const [updated] = await db.update(referralAgentCommissionLogs).set({
          paymentStatus: "paid",
          paymentConfirmedAt: /* @__PURE__ */ new Date(),
          paymentSlipUrl,
          processedBy: adminId,
          notes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(referralAgentCommissionLogs.id, logId)).returning();
        return updated;
      }
      // ===== UNIVERSAL INVOICE GENERATOR =====
      // Create universal invoice
      async createUniversalInvoice(invoice) {
        const [newInvoice] = await db.insert(universalInvoices).values(invoice).returning();
        return newInvoice;
      }
      // Add line items to invoice
      async addInvoiceLineItems(lineItems) {
        const newItems = await db.insert(universalInvoiceLineItems).values(lineItems).returning();
        return newItems;
      }
      // Get universal invoices with line items
      async getUniversalInvoices(organizationId2, filters) {
        let query = db.select().from(universalInvoices).where(eq2(universalInvoices.organizationId, organizationId2));
        if (filters?.createdBy) {
          query = query.where(eq2(universalInvoices.createdBy, filters.createdBy));
        }
        if (filters?.invoiceType) {
          query = query.where(eq2(universalInvoices.invoiceType, filters.invoiceType));
        }
        if (filters?.status) {
          query = query.where(eq2(universalInvoices.status, filters.status));
        }
        if (filters?.fromDate) {
          query = query.where(gte2(universalInvoices.invoiceDate, filters.fromDate));
        }
        if (filters?.toDate) {
          query = query.where(lte2(universalInvoices.invoiceDate, filters.toDate));
        }
        const invoices2 = await query.orderBy(desc2(universalInvoices.createdAt));
        const invoicesWithLineItems = await Promise.all(
          invoices2.map(async (invoice) => {
            const lineItems = await db.select().from(universalInvoiceLineItems).where(eq2(universalInvoiceLineItems.invoiceId, invoice.id));
            return { ...invoice, lineItems };
          })
        );
        return invoicesWithLineItems;
      }
      // Update universal invoice
      async updateUniversalInvoice(id, updates) {
        const [updated] = await db.update(universalInvoices).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(universalInvoices.id, id)).returning();
        return updated;
      }
      // Generate invoice number
      async generateInvoiceNumber(organizationId2, type) {
        const year = (/* @__PURE__ */ new Date()).getFullYear();
        const typePrefix = type.toUpperCase().substr(0, 3);
        const count3 = await db.select({ count: sql3`count(*)` }).from(universalInvoices).where(and3(
          eq2(universalInvoices.organizationId, organizationId2),
          like(universalInvoices.invoiceNumber, `${typePrefix}-${year}-%`)
        ));
        const nextNumber = (count3[0]?.count || 0) + 1;
        return `${typePrefix}-${year}-${String(nextNumber).padStart(4, "0")}`;
      }
      // ===== PAYMENT CONFIRMATIONS =====
      // Create payment confirmation
      async createPaymentConfirmation(confirmation) {
        const [newConfirmation] = await db.insert(paymentConfirmations).values(confirmation).returning();
        return newConfirmation;
      }
      // Get payment confirmations
      async getPaymentConfirmations(organizationId2, filters) {
        let query = db.select().from(paymentConfirmations).where(eq2(paymentConfirmations.organizationId, organizationId2));
        if (filters?.paymentType) {
          query = query.where(eq2(paymentConfirmations.paymentType, filters.paymentType));
        }
        if (filters?.referenceEntityType) {
          query = query.where(eq2(paymentConfirmations.referenceEntityType, filters.referenceEntityType));
        }
        if (filters?.referenceEntityId) {
          query = query.where(eq2(paymentConfirmations.referenceEntityId, filters.referenceEntityId));
        }
        if (filters?.confirmationStatus) {
          query = query.where(eq2(paymentConfirmations.confirmationStatus, filters.confirmationStatus));
        }
        return query.orderBy(desc2(paymentConfirmations.createdAt));
      }
      // Confirm payment
      async confirmPayment(confirmationId, userId) {
        const [updated] = await db.update(paymentConfirmations).set({
          confirmationStatus: "confirmed",
          confirmedBy: userId,
          confirmedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(paymentConfirmations.id, confirmationId)).returning();
        return updated;
      }
      // ===== FINANCIAL DASHBOARD ANALYTICS =====
      // Get staff salary analytics
      async getStaffSalaryAnalytics(organizationId2) {
        const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        const currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
        const currentPayroll = await db.select().from(staffPayrollRecords).where(and3(
          eq2(staffPayrollRecords.organizationId, organizationId2),
          eq2(staffPayrollRecords.payrollYear, currentYear),
          eq2(staffPayrollRecords.payrollMonth, currentMonth)
        ));
        const totalMonthlyPayroll = currentPayroll.reduce((sum4, record) => sum4 + parseFloat(record.netPay), 0);
        const totalPendingPayments = currentPayroll.filter((record) => record.paymentStatus === "pending").reduce((sum4, record) => sum4 + parseFloat(record.netPay), 0);
        const staffCount = new Set(currentPayroll.map((record) => record.staffId)).size;
        const averageSalary = staffCount > 0 ? totalMonthlyPayroll / staffCount : 0;
        const departmentBreakdown = [];
        return {
          totalMonthlyPayroll,
          totalPendingPayments,
          staffCount,
          averageSalary,
          departmentBreakdown
        };
      }
      // Get commission analytics
      async getCommissionAnalytics(organizationId2) {
        const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        const currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
        const lastMonth = currentMonth === 1 ? 12 : currentMonth - 1;
        const lastMonthYear = currentMonth === 1 ? currentYear - 1 : currentYear;
        const pmCommissions = await db.select().from(portfolioManagerCommissions).where(and3(
          eq2(portfolioManagerCommissions.organizationId, organizationId2),
          eq2(portfolioManagerCommissions.commissionYear, currentYear),
          eq2(portfolioManagerCommissions.commissionMonth, currentMonth)
        ));
        const raCommissions = await db.select().from(referralAgentCommissionLogs).where(and3(
          eq2(referralAgentCommissionLogs.organizationId, organizationId2),
          eq2(referralAgentCommissionLogs.commissionYear, currentYear),
          eq2(referralAgentCommissionLogs.commissionMonth, currentMonth)
        ));
        const portfolioManagerEarnings = pmCommissions.reduce((sum4, comm) => sum4 + parseFloat(comm.commissionAmount), 0);
        const referralAgentEarnings = raCommissions.reduce((sum4, comm) => sum4 + parseFloat(comm.commissionAmount), 0);
        const totalCommissionsPending = pmCommissions.filter((comm) => comm.payoutStatus === "pending").reduce((sum4, comm) => sum4 + parseFloat(comm.commissionAmount), 0) + raCommissions.filter((comm) => comm.paymentStatus === "pending").reduce((sum4, comm) => sum4 + parseFloat(comm.commissionAmount), 0);
        const totalCommissionsPaid = pmCommissions.filter((comm) => comm.payoutStatus === "paid").reduce((sum4, comm) => sum4 + parseFloat(comm.commissionAmount), 0) + raCommissions.filter((comm) => comm.paymentStatus === "paid").reduce((sum4, comm) => sum4 + parseFloat(comm.commissionAmount), 0);
        const monthlyGrowth = 5.2;
        return {
          totalCommissionsPending,
          totalCommissionsPaid,
          portfolioManagerEarnings,
          referralAgentEarnings,
          monthlyGrowth
        };
      }
      // ===== LIVE BOOKING CALENDAR SYSTEM =====
      // Create booking entry
      async createBookingEntry(booking) {
        const [newBooking] = await db.insert(liveBookingCalendar).values(booking).returning();
        return newBooking;
      }
      // Get bookings for calendar view
      async getBookingCalendar(organizationId2, filters) {
        let query = db.select().from(liveBookingCalendar).where(eq2(liveBookingCalendar.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(liveBookingCalendar.propertyId, filters.propertyId));
        }
        if (filters?.startDate) {
          query = query.where(gte2(liveBookingCalendar.checkInDate, filters.startDate));
        }
        if (filters?.endDate) {
          query = query.where(lte2(liveBookingCalendar.checkOutDate, filters.endDate));
        }
        if (filters?.bookingStatus) {
          query = query.where(eq2(liveBookingCalendar.bookingStatus, filters.bookingStatus));
        }
        if (filters?.bookingSource) {
          query = query.where(eq2(liveBookingCalendar.bookingSource, filters.bookingSource));
        }
        return query.orderBy(asc(liveBookingCalendar.checkInDate));
      }
      // Get upcoming bookings for a property
      async getUpcomingBookings(organizationId2, propertyId, days = 30) {
        const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        const futureDate = /* @__PURE__ */ new Date();
        futureDate.setDate(futureDate.getDate() + days);
        const futureString = futureDate.toISOString().split("T")[0];
        return db.select().from(liveBookingCalendar).where(
          and3(
            eq2(liveBookingCalendar.organizationId, organizationId2),
            eq2(liveBookingCalendar.propertyId, propertyId),
            gte2(liveBookingCalendar.checkInDate, today),
            lte2(liveBookingCalendar.checkInDate, futureString),
            eq2(liveBookingCalendar.bookingStatus, "confirmed")
          )
        ).orderBy(asc(liveBookingCalendar.checkInDate));
      }
      // Update booking from API sync
      async updateBookingFromAPI(externalBookingId, updateData) {
        const [updated] = await db.update(liveBookingCalendar).set({
          ...updateData,
          lastSyncedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(liveBookingCalendar.externalBookingId, externalBookingId)).returning();
        return updated;
      }
      // Get booking analytics for dashboard
      async getBookingAnalytics(organizationId2, propertyId) {
        let query = db.select().from(liveBookingCalendar).where(eq2(liveBookingCalendar.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(liveBookingCalendar.propertyId, propertyId));
        }
        const bookings3 = await query;
        const totalBookings = bookings3.length;
        const confirmedBookings = bookings3.filter((b) => b.bookingStatus === "confirmed").length;
        const totalRevenue = bookings3.reduce((sum4, b) => sum4 + parseFloat(b.totalAmount), 0);
        const averageStayDuration = bookings3.length > 0 ? bookings3.reduce((sum4, b) => sum4 + b.nightCount, 0) / bookings3.length : 0;
        const platformBreakdown = Object.entries(
          bookings3.reduce((acc, booking) => {
            const platform = booking.bookingSource;
            if (!acc[platform]) {
              acc[platform] = { bookings: 0, revenue: 0 };
            }
            acc[platform].bookings++;
            acc[platform].revenue += parseFloat(booking.totalAmount);
            return acc;
          }, {})
        ).map(([platform, data]) => ({ platform, ...data }));
        const occupancyRate = confirmedBookings > 0 ? confirmedBookings / totalBookings * 100 : 0;
        return {
          totalBookings,
          confirmedBookings,
          totalRevenue,
          occupancyRate,
          averageStayDuration,
          platformBreakdown
        };
      }
      // ===== PROPERTY AVAILABILITY MANAGEMENT =====
      // Create availability entry
      async createPropertyAvailability(availability) {
        const [newAvailability] = await db.insert(propertyAvailability).values(availability).returning();
        return newAvailability;
      }
      // Get property availability
      async getPropertyAvailability(organizationId2, filters) {
        let query = db.select().from(propertyAvailability).where(eq2(propertyAvailability.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(propertyAvailability.propertyId, filters.propertyId));
        }
        if (filters?.startDate) {
          query = query.where(gte2(propertyAvailability.startDate, filters.startDate));
        }
        if (filters?.endDate) {
          query = query.where(lte2(propertyAvailability.endDate, filters.endDate));
        }
        if (filters?.availabilityType) {
          query = query.where(eq2(propertyAvailability.availabilityType, filters.availabilityType));
        }
        return query.orderBy(asc(propertyAvailability.startDate));
      }
      // Check if property is available for dates
      async checkPropertyAvailability(propertyId, checkIn, checkOut) {
        const existingBookings = await db.select().from(liveBookingCalendar).where(
          and3(
            eq2(liveBookingCalendar.propertyId, propertyId),
            eq2(liveBookingCalendar.bookingStatus, "confirmed"),
            or(
              and3(
                gte2(liveBookingCalendar.checkInDate, checkIn),
                lt(liveBookingCalendar.checkInDate, checkOut)
              ),
              and3(
                gt(liveBookingCalendar.checkOutDate, checkIn),
                lte2(liveBookingCalendar.checkOutDate, checkOut)
              ),
              and3(
                lte2(liveBookingCalendar.checkInDate, checkIn),
                gte2(liveBookingCalendar.checkOutDate, checkOut)
              )
            )
          )
        );
        const blockedDates = await db.select().from(propertyAvailability).where(
          and3(
            eq2(propertyAvailability.propertyId, propertyId),
            eq2(propertyAvailability.availabilityType, "blocked"),
            or(
              and3(
                gte2(propertyAvailability.startDate, checkIn),
                lt(propertyAvailability.startDate, checkOut)
              ),
              and3(
                gt(propertyAvailability.endDate, checkIn),
                lte2(propertyAvailability.endDate, checkOut)
              ),
              and3(
                lte2(propertyAvailability.startDate, checkIn),
                gte2(propertyAvailability.endDate, checkOut)
              )
            )
          )
        );
        return existingBookings.length === 0 && blockedDates.length === 0;
      }
      // ===== AGENT SEARCH AND PREFERENCES =====
      // Get/create agent search preferences
      async getAgentSearchPreferences(organizationId2, agentId) {
        const [preferences] = await db.select().from(agentSearchPreferences).where(
          and3(
            eq2(agentSearchPreferences.organizationId, organizationId2),
            eq2(agentSearchPreferences.agentId, agentId)
          )
        );
        return preferences;
      }
      async updateAgentSearchPreferences(organizationId2, agentId, preferences) {
        const existing = await this.getAgentSearchPreferences(organizationId2, agentId);
        if (existing) {
          const [updated] = await db.update(agentSearchPreferences).set({ ...preferences, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(agentSearchPreferences.id, existing.id)).returning();
          return updated;
        } else {
          const [created] = await db.insert(agentSearchPreferences).values({ organizationId: organizationId2, agentId, ...preferences }).returning();
          return created;
        }
      }
      // ===== PROPERTY SEARCH INDEX FOR AGENTS =====
      // Get available properties for agent search
      async searchPropertiesForAgents(organizationId2, filters) {
        let query = db.select().from(propertySearchIndex).where(
          and3(
            eq2(propertySearchIndex.organizationId, organizationId2),
            eq2(propertySearchIndex.isActive, true)
          )
        );
        if (filters?.location) {
          query = query.where(eq2(propertySearchIndex.province, filters.location));
        }
        if (filters?.zone) {
          query = query.where(eq2(propertySearchIndex.zone, filters.zone));
        }
        if (filters?.minBedrooms) {
          query = query.where(gte2(propertySearchIndex.bedrooms, filters.minBedrooms));
        }
        if (filters?.maxBedrooms) {
          query = query.where(lte2(propertySearchIndex.bedrooms, filters.maxBedrooms));
        }
        if (filters?.minPrice) {
          query = query.where(gte2(propertySearchIndex.baseNightlyRate, filters.minPrice.toString()));
        }
        if (filters?.maxPrice) {
          query = query.where(lte2(propertySearchIndex.baseNightlyRate, filters.maxPrice.toString()));
        }
        if (filters?.maxGuests) {
          query = query.where(gte2(propertySearchIndex.maxGuests, filters.maxGuests));
        }
        const results = await query.orderBy(desc2(propertySearchIndex.popularityScore));
        if (filters?.checkIn && filters?.checkOut) {
          const availableProperties = [];
          for (const property of results) {
            const isAvailable = await this.checkPropertyAvailability(property.propertyId, filters.checkIn, filters.checkOut);
            if (isAvailable) {
              availableProperties.push(property);
            }
          }
          return availableProperties;
        }
        return results;
      }
      // Create/update property search index
      async updatePropertySearchIndex(propertyId, indexData) {
        const existing = await db.select().from(propertySearchIndex).where(eq2(propertySearchIndex.propertyId, propertyId));
        if (existing.length > 0) {
          const [updated] = await db.update(propertySearchIndex).set({ ...indexData, lastIndexedAt: /* @__PURE__ */ new Date() }).where(eq2(propertySearchIndex.propertyId, propertyId)).returning();
          return updated;
        } else {
          const [created] = await db.insert(propertySearchIndex).values({ propertyId, ...indexData }).returning();
          return created;
        }
      }
      // ===== AGENT BOOKING ENQUIRIES =====
      // Create booking enquiry
      async createBookingEnquiry(enquiry) {
        const [newEnquiry] = await db.insert(agentBookingEnquiries).values(enquiry).returning();
        return newEnquiry;
      }
      // Get agent booking enquiries
      async getAgentBookingEnquiries(organizationId2, filters) {
        let query = db.select().from(agentBookingEnquiries).where(eq2(agentBookingEnquiries.organizationId, organizationId2));
        if (filters?.agentId) {
          query = query.where(eq2(agentBookingEnquiries.agentId, filters.agentId));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(agentBookingEnquiries.propertyId, filters.propertyId));
        }
        if (filters?.enquiryStatus) {
          query = query.where(eq2(agentBookingEnquiries.enquiryStatus, filters.enquiryStatus));
        }
        if (filters?.dateRange) {
          query = query.where(
            and3(
              gte2(agentBookingEnquiries.requestedCheckIn, filters.dateRange.start.toISOString().split("T")[0]),
              lte2(agentBookingEnquiries.requestedCheckOut, filters.dateRange.end.toISOString().split("T")[0])
            )
          );
        }
        return query.orderBy(desc2(agentBookingEnquiries.createdAt));
      }
      // Update enquiry status
      async updateEnquiryStatus(enquiryId, status, processedBy) {
        const [updated] = await db.update(agentBookingEnquiries).set({
          enquiryStatus: status,
          processedBy,
          processedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(agentBookingEnquiries.id, enquiryId)).returning();
        return updated;
      }
      // Convert enquiry to booking
      async convertEnquiryToBooking(enquiryId, bookingData) {
        const booking = await this.createBookingEntry(bookingData);
        const [updatedEnquiry] = await db.update(agentBookingEnquiries).set({
          convertedToBooking: true,
          bookingId: booking.id,
          conversionDate: /* @__PURE__ */ new Date(),
          enquiryStatus: "confirmed",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(agentBookingEnquiries.id, enquiryId)).returning();
        return { enquiry: updatedEnquiry, booking };
      }
      // ===== BOOKING PLATFORM SYNC =====
      // Create/update platform sync configuration
      async updateBookingPlatformSync(organizationId2, syncData) {
        const existing = await db.select().from(bookingPlatformSync).where(
          and3(
            eq2(bookingPlatformSync.organizationId, organizationId2),
            eq2(bookingPlatformSync.platformName, syncData.platformName)
          )
        );
        if (existing.length > 0) {
          const [updated] = await db.update(bookingPlatformSync).set({ ...syncData, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(bookingPlatformSync.id, existing[0].id)).returning();
          return updated;
        } else {
          const [created] = await db.insert(bookingPlatformSync).values({ organizationId: organizationId2, ...syncData }).returning();
          return created;
        }
      }
      // Get platform sync configurations
      async getBookingPlatformSyncs(organizationId2, isActive) {
        let query = db.select().from(bookingPlatformSync).where(eq2(bookingPlatformSync.organizationId, organizationId2));
        if (isActive !== void 0) {
          query = query.where(eq2(bookingPlatformSync.isActive, isActive));
        }
        return query.orderBy(asc(bookingPlatformSync.platformName));
      }
      // Update sync status
      async updateSyncStatus(syncId, status, error) {
        const [updated] = await db.update(bookingPlatformSync).set({
          syncStatus: status,
          lastSyncAt: /* @__PURE__ */ new Date(),
          lastError: error || null,
          errorCount: error ? sql3`${bookingPlatformSync.errorCount} + 1` : 0,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(bookingPlatformSync.id, syncId)).returning();
        return updated;
      }
      // ===== OCCUPANCY ANALYTICS =====
      // Create/update occupancy analytics
      async updateOccupancyAnalytics(analytics) {
        const existing = await db.select().from(propertyOccupancyAnalytics).where(
          and3(
            eq2(propertyOccupancyAnalytics.propertyId, analytics.propertyId),
            eq2(propertyOccupancyAnalytics.periodType, analytics.periodType),
            eq2(propertyOccupancyAnalytics.periodDate, analytics.periodDate)
          )
        );
        if (existing.length > 0) {
          const [updated] = await db.update(propertyOccupancyAnalytics).set({ ...analytics, calculatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyOccupancyAnalytics.id, existing[0].id)).returning();
          return updated;
        } else {
          const [created] = await db.insert(propertyOccupancyAnalytics).values(analytics).returning();
          return created;
        }
      }
      // Get occupancy analytics
      async getOccupancyAnalytics(organizationId2, filters) {
        let query = db.select().from(propertyOccupancyAnalytics).where(eq2(propertyOccupancyAnalytics.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(propertyOccupancyAnalytics.propertyId, filters.propertyId));
        }
        if (filters?.periodType) {
          query = query.where(eq2(propertyOccupancyAnalytics.periodType, filters.periodType));
        }
        if (filters?.startDate) {
          query = query.where(gte2(propertyOccupancyAnalytics.periodDate, filters.startDate));
        }
        if (filters?.endDate) {
          query = query.where(lte2(propertyOccupancyAnalytics.periodDate, filters.endDate));
        }
        return query.orderBy(desc2(propertyOccupancyAnalytics.periodDate));
      }
      // ===== GUEST PORTAL INTERFACE METHODS =====
      // Guest Portal Sessions
      async createGuestPortalSession(session3) {
        const [newSession] = await db.insert(guestPortalSessions).values(session3).returning();
        return newSession;
      }
      async getGuestPortalSession(accessToken) {
        const [session3] = await db.select().from(guestPortalSessions).where(and3(
          eq2(guestPortalSessions.accessToken, accessToken),
          eq2(guestPortalSessions.isActive, true),
          gte2(guestPortalSessions.expiresAt, /* @__PURE__ */ new Date())
        ));
        return session3;
      }
      async updateGuestPortalSessionActivity(accessToken) {
        await db.update(guestPortalSessions).set({ lastAccessed: /* @__PURE__ */ new Date() }).where(eq2(guestPortalSessions.accessToken, accessToken));
      }
      async getGuestBookingOverview(guestSessionId) {
        const session3 = await db.select().from(guestPortalSessions).where(eq2(guestPortalSessions.id, guestSessionId)).limit(1);
        if (!session3[0]) {
          return { upcomingStays: [], currentStay: null, pastStays: [] };
        }
        const currentDate = /* @__PURE__ */ new Date();
        const checkInDate = session3[0].checkInDate;
        const checkOutDate = session3[0].checkOutDate;
        const isCurrentStay = currentDate >= checkInDate && currentDate <= checkOutDate;
        return {
          upcomingStays: isCurrentStay ? [] : [session3[0]],
          currentStay: isCurrentStay ? session3[0] : null,
          pastStays: currentDate > checkOutDate ? [session3[0]] : []
        };
      }
      // Guest Activity Timeline
      async getGuestActivityTimeline(guestSessionId) {
        return await db.select().from(guestActivityTimeline).where(and3(
          eq2(guestActivityTimeline.guestSessionId, guestSessionId),
          eq2(guestActivityTimeline.isVisible, true)
        )).orderBy(desc2(guestActivityTimeline.requestedAt));
      }
      async createGuestActivityRecord(activity) {
        const [newActivity] = await db.insert(guestActivityTimeline).values(activity).returning();
        return newActivity;
      }
      async updateGuestActivityStatus(id, status, completedAt) {
        const updateData = { status, updatedAt: /* @__PURE__ */ new Date() };
        if (completedAt) updateData.completedAt = completedAt;
        const [updated] = await db.update(guestActivityTimeline).set(updateData).where(eq2(guestActivityTimeline.id, id)).returning();
        return updated;
      }
      // Guest Chat & AI Operations
      async getGuestChatMessages(guestSessionId, limit = 50) {
        return await db.select().from(guestChatMessages).where(eq2(guestChatMessages.guestSessionId, guestSessionId)).orderBy(desc2(guestChatMessages.sentAt)).limit(limit);
      }
      async createGuestChatMessage(message) {
        const [newMessage] = await db.insert(guestChatMessages).values(message).returning();
        return newMessage;
      }
      async processGuestMessageWithAI(messageId) {
        const [message] = await db.select().from(guestChatMessages).where(eq2(guestChatMessages.id, messageId));
        if (!message) {
          return { detectedIssue: null, severity: null, autoCreatedTaskId: null, aiResponse: null };
        }
        const content = message.messageContent.toLowerCase();
        let detectedIssue = null;
        let severity = null;
        let aiResponse = "Thank you for your message. Our team will respond shortly.";
        if (content.includes("broken") || content.includes("not working") || content.includes("problem")) {
          detectedIssue = "maintenance";
          severity = content.includes("urgent") || content.includes("emergency") ? "urgent" : "medium";
          aiResponse = "I understand there's a maintenance issue. I've notified our team and they'll address this shortly.";
        } else if (content.includes("dirty") || content.includes("clean")) {
          detectedIssue = "cleaning";
          severity = "medium";
          aiResponse = "I'll arrange for additional cleaning service right away.";
        }
        await db.update(guestChatMessages).set({
          aiProcessed: true,
          detectedIssue,
          issueSeverity: severity,
          requiresStaffResponse: detectedIssue !== null
        }).where(eq2(guestChatMessages.id, messageId));
        return { detectedIssue, severity, autoCreatedTaskId: null, aiResponse };
      }
      async getGuestAiFaqResponses(organizationId2, propertyId) {
        const conditions = [eq2(guestAiFaqKnowledge.organizationId, organizationId2)];
        if (propertyId) {
          conditions.push(eq2(guestAiFaqKnowledge.propertyId, propertyId));
        }
        return await db.select().from(guestAiFaqKnowledge).where(and3(...conditions)).orderBy(desc2(guestAiFaqKnowledge.priority));
      }
      // Guest Add-On Service Requests
      async getAvailableAddonServices(organizationId2, propertyId) {
        return await db.select().from(guestAddonServices).where(and3(
          eq2(guestAddonServices.organizationId, organizationId2),
          eq2(guestAddonServices.isActive, true)
        )).orderBy(asc(guestAddonServices.serviceName));
      }
      async createGuestAddonServiceRequest(request) {
        const [newRequest] = await db.insert(guestAddonServiceRequests).values(request).returning();
        return newRequest;
      }
      async getGuestAddonServiceRequests(guestSessionId) {
        return await db.select().from(guestAddonServiceRequests).where(eq2(guestAddonServiceRequests.guestSessionId, guestSessionId)).orderBy(desc2(guestAddonServiceRequests.createdAt));
      }
      async updateAddonServiceRequestStatus(id, status, confirmedBy) {
        const updateData = { requestStatus: status, updatedAt: /* @__PURE__ */ new Date() };
        if (confirmedBy) {
          updateData.confirmedBy = confirmedBy;
          updateData.confirmedAt = /* @__PURE__ */ new Date();
        }
        const [updated] = await db.update(guestAddonServiceRequests).set(updateData).where(eq2(guestAddonServiceRequests.id, id)).returning();
        return updated;
      }
      async completeAddonServiceRequest(id, completionNotes, rating, review) {
        const updateData = {
          requestStatus: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          completionNotes,
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (rating) updateData.guestRating = rating;
        if (review) updateData.guestReview = review;
        const [updated] = await db.update(guestAddonServiceRequests).set(updateData).where(eq2(guestAddonServiceRequests.id, id)).returning();
        return updated;
      }
      // Guest Property Local Information
      async getGuestPropertyLocalInfo(propertyId, locationType) {
        const conditions = [
          eq2(guestPropertyLocalInfo.propertyId, propertyId),
          eq2(guestPropertyLocalInfo.isActive, true)
        ];
        if (locationType) {
          conditions.push(eq2(guestPropertyLocalInfo.locationType, locationType));
        }
        return await db.select().from(guestPropertyLocalInfo).where(and3(...conditions)).orderBy(asc(guestPropertyLocalInfo.displayOrder), desc2(guestPropertyLocalInfo.recommendationScore));
      }
      async createPropertyLocalInfo(info) {
        const [newInfo] = await db.insert(guestPropertyLocalInfo).values(info).returning();
        return newInfo;
      }
      async updatePropertyLocalInfo(id, info) {
        const [updated] = await db.update(guestPropertyLocalInfo).set({ ...info, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(guestPropertyLocalInfo.id, id)).returning();
        return updated;
      }
      // Guest Maintenance Reports
      async createGuestMaintenanceReport(report) {
        const [newReport] = await db.insert(guestMaintenanceReports).values(report).returning();
        return newReport;
      }
      async getGuestMaintenanceReports(guestSessionId) {
        return await db.select().from(guestMaintenanceReports).where(eq2(guestMaintenanceReports.guestSessionId, guestSessionId)).orderBy(desc2(guestMaintenanceReports.reportedAt));
      }
      async updateMaintenanceReportStatus(id, status, assignedTo) {
        const updateData = { reportStatus: status, updatedAt: /* @__PURE__ */ new Date() };
        if (assignedTo) {
          updateData.assignedTo = assignedTo;
          updateData.assignedAt = /* @__PURE__ */ new Date();
        }
        const [updated] = await db.update(guestMaintenanceReports).set(updateData).where(eq2(guestMaintenanceReports.id, id)).returning();
        return updated;
      }
      async completeMaintenanceReport(id, resolutionNotes, images) {
        const updateData = {
          reportStatus: "resolved",
          actualResolutionTime: /* @__PURE__ */ new Date(),
          resolutionNotes,
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (images) updateData.resolutionImages = images;
        const [updated] = await db.update(guestMaintenanceReports).set(updateData).where(eq2(guestMaintenanceReports.id, id)).returning();
        return updated;
      }
      // Finance Engine Methods
      async getOwnerBalances(organizationId2) {
        return await db.select({
          id: ownerBalances.id,
          ownerId: ownerBalances.ownerId,
          ownerName: sql3`CONCAT(${users.firstName}, ' ', ${users.lastName})`,
          currentBalance: ownerBalances.currentBalance,
          totalEarnings: ownerBalances.totalEarnings,
          totalExpenses: ownerBalances.totalExpenses,
          thisMonthEarnings: ownerBalances.thisMonthEarnings,
          thisMonthExpenses: ownerBalances.thisMonthExpenses,
          thisMonthNet: ownerBalances.thisMonthNet,
          lastCalculated: ownerBalances.lastCalculated
        }).from(ownerBalances).leftJoin(users, eq2(users.id, ownerBalances.ownerId)).where(eq2(ownerBalances.organizationId, organizationId2));
      }
      async getOwnerPayoutRequests(organizationId2) {
        return await db.select({
          id: ownerPayoutRequests.id,
          ownerId: ownerPayoutRequests.ownerId,
          ownerName: sql3`CONCAT(${users.firstName}, ' ', ${users.lastName})`,
          amount: ownerPayoutRequests.amount,
          currency: ownerPayoutRequests.currency,
          status: ownerPayoutRequests.status,
          requestNotes: ownerPayoutRequests.requestNotes,
          adminNotes: ownerPayoutRequests.adminNotes,
          transferMethod: ownerPayoutRequests.transferMethod,
          transferReference: ownerPayoutRequests.transferReference,
          transferReceiptUrl: ownerPayoutRequests.transferReceiptUrl,
          ownerConfirmed: ownerPayoutRequests.ownerConfirmed,
          requestedAt: ownerPayoutRequests.requestedAt,
          approvedAt: ownerPayoutRequests.approvedAt,
          transferredAt: ownerPayoutRequests.transferredAt,
          completedAt: ownerPayoutRequests.completedAt
        }).from(ownerPayoutRequests).leftJoin(users, eq2(users.id, ownerPayoutRequests.ownerId)).where(eq2(ownerPayoutRequests.organizationId, organizationId2)).orderBy(desc2(ownerPayoutRequests.requestedAt));
      }
      async createOwnerPayoutRequest(data) {
        const [payout] = await db.insert(ownerPayoutRequests).values(data).returning();
        return payout;
      }
      async updateOwnerPayoutRequest(id, data) {
        const [payout] = await db.update(ownerPayoutRequests).set(data).where(eq2(ownerPayoutRequests.id, id)).returning();
        return payout;
      }
      async getOwnerChargeRequests(organizationId2) {
        return await db.select({
          id: ownerChargeRequests.id,
          ownerId: ownerChargeRequests.ownerId,
          ownerName: sql3`CONCAT(${users.firstName}, ' ', ${users.lastName})`,
          chargedBy: ownerChargeRequests.chargedBy,
          amount: ownerChargeRequests.amount,
          currency: ownerChargeRequests.currency,
          reason: ownerChargeRequests.reason,
          description: ownerChargeRequests.description,
          status: ownerChargeRequests.status,
          paymentMethod: ownerChargeRequests.paymentMethod,
          paymentReference: ownerChargeRequests.paymentReference,
          chargedAt: ownerChargeRequests.chargedAt,
          paidAt: ownerChargeRequests.paidAt
        }).from(ownerChargeRequests).leftJoin(users, eq2(users.id, ownerChargeRequests.ownerId)).where(eq2(ownerChargeRequests.organizationId, organizationId2)).orderBy(desc2(ownerChargeRequests.chargedAt));
      }
      async createOwnerChargeRequest(data) {
        const [charge] = await db.insert(ownerChargeRequests).values(data).returning();
        return charge;
      }
      // ===== TASK SCHEDULING SYSTEM IMPLEMENTATION =====
      // Task Scheduling System operations
      async getScheduledTasks(organizationId2, filters) {
        let conditions = [eq2(tasks.organizationId, organizationId2)];
        if (filters?.propertyId) {
          conditions.push(eq2(tasks.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          conditions.push(eq2(tasks.status, filters.status));
        }
        const taskResult = await db.select().from(tasks).where(and3(...conditions)).orderBy(desc2(tasks.scheduledDate)).limit(50);
        return taskResult.map((task) => ({
          id: task.id,
          reservationId: task.bookingId?.toString() || null,
          taskType: task.category,
          title: task.title,
          description: task.description || "",
          scheduledDate: task.scheduledDate,
          scheduledTime: task.scheduledTime || "09:00",
          duration: task.estimatedDuration || "1 hour",
          assignedRole: task.assignedStaff || "staff",
          assignedTo: task.assignedStaff || "Unassigned",
          property: task.propertyId ? `Property ${task.propertyId}` : "Unknown",
          propertyId: task.propertyId,
          status: task.status,
          priority: task.priority,
          evidenceRequired: false,
          guestVisible: false
        }));
      }
      async getScheduledTask(id) {
        const taskResult = await db.select().from(tasks).where(eq2(tasks.id, id)).limit(1);
        return taskResult.length ? taskResult[0] : void 0;
      }
      async updateScheduledTask(id, updates) {
        const task = await this.getScheduledTask(id);
        if (!task) return void 0;
        return {
          ...task,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async deleteScheduledTask(id) {
        const task = await this.getScheduledTask(id);
        return !!task;
      }
      async updateTaskStatus(id, status, completedBy, evidence) {
        const task = await this.getScheduledTask(id);
        if (!task) return void 0;
        return {
          ...task,
          status,
          completedBy,
          evidence,
          completedAt: status === "completed" ? /* @__PURE__ */ new Date() : void 0,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Demo data methods for task scheduling
      async getDemoTaskSchedule(role, date3, reservationId) {
        return this.getScheduledTasks("default-org", {
          role,
          date: date3,
          reservationId
        });
      }
      async getDemoGuestInfo(reservationId) {
        const bookingResult = await db.select().from(bookings).where(eq2(bookings.hostaway_id, reservationId)).limit(1);
        if (!bookingResult.length) return void 0;
        const booking = bookingResult[0];
        const propertyResult = await db.select().from(properties).where(eq2(properties.id, booking.propertyId)).limit(1);
        return {
          guestName: booking.guestName,
          guestEmail: booking.guestEmail,
          checkInDate: booking.checkIn,
          checkOutDate: booking.checkOut,
          property: propertyResult.length ? propertyResult[0] : null
        };
      }
      async getDemoPropertyInfo(propertyId) {
        const propertyResult = await db.select().from(properties).where(eq2(properties.id, propertyId)).limit(1);
        return propertyResult.length ? propertyResult[0] : void 0;
      }
      async getUtilityAccounts(organizationId2) {
        try {
          return await db.select({
            id: propertyUtilityAccountsNew.id,
            propertyId: propertyUtilityAccountsNew.propertyId,
            propertyName: properties.name,
            utilityType: propertyUtilityAccountsNew.utilityType,
            providerName: propertyUtilityAccountsNew.providerName,
            accountNumber: propertyUtilityAccountsNew.accountNumber,
            expectedBillDate: propertyUtilityAccountsNew.expectedBillDate,
            averageMonthlyAmount: propertyUtilityAccountsNew.averageMonthlyAmount,
            autoRemindersEnabled: propertyUtilityAccountsNew.autoRemindersEnabled,
            isActive: propertyUtilityAccountsNew.isActive
          }).from(propertyUtilityAccountsNew).leftJoin(properties, eq2(properties.id, propertyUtilityAccountsNew.propertyId)).where(eq2(propertyUtilityAccountsNew.organizationId, organizationId2));
        } catch (error) {
          console.error("Error fetching utility accounts:", error);
          return [];
        }
      }
      async createUtilityAccount(data) {
        const [account] = await db.insert(propertyUtilityAccountsNew).values(data).returning();
        return account;
      }
      async getRecurringServices(organizationId2) {
        try {
          return await db.select({
            id: recurringServiceCharges.id,
            propertyId: recurringServiceCharges.propertyId,
            propertyName: properties.name,
            serviceName: recurringServiceCharges.serviceName,
            serviceCategory: recurringServiceCharges.serviceCategory,
            monthlyRate: recurringServiceCharges.monthlyRate,
            chargeAssignment: recurringServiceCharges.chargeAssignment,
            serviceFrequency: recurringServiceCharges.serviceFrequency,
            isActive: recurringServiceCharges.isActive,
            startDate: recurringServiceCharges.startDate,
            nextChargeDate: recurringServiceCharges.nextChargeDate
          }).from(recurringServiceCharges).leftJoin(properties, eq2(properties.id, recurringServiceCharges.propertyId)).where(eq2(recurringServiceCharges.organizationId, organizationId2));
        } catch (error) {
          console.error("Error fetching recurring services:", error);
          return [];
        }
      }
      async createRecurringService(data) {
        const [service] = await db.insert(recurringServiceCharges).values(data).returning();
        return service;
      }
      async getFinancialTransactions(organizationId2) {
        try {
          return await db.select().from(financialTransactions).where(eq2(financialTransactions.organizationId, organizationId2)).orderBy(desc2(financialTransactions.createdAt));
        } catch (error) {
          console.error("Error fetching financial transactions:", error);
          return [];
        }
      }
      async createFinancialTransaction(data) {
        const [transaction] = await db.insert(financialTransactions).values(data).returning();
        return transaction;
      }
      async getOwnersForSelection(organizationId2) {
        return await db.select({
          id: users.id,
          firstName: users.firstName,
          lastName: users.lastName,
          email: users.email
        }).from(users).where(and3(
          eq2(users.organizationId, organizationId2),
          eq2(users.role, "owner")
        ));
      }
      // ===== ENHANCED MAINTENANCE TASK SYSTEM METHODS =====
      // Task Checklists
      async getTaskChecklists(organizationId2) {
        return [
          {
            id: 1,
            taskType: "cleaning",
            department: "cleaning",
            checklistName: "Standard Room Cleaning",
            checklistItems: [
              "Strip and remake beds with fresh linens",
              "Clean and disinfect all surfaces",
              "Vacuum carpets and mop floors",
              "Restock toiletries and towels",
              "Check and replace light bulbs",
              "Empty trash and replace liners",
              "Clean windows and mirrors",
              "Inspect for damages"
            ],
            isDefault: true,
            propertyId: null
          },
          {
            id: 2,
            taskType: "pool-service",
            department: "pool",
            checklistName: "Pool Maintenance",
            checklistItems: [
              "Test pH and chlorine levels",
              "Skim surface debris",
              "Brush pool walls and floor",
              "Empty skimmer baskets",
              "Clean pool equipment",
              "Check filtration system",
              "Document chemical readings"
            ],
            isDefault: true,
            propertyId: null
          },
          {
            id: 3,
            taskType: "garden",
            department: "garden",
            checklistName: "Garden Maintenance",
            checklistItems: [
              "Water plants and trees",
              "Trim overgrown vegetation",
              "Remove weeds",
              "Check irrigation system",
              "Collect fallen leaves",
              "Inspect for pest damage",
              "Fertilize as needed"
            ],
            isDefault: true,
            propertyId: null
          }
        ];
      }
      // Property Guides
      async getPropertyGuides(organizationId2) {
        return [
          {
            id: 1,
            propertyId: 1,
            guideName: "Villa Sunset Pool Maintenance Guide",
            guideContent: `Weekly Pool Service Procedure:

1. Test water chemistry (pH 7.2-7.8, Free Chlorine 1.0-3.0 ppm)
2. Skim surface and empty leaf baskets
3. Brush walls, steps, and waterline
4. Vacuum pool floor
5. Backwash filter if pressure gauge reads 8-10 psi above clean reading
6. Add chemicals as needed
7. Document all readings and actions taken

Special Notes:
- Pool heater timer set for 6am-10pm
- Waterfall feature runs on separate pump
- Emergency shut-off valve located behind pool equipment`,
            category: "Pool Service",
            department: "pool",
            attachments: ["pool_schematic.pdf", "chemical_chart.jpg"]
          },
          {
            id: 2,
            propertyId: 1,
            guideName: "Garden Irrigation System",
            guideContent: `Automated Irrigation Schedule:
- Zone 1 (Front Garden): Daily 6am, 15 minutes
- Zone 2 (Pool Area): Daily 7am, 10 minutes  
- Zone 3 (Back Garden): Daily 6pm, 20 minutes

Manual Override:
- Controller located in utility room
- Emergency shut-off at main water line
- Seasonal adjustments: Reduce 30% in rainy season

Plant Care:
- Bougainvillea: Trim monthly to maintain shape
- Palm trees: Remove dead fronds only
- Orchids: Water 2x weekly, fertilize monthly`,
            category: "Garden Care",
            department: "garden",
            attachments: ["irrigation_map.png"]
          }
        ];
      }
      // AI Task Suggestions
      async getAiTaskSuggestions(organizationId2) {
        return [
          {
            id: 1,
            propertyId: 1,
            suggestedTaskType: "pool-service",
            department: "pool",
            priority: "high",
            reason: "Guest reported cloudy water. Immediate pool service recommended.",
            status: "pending",
            suggestedDate: new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString()
          },
          {
            id: 2,
            propertyId: 2,
            suggestedTaskType: "maintenance",
            department: "maintenance",
            priority: "medium",
            reason: "Air conditioning filter due for replacement based on usage data.",
            status: "pending",
            suggestedDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3).toISOString()
          },
          {
            id: 3,
            propertyId: 1,
            suggestedTaskType: "cleaning",
            department: "cleaning",
            priority: "urgent",
            reason: "Check-in in 2 hours. Final cleaning verification needed.",
            status: "pending",
            suggestedDate: (/* @__PURE__ */ new Date()).toISOString()
          }
        ];
      }
      // Start Task
      async startTask(taskId, userId) {
        const startTime = (/* @__PURE__ */ new Date()).toISOString();
        return {
          id: taskId,
          status: "in-progress",
          startedAt: startTime,
          startedBy: userId
        };
      }
      // Complete Task
      async completeTask(taskId, completionData) {
        const completedAt = (/* @__PURE__ */ new Date()).toISOString();
        return {
          id: taskId,
          status: "completed",
          completedAt,
          completionNotes: completionData.completionNotes,
          evidencePhotos: completionData.evidencePhotos,
          issuesFound: completionData.issuesFound,
          completedBy: completionData.completedBy
        };
      }
      // Accept AI Suggestion
      async acceptAiSuggestion(suggestionId, userId) {
        const newTaskId = Math.floor(Math.random() * 1e3) + 100;
        return {
          suggestionId,
          newTaskId,
          status: "accepted",
          acceptedBy: userId,
          acceptedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
      // Export Tasks PDF
      async exportTasksPdf(organizationId2, month) {
        const exportId = `export_${month}_${Date.now()}`;
        return {
          id: exportId,
          month,
          organizationId: organizationId2,
          status: "processing",
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
      // ==================== ENHANCED FINANCE ENGINE ====================
      // Owner Balance Tracker Management
      async getOwnerBalanceTracker(organizationId2, ownerId, propertyId) {
        let query = db.select().from(ownerBalanceTracker).where(
          and3(
            eq2(ownerBalanceTracker.organizationId, organizationId2),
            eq2(ownerBalanceTracker.ownerId, ownerId)
          )
        );
        if (propertyId) {
          query = query.where(eq2(ownerBalanceTracker.propertyId, propertyId));
        }
        const [balance] = await query;
        return balance;
      }
      async updateOwnerBalanceTracker(organizationId2, ownerId, updates) {
        const [updated] = await db.update(ownerBalanceTracker).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(
          and3(
            eq2(ownerBalanceTracker.organizationId, organizationId2),
            eq2(ownerBalanceTracker.ownerId, ownerId)
          )
        ).returning();
        return updated;
      }
      async createOwnerBalanceTracker(balance) {
        const [newBalance] = await db.insert(ownerBalanceTracker).values(balance).returning();
        return newBalance;
      }
      // Payout Routing Rules Management
      async getPayoutRoutingRules(organizationId2, propertyId) {
        let query = db.select().from(payoutRoutingRules).where(eq2(payoutRoutingRules.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(payoutRoutingRules.propertyId, propertyId));
        }
        return query.where(eq2(payoutRoutingRules.isActive, true));
      }
      async createPayoutRoutingRule(rule) {
        const [newRule] = await db.insert(payoutRoutingRules).values(rule).returning();
        return newRule;
      }
      async updatePayoutRoutingRule(id, updates) {
        const [updated] = await db.update(payoutRoutingRules).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(payoutRoutingRules.id, id)).returning();
        return updated;
      }
      // Utility Bill Processing Management
      async getUtilityBillProcessing(organizationId2, filters) {
        let query = db.select().from(utilityBillProcessing).where(eq2(utilityBillProcessing.organizationId, organizationId2));
        if (filters?.utilityBillId) {
          query = query.where(eq2(utilityBillProcessing.utilityBillId, filters.utilityBillId));
        }
        if (filters?.processingStatus) {
          query = query.where(eq2(utilityBillProcessing.processingStatus, filters.processingStatus));
        }
        return query.orderBy(desc2(utilityBillProcessing.createdAt));
      }
      async createUtilityBillProcessing(processing) {
        const [newProcessing] = await db.insert(utilityBillProcessing).values(processing).returning();
        return newProcessing;
      }
      async updateUtilityBillProcessing(id, updates) {
        const [updated] = await db.update(utilityBillProcessing).set(updates).where(eq2(utilityBillProcessing.id, id)).returning();
        return updated;
      }
      // Enhanced Finance Transaction Logs
      async getEnhancedFinanceTransactionLogs(organizationId2, filters) {
        let query = db.select().from(enhancedFinanceTransactionLogs).where(eq2(enhancedFinanceTransactionLogs.organizationId, organizationId2));
        if (filters?.transactionType) {
          query = query.where(eq2(enhancedFinanceTransactionLogs.transactionType, filters.transactionType));
        }
        if (filters?.relatedTableName) {
          query = query.where(eq2(enhancedFinanceTransactionLogs.relatedTableName, filters.relatedTableName));
        }
        if (filters?.processedBy) {
          query = query.where(eq2(enhancedFinanceTransactionLogs.processedBy, filters.processedBy));
        }
        if (filters?.fromDate) {
          query = query.where(gte2(enhancedFinanceTransactionLogs.transactionDate, filters.fromDate));
        }
        if (filters?.toDate) {
          query = query.where(lte2(enhancedFinanceTransactionLogs.transactionDate, filters.toDate));
        }
        return query.orderBy(desc2(enhancedFinanceTransactionLogs.transactionDate));
      }
      async createEnhancedFinanceTransactionLog(transaction) {
        const [newTransaction] = await db.insert(enhancedFinanceTransactionLogs).values(transaction).returning();
        return newTransaction;
      }
      // Enhanced Finance Analytics
      async getOwnerFinancialSummary(organizationId2, ownerId) {
        const balance = await this.getOwnerBalanceTracker(organizationId2, ownerId);
        const recentTransactions = await this.getEnhancedFinanceTransactionLogs(organizationId2, {
          relatedTableName: "owner_payouts",
          fromDate: new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1)
          // Start of current month
        });
        const pendingPayouts = await db.select().from(ownerPayouts).where(
          and3(
            eq2(ownerPayouts.organizationId, organizationId2),
            eq2(ownerPayouts.ownerId, ownerId),
            eq2(ownerPayouts.status, "pending")
          )
        );
        const totalPendingPayouts = pendingPayouts.reduce((sum4, payout) => sum4 + parseFloat(payout.amount.toString()), 0);
        return {
          currentBalance: parseFloat(balance?.currentBalance?.toString() || "0"),
          thisMonthEarnings: parseFloat(balance?.thisMonthEarnings?.toString() || "0"),
          thisMonthExpenses: parseFloat(balance?.thisMonthExpenses?.toString() || "0"),
          netIncome: parseFloat(balance?.thisMonthEarnings?.toString() || "0") - parseFloat(balance?.thisMonthExpenses?.toString() || "0"),
          pendingPayouts: totalPendingPayouts,
          totalLifetimeEarnings: parseFloat(balance?.totalLifetimeEarnings?.toString() || "0"),
          recentTransactions
        };
      }
      async getPlatformPayoutBreakdown(organizationId2, propertyId) {
        const rules = await this.getPayoutRoutingRules(organizationId2, propertyId);
        return rules.map((rule) => ({
          platform: rule.platform,
          ownerPercentage: parseFloat(rule.ownerPercentage.toString()),
          managementPercentage: parseFloat(rule.managementPercentage.toString()),
          platformFeePercentage: parseFloat(rule.platformFeePercentage?.toString() || "0"),
          routingType: rule.routingType
        }));
      }
      // Process utility bill with enhanced routing
      async processUtilityBillWithRouting(billId, routingDecision, processedBy, notes) {
        try {
          const [bill] = await db.select().from(utilityBills).where(eq2(utilityBills.id, billId));
          if (!bill) {
            return { success: false, message: "Utility bill not found" };
          }
          const processing = await this.createUtilityBillProcessing({
            organizationId: bill.organizationId,
            utilityBillId: billId,
            processedBy,
            processingStatus: "processed",
            routingDecision,
            processingNotes: notes,
            processedAt: /* @__PURE__ */ new Date()
          });
          const transaction = await this.createEnhancedFinanceTransactionLog({
            organizationId: bill.organizationId,
            transactionType: "utility_charge",
            relatedTableId: billId,
            relatedTableName: "utility_bills",
            amount: bill.amount || "0",
            currency: bill.currency || "AUD",
            description: `Utility bill processed - ${bill.type} for property ${bill.propertyId}`,
            processedBy,
            processingNotes: `Routing: ${routingDecision}. ${notes || ""}`
          });
          return {
            success: true,
            message: "Utility bill processed successfully",
            processing,
            transaction
          };
        } catch (error) {
          return {
            success: false,
            message: `Error processing utility bill: ${error}`
          };
        }
      }
      // ==================== TASK CHECKLIST & PROOF SYSTEM ====================
      // Mock Task Checklists - Stub implementation for MVP
      async getTaskChecklists(organizationId2, filters) {
        const mockChecklists = [
          {
            id: 1,
            organizationId: organizationId2,
            taskType: "cleaning",
            checklistName: "Checkout Clean",
            checklistItems: [
              { task: "Vacuum all floors", required: true, safetyNote: "Check for small objects", tools: ["Vacuum"] },
              { task: "Clean bathrooms", required: true, safetyNote: "Use gloves", tools: ["Disinfectant", "Gloves"] },
              { task: "Change bed linens", required: true, safetyNote: "Check for damage", tools: ["Fresh linens"] }
            ],
            isDefault: true,
            propertyId: filters?.propertyId || null,
            estimatedMinutes: 120,
            safetyNotes: "Always wear gloves when handling chemicals",
            version: "1.0",
            createdBy: "system",
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          },
          {
            id: 2,
            organizationId: organizationId2,
            taskType: "pool",
            checklistName: "Pool Maintenance",
            checklistItems: [
              { task: "Test water chemistry", required: true, safetyNote: "Handle chemicals carefully", tools: ["Test strips"] },
              { task: "Skim surface debris", required: true, safetyNote: "Use proper skimmer", tools: ["Pool skimmer"] },
              { task: "Empty skimmer baskets", required: true, safetyNote: "Wear gloves", tools: ["Gloves"] }
            ],
            isDefault: true,
            propertyId: filters?.propertyId || null,
            estimatedMinutes: 60,
            safetyNotes: "Never mix different chemicals",
            version: "1.0",
            createdBy: "system",
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        ];
        return mockChecklists.filter(
          (checklist) => (!filters?.taskType || checklist.taskType === filters.taskType) && (!filters?.propertyId || checklist.propertyId === filters.propertyId || checklist.propertyId === null)
        );
      }
      async createTaskChecklist(checklist) {
        return {
          id: Math.floor(Math.random() * 1e3),
          ...checklist,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Mock Property Guides - Stub implementation for MVP
      async getPropertyGuides(organizationId2, filters) {
        const mockGuides = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: 1,
            guideName: "Pool Equipment Guide",
            taskCategory: "pool",
            instructions: "The pool has a special salt water system that requires weekly cleaning of the salt cell. Turn off power before maintenance.",
            specialEquipment: ["Salt water chlorinator", "Salt cell cleaning tool"],
            safetyWarnings: "Always turn off power before accessing electrical components",
            frequency: "weekly",
            version: "1.0",
            isActive: true,
            createdBy: "system",
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        ];
        return mockGuides.filter(
          (guide) => (!filters?.propertyId || guide.propertyId === filters.propertyId) && (!filters?.taskCategory || guide.taskCategory === filters.taskCategory)
        );
      }
      async createPropertyGuide(guide) {
        return {
          id: Math.floor(Math.random() * 1e3),
          ...guide,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Mock Task Completions - Stub implementation for MVP
      async getTaskCompletions(organizationId2, filters) {
        const mockCompletions = [
          {
            id: 1,
            organizationId: organizationId2,
            taskId: 1,
            propertyId: 1,
            completedBy: "staff@test.com",
            completionNotes: "All cleaning tasks completed successfully. Found minor issue with bathroom faucet.",
            issuesFound: ["Bathroom faucet dripping slightly"],
            expenseAmount: 25,
            expenseDescription: "Replacement faucet washer",
            proofPhotos: ["photo1.jpg", "photo2.jpg", "photo3.jpg"],
            reviewStatus: "approved",
            completedAt: (/* @__PURE__ */ new Date()).toISOString(),
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          },
          {
            id: 2,
            organizationId: organizationId2,
            taskId: 2,
            propertyId: 1,
            completedBy: "staff@test.com",
            completionNotes: "Pool maintenance completed. Chemical levels balanced.",
            issuesFound: [],
            expenseAmount: 0,
            expenseDescription: "",
            proofPhotos: ["pool1.jpg", "pool2.jpg"],
            reviewStatus: "pending",
            completedAt: (/* @__PURE__ */ new Date()).toISOString(),
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        ];
        return mockCompletions.filter(
          (completion) => (!filters?.propertyId || completion.propertyId === filters.propertyId) && (!filters?.taskId || completion.taskId === filters.taskId)
        );
      }
      // Mock Monthly Exports - Stub implementation for MVP
      async getMonthlyExports(organizationId2, filters) {
        const mockExports = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: 1,
            exportMonth: "2024-12",
            exportType: "full-report",
            fileName: "task-report-2024-12.pdf",
            fileUrl: "/exports/task-report-2024-12.pdf",
            fileSize: 2048576,
            // 2MB
            taskCount: 25,
            photoCount: 45,
            exportStatus: "completed",
            exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
            exportedBy: "admin@test.com"
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: 1,
            exportMonth: "2024-11",
            exportType: "full-report",
            fileName: "task-report-2024-11.pdf",
            fileUrl: "/exports/task-report-2024-11.pdf",
            fileSize: 1876543,
            taskCount: 22,
            photoCount: 38,
            exportStatus: "completed",
            exportedAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3).toISOString(),
            exportedBy: "admin@test.com"
          }
        ];
        return mockExports.filter(
          (exportLog) => (!filters?.propertyId || exportLog.propertyId === filters.propertyId) && (!filters?.exportMonth || exportLog.exportMonth === filters.exportMonth)
        );
      }
      async createMonthlyExport(exportData) {
        return {
          id: Math.floor(Math.random() * 1e3),
          ...exportData,
          exportStatus: "processing",
          fileName: `task-report-${exportData.exportMonth}.pdf`,
          fileUrl: `/exports/task-report-${exportData.exportMonth}.pdf`,
          fileSize: 0,
          taskCount: 0,
          photoCount: 0,
          exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
          exportedBy: exportData.exportedBy || "system"
        };
      }
      // === AI-TRIGGERED TASK SYSTEM ===
      // Enhanced AI Suggestions with Review Analysis
      async createEnhancedAiSuggestion(suggestion) {
        const [newSuggestion] = await db.insert(enhancedAiSuggestions).values(suggestion).returning();
        return newSuggestion;
      }
      async getEnhancedAiSuggestions(organizationId2, filters) {
        let query = db.select().from(enhancedAiSuggestions).where(eq2(enhancedAiSuggestions.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(enhancedAiSuggestions.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          query = query.where(eq2(enhancedAiSuggestions.status, filters.status));
        }
        if (filters?.urgencyLevel) {
          query = query.where(eq2(enhancedAiSuggestions.urgencyLevel, filters.urgencyLevel));
        }
        return await query.orderBy(desc2(enhancedAiSuggestions.createdAt));
      }
      async acceptAiSuggestion(suggestionId, reviewedBy, createdTaskId) {
        await db.update(enhancedAiSuggestions).set({
          status: "accepted",
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          createdTaskId
        }).where(eq2(enhancedAiSuggestions.id, suggestionId));
      }
      async rejectAiSuggestion(suggestionId, reviewedBy) {
        await db.update(enhancedAiSuggestions).set({
          status: "rejected",
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date()
        }).where(eq2(enhancedAiSuggestions.id, suggestionId));
      }
      // Property Timeline Management
      async createTimelineEvent(event) {
        const [newEvent] = await db.insert(propertyTimeline).values(event).returning();
        return newEvent;
      }
      async getPropertyTimeline(organizationId2, propertyId, limit = 50) {
        return await db.select().from(propertyTimeline).where(
          and3(
            eq2(propertyTimeline.organizationId, organizationId2),
            eq2(propertyTimeline.propertyId, propertyId),
            eq2(propertyTimeline.isVisible, true)
          )
        ).orderBy(desc2(propertyTimeline.createdAt)).limit(limit);
      }
      // Smart Notification System
      async createSmartNotification(notification) {
        const [newNotification] = await db.insert(smartNotifications).values(notification).returning();
        return newNotification;
      }
      async getSmartNotifications(organizationId2, recipientId) {
        return await db.select().from(smartNotifications).where(
          and3(
            eq2(smartNotifications.organizationId, organizationId2),
            eq2(smartNotifications.recipientId, recipientId)
          )
        ).orderBy(desc2(smartNotifications.createdAt));
      }
      async markNotificationRead(notificationId) {
        await db.update(smartNotifications).set({
          isRead: true,
          readAt: /* @__PURE__ */ new Date()
        }).where(eq2(smartNotifications.id, notificationId));
      }
      // Fast Action Suggestions
      async createFastActionSuggestion(suggestion) {
        const [newSuggestion] = await db.insert(fastActionSuggestions).values(suggestion).returning();
        return newSuggestion;
      }
      async getFastActionSuggestions(organizationId2, propertyId) {
        let query = db.select().from(fastActionSuggestions).where(eq2(fastActionSuggestions.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(fastActionSuggestions.propertyId, propertyId));
        }
        return await query.orderBy(desc2(fastActionSuggestions.createdAt));
      }
      async approveFastAction(actionId, approvedBy) {
        await db.update(fastActionSuggestions).set({
          status: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date()
        }).where(eq2(fastActionSuggestions.id, actionId));
      }
      async rejectFastAction(actionId, approvedBy, rejectionReason) {
        await db.update(fastActionSuggestions).set({
          status: "rejected",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          rejectionReason
        }).where(eq2(fastActionSuggestions.id, actionId));
      }
      // AI Task Processing
      async processGuestReviewFeedback(organizationId2, bookingId, reviewText) {
        const taskRules = [
          {
            keywords: ["dirty", "unclean", "not clean", "messy", "needs cleaning"],
            taskType: "cleaning",
            title: "Deep Cleaning Required",
            urgency: "high",
            estimatedCost: 150
          },
          {
            keywords: ["pool", "swim", "water dirty", "cloudy water"],
            taskType: "pool-maintenance",
            title: "Pool Maintenance & Cleaning",
            urgency: "medium",
            estimatedCost: 100
          },
          {
            keywords: ["garden", "plants", "landscaping", "overgrown"],
            taskType: "garden",
            title: "Garden Maintenance",
            urgency: "low",
            estimatedCost: 75
          },
          {
            keywords: ["broken", "not working", "repair", "fix", "maintenance"],
            taskType: "maintenance",
            title: "Repair Required",
            urgency: "high",
            estimatedCost: 200
          }
        ];
        const suggestions = [];
        const reviewLower = reviewText.toLowerCase();
        for (const rule of taskRules) {
          const matchedKeywords = rule.keywords.filter((keyword) => reviewLower.includes(keyword));
          if (matchedKeywords.length > 0) {
            const suggestion = await this.createEnhancedAiSuggestion({
              organizationId: organizationId2,
              propertyId: 1,
              // This should come from the booking
              bookingId,
              suggestionType: "review-feedback",
              sourceData: { reviewText, matchedKeywords },
              suggestedTaskType: rule.taskType,
              suggestedTitle: rule.title,
              suggestedDescription: `Guest feedback indicates: "${reviewText.substring(0, 200)}..."`,
              confidenceScore: (matchedKeywords.length / rule.keywords.length * 100).toString(),
              urgencyLevel: rule.urgency,
              estimatedCost: rule.estimatedCost.toString(),
              aiAnalysis: `Detected ${matchedKeywords.length} relevant keywords: ${matchedKeywords.join(", ")}`,
              triggerKeywords: matchedKeywords,
              notificationRouting: { roles: ["admin", "staff"], urgency: rule.urgency }
            });
            suggestions.push(suggestion);
          }
        }
        return suggestions;
      }
      // Long-stay cleaning automation
      async createLongStayCleaningTasks(organizationId2, bookingId) {
        const suggestions = await this.createEnhancedAiSuggestion({
          organizationId: organizationId2,
          propertyId: 1,
          // Should come from booking
          bookingId,
          suggestionType: "long-stay",
          sourceData: { reason: "stay_duration_6_nights_plus" },
          suggestedTaskType: "cleaning",
          suggestedTitle: "Mid-Stay Cleaning Service",
          suggestedDescription: "Automatic cleaning service for long-stay guests (6+ nights)",
          confidenceScore: "95",
          urgencyLevel: "medium",
          estimatedCost: "120",
          aiAnalysis: "Long-stay booking detected - mid-stay cleaning recommended for guest comfort",
          triggerKeywords: ["long-stay", "mid-stay-cleaning"],
          notificationRouting: { roles: ["admin", "staff"], urgency: "medium" }
        });
        return [suggestions];
      }
      // ===== OWNER BALANCE & PAYMENT SYSTEM =====
      // Owner Balance Tracker Operations
      async getOwnerBalanceByProperty(organizationId2, ownerId, propertyId) {
        const [balance] = await db.select().from(ownerBalanceTrackers).where(
          and3(
            eq2(ownerBalanceTrackers.organizationId, organizationId2),
            eq2(ownerBalanceTrackers.ownerId, ownerId),
            eq2(ownerBalanceTrackers.propertyId, propertyId)
          )
        ).orderBy(desc2(ownerBalanceTrackers.lastCalculatedAt));
        return balance || null;
      }
      async getAllOwnerBalances(organizationId2, ownerId) {
        return await db.select().from(ownerBalanceTrackers).innerJoin(properties, eq2(ownerBalanceTrackers.propertyId, properties.id)).where(
          and3(
            eq2(ownerBalanceTrackers.organizationId, organizationId2),
            eq2(ownerBalanceTrackers.ownerId, ownerId)
          )
        ).orderBy(desc2(ownerBalanceTrackers.lastCalculatedAt));
      }
      async updateOwnerBalance(balanceData) {
        const [updated] = await db.insert(ownerBalanceTrackers).values(balanceData).onConflictDoUpdate({
          target: [ownerBalanceTrackers.ownerId, ownerBalanceTrackers.propertyId],
          set: {
            totalEarnings: balanceData.totalEarnings,
            totalExpenses: balanceData.totalExpenses,
            totalCommissions: balanceData.totalCommissions,
            netBalance: balanceData.netBalance,
            lastCalculatedAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return updated;
      }
      // Owner Payout Request Operations
      async createOwnerPayoutRequest(requestData) {
        const [created] = await db.insert(ownerPayoutRequests).values(requestData).returning();
        return created;
      }
      async getOwnerPayoutRequests(organizationId2, ownerId) {
        let query = db.select().from(ownerPayoutRequests).innerJoin(properties, eq2(ownerPayoutRequests.propertyId, properties.id)).innerJoin(users, eq2(ownerPayoutRequests.ownerId, users.id)).where(eq2(ownerPayoutRequests.organizationId, organizationId2));
        if (ownerId) {
          query = query.where(eq2(ownerPayoutRequests.ownerId, ownerId));
        }
        return await query.orderBy(desc2(ownerPayoutRequests.requestedAt));
      }
      async updatePayoutRequestStatus(requestId, updates) {
        const [updated] = await db.update(ownerPayoutRequests).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerPayoutRequests.id, requestId)).returning();
        return updated;
      }
      async uploadPaymentSlip(requestId, slipUrl, paidBy) {
        const [updated] = await db.update(ownerPayoutRequests).set({
          paymentSlipUrl: slipUrl,
          paidBy,
          paidAt: /* @__PURE__ */ new Date(),
          requestStatus: "paid",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerPayoutRequests.id, requestId)).returning();
        return updated;
      }
      async confirmPaymentReceived(requestId, confirmedBy, notes) {
        const [updated] = await db.update(ownerPayoutRequests).set({
          confirmedBy,
          confirmedAt: /* @__PURE__ */ new Date(),
          confirmationNotes: notes,
          requestStatus: "confirmed",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerPayoutRequests.id, requestId)).returning();
        return updated;
      }
      // Owner Payment Log Operations
      async createPaymentLog(logData) {
        const [created] = await db.insert(ownerPaymentLogs).values(logData).returning();
        return created;
      }
      async getOwnerPaymentHistory(organizationId2, ownerId, propertyId) {
        let query = db.select().from(ownerPaymentLogs).innerJoin(users, eq2(ownerPaymentLogs.processedBy, users.id)).where(
          and3(
            eq2(ownerPaymentLogs.organizationId, organizationId2),
            eq2(ownerPaymentLogs.ownerId, ownerId)
          )
        );
        if (propertyId) {
          query = query.where(eq2(ownerPaymentLogs.propertyId, propertyId));
        }
        return await query.orderBy(desc2(ownerPaymentLogs.processedAt));
      }
      // Owner Debt Tracking Operations
      async createOwnerDebt(debtData) {
        const [created] = await db.insert(ownerDebtTrackers).values(debtData).returning();
        return created;
      }
      async getOwnerDebts(organizationId2, ownerId) {
        return await db.select().from(ownerDebtTrackers).where(
          and3(
            eq2(ownerDebtTrackers.organizationId, organizationId2),
            eq2(ownerDebtTrackers.ownerId, ownerId),
            eq2(ownerDebtTrackers.debtStatus, "outstanding")
          )
        ).orderBy(desc2(ownerDebtTrackers.createdAt));
      }
      async updateDebtPayment(debtId, paymentData) {
        const [updated] = await db.update(ownerDebtTrackers).set({
          ...paymentData,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerDebtTrackers.id, debtId)).returning();
        return updated;
      }
      // Property Payout Settings Operations
      async getPropertyPayoutSettings(organizationId2, propertyId) {
        const [settings] = await db.select().from(propertyPayoutSettings).where(
          and3(
            eq2(propertyPayoutSettings.organizationId, organizationId2),
            eq2(propertyPayoutSettings.propertyId, propertyId)
          )
        );
        return settings;
      }
      async updatePropertyPayoutSettings(settingsData) {
        const [updated] = await db.insert(propertyPayoutSettings).values(settingsData).onConflictDoUpdate({
          target: [propertyPayoutSettings.propertyId],
          set: {
            ...settingsData,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return updated;
      }
      // Balance Calculation Helper
      async calculateOwnerBalance(organizationId2, ownerId, propertyId, period) {
        const bookings3 = await db.select().from(bookings3).where(
          and3(
            eq2(bookings3.organizationId, organizationId2),
            eq2(bookings3.propertyId, propertyId),
            eq2(bookings3.status, "completed"),
            sql3`${bookings3.checkOut} BETWEEN ${period.start} AND ${period.end}`
          )
        );
        const totalEarnings = bookings3.reduce((sum4, booking) => sum4 + parseFloat(booking.totalAmount || "0"), 0);
        const expenses = await db.select().from(finances).where(
          and3(
            eq2(finances.organizationId, organizationId2),
            eq2(finances.propertyId, propertyId),
            eq2(finances.type, "expense"),
            sql3`${finances.date} BETWEEN ${period.start} AND ${period.end}`
          )
        );
        const totalExpenses = expenses.reduce((sum4, expense) => sum4 + parseFloat(expense.amount || "0"), 0);
        const totalCommissions = totalEarnings * 0.2;
        const netBalance = totalEarnings - totalExpenses - totalCommissions;
        return {
          totalEarnings: totalEarnings.toFixed(2),
          totalExpenses: totalExpenses.toFixed(2),
          totalCommissions: totalCommissions.toFixed(2),
          netBalance: netBalance.toFixed(2)
        };
      }
      // ==================== ENHANCED UTILITY TRACKER ====================
      async getUtilityAccounts(organizationId2) {
        const accounts = await db.select().from(propertyUtilityAccounts).where(eq2(propertyUtilityAccounts.organizationId, organizationId2));
        return accounts;
      }
      async createUtilityAccount(accountData) {
        const [account] = await db.insert(propertyUtilityAccounts).values(accountData).returning();
        return account;
      }
      async getUtilityBills(organizationId2, filters = {}) {
        let query = db.select().from(utilityBills).where(eq2(utilityBills.organizationId, organizationId2));
        if (filters.propertyId) {
          query = query.where(eq2(utilityBills.propertyId, filters.propertyId));
        }
        if (filters.status) {
          query = query.where(eq2(utilityBills.status, filters.status));
        }
        if (filters.utilityType) {
          query = query.where(eq2(utilityBills.type, filters.utilityType));
        }
        const bills = await query.orderBy(desc2(utilityBills.createdAt));
        return bills;
      }
      async createUtilityBill(billData) {
        const [bill] = await db.insert(utilityBills).values(billData).returning();
        return bill;
      }
      async confirmUtilityBillPayment(billId, paymentData) {
        const [updated] = await db.update(utilityBills).set({
          ...paymentData,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(utilityBills.id, billId)).returning();
        return updated;
      }
      async getUtilityReminders(organizationId2) {
        const reminders = await db.select().from(utilityBillReminders).where(eq2(utilityBillReminders.organizationId, organizationId2)).orderBy(desc2(utilityBillReminders.createdAt));
        return reminders;
      }
      async getUtilityStats(organizationId2) {
        const totalBillsResult = await db.select({ count: count() }).from(utilityBills).where(eq2(utilityBills.organizationId, organizationId2));
        const pendingBillsResult = await db.select({ count: count() }).from(utilityBills).where(
          and3(
            eq2(utilityBills.organizationId, organizationId2),
            eq2(utilityBills.status, "pending")
          )
        );
        const overdueBillsResult = await db.select({ count: count() }).from(utilityBills).where(
          and3(
            eq2(utilityBills.organizationId, organizationId2),
            eq2(utilityBills.status, "overdue")
          )
        );
        const currentMonth = (/* @__PURE__ */ new Date()).toISOString().slice(0, 7);
        const monthlyTotalResult = await db.select({ total: sum(utilityBills.amount) }).from(utilityBills).where(
          and3(
            eq2(utilityBills.organizationId, organizationId2),
            eq2(utilityBills.billingMonth, currentMonth)
          )
        );
        return {
          totalBills: totalBillsResult[0]?.count || 0,
          pendingBills: pendingBillsResult[0]?.count || 0,
          overdueBills: overdueBillsResult[0]?.count || 0,
          monthlyTotal: parseFloat(monthlyTotalResult[0]?.total || "0")
        };
      }
      // ==================== MEDIA LIBRARY & AGENT SHARING TOOLS ====================
      async getPropertyMediaFiles(organizationId2, propertyId) {
        let query = db.select().from(propertyMediaFiles).where(eq2(propertyMediaFiles.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(propertyMediaFiles.propertyId, propertyId));
        }
        const files = await query.orderBy(desc2(propertyMediaFiles.createdAt));
        return files;
      }
      async createPropertyMediaFile(fileData) {
        const [file] = await db.insert(propertyMediaFiles).values(fileData).returning();
        return file;
      }
      async updatePropertyMediaFile(fileId, updateData) {
        const [updated] = await db.update(propertyMediaFiles).set({
          ...updateData,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(propertyMediaFiles.id, fileId)).returning();
        return updated;
      }
      async deletePropertyMediaFile(fileId) {
        const result = await db.delete(propertyMediaFiles).where(eq2(propertyMediaFiles.id, fileId));
        return result.rowCount > 0;
      }
      async getAgentAccessibleMedia(organizationId2, agentId, agentRole) {
        const accessConditions = agentRole === "referral-agent" ? or(
          eq2(propertyMediaFiles.isAgentApproved, true),
          eq2(propertyMediaFiles.isUnbranded, true)
        ) : eq2(propertyMediaFiles.accessLevel, "agent_approved");
        const files = await db.select().from(propertyMediaFiles).where(
          and3(
            eq2(propertyMediaFiles.organizationId, organizationId2),
            eq2(propertyMediaFiles.isActive, true),
            accessConditions
          )
        ).orderBy(desc2(propertyMediaFiles.createdAt));
        return files;
      }
      async logAgentMediaAccess(accessData) {
        const [accessLog] = await db.insert(agentMediaAccess).values(accessData).returning();
        return accessLog;
      }
      async getAgentMediaAccessLogs(organizationId2, mediaFileId) {
        let query = db.select().from(agentMediaAccess).where(eq2(agentMediaAccess.organizationId, organizationId2));
        if (mediaFileId) {
          query = query.where(eq2(agentMediaAccess.mediaFileId, mediaFileId));
        }
        const logs = await query.orderBy(desc2(agentMediaAccess.createdAt));
        return logs;
      }
      async getMediaFolders(organizationId2, propertyId) {
        let query = db.select().from(mediaFolders).where(eq2(mediaFolders.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(mediaFolders.propertyId, propertyId));
        }
        const folders = await query.orderBy(asc(mediaFolders.sortOrder));
        return folders;
      }
      async createMediaFolder(folderData) {
        const [folder] = await db.insert(mediaFolders).values(folderData).returning();
        return folder;
      }
      async updateMediaFolder(folderId, updateData) {
        const [updated] = await db.update(mediaFolders).set({
          ...updateData,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(mediaFolders.id, folderId)).returning();
        return updated;
      }
      async getPropertyMediaSettings(organizationId2, propertyId) {
        const [settings] = await db.select().from(propertyMediaSettings).where(
          and3(
            eq2(propertyMediaSettings.organizationId, organizationId2),
            eq2(propertyMediaSettings.propertyId, propertyId)
          )
        );
        if (!settings) {
          return {
            allowOwnerUploads: true,
            requireAdminApproval: true,
            maxFileSize: "50MB",
            allowedFormats: ["jpg", "jpeg", "png", "mp4", "pdf"],
            allowReferralAgentAccess: true,
            allowRetailAgentAccess: false,
            autoApproveUnbranded: false,
            enableAiSuggestions: true,
            autoDetectMissingMedia: true,
            autoFlagOutdated: true,
            notifyOnNewUploads: true,
            notifyOnAgentAccess: false,
            notifyOnExpiry: true
          };
        }
        return settings;
      }
      async updatePropertyMediaSettings(organizationId2, propertyId, settingsData) {
        const existing = await db.select().from(propertyMediaSettings).where(
          and3(
            eq2(propertyMediaSettings.organizationId, organizationId2),
            eq2(propertyMediaSettings.propertyId, propertyId)
          )
        );
        if (existing.length === 0) {
          const [created] = await db.insert(propertyMediaSettings).values({
            organizationId: organizationId2,
            propertyId,
            ...settingsData
          }).returning();
          return created;
        } else {
          const [updated] = await db.update(propertyMediaSettings).set({
            ...settingsData,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(
            and3(
              eq2(propertyMediaSettings.organizationId, organizationId2),
              eq2(propertyMediaSettings.propertyId, propertyId)
            )
          ).returning();
          return updated;
        }
      }
      async getMediaUsageAnalytics(organizationId2, propertyId) {
        let query = db.select().from(mediaUsageAnalytics).where(eq2(mediaUsageAnalytics.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(mediaUsageAnalytics.propertyId, propertyId));
        }
        const analytics = await query.orderBy(desc2(mediaUsageAnalytics.popularityScore));
        return analytics;
      }
      async updateMediaUsageAnalytics(mediaFileId, usageType) {
        let [analytics] = await db.select().from(mediaUsageAnalytics).where(eq2(mediaUsageAnalytics.mediaFileId, mediaFileId));
        if (!analytics) {
          const mediaFile = await db.select().from(propertyMediaFiles).where(eq2(propertyMediaFiles.id, mediaFileId)).limit(1);
          if (mediaFile.length === 0) return null;
          [analytics] = await db.insert(mediaUsageAnalytics).values({
            organizationId: mediaFile[0].organizationId,
            propertyId: mediaFile[0].propertyId,
            mediaFileId,
            viewCount: usageType === "view" ? 1 : 0,
            downloadCount: usageType === "download" ? 1 : 0,
            shareCount: usageType === "share" ? 1 : 0,
            lastAccessed: /* @__PURE__ */ new Date(),
            weeklyViews: usageType === "view" ? 1 : 0,
            monthlyViews: usageType === "view" ? 1 : 0
          }).returning();
        } else {
          const updates = {
            lastAccessed: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          };
          if (usageType === "view") {
            updates.viewCount = analytics.viewCount + 1;
            updates.weeklyViews = analytics.weeklyViews + 1;
            updates.monthlyViews = analytics.monthlyViews + 1;
          } else if (usageType === "download") {
            updates.downloadCount = analytics.downloadCount + 1;
          } else if (usageType === "share") {
            updates.shareCount = analytics.shareCount + 1;
          }
          [analytics] = await db.update(mediaUsageAnalytics).set(updates).where(eq2(mediaUsageAnalytics.mediaFileId, mediaFileId)).returning();
        }
        return analytics;
      }
      async getAiMediaSuggestions(organizationId2, propertyId) {
        let query = db.select().from(aiMediaSuggestions).where(eq2(aiMediaSuggestions.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(aiMediaSuggestions.propertyId, propertyId));
        }
        const suggestions = await query.where(eq2(aiMediaSuggestions.status, "pending")).orderBy(desc2(aiMediaSuggestions.priority), desc2(aiMediaSuggestions.confidenceScore));
        return suggestions;
      }
      async createAiMediaSuggestion(suggestionData) {
        const [suggestion] = await db.insert(aiMediaSuggestions).values(suggestionData).returning();
        return suggestion;
      }
      async updateAiMediaSuggestion(suggestionId, updateData) {
        const [updated] = await db.update(aiMediaSuggestions).set({
          ...updateData,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(aiMediaSuggestions.id, suggestionId)).returning();
        return updated;
      }
      async getMediaLibraryStats(organizationId2) {
        const totalFilesResult = await db.select({ count: count() }).from(propertyMediaFiles).where(eq2(propertyMediaFiles.organizationId, organizationId2));
        const agentApprovedResult = await db.select({ count: count() }).from(propertyMediaFiles).where(
          and3(
            eq2(propertyMediaFiles.organizationId, organizationId2),
            eq2(propertyMediaFiles.isActive, true),
            eq2(propertyMediaFiles.isAgentApproved, true)
          )
        );
        const pendingApprovalResult = await db.select({ count: count() }).from(propertyMediaFiles).where(
          and3(
            eq2(propertyMediaFiles.organizationId, organizationId2),
            eq2(propertyMediaFiles.isActive, true),
            eq2(propertyMediaFiles.accessLevel, "private"),
            isNull2(propertyMediaFiles.approvedBy)
          )
        );
        const totalViewsResult = await db.select({ total: sum(mediaUsageAnalytics.viewCount) }).from(mediaUsageAnalytics).where(eq2(mediaUsageAnalytics.organizationId, organizationId2));
        return {
          totalFiles: totalFilesResult[0]?.count || 0,
          agentApproved: agentApprovedResult[0]?.count || 0,
          pendingApproval: pendingApprovalResult[0]?.count || 0,
          totalViews: parseInt(totalViewsResult[0]?.total || "0")
        };
      }
      // ==================== PLATFORM-BASED REVENUE ROUTING RULES ====================
      // Platform Routing Rules Operations
      async getPlatformRoutingRules(organizationId2) {
        return db.select().from(platformRoutingRules).where(eq2(platformRoutingRules.organizationId, organizationId2)).orderBy(platformRoutingRules.platformDisplayName);
      }
      async getPlatformRoutingRule(id) {
        const [rule] = await db.select().from(platformRoutingRules).where(eq2(platformRoutingRules.id, id));
        return rule;
      }
      async createPlatformRoutingRule(rule) {
        const [newRule] = await db.insert(platformRoutingRules).values(rule).returning();
        return newRule;
      }
      async updatePlatformRoutingRule(id, updates) {
        const [updated] = await db.update(platformRoutingRules).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(platformRoutingRules.id, id)).returning();
        return updated;
      }
      async deletePlatformRoutingRule(id) {
        const result = await db.delete(platformRoutingRules).where(eq2(platformRoutingRules.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Property Platform Rules Operations
      async getPropertyPlatformRules(organizationId2, filters) {
        let query = db.select({
          id: propertyPlatformRules.id,
          organizationId: propertyPlatformRules.organizationId,
          propertyId: propertyPlatformRules.propertyId,
          platformRuleId: propertyPlatformRules.platformRuleId,
          overrideOwnerPercentage: propertyPlatformRules.overrideOwnerPercentage,
          overrideManagementPercentage: propertyPlatformRules.overrideManagementPercentage,
          overrideRoutingType: propertyPlatformRules.overrideRoutingType,
          isActive: propertyPlatformRules.isActive,
          specialInstructions: propertyPlatformRules.specialInstructions,
          setBy: propertyPlatformRules.setBy,
          createdAt: propertyPlatformRules.createdAt,
          updatedAt: propertyPlatformRules.updatedAt,
          // Platform rule details
          platformDisplayName: platformRoutingRules.platformDisplayName,
          defaultOwnerPercentage: platformRoutingRules.defaultOwnerPercentage,
          defaultManagementPercentage: platformRoutingRules.defaultManagementPercentage,
          routingType: platformRoutingRules.routingType,
          // Property details
          propertyName: properties.name
        }).from(propertyPlatformRules).leftJoin(platformRoutingRules, eq2(propertyPlatformRules.platformRuleId, platformRoutingRules.id)).leftJoin(properties, eq2(propertyPlatformRules.propertyId, properties.id)).where(eq2(propertyPlatformRules.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(propertyPlatformRules.propertyId, filters.propertyId));
        }
        if (filters?.platformRuleId) {
          query = query.where(eq2(propertyPlatformRules.platformRuleId, filters.platformRuleId));
        }
        return query.orderBy(properties.name, platformRoutingRules.platformDisplayName);
      }
      async getPropertyPlatformRule(id) {
        const [rule] = await db.select().from(propertyPlatformRules).where(eq2(propertyPlatformRules.id, id));
        return rule;
      }
      async createPropertyPlatformRule(rule) {
        const [newRule] = await db.insert(propertyPlatformRules).values(rule).returning();
        return newRule;
      }
      async updatePropertyPlatformRule(id, updates) {
        const [updated] = await db.update(propertyPlatformRules).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyPlatformRules.id, id)).returning();
        return updated;
      }
      async deletePropertyPlatformRule(id) {
        const result = await db.delete(propertyPlatformRules).where(eq2(propertyPlatformRules.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Booking Platform Routing Operations
      async getBookingPlatformRouting(organizationId2, filters) {
        let query = db.select({
          id: bookingPlatformRouting.id,
          organizationId: bookingPlatformRouting.organizationId,
          bookingId: bookingPlatformRouting.bookingId,
          platformRuleId: bookingPlatformRouting.platformRuleId,
          actualOwnerPercentage: bookingPlatformRouting.actualOwnerPercentage,
          actualManagementPercentage: bookingPlatformRouting.actualManagementPercentage,
          actualRoutingType: bookingPlatformRouting.actualRoutingType,
          totalBookingAmount: bookingPlatformRouting.totalBookingAmount,
          ownerAmount: bookingPlatformRouting.ownerAmount,
          managementAmount: bookingPlatformRouting.managementAmount,
          platformFeeAmount: bookingPlatformRouting.platformFeeAmount,
          overrideReason: bookingPlatformRouting.overrideReason,
          isOverride: bookingPlatformRouting.isOverride,
          routingStatus: bookingPlatformRouting.routingStatus,
          processedAt: bookingPlatformRouting.processedAt,
          processedBy: bookingPlatformRouting.processedBy,
          createdBy: bookingPlatformRouting.createdBy,
          createdAt: bookingPlatformRouting.createdAt,
          updatedAt: bookingPlatformRouting.updatedAt,
          // Platform rule details
          platformDisplayName: platformRoutingRules.platformDisplayName,
          // Booking details
          guestName: bookings.guestName,
          propertyName: properties.name
        }).from(bookingPlatformRouting).leftJoin(platformRoutingRules, eq2(bookingPlatformRouting.platformRuleId, platformRoutingRules.id)).leftJoin(bookings, eq2(bookingPlatformRouting.bookingId, bookings.id)).leftJoin(properties, eq2(bookings.propertyId, properties.id)).where(eq2(bookingPlatformRouting.organizationId, organizationId2));
        if (filters?.bookingId) {
          query = query.where(eq2(bookingPlatformRouting.bookingId, filters.bookingId));
        }
        if (filters?.platformRuleId) {
          query = query.where(eq2(bookingPlatformRouting.platformRuleId, filters.platformRuleId));
        }
        if (filters?.routingStatus) {
          query = query.where(eq2(bookingPlatformRouting.routingStatus, filters.routingStatus));
        }
        return query.orderBy(desc2(bookingPlatformRouting.createdAt));
      }
      async getBookingPlatformRoutingById(id) {
        const [routing] = await db.select().from(bookingPlatformRouting).where(eq2(bookingPlatformRouting.id, id));
        return routing;
      }
      async createBookingPlatformRouting(routing) {
        const [newRouting] = await db.insert(bookingPlatformRouting).values(routing).returning();
        return newRouting;
      }
      async updateBookingPlatformRouting(id, updates) {
        const [updated] = await db.update(bookingPlatformRouting).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(bookingPlatformRouting.id, id)).returning();
        return updated;
      }
      async processBookingRouting(id, processedBy) {
        const [updated] = await db.update(bookingPlatformRouting).set({
          routingStatus: "processed",
          processedAt: /* @__PURE__ */ new Date(),
          processedBy,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(bookingPlatformRouting.id, id)).returning();
        return updated;
      }
      // Routing Audit Log Operations
      async getRoutingAuditLogs(organizationId2, filters) {
        let query = db.select().from(routingAuditLog).where(eq2(routingAuditLog.organizationId, organizationId2));
        if (filters?.relatedType) {
          query = query.where(eq2(routingAuditLog.relatedType, filters.relatedType));
        }
        if (filters?.relatedId) {
          query = query.where(eq2(routingAuditLog.relatedId, filters.relatedId));
        }
        if (filters?.actionType) {
          query = query.where(eq2(routingAuditLog.actionType, filters.actionType));
        }
        if (filters?.performedBy) {
          query = query.where(eq2(routingAuditLog.performedBy, filters.performedBy));
        }
        if (filters?.fromDate) {
          query = query.where(gte2(routingAuditLog.performedAt, filters.fromDate));
        }
        if (filters?.toDate) {
          query = query.where(lte2(routingAuditLog.performedAt, filters.toDate));
        }
        return query.orderBy(desc2(routingAuditLog.performedAt));
      }
      async createRoutingAuditLog(log2) {
        const [newLog] = await db.insert(routingAuditLog).values(log2).returning();
        return newLog;
      }
      // Utility methods for routing calculations
      async calculateBookingRouting(bookingId, platformRuleId, totalAmount, overrides) {
        const platformRule = await this.getPlatformRoutingRule(platformRuleId);
        if (!platformRule) {
          throw new Error("Platform rule not found");
        }
        const booking = await this.getBooking(bookingId);
        if (!booking) {
          throw new Error("Booking not found");
        }
        const propertyRules = await this.getPropertyPlatformRules(booking.organizationId, {
          propertyId: booking.propertyId,
          platformRuleId
        });
        const propertyRule = propertyRules.length > 0 ? propertyRules[0] : null;
        let ownerPercentage = parseFloat(platformRule.defaultOwnerPercentage);
        let managementPercentage = parseFloat(platformRule.defaultManagementPercentage);
        let routingType = platformRule.routingType;
        if (propertyRule) {
          if (propertyRule.overrideOwnerPercentage) {
            ownerPercentage = parseFloat(propertyRule.overrideOwnerPercentage);
          }
          if (propertyRule.overrideManagementPercentage) {
            managementPercentage = parseFloat(propertyRule.overrideManagementPercentage);
          }
          if (propertyRule.overrideRoutingType) {
            routingType = propertyRule.overrideRoutingType;
          }
        }
        if (overrides) {
          if (overrides.ownerPercentage !== void 0) {
            ownerPercentage = overrides.ownerPercentage;
          }
          if (overrides.managementPercentage !== void 0) {
            managementPercentage = overrides.managementPercentage;
          }
          if (overrides.routingType) {
            routingType = overrides.routingType;
          }
        }
        const platformFeePercentage = parseFloat(platformRule.platformFeePercentage || "0");
        const platformFeeAmount = totalAmount * (platformFeePercentage / 100);
        const netAmount = totalAmount - platformFeeAmount;
        const ownerAmount = netAmount * (ownerPercentage / 100);
        const managementAmount = netAmount * (managementPercentage / 100);
        return {
          ownerAmount: Math.round(ownerAmount * 100) / 100,
          managementAmount: Math.round(managementAmount * 100) / 100,
          platformFeeAmount: Math.round(platformFeeAmount * 100) / 100,
          ownerPercentage,
          managementPercentage,
          routingType
        };
      }
      async getRoutingRulesForProperty(propertyId) {
        return db.select({
          platformRuleId: platformRoutingRules.id,
          platformName: platformRoutingRules.platformName,
          platformDisplayName: platformRoutingRules.platformDisplayName,
          defaultOwnerPercentage: platformRoutingRules.defaultOwnerPercentage,
          defaultManagementPercentage: platformRoutingRules.defaultManagementPercentage,
          routingType: platformRoutingRules.routingType,
          // Property override details
          hasOverride: sql3`CASE WHEN ${propertyPlatformRules.id} IS NOT NULL THEN true ELSE false END`,
          overrideOwnerPercentage: propertyPlatformRules.overrideOwnerPercentage,
          overrideManagementPercentage: propertyPlatformRules.overrideManagementPercentage,
          overrideRoutingType: propertyPlatformRules.overrideRoutingType,
          specialInstructions: propertyPlatformRules.specialInstructions
        }).from(platformRoutingRules).leftJoin(
          propertyPlatformRules,
          and3(
            eq2(propertyPlatformRules.platformRuleId, platformRoutingRules.id),
            eq2(propertyPlatformRules.propertyId, propertyId)
          )
        ).where(eq2(platformRoutingRules.isActive, true)).orderBy(platformRoutingRules.platformDisplayName);
      }
      // ===== INVENTORY & WELCOME PACK TRACKER METHODS =====
      // Inventory Categories
      async getInventoryCategories(organizationId2) {
        return db.select().from(inventoryCategories).where(
          and3(
            eq2(inventoryCategories.organizationId, organizationId2),
            eq2(inventoryCategories.isActive, true)
          )
        ).orderBy(inventoryCategories.sortOrder, inventoryCategories.categoryName);
      }
      async createInventoryCategory(data) {
        const [category] = await db.insert(inventoryCategories).values(data).returning();
        return category;
      }
      async updateInventoryCategory(id, data) {
        const [category] = await db.update(inventoryCategories).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(inventoryCategories.id, id)).returning();
        return category;
      }
      async deleteInventoryCategory(id) {
        const result = await db.update(inventoryCategories).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(inventoryCategories.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Inventory Items
      async getInventoryItems(organizationId2, filters) {
        let query = db.select({
          id: inventoryItems.id,
          organizationId: inventoryItems.organizationId,
          categoryId: inventoryItems.categoryId,
          itemName: inventoryItems.itemName,
          description: inventoryItems.description,
          unitType: inventoryItems.unitType,
          defaultQuantityPerBedroom: inventoryItems.defaultQuantityPerBedroom,
          costPerUnit: inventoryItems.costPerUnit,
          isActive: inventoryItems.isActive,
          sortOrder: inventoryItems.sortOrder,
          createdAt: inventoryItems.createdAt,
          updatedAt: inventoryItems.updatedAt,
          categoryName: inventoryCategories.categoryName,
          currentStock: inventoryStockLevels.currentStock,
          minimumStock: inventoryStockLevels.minimumStock,
          isLowStock: inventoryStockLevels.isLowStock
        }).from(inventoryItems).leftJoin(inventoryCategories, eq2(inventoryItems.categoryId, inventoryCategories.id)).leftJoin(inventoryStockLevels, eq2(inventoryItems.id, inventoryStockLevels.inventoryItemId)).where(eq2(inventoryItems.organizationId, organizationId2));
        if (filters?.categoryId) {
          query = query.where(eq2(inventoryItems.categoryId, filters.categoryId));
        }
        if (filters?.isActive !== void 0) {
          query = query.where(eq2(inventoryItems.isActive, filters.isActive));
        }
        return query.orderBy(inventoryCategories.sortOrder, inventoryItems.sortOrder, inventoryItems.itemName);
      }
      async createInventoryItem(data) {
        const [item] = await db.insert(inventoryItems).values(data).returning();
        return item;
      }
      async updateInventoryItem(id, data) {
        const [item] = await db.update(inventoryItems).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(inventoryItems.id, id)).returning();
        return item;
      }
      async deleteInventoryItem(id) {
        const result = await db.update(inventoryItems).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(inventoryItems.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Property Welcome Pack Configs
      async getPropertyWelcomePackConfig(organizationId2, propertyId) {
        const [config] = await db.select().from(propertyWelcomePackConfigs).where(
          and3(
            eq2(propertyWelcomePackConfigs.organizationId, organizationId2),
            eq2(propertyWelcomePackConfigs.propertyId, propertyId),
            eq2(propertyWelcomePackConfigs.isActive, true)
          )
        );
        return config;
      }
      async createPropertyWelcomePackConfig(data) {
        const [config] = await db.insert(propertyWelcomePackConfigs).values(data).returning();
        return config;
      }
      async updatePropertyWelcomePackConfig(id, data) {
        const [config] = await db.update(propertyWelcomePackConfigs).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyWelcomePackConfigs.id, id)).returning();
        return config;
      }
      // Inventory Usage Logs
      async getInventoryUsageLogs(organizationId2, filters) {
        let query = db.select({
          id: inventoryUsageLogs.id,
          organizationId: inventoryUsageLogs.organizationId,
          propertyId: inventoryUsageLogs.propertyId,
          taskId: inventoryUsageLogs.taskId,
          bookingId: inventoryUsageLogs.bookingId,
          guestCount: inventoryUsageLogs.guestCount,
          stayNights: inventoryUsageLogs.stayNights,
          checkoutDate: inventoryUsageLogs.checkoutDate,
          totalPackCost: inventoryUsageLogs.totalPackCost,
          billingRule: inventoryUsageLogs.billingRule,
          billingReason: inventoryUsageLogs.billingReason,
          staffMemberId: inventoryUsageLogs.staffMemberId,
          isProcessed: inventoryUsageLogs.isProcessed,
          processedBy: inventoryUsageLogs.processedBy,
          processedAt: inventoryUsageLogs.processedAt,
          notes: inventoryUsageLogs.notes,
          createdAt: inventoryUsageLogs.createdAt,
          propertyName: properties.name,
          staffFirstName: users.firstName,
          staffLastName: users.lastName
        }).from(inventoryUsageLogs).leftJoin(properties, eq2(inventoryUsageLogs.propertyId, properties.id)).leftJoin(users, eq2(inventoryUsageLogs.staffMemberId, users.id)).where(eq2(inventoryUsageLogs.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(inventoryUsageLogs.propertyId, filters.propertyId));
        }
        if (filters?.staffMemberId) {
          query = query.where(eq2(inventoryUsageLogs.staffMemberId, filters.staffMemberId));
        }
        if (filters?.billingRule) {
          query = query.where(eq2(inventoryUsageLogs.billingRule, filters.billingRule));
        }
        if (filters?.isProcessed !== void 0) {
          query = query.where(eq2(inventoryUsageLogs.isProcessed, filters.isProcessed));
        }
        if (filters?.startDate) {
          query = query.where(gte2(inventoryUsageLogs.checkoutDate, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(inventoryUsageLogs.checkoutDate, new Date(filters.endDate)));
        }
        return query.orderBy(desc2(inventoryUsageLogs.checkoutDate));
      }
      async getInventoryUsageLog(id) {
        const [log2] = await db.select({
          id: inventoryUsageLogs.id,
          organizationId: inventoryUsageLogs.organizationId,
          propertyId: inventoryUsageLogs.propertyId,
          taskId: inventoryUsageLogs.taskId,
          bookingId: inventoryUsageLogs.bookingId,
          guestCount: inventoryUsageLogs.guestCount,
          stayNights: inventoryUsageLogs.stayNights,
          checkoutDate: inventoryUsageLogs.checkoutDate,
          totalPackCost: inventoryUsageLogs.totalPackCost,
          billingRule: inventoryUsageLogs.billingRule,
          billingReason: inventoryUsageLogs.billingReason,
          staffMemberId: inventoryUsageLogs.staffMemberId,
          isProcessed: inventoryUsageLogs.isProcessed,
          processedBy: inventoryUsageLogs.processedBy,
          processedAt: inventoryUsageLogs.processedAt,
          notes: inventoryUsageLogs.notes,
          createdAt: inventoryUsageLogs.createdAt,
          propertyName: properties.name,
          staffFirstName: users.firstName,
          staffLastName: users.lastName
        }).from(inventoryUsageLogs).leftJoin(properties, eq2(inventoryUsageLogs.propertyId, properties.id)).leftJoin(users, eq2(inventoryUsageLogs.staffMemberId, users.id)).where(eq2(inventoryUsageLogs.id, id));
        return log2;
      }
      async createInventoryUsageLog(data) {
        const [log2] = await db.insert(inventoryUsageLogs).values(data).returning();
        return log2;
      }
      async updateInventoryUsageLog(id, data) {
        const [log2] = await db.update(inventoryUsageLogs).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(inventoryUsageLogs.id, id)).returning();
        return log2;
      }
      async processInventoryUsageLog(id, processedBy) {
        const [log2] = await db.update(inventoryUsageLogs).set({
          isProcessed: true,
          processedBy,
          processedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(inventoryUsageLogs.id, id)).returning();
        return log2;
      }
      // Inventory Usage Items
      async getInventoryUsageItems(usageLogId) {
        return db.select({
          id: inventoryUsageItems.id,
          usageLogId: inventoryUsageItems.usageLogId,
          inventoryItemId: inventoryUsageItems.inventoryItemId,
          quantityUsed: inventoryUsageItems.quantityUsed,
          unitCost: inventoryUsageItems.unitCost,
          totalCost: inventoryUsageItems.totalCost,
          notes: inventoryUsageItems.notes,
          createdAt: inventoryUsageItems.createdAt,
          itemName: inventoryItems.itemName,
          unitType: inventoryItems.unitType,
          categoryName: inventoryCategories.categoryName
        }).from(inventoryUsageItems).leftJoin(inventoryItems, eq2(inventoryUsageItems.inventoryItemId, inventoryItems.id)).leftJoin(inventoryCategories, eq2(inventoryItems.categoryId, inventoryCategories.id)).where(eq2(inventoryUsageItems.usageLogId, usageLogId)).orderBy(inventoryCategories.sortOrder, inventoryItems.sortOrder);
      }
      async createInventoryUsageItems(items) {
        if (items.length === 0) return [];
        const result = await db.insert(inventoryUsageItems).values(items).returning();
        return result;
      }
      async deleteInventoryUsageItems(usageLogId) {
        const result = await db.delete(inventoryUsageItems).where(eq2(inventoryUsageItems.usageLogId, usageLogId));
        return (result.rowCount || 0) > 0;
      }
      // Stock Level Management
      async getInventoryStockLevels(organizationId2, filters) {
        let query = db.select({
          id: inventoryStockLevels.id,
          inventoryItemId: inventoryStockLevels.inventoryItemId,
          currentStock: inventoryStockLevels.currentStock,
          minimumStock: inventoryStockLevels.minimumStock,
          maxStock: inventoryStockLevels.maxStock,
          lastRestockDate: inventoryStockLevels.lastRestockDate,
          lastRestockQuantity: inventoryStockLevels.lastRestockQuantity,
          isLowStock: inventoryStockLevels.isLowStock,
          createdAt: inventoryStockLevels.createdAt,
          updatedAt: inventoryStockLevels.updatedAt,
          itemName: inventoryItems.itemName,
          unitType: inventoryItems.unitType,
          categoryName: inventoryCategories.categoryName
        }).from(inventoryStockLevels).leftJoin(inventoryItems, eq2(inventoryStockLevels.inventoryItemId, inventoryItems.id)).leftJoin(inventoryCategories, eq2(inventoryItems.categoryId, inventoryCategories.id)).where(eq2(inventoryStockLevels.organizationId, organizationId2));
        if (filters?.isLowStock !== void 0) {
          query = query.where(eq2(inventoryStockLevels.isLowStock, filters.isLowStock));
        }
        if (filters?.inventoryItemId) {
          query = query.where(eq2(inventoryStockLevels.inventoryItemId, filters.inventoryItemId));
        }
        return query.orderBy(inventoryCategories.sortOrder, inventoryItems.itemName);
      }
      async updateInventoryStockLevel(inventoryItemId, data) {
        const [stockLevel] = await db.insert(inventoryStockLevels).values({
          inventoryItemId,
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }).onConflictDoUpdate({
          target: inventoryStockLevels.inventoryItemId,
          set: {
            ...data,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return stockLevel;
      }
      // Welcome Pack Billing Summaries
      async getWelcomePackBillingSummaries(organizationId2, filters) {
        let query = db.select({
          id: welcomePackBillingSummaries.id,
          organizationId: welcomePackBillingSummaries.organizationId,
          propertyId: welcomePackBillingSummaries.propertyId,
          monthYear: welcomePackBillingSummaries.monthYear,
          totalUsages: welcomePackBillingSummaries.totalUsages,
          totalCostOwner: welcomePackBillingSummaries.totalCostOwner,
          totalCostGuest: welcomePackBillingSummaries.totalCostGuest,
          totalCostCompany: welcomePackBillingSummaries.totalCostCompany,
          totalCostComplimentary: welcomePackBillingSummaries.totalCostComplimentary,
          isProcessed: welcomePackBillingSummaries.isProcessed,
          processedAt: welcomePackBillingSummaries.processedAt,
          createdAt: welcomePackBillingSummaries.createdAt,
          propertyName: properties.name
        }).from(welcomePackBillingSummaries).leftJoin(properties, eq2(welcomePackBillingSummaries.propertyId, properties.id)).where(eq2(welcomePackBillingSummaries.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(welcomePackBillingSummaries.propertyId, filters.propertyId));
        }
        if (filters?.monthYear) {
          query = query.where(eq2(welcomePackBillingSummaries.monthYear, filters.monthYear));
        }
        if (filters?.isProcessed !== void 0) {
          query = query.where(eq2(welcomePackBillingSummaries.isProcessed, filters.isProcessed));
        }
        return query.orderBy(desc2(welcomePackBillingSummaries.monthYear), properties.name);
      }
      async createWelcomePackBillingSummary(data) {
        const [summary] = await db.insert(welcomePackBillingSummaries).values(data).returning();
        return summary;
      }
      async updateWelcomePackBillingSummary(id, data) {
        const [summary] = await db.update(welcomePackBillingSummaries).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(welcomePackBillingSummaries.id, id)).returning();
        return summary;
      }
      // Inventory Analytics & Reports
      async getInventoryUsageAnalytics(organizationId2, filters) {
        const baseConditions = [eq2(inventoryUsageLogs.organizationId, organizationId2)];
        if (filters?.propertyId) {
          baseConditions.push(eq2(inventoryUsageLogs.propertyId, filters.propertyId));
        }
        if (filters?.startDate) {
          baseConditions.push(gte2(inventoryUsageLogs.checkoutDate, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          baseConditions.push(lte2(inventoryUsageLogs.checkoutDate, new Date(filters.endDate)));
        }
        const totalStats = await db.select({
          totalLogs: count(),
          totalCost: sum(inventoryUsageLogs.totalPackCost),
          avgCostPerStay: avg(inventoryUsageLogs.totalPackCost),
          totalGuests: sum(inventoryUsageLogs.guestCount),
          totalNights: sum(inventoryUsageLogs.stayNights)
        }).from(inventoryUsageLogs).where(and3(...baseConditions));
        const billingBreakdown = await db.select({
          billingRule: inventoryUsageLogs.billingRule,
          count: count(),
          totalCost: sum(inventoryUsageLogs.totalPackCost)
        }).from(inventoryUsageLogs).where(and3(...baseConditions)).groupBy(inventoryUsageLogs.billingRule);
        const topItems = await db.select({
          itemName: inventoryItems.itemName,
          categoryName: inventoryCategories.categoryName,
          totalQuantityUsed: sum(inventoryUsageItems.quantityUsed),
          totalCost: sum(inventoryUsageItems.totalCost),
          usageCount: count(inventoryUsageItems.id)
        }).from(inventoryUsageItems).leftJoin(inventoryUsageLogs, eq2(inventoryUsageItems.usageLogId, inventoryUsageLogs.id)).leftJoin(inventoryItems, eq2(inventoryUsageItems.inventoryItemId, inventoryItems.id)).leftJoin(inventoryCategories, eq2(inventoryItems.categoryId, inventoryCategories.id)).where(and3(...baseConditions)).groupBy(inventoryItems.id, inventoryItems.itemName, inventoryCategories.categoryName).orderBy(desc2(sum(inventoryUsageItems.totalCost))).limit(10);
        return {
          totalStats: totalStats[0] || {},
          billingBreakdown,
          topItems
        };
      }
      async getInventoryUsageReportData(organizationId2, filters) {
        let query = db.select({
          logId: inventoryUsageLogs.id,
          propertyName: properties.name,
          checkoutDate: inventoryUsageLogs.checkoutDate,
          guestCount: inventoryUsageLogs.guestCount,
          stayNights: inventoryUsageLogs.stayNights,
          totalPackCost: inventoryUsageLogs.totalPackCost,
          billingRule: inventoryUsageLogs.billingRule,
          billingReason: inventoryUsageLogs.billingReason,
          staffName: sql3`CONCAT(${users.firstName}, ' ', ${users.lastName})`,
          isProcessed: inventoryUsageLogs.isProcessed,
          processedAt: inventoryUsageLogs.processedAt,
          notes: inventoryUsageLogs.notes,
          // Item details
          itemName: inventoryItems.itemName,
          categoryName: inventoryCategories.categoryName,
          quantityUsed: inventoryUsageItems.quantityUsed,
          unitCost: inventoryUsageItems.unitCost,
          itemTotalCost: inventoryUsageItems.totalCost,
          unitType: inventoryItems.unitType
        }).from(inventoryUsageLogs).leftJoin(properties, eq2(inventoryUsageLogs.propertyId, properties.id)).leftJoin(users, eq2(inventoryUsageLogs.staffMemberId, users.id)).leftJoin(inventoryUsageItems, eq2(inventoryUsageItems.usageLogId, inventoryUsageLogs.id)).leftJoin(inventoryItems, eq2(inventoryUsageItems.inventoryItemId, inventoryItems.id)).leftJoin(inventoryCategories, eq2(inventoryItems.categoryId, inventoryCategories.id)).where(eq2(inventoryUsageLogs.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(inventoryUsageLogs.propertyId, filters.propertyId));
        }
        if (filters?.staffMemberId) {
          query = query.where(eq2(inventoryUsageLogs.staffMemberId, filters.staffMemberId));
        }
        if (filters?.billingRule) {
          query = query.where(eq2(inventoryUsageLogs.billingRule, filters.billingRule));
        }
        if (filters?.startDate) {
          query = query.where(gte2(inventoryUsageLogs.checkoutDate, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(inventoryUsageLogs.checkoutDate, new Date(filters.endDate)));
        }
        return query.orderBy(desc2(inventoryUsageLogs.checkoutDate), inventoryCategories.sortOrder);
      }
      // ===== TASK COMPLETION PHOTO PROOF & PDF ARCHIVE SYSTEM =====
      // Task Completion Photos
      async createTaskCompletionPhoto(photo) {
        const [newPhoto] = await db.insert(taskCompletionPhotos).values(photo).returning();
        return newPhoto;
      }
      async getTaskCompletionPhotos(organizationId2, taskId) {
        return await db.select().from(taskCompletionPhotos).where(and3(
          eq2(taskCompletionPhotos.organizationId, organizationId2),
          eq2(taskCompletionPhotos.taskId, taskId)
        )).orderBy(taskCompletionPhotos.uploadedAt);
      }
      async deleteTaskCompletionPhoto(organizationId2, photoId) {
        const result = await db.delete(taskCompletionPhotos).where(and3(
          eq2(taskCompletionPhotos.organizationId, organizationId2),
          eq2(taskCompletionPhotos.id, photoId)
        ));
        return (result.rowCount || 0) > 0;
      }
      // Task Completion Notes
      async createTaskCompletionNote(note) {
        const [newNote] = await db.insert(taskCompletionNotes).values(note).returning();
        return newNote;
      }
      async getTaskCompletionNotes(organizationId2, taskId) {
        return await db.select().from(taskCompletionNotes).where(and3(
          eq2(taskCompletionNotes.organizationId, organizationId2),
          eq2(taskCompletionNotes.taskId, taskId)
        )).orderBy(taskCompletionNotes.addedAt);
      }
      // Task Completion Expenses
      async createTaskCompletionExpense(expense) {
        const [newExpense] = await db.insert(taskCompletionExpenses).values(expense).returning();
        return newExpense;
      }
      async getTaskCompletionExpenses(organizationId2, taskId) {
        return await db.select().from(taskCompletionExpenses).where(and3(
          eq2(taskCompletionExpenses.organizationId, organizationId2),
          eq2(taskCompletionExpenses.taskId, taskId)
        )).orderBy(taskCompletionExpenses.addedAt);
      }
      async deleteTaskCompletionExpense(organizationId2, expenseId) {
        const result = await db.delete(taskCompletionExpenses).where(and3(
          eq2(taskCompletionExpenses.organizationId, organizationId2),
          eq2(taskCompletionExpenses.id, expenseId)
        ));
        return (result.rowCount || 0) > 0;
      }
      // Task Approval Workflow
      async submitTaskForApproval(taskId, submittedBy, organizationId2) {
        await db.update(tasks).set({
          status: "pending_approval",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(tasks.id, taskId));
        const [approval] = await db.insert(taskApprovals).values({
          organizationId: organizationId2,
          taskId,
          submittedBy,
          status: "pending"
        }).returning();
        return approval;
      }
      async getTaskApproval(organizationId2, taskId) {
        const [approval] = await db.select().from(taskApprovals).where(and3(
          eq2(taskApprovals.organizationId, organizationId2),
          eq2(taskApprovals.taskId, taskId)
        ));
        return approval;
      }
      async getPendingTaskApprovals(organizationId2) {
        return await db.select({
          ...taskApprovals,
          taskTitle: tasks.title,
          taskDescription: tasks.description,
          taskType: tasks.type,
          propertyName: properties.name,
          submitterName: users.firstName
        }).from(taskApprovals).leftJoin(tasks, eq2(taskApprovals.taskId, tasks.id)).leftJoin(properties, eq2(tasks.propertyId, properties.id)).leftJoin(users, eq2(taskApprovals.submittedBy, users.id)).where(and3(
          eq2(taskApprovals.organizationId, organizationId2),
          eq2(taskApprovals.status, "pending")
        )).orderBy(taskApprovals.submittedAt);
      }
      async approveTask(organizationId2, taskId, reviewedBy, reviewNotes) {
        const [approval] = await db.update(taskApprovals).set({
          status: "approved",
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          reviewNotes
        }).where(and3(
          eq2(taskApprovals.organizationId, organizationId2),
          eq2(taskApprovals.taskId, taskId)
        )).returning();
        await db.update(tasks).set({
          status: "completed",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(tasks.id, taskId));
        return approval;
      }
      async requestTaskRedo(organizationId2, taskId, reviewedBy, reviewNotes) {
        const [approval] = await db.update(taskApprovals).set({
          status: "redo_requested",
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          reviewNotes
        }).where(and3(
          eq2(taskApprovals.organizationId, organizationId2),
          eq2(taskApprovals.taskId, taskId)
        )).returning();
        await db.update(tasks).set({
          status: "in_progress",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(tasks.id, taskId));
        return approval;
      }
      // Task Archive Management
      async getTasksReadyForArchive(organizationId2) {
        const thirtyDaysAgo = /* @__PURE__ */ new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        return await db.select({
          ...tasks,
          propertyName: properties.name,
          approvalStatus: taskApprovals.status,
          photosCount: count(taskCompletionPhotos.id),
          notesCount: count(taskCompletionNotes.id),
          expensesCount: count(taskCompletionExpenses.id)
        }).from(tasks).leftJoin(properties, eq2(tasks.propertyId, properties.id)).leftJoin(taskApprovals, eq2(tasks.id, taskApprovals.taskId)).leftJoin(taskCompletionPhotos, eq2(tasks.id, taskCompletionPhotos.taskId)).leftJoin(taskCompletionNotes, eq2(tasks.id, taskCompletionNotes.taskId)).leftJoin(taskCompletionExpenses, eq2(tasks.id, taskCompletionExpenses.taskId)).leftJoin(taskArchiveStatus, eq2(tasks.id, taskArchiveStatus.taskId)).where(and3(
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.status, "completed"),
          lt(tasks.updatedAt, thirtyDaysAgo),
          isNull2(taskArchiveStatus.id)
          // Not already archived
        )).groupBy(tasks.id, properties.name, taskApprovals.status);
      }
      async generateTaskPdfArchive(archiveData) {
        const [archive] = await db.insert(taskPdfArchives).values(archiveData).returning();
        return archive;
      }
      async markTasksAsArchived(taskIds, pdfArchiveId, organizationId2) {
        const archiveStatuses = taskIds.map((taskId) => ({
          organizationId: organizationId2,
          taskId,
          isArchived: true,
          archiveDate: /* @__PURE__ */ new Date(),
          pdfArchiveId
        }));
        await db.insert(taskArchiveStatus).values(archiveStatuses);
      }
      async deleteArchivedTaskPhotos(taskIds, organizationId2) {
        await db.update(taskArchiveStatus).set({
          photosDeleted: true,
          photosDeletedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(taskArchiveStatus.organizationId, organizationId2),
          inArray(taskArchiveStatus.taskId, taskIds)
        ));
        await db.delete(taskCompletionPhotos).where(and3(
          eq2(taskCompletionPhotos.organizationId, organizationId2),
          inArray(taskCompletionPhotos.taskId, taskIds)
        ));
      }
      async getTaskPdfArchives(organizationId2, propertyId) {
        let query = db.select({
          ...taskPdfArchives,
          propertyName: properties.name
        }).from(taskPdfArchives).leftJoin(properties, eq2(taskPdfArchives.propertyId, properties.id)).where(eq2(taskPdfArchives.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(taskPdfArchives.propertyId, propertyId));
        }
        return await query.orderBy(desc2(taskPdfArchives.generatedAt));
      }
      async updateTaskPdfArchive(id, updates) {
        const [updated] = await db.update(taskPdfArchives).set(updates).where(eq2(taskPdfArchives.id, id)).returning();
        return updated;
      }
      // Get comprehensive task details with all photos, notes, and expenses
      async getTaskWithCompletionDetails(organizationId2, taskId) {
        const [task] = await db.select({
          ...tasks,
          propertyName: properties.name,
          assignedUserName: users.firstName
        }).from(tasks).leftJoin(properties, eq2(tasks.propertyId, properties.id)).leftJoin(users, eq2(tasks.assignedTo, users.id)).where(and3(
          eq2(tasks.organizationId, organizationId2),
          eq2(tasks.id, taskId)
        ));
        if (!task) return null;
        const [photos, notes, expenses, approval] = await Promise.all([
          this.getTaskCompletionPhotos(organizationId2, taskId),
          this.getTaskCompletionNotes(organizationId2, taskId),
          this.getTaskCompletionExpenses(organizationId2, taskId),
          this.getTaskApproval(organizationId2, taskId)
        ]);
        return {
          ...task,
          photos,
          notes,
          expenses,
          approval
        };
      }
      // ==================== STAFF OVERHOURS & EMERGENCY TASK TRACKER ====================
      // Staff Work Hours Configuration
      async getStaffWorkHours(organizationId2, staffId) {
        let query = db.select().from(staffWorkHours).where(eq2(staffWorkHours.organizationId, organizationId2));
        if (staffId) {
          query = query.where(eq2(staffWorkHours.staffId, staffId));
        }
        return await query.where(eq2(staffWorkHours.isActive, true)).orderBy(staffWorkHours.staffName);
      }
      async getStaffWorkHoursById(id) {
        const [workHours] = await db.select().from(staffWorkHours).where(eq2(staffWorkHours.id, id));
        return workHours;
      }
      async createStaffWorkHours(workHours) {
        const [newWorkHours] = await db.insert(staffWorkHours).values(workHours).returning();
        return newWorkHours;
      }
      async updateStaffWorkHours(id, updates) {
        const [updated] = await db.update(staffWorkHours).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffWorkHours.id, id)).returning();
        return updated;
      }
      // Task Time Tracking - Clock In/Out System
      async startTaskTimer(taskTimeTracking2) {
        const workHours = await this.getStaffWorkHours(taskTimeTracking2.organizationId, taskTimeTracking2.staffId);
        const staffWorkHours2 = workHours[0];
        let isOutsideNormalHours = false;
        if (staffWorkHours2) {
          const startTime = new Date(taskTimeTracking2.startTime);
          const currentTime = startTime.toTimeString().slice(0, 5);
          const currentDay = startTime.toLocaleDateString("en-US", { weekday: "lowercase" });
          if (!staffWorkHours2.workDays.includes(currentDay) || currentTime < staffWorkHours2.normalStartTime || currentTime > staffWorkHours2.normalEndTime) {
            isOutsideNormalHours = true;
          }
        }
        const newTaskTracking = await db.insert(taskTimeTracking2).values({
          ...taskTimeTracking2,
          isOutsideNormalHours,
          status: "active"
        }).returning();
        return newTaskTracking[0];
      }
      async endTaskTimer(taskTrackingId, endTime, taskNotes) {
        const [tracking] = await db.select().from(taskTimeTracking).where(eq2(taskTimeTracking.id, taskTrackingId));
        if (!tracking) {
          return void 0;
        }
        const duration = Math.floor((endTime.getTime() - tracking.startTime.getTime()) / (1e3 * 60));
        const [updated] = await db.update(taskTimeTracking).set({
          endTime,
          duration,
          taskNotes,
          status: "completed",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(taskTimeTracking.id, taskTrackingId)).returning();
        await this.updateOvertimeSummary(tracking.organizationId, tracking.staffId, tracking.startTime);
        return updated;
      }
      async markTaskAsEmergency(taskTrackingId, emergencyReason, markedBy) {
        const [updated] = await db.update(taskTimeTracking).set({
          isEmergencyTask: true,
          emergencyReason: `${emergencyReason} (Marked by: ${markedBy})`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(taskTimeTracking.id, taskTrackingId)).returning();
        return updated;
      }
      // Get task time tracking records
      async getTaskTimeTracking(organizationId2, filters) {
        let query = db.select().from(taskTimeTracking).where(eq2(taskTimeTracking.organizationId, organizationId2));
        if (filters?.staffId) {
          query = query.where(eq2(taskTimeTracking.staffId, filters.staffId));
        }
        if (filters?.taskId) {
          query = query.where(eq2(taskTimeTracking.taskId, filters.taskId));
        }
        if (filters?.status) {
          query = query.where(eq2(taskTimeTracking.status, filters.status));
        }
        if (filters?.fromDate) {
          query = query.where(gte2(taskTimeTracking.startTime, filters.fromDate));
        }
        if (filters?.toDate) {
          query = query.where(lte2(taskTimeTracking.startTime, filters.toDate));
        }
        if (filters?.isOutsideNormalHours !== void 0) {
          query = query.where(eq2(taskTimeTracking.isOutsideNormalHours, filters.isOutsideNormalHours));
        }
        if (filters?.isEmergencyTask !== void 0) {
          query = query.where(eq2(taskTimeTracking.isEmergencyTask, filters.isEmergencyTask));
        }
        return await query.orderBy(desc2(taskTimeTracking.startTime));
      }
      // Overtime Hours Summary Management
      async updateOvertimeSummary(organizationId2, staffId, taskDate) {
        const monthYear = taskDate.toISOString().slice(0, 7);
        const overtimeRecords = await this.getTaskTimeTracking(organizationId2, {
          staffId,
          isOutsideNormalHours: true,
          fromDate: new Date(taskDate.getFullYear(), taskDate.getMonth(), 1),
          toDate: new Date(taskDate.getFullYear(), taskDate.getMonth() + 1, 0)
        });
        const completedRecords = overtimeRecords.filter((record) => record.status === "completed" && record.duration);
        const totalOvertimeMinutes = completedRecords.reduce((sum4, record) => sum4 + (record.duration || 0), 0);
        const totalEmergencyTasks = completedRecords.filter((record) => record.isEmergencyTask).length;
        const totalRegularTasks = completedRecords.filter((record) => !record.isEmergencyTask).length;
        const workHours = await this.getStaffWorkHours(organizationId2, staffId);
        const staffWorkHours2 = workHours[0];
        let estimatedOvertimePay = 0;
        if (staffWorkHours2) {
          const baseSalary = parseFloat(staffWorkHours2.baseMonthlySalary.toString());
          const overtimeRate = parseFloat(staffWorkHours2.overtimeRate.toString());
          const hoursPerMonth = 160;
          const hourlyRate = baseSalary / hoursPerMonth;
          estimatedOvertimePay = totalOvertimeMinutes / 60 * hourlyRate * overtimeRate;
        }
        const [existingSummary] = await db.select().from(overtimeHoursSummary).where(
          and3(
            eq2(overtimeHoursSummary.organizationId, organizationId2),
            eq2(overtimeHoursSummary.staffId, staffId),
            eq2(overtimeHoursSummary.monthYear, monthYear)
          )
        );
        const summaryData = {
          totalOvertimeMinutes,
          totalEmergencyTasks,
          totalRegularTasks,
          estimatedOvertimePay: estimatedOvertimePay.toString(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (existingSummary) {
          await db.update(overtimeHoursSummary).set(summaryData).where(eq2(overtimeHoursSummary.id, existingSummary.id));
        } else {
          const staff = await this.getUser(staffId);
          await db.insert(overtimeHoursSummary).values({
            organizationId: organizationId2,
            staffId,
            staffName: staff?.firstName && staff?.lastName ? `${staff.firstName} ${staff.lastName}` : "Unknown Staff",
            monthYear,
            ...summaryData,
            status: "pending"
          });
        }
      }
      async getOvertimeHoursSummary(organizationId2, filters) {
        let query = db.select().from(overtimeHoursSummary).where(eq2(overtimeHoursSummary.organizationId, organizationId2));
        if (filters?.staffId) {
          query = query.where(eq2(overtimeHoursSummary.staffId, filters.staffId));
        }
        if (filters?.monthYear) {
          query = query.where(eq2(overtimeHoursSummary.monthYear, filters.monthYear));
        }
        if (filters?.status) {
          query = query.where(eq2(overtimeHoursSummary.status, filters.status));
        }
        return await query.orderBy(desc2(overtimeHoursSummary.monthYear), overtimeHoursSummary.staffName);
      }
      async approveOvertimeHours(summaryId, approvedBy, approvedMinutes) {
        const [summary] = await db.select().from(overtimeHoursSummary).where(eq2(overtimeHoursSummary.id, summaryId));
        if (!summary) {
          return void 0;
        }
        const finalApprovedMinutes = approvedMinutes || summary.totalOvertimeMinutes;
        const unpaidMinutes = summary.totalOvertimeMinutes - finalApprovedMinutes;
        const [updated] = await db.update(overtimeHoursSummary).set({
          status: "approved",
          approvedOvertimeMinutes: finalApprovedMinutes,
          unpaidOvertimeMinutes: unpaidMinutes,
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(overtimeHoursSummary.id, summaryId)).returning();
        return updated;
      }
      // Staff Commission Bonuses
      async getStaffCommissionBonuses(organizationId2, filters) {
        let query = db.select().from(staffCommissionBonuses).where(eq2(staffCommissionBonuses.organizationId, organizationId2));
        if (filters?.staffId) {
          query = query.where(eq2(staffCommissionBonuses.staffId, filters.staffId));
        }
        if (filters?.monthYear) {
          query = query.where(eq2(staffCommissionBonuses.monthYear, filters.monthYear));
        }
        if (filters?.bonusType) {
          query = query.where(eq2(staffCommissionBonuses.bonusType, filters.bonusType));
        }
        if (filters?.status) {
          query = query.where(eq2(staffCommissionBonuses.status, filters.status));
        }
        return await query.orderBy(desc2(staffCommissionBonuses.awardedAt));
      }
      async createStaffCommissionBonus(bonus) {
        const [newBonus] = await db.insert(staffCommissionBonuses).values(bonus).returning();
        return newBonus;
      }
      async approveStaffBonus(bonusId, approvedBy) {
        const [updated] = await db.update(staffCommissionBonuses).set({
          status: "approved",
          awardedAt: /* @__PURE__ */ new Date()
        }).where(eq2(staffCommissionBonuses.id, bonusId)).returning();
        return updated;
      }
      // Emergency Task Reasons
      async getEmergencyTaskReasons(organizationId2) {
        return await db.select().from(emergencyTaskReasons).where(and3(
          eq2(emergencyTaskReasons.organizationId, organizationId2),
          eq2(emergencyTaskReasons.isActive, true)
        )).orderBy(emergencyTaskReasons.category, emergencyTaskReasons.reason);
      }
      async createEmergencyTaskReason(reason) {
        const [newReason] = await db.insert(emergencyTaskReasons).values(reason).returning();
        return newReason;
      }
      // Staff overtime analytics
      async getStaffOvertimeAnalytics(organizationId2, staffId, fromDate, toDate) {
        const filters = { organizationId: organizationId2 };
        if (staffId) filters.staffId = staffId;
        if (fromDate) filters.fromDate = fromDate;
        if (toDate) filters.toDate = toDate;
        const timeRecords = await this.getTaskTimeTracking(organizationId2, filters);
        const completedRecords = timeRecords.filter((record) => record.status === "completed" && record.duration);
        const totalOvertimeMinutes = completedRecords.filter((record) => record.isOutsideNormalHours).reduce((sum4, record) => sum4 + (record.duration || 0), 0);
        const totalEmergencyTasks = completedRecords.filter((record) => record.isEmergencyTask).length;
        const averageTaskDuration = completedRecords.length > 0 ? completedRecords.reduce((sum4, record) => sum4 + (record.duration || 0), 0) / completedRecords.length : 0;
        const emergencyReasons = completedRecords.filter((record) => record.isEmergencyTask && record.emergencyReason).map((record) => record.emergencyReason);
        const reasonCounts = emergencyReasons.reduce((acc, reason) => {
          acc[reason] = (acc[reason] || 0) + 1;
          return acc;
        }, {});
        const mostCommonEmergencyReason = Object.entries(reasonCounts).sort(([, a], [, b]) => b - a)[0]?.[0] || "None";
        const monthlyBreakdown = completedRecords.reduce((acc, record) => {
          const month = record.startTime.toISOString().slice(0, 7);
          if (!acc[month]) {
            acc[month] = { month, hours: 0, tasks: 0, emergencyTasks: 0 };
          }
          acc[month].hours += (record.duration || 0) / 60;
          acc[month].tasks += 1;
          if (record.isEmergencyTask) {
            acc[month].emergencyTasks += 1;
          }
          return acc;
        }, {});
        return {
          totalOvertimeHours: totalOvertimeMinutes / 60,
          totalEmergencyTasks,
          averageTaskDuration,
          mostCommonEmergencyReason,
          monthlyBreakdown: Object.values(monthlyBreakdown)
        };
      }
      // ===== TASK ATTACHMENTS & PROPERTY NOTES OPERATIONS =====
      // Task attachments operations
      async getTaskAttachments(taskId) {
        return await db.select().from(taskAttachments).where(and3(
          eq2(taskAttachments.taskId, taskId),
          eq2(taskAttachments.isActive, true)
        )).orderBy(asc(taskAttachments.sortOrder), asc(taskAttachments.fileName));
      }
      async getTaskAttachment(id) {
        const [attachment] = await db.select().from(taskAttachments).where(eq2(taskAttachments.id, id));
        return attachment;
      }
      async createTaskAttachment(attachment) {
        const [newAttachment] = await db.insert(taskAttachments).values(attachment).returning();
        return newAttachment;
      }
      async updateTaskAttachment(id, attachment) {
        const [updatedAttachment] = await db.update(taskAttachments).set({ ...attachment, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(taskAttachments.id, id)).returning();
        return updatedAttachment;
      }
      async deleteTaskAttachment(id) {
        const result = await db.update(taskAttachments).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(taskAttachments.id, id));
        return (result.rowCount ?? 0) > 0;
      }
      // Property notes operations
      async getPropertyNotes(propertyId, filters) {
        let query = db.select().from(propertyNotes).where(and3(
          eq2(propertyNotes.propertyId, propertyId),
          eq2(propertyNotes.isActive, true)
        ));
        if (filters?.noteType) {
          query = query.where(eq2(propertyNotes.noteType, filters.noteType));
        }
        if (filters?.isPinned !== void 0) {
          query = query.where(eq2(propertyNotes.isPinned, filters.isPinned));
        }
        if (filters?.department) {
          query = query.where(sql3`${propertyNotes.applicableDepartments} && ARRAY[${filters.department}]`);
        }
        return await query.orderBy(
          desc2(propertyNotes.isPinned),
          desc2(propertyNotes.priority),
          asc(propertyNotes.title)
        );
      }
      async getPropertyNote(id) {
        const [note] = await db.select().from(propertyNotes).where(eq2(propertyNotes.id, id));
        return note;
      }
      async createPropertyNote(note) {
        const [newNote] = await db.insert(propertyNotes).values(note).returning();
        return newNote;
      }
      async updatePropertyNote(id, note) {
        const [updatedNote] = await db.update(propertyNotes).set({ ...note, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyNotes.id, id)).returning();
        return updatedNote;
      }
      async deletePropertyNote(id) {
        const result = await db.update(propertyNotes).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyNotes.id, id));
        return (result.rowCount ?? 0) > 0;
      }
      // Property attachments operations
      async getPropertyAttachments(propertyId, filters) {
        let query = db.select().from(propertyAttachments).where(and3(
          eq2(propertyAttachments.propertyId, propertyId),
          eq2(propertyAttachments.isActive, true)
        ));
        if (filters?.category) {
          query = query.where(eq2(propertyAttachments.category, filters.category));
        }
        if (filters?.department) {
          query = query.where(sql3`${propertyAttachments.applicableDepartments} && ARRAY[${filters.department}]`);
        }
        return await query.orderBy(asc(propertyAttachments.sortOrder), asc(propertyAttachments.title));
      }
      async getPropertyAttachment(id) {
        const [attachment] = await db.select().from(propertyAttachments).where(eq2(propertyAttachments.id, id));
        return attachment;
      }
      async createPropertyAttachment(attachment) {
        const [newAttachment] = await db.insert(propertyAttachments).values(attachment).returning();
        return newAttachment;
      }
      async updatePropertyAttachment(id, attachment) {
        const [updatedAttachment] = await db.update(propertyAttachments).set({ ...attachment, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyAttachments.id, id)).returning();
        return updatedAttachment;
      }
      async deletePropertyAttachment(id) {
        const result = await db.update(propertyAttachments).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyAttachments.id, id));
        return (result.rowCount ?? 0) > 0;
      }
      // Task guide templates operations
      async getTaskGuideTemplates(organizationId2, filters) {
        let query = db.select().from(taskGuideTemplates).where(and3(
          eq2(taskGuideTemplates.organizationId, organizationId2),
          eq2(taskGuideTemplates.isActive, true)
        ));
        if (filters?.category) {
          query = query.where(eq2(taskGuideTemplates.category, filters.category));
        }
        if (filters?.guideType) {
          query = query.where(eq2(taskGuideTemplates.guideType, filters.guideType));
        }
        return await query.orderBy(asc(taskGuideTemplates.templateName));
      }
      async getTaskGuideTemplate(id) {
        const [template] = await db.select().from(taskGuideTemplates).where(eq2(taskGuideTemplates.id, id));
        return template;
      }
      async createTaskGuideTemplate(template) {
        const [newTemplate] = await db.insert(taskGuideTemplates).values(template).returning();
        return newTemplate;
      }
      async updateTaskGuideTemplate(id, template) {
        const [updatedTemplate] = await db.update(taskGuideTemplates).set({ ...template, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(taskGuideTemplates.id, id)).returning();
        return updatedTemplate;
      }
      async deleteTaskGuideTemplate(id) {
        const result = await db.update(taskGuideTemplates).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(taskGuideTemplates.id, id));
        return (result.rowCount ?? 0) > 0;
      }
      // Attachment access logs operations
      async logAttachmentAccess(log2) {
        const [newLog] = await db.insert(attachmentAccessLogs).values(log2).returning();
        return newLog;
      }
      async getAttachmentAccessLogs(organizationId2, filters) {
        let query = db.select().from(attachmentAccessLogs).where(eq2(attachmentAccessLogs.organizationId, organizationId2));
        if (filters?.attachmentId) {
          query = query.where(eq2(attachmentAccessLogs.attachmentId, filters.attachmentId));
        }
        if (filters?.attachmentType) {
          query = query.where(eq2(attachmentAccessLogs.attachmentType, filters.attachmentType));
        }
        if (filters?.accessedBy) {
          query = query.where(eq2(attachmentAccessLogs.accessedBy, filters.accessedBy));
        }
        return await query.orderBy(desc2(attachmentAccessLogs.createdAt));
      }
      // ===== ADD-ON SERVICES BOOKING ENGINE IMPLEMENTATION =====
      // Service Categories
      async getServiceCategories(organizationId2) {
        return [
          { id: 1, name: "Cleaning", description: "House cleaning services", icon: "sparkles", isActive: true },
          { id: 2, name: "Massage", description: "In-villa massage services", icon: "user", isActive: true },
          { id: 3, name: "Chef", description: "Private chef services", icon: "utensils", isActive: true },
          { id: 4, name: "Transport", description: "Transportation services", icon: "car", isActive: true },
          { id: 5, name: "Pool", description: "Pool cleaning and maintenance", icon: "waves", isActive: true },
          { id: 6, name: "Laundry", description: "Laundry and dry cleaning", icon: "shirt", isActive: true },
          { id: 7, name: "Tours", description: "Local tours and activities", icon: "map-pin", isActive: true },
          { id: 8, name: "Baby Setup", description: "Baby equipment and setup", icon: "gift", isActive: true }
        ];
      }
      async createServiceCategory(category) {
        return { id: Math.floor(Math.random() * 1e3), ...category, createdAt: /* @__PURE__ */ new Date() };
      }
      async updateServiceCategory(id, updates) {
        return { id, ...updates, updatedAt: /* @__PURE__ */ new Date() };
      }
      async deleteServiceCategory(id) {
        return true;
      }
      // Add-on Services
      async getAddonServices(organizationId2, filters) {
        const mockServices = [
          {
            id: 1,
            name: "Deep House Cleaning",
            description: "Comprehensive deep cleaning service for your villa",
            categoryId: 1,
            categoryName: "Cleaning",
            defaultPrice: 150,
            pricingType: "fixed",
            currency: "AUD",
            estimatedDuration: 180,
            isActive: true,
            requiresQuote: false,
            canCreateTask: true,
            taskDepartment: "cleaning",
            availabilityNotes: "Available 9 AM - 5 PM"
          },
          {
            id: 2,
            name: "Traditional Thai Massage",
            description: "Authentic Thai massage in your villa",
            categoryId: 2,
            categoryName: "Massage",
            defaultPrice: 120,
            pricingType: "per_person",
            currency: "AUD",
            estimatedDuration: 90,
            isActive: true,
            requiresQuote: false,
            canCreateTask: false,
            taskDepartment: "front-desk",
            availabilityNotes: "Book 24 hours in advance"
          },
          {
            id: 3,
            name: "Private Chef Dinner",
            description: "Personal chef for special dinner experience",
            categoryId: 3,
            categoryName: "Chef",
            defaultPrice: 0,
            pricingType: "quote_required",
            currency: "AUD",
            estimatedDuration: 240,
            isActive: true,
            requiresQuote: true,
            canCreateTask: true,
            taskDepartment: "front-desk",
            availabilityNotes: "Menu consultation required"
          },
          {
            id: 4,
            name: "Airport Transfer",
            description: "Private airport transfer service",
            categoryId: 4,
            categoryName: "Transport",
            defaultPrice: 85,
            pricingType: "fixed",
            currency: "AUD",
            estimatedDuration: 60,
            isActive: true,
            requiresQuote: false,
            canCreateTask: true,
            taskDepartment: "transport",
            availabilityNotes: "Book 2 hours in advance"
          },
          {
            id: 5,
            name: "Pool Cleaning",
            description: "Professional pool cleaning and maintenance",
            categoryId: 5,
            categoryName: "Pool",
            defaultPrice: 80,
            pricingType: "fixed",
            currency: "AUD",
            estimatedDuration: 120,
            isActive: true,
            requiresQuote: false,
            canCreateTask: true,
            taskDepartment: "pool",
            availabilityNotes: "Available daily"
          },
          {
            id: 6,
            name: "Express Laundry",
            description: "Same-day laundry and ironing service",
            categoryId: 6,
            categoryName: "Laundry",
            defaultPrice: 25,
            pricingType: "hourly",
            currency: "AUD",
            estimatedDuration: 180,
            isActive: true,
            requiresQuote: false,
            canCreateTask: true,
            taskDepartment: "cleaning",
            availabilityNotes: "Pickup by 10 AM for same day return"
          },
          {
            id: 7,
            name: "Island Hopping Tour",
            description: "Full day island hopping experience",
            categoryId: 7,
            categoryName: "Tours",
            defaultPrice: 220,
            pricingType: "per_person",
            currency: "AUD",
            estimatedDuration: 480,
            isActive: true,
            requiresQuote: false,
            canCreateTask: true,
            taskDepartment: "front-desk",
            availabilityNotes: "Weather dependent"
          },
          {
            id: 8,
            name: "Baby Equipment Setup",
            description: "Complete baby equipment setup and safety check",
            categoryId: 8,
            categoryName: "Baby Setup",
            defaultPrice: 75,
            pricingType: "fixed",
            currency: "AUD",
            estimatedDuration: 60,
            isActive: true,
            requiresQuote: false,
            canCreateTask: true,
            taskDepartment: "cleaning",
            availabilityNotes: "Setup 1 day before arrival"
          }
        ];
        let filteredServices = mockServices;
        if (filters?.categoryId) {
          filteredServices = filteredServices.filter((service) => service.categoryId === filters.categoryId);
        }
        if (filters?.isActive !== void 0) {
          filteredServices = filteredServices.filter((service) => service.isActive === filters.isActive);
        }
        return filteredServices;
      }
      async getAddonService(id) {
        const services = await this.getAddonServices("demo-org");
        return services.find((service) => service.id === id);
      }
      async createAddonService(service) {
        return { id: Math.floor(Math.random() * 1e3), ...service, createdAt: /* @__PURE__ */ new Date() };
      }
      async updateAddonService(id, updates) {
        return { id, ...updates, updatedAt: /* @__PURE__ */ new Date() };
      }
      async deleteAddonService(id) {
        return true;
      }
      // Service Bookings
      async getServiceBookings(organizationId2, filters) {
        const mockBookings = [
          {
            id: 1,
            propertyId: 1,
            propertyName: "Ocean Vista Villa",
            serviceId: 1,
            serviceName: "Deep House Cleaning",
            guestName: "Sarah Johnson",
            guestEmail: "sarah@example.com",
            guestPhone: "+61 400 123 456",
            bookingDate: "2025-01-05",
            bookingTime: "10:00",
            quantity: 1,
            totalPrice: 150,
            currency: "AUD",
            paymentRoute: "guest_paid",
            status: "confirmed",
            specialRequests: "Please focus on bathrooms",
            createdByType: "staff",
            createdAt: "2025-01-03T10:00:00Z"
          },
          {
            id: 2,
            propertyId: 2,
            propertyName: "Sunset Beach House",
            serviceId: 2,
            serviceName: "Traditional Thai Massage",
            guestName: "Michael Chen",
            guestEmail: "michael@example.com",
            guestPhone: "+61 400 789 123",
            bookingDate: "2025-01-06",
            bookingTime: "16:00",
            quantity: 2,
            totalPrice: 240,
            currency: "AUD",
            paymentRoute: "owner_paid",
            status: "pending",
            specialRequests: "Couples massage please",
            createdByType: "guest",
            createdAt: "2025-01-04T14:30:00Z"
          },
          {
            id: 3,
            propertyId: 1,
            propertyName: "Ocean Vista Villa",
            serviceId: 4,
            serviceName: "Airport Transfer",
            guestName: "Emma Wilson",
            guestEmail: "emma@example.com",
            guestPhone: "+61 400 456 789",
            bookingDate: "2025-01-07",
            bookingTime: "14:00",
            quantity: 1,
            totalPrice: 85,
            currency: "AUD",
            paymentRoute: "company_paid",
            status: "completed",
            specialRequests: "Flight details: QF123 arriving at 13:30",
            createdByType: "staff",
            createdAt: "2025-01-05T09:15:00Z"
          },
          {
            id: 4,
            propertyId: 3,
            propertyName: "Mountain Retreat",
            serviceId: 3,
            serviceName: "Private Chef Dinner",
            guestName: "David Smith",
            guestEmail: "david@example.com",
            guestPhone: "+61 400 321 654",
            bookingDate: "2025-01-08",
            bookingTime: "19:00",
            quantity: 4,
            totalPrice: 450,
            currency: "AUD",
            paymentRoute: "complimentary",
            complimentaryType: "owner_gift",
            status: "confirmed",
            specialRequests: "Vegetarian menu for 2 guests, seafood allergies to consider",
            createdByType: "staff",
            createdAt: "2025-01-02T16:45:00Z"
          },
          {
            id: 5,
            propertyId: 2,
            propertyName: "Sunset Beach House",
            serviceId: 7,
            serviceName: "Island Hopping Tour",
            guestName: "Lisa Rodriguez",
            guestEmail: "lisa@example.com",
            guestPhone: "+61 400 987 321",
            bookingDate: "2025-01-09",
            bookingTime: "08:00",
            quantity: 3,
            totalPrice: 660,
            currency: "AUD",
            paymentRoute: "guest_paid",
            status: "pending",
            specialRequests: "Snorkeling equipment needed",
            createdByType: "guest",
            createdAt: "2025-01-06T11:20:00Z"
          }
        ];
        let filteredBookings = mockBookings;
        if (filters?.propertyId) {
          filteredBookings = filteredBookings.filter((booking) => booking.propertyId === filters.propertyId);
        }
        if (filters?.status) {
          filteredBookings = filteredBookings.filter((booking) => booking.status === filters.status);
        }
        if (filters?.paymentRoute) {
          filteredBookings = filteredBookings.filter((booking) => booking.paymentRoute === filters.paymentRoute);
        }
        return filteredBookings;
      }
      async getServiceBooking(id) {
        const bookings3 = await this.getServiceBookings("demo-org");
        return bookings3.find((booking) => booking.id === id);
      }
      async createServiceBooking(booking) {
        const newBooking = {
          id: Math.floor(Math.random() * 1e3),
          ...booking,
          status: "pending",
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        if (booking.canCreateTask) {
        }
        return newBooking;
      }
      async updateServiceBooking(id, updates) {
        return { id, ...updates, updatedAt: /* @__PURE__ */ new Date() };
      }
      async deleteServiceBooking(id) {
        return true;
      }
      // Property Service Pricing
      async getPropertyServicePricing(propertyId, serviceId) {
        return [];
      }
      async createPropertyServicePricing(pricing) {
        return { id: Math.floor(Math.random() * 1e3), ...pricing, createdAt: /* @__PURE__ */ new Date() };
      }
      async updatePropertyServicePricing(id, updates) {
        return { id, ...updates, updatedAt: /* @__PURE__ */ new Date() };
      }
      // Service Availability
      async getServiceAvailability(serviceId) {
        return [];
      }
      async createServiceAvailability(availability) {
        return { id: Math.floor(Math.random() * 1e3), ...availability, createdAt: /* @__PURE__ */ new Date() };
      }
      async updateServiceAvailability(id, updates) {
        return { id, ...updates, updatedAt: /* @__PURE__ */ new Date() };
      }
      // ===== STAFF SALARY & OVERTIME MANAGEMENT =====
      // Staff Salary Profiles
      async getStaffSalaryProfiles(organizationId2) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            userId: "demo-staff",
            userName: "John Staff",
            role: "staff",
            monthlySalary: "4500.00",
            currency: "AUD",
            bonusEligible: true,
            overtimeRate: "1.5",
            emergencyCalloutRate: "75.00",
            isActive: true,
            hireDate: /* @__PURE__ */ new Date("2024-01-15"),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          },
          {
            id: 2,
            organizationId: organizationId2,
            userId: "demo-manager",
            userName: "Sarah Manager",
            role: "portfolio-manager",
            monthlySalary: "7500.00",
            currency: "AUD",
            bonusEligible: true,
            overtimeRate: "1.5",
            emergencyCalloutRate: "100.00",
            isActive: true,
            hireDate: /* @__PURE__ */ new Date("2023-06-01"),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        ];
      }
      async getStaffSalaryProfile(userId) {
        const profiles = await this.getStaffSalaryProfiles("default-org");
        return profiles.find((p) => p.userId === userId);
      }
      async createStaffSalaryProfile(profile) {
        return {
          id: Math.floor(Math.random() * 1e3),
          ...profile,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async updateStaffSalaryProfile(userId, updates) {
        const profile = await this.getStaffSalaryProfile(userId);
        if (profile) {
          return { ...profile, ...updates, updatedAt: /* @__PURE__ */ new Date() };
        }
        return void 0;
      }
      // Staff Commission & Bonus Log
      async getStaffCommissionLog(organizationId2, filters) {
        const commissions = [
          {
            id: 1,
            organizationId: organizationId2,
            userId: "demo-staff",
            userName: "John Staff",
            commissionType: "emergency_bonus",
            sourceType: "task",
            sourceId: 101,
            amount: "150.00",
            currency: "AUD",
            description: "Emergency callout bonus for urgent pool repair",
            status: "approved",
            approvedBy: "demo-admin",
            approvedAt: /* @__PURE__ */ new Date("2025-01-15"),
            paymentDate: /* @__PURE__ */ new Date("2025-01-31"),
            month: "2025-01",
            createdAt: /* @__PURE__ */ new Date("2025-01-15")
          },
          {
            id: 2,
            organizationId: organizationId2,
            userId: "demo-manager",
            userName: "Sarah Manager",
            commissionType: "booking_bonus",
            sourceType: "booking",
            sourceId: 201,
            amount: "300.00",
            currency: "AUD",
            description: "Commission for high-value booking (Villa Sunset)",
            status: "pending",
            month: "2025-01",
            createdAt: /* @__PURE__ */ new Date("2025-01-20")
          },
          {
            id: 3,
            organizationId: organizationId2,
            userId: "demo-staff",
            userName: "John Staff",
            commissionType: "task_completion",
            sourceType: "task",
            sourceId: 102,
            amount: "75.00",
            currency: "AUD",
            description: "Bonus for completing 10 tasks this month",
            status: "approved",
            approvedBy: "demo-admin",
            approvedAt: /* @__PURE__ */ new Date("2025-01-25"),
            month: "2025-01",
            createdAt: /* @__PURE__ */ new Date("2025-01-25")
          }
        ];
        let filtered = commissions;
        if (filters?.userId) {
          filtered = filtered.filter((c) => c.userId === filters.userId);
        }
        if (filters?.month) {
          filtered = filtered.filter((c) => c.month === filters.month);
        }
        if (filters?.status) {
          filtered = filtered.filter((c) => c.status === filters.status);
        }
        return filtered;
      }
      async createStaffCommissionLog(commission) {
        return {
          id: Math.floor(Math.random() * 1e3),
          ...commission,
          createdAt: /* @__PURE__ */ new Date()
        };
      }
      async updateStaffCommissionStatus(id, status, approvedBy) {
        return {
          id,
          status,
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Emergency Clock-In System
      async getStaffTimeClocks(organizationId2, filters) {
        const timeClocks = [
          {
            id: 1,
            organizationId: organizationId2,
            userId: "demo-staff",
            userName: "John Staff",
            clockType: "emergency",
            shiftType: "clock_in",
            clockTime: /* @__PURE__ */ new Date("2025-01-15T14:30:00"),
            location: "Villa Sunset - Pool Area",
            propertyId: 1,
            propertyName: "Villa Sunset",
            reason: "Pool pump failure - guests unable to use pool",
            workDescription: "Diagnosed and replaced faulty pool pump motor",
            supervisorApproval: "approved",
            approvedBy: "demo-admin",
            approvedAt: /* @__PURE__ */ new Date("2025-01-16"),
            hoursPaid: "2.5",
            hourlyRate: "35.00",
            totalPay: "131.25",
            // 2.5 hours * $35 * 1.5 (emergency rate)
            notes: "Quick response, excellent work quality",
            createdAt: /* @__PURE__ */ new Date("2025-01-15"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-16")
          },
          {
            id: 2,
            organizationId: organizationId2,
            userId: "demo-staff",
            userName: "John Staff",
            clockType: "emergency",
            shiftType: "clock_out",
            clockTime: /* @__PURE__ */ new Date("2025-01-15T17:00:00"),
            location: "Villa Sunset - Pool Area",
            propertyId: 1,
            propertyName: "Villa Sunset",
            reason: "Pool pump failure completion",
            workDescription: "Completed pool pump replacement and tested system",
            supervisorApproval: "approved",
            approvedBy: "demo-admin",
            approvedAt: /* @__PURE__ */ new Date("2025-01-16"),
            hoursPaid: "2.5",
            hourlyRate: "35.00",
            totalPay: "131.25",
            notes: "Job completed successfully",
            createdAt: /* @__PURE__ */ new Date("2025-01-15"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-16")
          },
          {
            id: 3,
            organizationId: organizationId2,
            userId: "demo-manager",
            userName: "Sarah Manager",
            clockType: "overtime",
            shiftType: "clock_in",
            clockTime: /* @__PURE__ */ new Date("2025-01-20T18:00:00"),
            location: "Office - Property Management",
            reason: "Guest complaint resolution - urgent booking issue",
            workDescription: "Resolved booking conflict and guest compensation",
            supervisorApproval: "pending",
            hoursPaid: "3.0",
            hourlyRate: "45.00",
            totalPay: "202.50",
            // 3 hours * $45 * 1.5 (overtime rate)
            notes: null,
            createdAt: /* @__PURE__ */ new Date("2025-01-20"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-20")
          }
        ];
        let filtered = timeClocks;
        if (filters?.userId) {
          filtered = filtered.filter((t) => t.userId === filters.userId);
        }
        if (filters?.clockType) {
          filtered = filtered.filter((t) => t.clockType === filters.clockType);
        }
        if (filters?.month) {
          const month = filters.month;
          filtered = filtered.filter((t) => t.clockTime.toISOString().startsWith(month));
        }
        return filtered;
      }
      async createStaffTimeClock(timeClock) {
        return {
          id: Math.floor(Math.random() * 1e3),
          ...timeClock,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async updateStaffTimeClock(id, updates) {
        return {
          id,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async approveTimeClock(id, approvedBy, hoursPaid, notes) {
        return {
          id,
          supervisorApproval: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          hoursPaid: hoursPaid.toString(),
          notes,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Emergency Callout Summary
      async getEmergencyCalloutSummary(organizationId2, month) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            userId: "demo-staff",
            userName: "John Staff",
            month: "2025-01",
            totalCallouts: 12,
            totalHours: "28.5",
            totalPay: "1425.00",
            averageResponseTime: 25,
            // minutes
            bonusEligible: true,
            bonusAmount: "200.00",
            bonusApproved: true,
            lastUpdated: /* @__PURE__ */ new Date()
          },
          {
            id: 2,
            organizationId: organizationId2,
            userId: "demo-manager",
            userName: "Sarah Manager",
            month: "2025-01",
            totalCallouts: 8,
            totalHours: "18.0",
            totalPay: "1215.00",
            averageResponseTime: 15,
            bonusEligible: false,
            bonusAmount: "0.00",
            bonusApproved: false,
            lastUpdated: /* @__PURE__ */ new Date()
          }
        ];
      }
      async updateEmergencyCalloutSummary(userId, month) {
        return {
          userId,
          month,
          totalCallouts: 12,
          totalHours: "28.5",
          updated: true,
          lastUpdated: /* @__PURE__ */ new Date()
        };
      }
      // ===== INVOICE GENERATOR =====
      // Invoice Operations
      async getInvoices(organizationId2, filters) {
        const invoices2 = [
          {
            id: 1,
            organizationId: organizationId2,
            invoiceNumber: "INV-2025-001",
            invoiceType: "owner_to_company",
            fromPartyType: "owner",
            fromPartyId: "demo-owner",
            fromPartyName: "Villa Owner LLC",
            toPartyType: "company",
            toPartyId: "default-org",
            toPartyName: "HostPilotPro Management",
            propertyId: 1,
            propertyName: "Villa Sunset",
            description: "Monthly management fee for January 2025",
            subtotal: "2500.00",
            vatEnabled: true,
            vatRate: "10.00",
            vatAmount: "250.00",
            totalAmount: "2750.00",
            currency: "AUD",
            dueDate: /* @__PURE__ */ new Date("2025-02-15"),
            status: "sent",
            receiptUrl: null,
            notes: "Standard monthly management fee",
            createdBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2025-01-31"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-31")
          },
          {
            id: 2,
            organizationId: organizationId2,
            invoiceNumber: "INV-2025-002",
            invoiceType: "company_to_owner",
            fromPartyType: "company",
            fromPartyId: "default-org",
            fromPartyName: "HostPilotPro Management",
            toPartyType: "owner",
            toPartyId: "demo-owner",
            toPartyName: "Villa Owner LLC",
            propertyId: 1,
            propertyName: "Villa Sunset",
            description: "Emergency pool pump repair costs",
            subtotal: "850.00",
            vatEnabled: true,
            vatRate: "10.00",
            vatAmount: "85.00",
            totalAmount: "935.00",
            currency: "AUD",
            dueDate: /* @__PURE__ */ new Date("2025-02-20"),
            status: "draft",
            receiptUrl: "/uploads/pool-pump-receipt.pdf",
            notes: "Emergency repair completed by John Staff",
            createdBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2025-01-25"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-25")
          },
          {
            id: 3,
            organizationId: organizationId2,
            invoiceNumber: "INV-2025-003",
            invoiceType: "pm_to_company",
            fromPartyType: "pm",
            fromPartyId: "demo-manager",
            fromPartyName: "Sarah Manager",
            toPartyType: "company",
            toPartyId: "default-org",
            toPartyName: "HostPilotPro Management",
            propertyId: 2,
            propertyName: "Ocean View Apartment",
            description: "Portfolio Manager payout request for January",
            subtotal: "3200.00",
            vatEnabled: false,
            vatRate: "0.00",
            vatAmount: "0.00",
            totalAmount: "3200.00",
            currency: "AUD",
            dueDate: /* @__PURE__ */ new Date("2025-02-10"),
            status: "pending",
            receiptUrl: null,
            notes: "Monthly PM commission and bonus",
            createdBy: "demo-manager",
            createdAt: /* @__PURE__ */ new Date("2025-02-01"),
            updatedAt: /* @__PURE__ */ new Date("2025-02-01")
          }
        ];
        let filtered = invoices2;
        if (filters?.fromPartyId) {
          filtered = filtered.filter((i) => i.fromPartyId === filters.fromPartyId);
        }
        if (filters?.toPartyId) {
          filtered = filtered.filter((i) => i.toPartyId === filters.toPartyId);
        }
        if (filters?.status) {
          filtered = filtered.filter((i) => i.status === filters.status);
        }
        return filtered;
      }
      async getInvoice(id) {
        const invoices2 = await this.getInvoices("default-org");
        return invoices2.find((i) => i.id === id);
      }
      async createInvoice(invoice) {
        const invoiceNumber = `INV-${(/* @__PURE__ */ new Date()).getFullYear()}-${String(Math.floor(Math.random() * 999) + 1).padStart(3, "0")}`;
        return {
          id: Math.floor(Math.random() * 1e3),
          invoiceNumber,
          ...invoice,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async updateInvoice(id, updates) {
        const invoice = await this.getInvoice(id);
        if (invoice) {
          return { ...invoice, ...updates, updatedAt: /* @__PURE__ */ new Date() };
        }
        return void 0;
      }
      async deleteInvoice(id) {
        return true;
      }
      // Invoice Line Items
      async getInvoiceLineItems(invoiceId) {
        const lineItems = [
          // Line items for Invoice 1 (Management Fee)
          {
            id: 1,
            organizationId: "default-org",
            invoiceId: 1,
            description: "Property management fee",
            quantity: "1.00",
            unitPrice: "2000.00",
            lineTotal: "2000.00",
            category: "management_fee",
            orderIndex: 0,
            createdAt: /* @__PURE__ */ new Date()
          },
          {
            id: 2,
            organizationId: "default-org",
            invoiceId: 1,
            description: "Guest communication services",
            quantity: "1.00",
            unitPrice: "300.00",
            lineTotal: "300.00",
            category: "management_fee",
            orderIndex: 1,
            createdAt: /* @__PURE__ */ new Date()
          },
          {
            id: 3,
            organizationId: "default-org",
            invoiceId: 1,
            description: "Cleaning coordination",
            quantity: "1.00",
            unitPrice: "200.00",
            lineTotal: "200.00",
            category: "management_fee",
            orderIndex: 2,
            createdAt: /* @__PURE__ */ new Date()
          },
          // Line items for Invoice 2 (Emergency Repair)
          {
            id: 4,
            organizationId: "default-org",
            invoiceId: 2,
            description: "Pool pump replacement unit",
            quantity: "1.00",
            unitPrice: "650.00",
            lineTotal: "650.00",
            category: "maintenance",
            orderIndex: 0,
            createdAt: /* @__PURE__ */ new Date()
          },
          {
            id: 5,
            organizationId: "default-org",
            invoiceId: 2,
            description: "Emergency labor (2.5 hours)",
            quantity: "2.50",
            unitPrice: "80.00",
            lineTotal: "200.00",
            category: "maintenance",
            orderIndex: 1,
            createdAt: /* @__PURE__ */ new Date()
          },
          // Line items for Invoice 3 (PM Payout)
          {
            id: 6,
            organizationId: "default-org",
            invoiceId: 3,
            description: "Portfolio management commission (January)",
            quantity: "1.00",
            unitPrice: "2800.00",
            lineTotal: "2800.00",
            category: "commission",
            orderIndex: 0,
            createdAt: /* @__PURE__ */ new Date()
          },
          {
            id: 7,
            organizationId: "default-org",
            invoiceId: 3,
            description: "Performance bonus",
            quantity: "1.00",
            unitPrice: "400.00",
            lineTotal: "400.00",
            category: "commission",
            orderIndex: 1,
            createdAt: /* @__PURE__ */ new Date()
          }
        ];
        return lineItems.filter((item) => item.invoiceId === invoiceId);
      }
      async createInvoiceLineItem(lineItem) {
        return {
          id: Math.floor(Math.random() * 1e3),
          ...lineItem,
          createdAt: /* @__PURE__ */ new Date()
        };
      }
      async updateInvoiceLineItem(id, updates) {
        return {
          id,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async deleteInvoiceLineItem(id) {
        return true;
      }
      // Invoice Payments
      async getInvoicePayments(invoiceId) {
        return [
          {
            id: 1,
            organizationId: "default-org",
            invoiceId: 1,
            paymentAmount: "2750.00",
            paymentMethod: "bank_transfer",
            paymentReference: "BT-2025-001",
            paymentDate: /* @__PURE__ */ new Date("2025-02-15"),
            receiptUrl: "/uploads/payment-receipt-001.pdf",
            notes: "Payment received on time",
            recordedBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2025-02-15")
          }
        ];
      }
      async createInvoicePayment(payment) {
        return {
          id: Math.floor(Math.random() * 1e3),
          ...payment,
          createdAt: /* @__PURE__ */ new Date()
        };
      }
      // Salary Analytics
      async getSalaryAnalytics(organizationId2, month) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            month: "2025-01",
            totalStaffCost: "12000.00",
            totalOvertimeCost: "2500.00",
            totalBonusCost: "800.00",
            totalEmergencyCost: "1800.00",
            activeStaffCount: 4,
            averageSalary: "5500.00",
            highestOvertimeUser: "John Staff",
            highestOvertimeHours: "28.50",
            lastUpdated: /* @__PURE__ */ new Date()
          }
        ];
      }
      async updateSalaryAnalytics(organizationId2, month) {
        return {
          organizationId: organizationId2,
          month,
          updated: true,
          lastUpdated: /* @__PURE__ */ new Date()
        };
      }
      // ===== AI GUEST PORTAL & SMART COMMUNICATION CENTER METHODS =====
      // Guest Message Management
      async getGuestMessages(organizationId2, filters = {}) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            guestId: "guest-001",
            guestName: "Sarah Johnson",
            guestEmail: "sarah.johnson@example.com",
            bookingId: 101,
            propertyId: 1,
            messageContent: "The pool seems dirty and there's no hot water in the bathroom. Could someone please look into this?",
            messageType: "complaint",
            priority: "high",
            status: "new",
            aiProcessed: true,
            aiKeywords: ["pool", "maintenance", "water"],
            aiSentiment: "negative",
            aiConfidence: "0.92",
            aiSuggestions: ["Create pool maintenance task", "Create plumbing task"],
            staffResponse: null,
            respondedBy: null,
            respondedAt: null,
            createdAt: /* @__PURE__ */ new Date("2025-01-03T10:30:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-03T10:30:00Z")
          },
          {
            id: 2,
            organizationId: organizationId2,
            guestId: "guest-002",
            guestName: "Mike Chen",
            guestEmail: "mike.chen@example.com",
            bookingId: 102,
            propertyId: 1,
            messageContent: "We would love to book a massage for tomorrow evening. Can you arrange that for us?",
            messageType: "request",
            priority: "normal",
            status: "acknowledged",
            aiProcessed: true,
            aiKeywords: ["massage", "booking"],
            aiSentiment: "positive",
            aiConfidence: "0.95",
            aiSuggestions: ["Create service booking", "Contact massage therapist"],
            staffResponse: "We'll arrange a massage for you tomorrow evening. I'll contact our therapist and get back to you with available times.",
            respondedBy: "demo-staff",
            respondedAt: /* @__PURE__ */ new Date("2025-01-03T11:15:00Z"),
            createdAt: /* @__PURE__ */ new Date("2025-01-03T09:45:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-03T11:15:00Z")
          },
          {
            id: 3,
            organizationId: organizationId2,
            guestId: "guest-003",
            guestName: "Emma Williams",
            guestEmail: "emma.williams@example.com",
            bookingId: 103,
            propertyId: 2,
            messageContent: "The wifi password isn't working. Could you please help?",
            messageType: "chat",
            priority: "normal",
            status: "resolved",
            aiProcessed: true,
            aiKeywords: ["wifi", "password"],
            aiSentiment: "neutral",
            aiConfidence: "0.88",
            aiSuggestions: ["Provide wifi credentials", "Check router status"],
            staffResponse: "The wifi password is 'VillaSunset2025'. Let me know if you still have issues!",
            respondedBy: "demo-staff",
            respondedAt: /* @__PURE__ */ new Date("2025-01-03T08:20:00Z"),
            createdAt: /* @__PURE__ */ new Date("2025-01-03T08:10:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-03T08:20:00Z")
          }
        ].filter((message) => {
          if (filters.guestId && message.guestId !== filters.guestId) return false;
          if (filters.propertyId && message.propertyId !== parseInt(filters.propertyId)) return false;
          if (filters.messageType && message.messageType !== filters.messageType) return false;
          if (filters.priority && message.priority !== filters.priority) return false;
          if (filters.status && message.status !== filters.status) return false;
          return true;
        });
      }
      async createGuestMessage(messageData) {
        const newMessage = {
          id: Date.now(),
          ...messageData,
          aiProcessed: false,
          status: "new",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        const aiAnalysis = await this.processMessageForKeywords(messageData.messageContent);
        newMessage.aiProcessed = true;
        newMessage.aiKeywords = aiAnalysis.keywords;
        newMessage.aiSentiment = aiAnalysis.sentiment;
        newMessage.aiConfidence = aiAnalysis.confidence.toString();
        newMessage.priority = aiAnalysis.priority;
        newMessage.aiSuggestions = aiAnalysis.suggestions;
        return newMessage;
      }
      async updateGuestMessage(id, updateData) {
        return { id, ...updateData, updatedAt: /* @__PURE__ */ new Date() };
      }
      async processMessageWithAI(messageId, aiData) {
        return { id: messageId, aiProcessed: true, ...aiData, updatedAt: /* @__PURE__ */ new Date() };
      }
      async respondToGuestMessage(messageId, response, respondedBy) {
        return {
          id: messageId,
          staffResponse: response,
          respondedBy,
          respondedAt: /* @__PURE__ */ new Date(),
          status: "resolved",
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // AI-Generated Task Management
      async getAiGeneratedTasks(organizationId2, filters = {}) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            messageId: 1,
            taskId: null,
            guestId: "guest-001",
            propertyId: 1,
            department: "pool",
            taskType: "issue_report",
            urgency: "high",
            aiDescription: "Guest reported: The pool seems dirty and there's no hot water in the bathroom.",
            aiKeywords: ["pool", "maintenance", "water"],
            confidence: "0.92",
            status: "pending",
            assignedTo: null,
            approvedBy: null,
            approvedAt: null,
            completedAt: null,
            createdAt: /* @__PURE__ */ new Date("2025-01-03T10:31:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-03T10:31:00Z")
          },
          {
            id: 2,
            organizationId: organizationId2,
            messageId: 2,
            taskId: null,
            guestId: "guest-002",
            propertyId: 1,
            department: "general",
            taskType: "service_request",
            urgency: "medium",
            aiDescription: "Guest reported: We would love to book a massage for tomorrow evening.",
            aiKeywords: ["massage", "booking"],
            confidence: "0.95",
            status: "approved",
            assignedTo: "demo-staff",
            approvedBy: "demo-admin",
            approvedAt: /* @__PURE__ */ new Date("2025-01-03T11:00:00Z"),
            completedAt: null,
            createdAt: /* @__PURE__ */ new Date("2025-01-03T09:46:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-03T11:00:00Z")
          }
        ].filter((task) => {
          if (filters.department && task.department !== filters.department) return false;
          if (filters.status && task.status !== filters.status) return false;
          if (filters.urgency && task.urgency !== filters.urgency) return false;
          if (filters.assignedTo && task.assignedTo !== filters.assignedTo) return false;
          return true;
        });
      }
      async createAiGeneratedTask(taskData) {
        return {
          id: Date.now(),
          ...taskData,
          status: "pending",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async approveAiTask(taskId, approvedBy) {
        return {
          id: taskId,
          status: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async rejectAiTask(taskId, approvedBy) {
        return {
          id: taskId,
          status: "rejected",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async completeAiTask(taskId) {
        return {
          id: taskId,
          status: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Guest Service Request Management
      async getGuestServiceRequests(organizationId2, filters = {}) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            guestId: "guest-002",
            guestName: "Mike Chen",
            bookingId: 102,
            propertyId: 1,
            serviceType: "massage",
            serviceName: "Traditional Thai Massage",
            requestedDate: /* @__PURE__ */ new Date("2025-01-04T19:00:00Z"),
            requestedTime: "19:00",
            numberOfGuests: 2,
            specialRequests: "Couples massage preferred",
            estimatedCost: "180.00",
            currency: "AUD",
            paymentMethod: "guest_charge",
            status: "confirmed",
            confirmedBy: "demo-staff",
            confirmedAt: /* @__PURE__ */ new Date("2025-01-03T11:30:00Z"),
            completedAt: null,
            guestRating: null,
            guestFeedback: null,
            createdAt: /* @__PURE__ */ new Date("2025-01-03T09:46:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-03T11:30:00Z")
          },
          {
            id: 2,
            organizationId: organizationId2,
            guestId: "guest-004",
            guestName: "David Thompson",
            bookingId: 104,
            propertyId: 2,
            serviceType: "taxi",
            serviceName: "Airport Transfer",
            requestedDate: /* @__PURE__ */ new Date("2025-01-05T09:00:00Z"),
            requestedTime: "09:00",
            numberOfGuests: 4,
            specialRequests: "Large SUV needed for luggage",
            estimatedCost: "85.00",
            currency: "AUD",
            paymentMethod: "guest_charge",
            status: "pending",
            confirmedBy: null,
            confirmedAt: null,
            completedAt: null,
            guestRating: null,
            guestFeedback: null,
            createdAt: /* @__PURE__ */ new Date("2025-01-03T14:20:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-03T14:20:00Z")
          },
          {
            id: 3,
            organizationId: organizationId2,
            guestId: "guest-005",
            guestName: "Lisa Martinez",
            bookingId: 105,
            propertyId: 1,
            serviceType: "chef",
            serviceName: "Private Chef Dinner",
            requestedDate: /* @__PURE__ */ new Date("2025-01-06T18:00:00Z"),
            requestedTime: "18:00",
            numberOfGuests: 6,
            specialRequests: "Seafood-focused menu, one vegetarian option",
            estimatedCost: "450.00",
            currency: "AUD",
            paymentMethod: "owner_sponsored",
            status: "completed",
            confirmedBy: "demo-manager",
            confirmedAt: /* @__PURE__ */ new Date("2025-01-02T16:45:00Z"),
            completedAt: /* @__PURE__ */ new Date("2025-01-02T22:30:00Z"),
            guestRating: 5,
            guestFeedback: "Absolutely amazing dinner! The chef was fantastic and the food was incredible.",
            createdAt: /* @__PURE__ */ new Date("2025-01-02T15:10:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-02T22:30:00Z")
          }
        ].filter((request) => {
          if (filters.guestId && request.guestId !== filters.guestId) return false;
          if (filters.propertyId && request.propertyId !== parseInt(filters.propertyId)) return false;
          if (filters.serviceType && request.serviceType !== filters.serviceType) return false;
          if (filters.status && request.status !== filters.status) return false;
          return true;
        });
      }
      async createGuestServiceRequest(requestData) {
        return {
          id: Date.now(),
          ...requestData,
          status: "pending",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async updateServiceRequest(id, updateData) {
        return { id, ...updateData, updatedAt: /* @__PURE__ */ new Date() };
      }
      async confirmServiceRequest(id, confirmedBy) {
        return {
          id,
          status: "confirmed",
          confirmedBy,
          confirmedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async completeServiceRequest(id, guestRating, guestFeedback2) {
        return {
          id,
          status: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          guestRating,
          guestFeedback: guestFeedback2,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // AI Smart Suggestions Management
      async getAiSmartSuggestions(organizationId2, filters = {}) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: 1,
            suggestionType: "service_upsell",
            targetAudience: "guest",
            suggestionTitle: "Offer Welcome Spa Package",
            suggestionDescription: "Based on guest feedback analysis, 78% of guests mention wanting relaxation services. Offering a welcome spa package could increase revenue by 25%.",
            basedOnData: "guest_reviews",
            confidence: "0.92",
            potentialRevenue: "2500.00",
            implementationCost: "800.00",
            priority: "high",
            status: "pending",
            reviewedBy: null,
            reviewedAt: null,
            implementedAt: null,
            notes: null,
            createdAt: /* @__PURE__ */ new Date("2025-01-03T12:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-03T12:00:00Z")
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: 2,
            suggestionType: "maintenance_improvement",
            targetAudience: "owner",
            suggestionTitle: "Upgrade Pool Filtration System",
            suggestionDescription: "Analysis of guest complaints shows 23% mention pool cleanliness. Upgrading the filtration system could reduce maintenance costs and improve satisfaction.",
            basedOnData: "message_analysis",
            confidence: "0.87",
            potentialRevenue: "0.00",
            implementationCost: "3200.00",
            priority: "medium",
            status: "reviewed",
            reviewedBy: "demo-admin",
            reviewedAt: /* @__PURE__ */ new Date("2025-01-02T14:30:00Z"),
            implementedAt: null,
            notes: "Good suggestion - will discuss with property owner",
            createdAt: /* @__PURE__ */ new Date("2025-01-02T10:15:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-02T14:30:00Z")
          },
          {
            id: 3,
            organizationId: organizationId2,
            propertyId: 1,
            suggestionType: "guest_experience",
            targetAudience: "staff",
            suggestionTitle: "Proactive WiFi Support",
            suggestionDescription: "15% of guest messages are about WiFi issues. Create a proactive check-in process to provide WiFi credentials and troubleshooting guide.",
            basedOnData: "service_patterns",
            confidence: "0.94",
            potentialRevenue: "0.00",
            implementationCost: "150.00",
            priority: "medium",
            status: "implemented",
            reviewedBy: "demo-manager",
            reviewedAt: /* @__PURE__ */ new Date("2025-01-01T16:00:00Z"),
            implementedAt: /* @__PURE__ */ new Date("2025-01-02T09:00:00Z"),
            notes: "Implemented as part of standard check-in procedure",
            createdAt: /* @__PURE__ */ new Date("2025-01-01T14:20:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-02T09:00:00Z")
          }
        ].filter((suggestion) => {
          if (filters.suggestionType && suggestion.suggestionType !== filters.suggestionType) return false;
          if (filters.targetAudience && suggestion.targetAudience !== filters.targetAudience) return false;
          if (filters.status && suggestion.status !== filters.status) return false;
          if (filters.priority && suggestion.priority !== filters.priority) return false;
          return true;
        });
      }
      async createAiSmartSuggestion(suggestionData) {
        return {
          id: Date.now(),
          ...suggestionData,
          status: "pending",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async reviewAiSuggestion(id, reviewedBy, status, notes) {
        return {
          id,
          status,
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          notes,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async implementAiSuggestion(id) {
        return {
          id,
          status: "implemented",
          implementedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Guest Communication Notification Management
      async getGuestCommunicationNotifications(recipientId, filters = {}) {
        return [
          {
            id: 1,
            organizationId: "default-org",
            messageId: 1,
            serviceRequestId: null,
            taskId: 1,
            recipientId,
            recipientRole: "staff",
            notificationType: "urgent_issue",
            title: "Urgent Guest Issue - Pool Maintenance",
            message: "Guest Sarah Johnson reported pool cleanliness issues. AI has created a high-priority task.",
            isRead: false,
            readAt: null,
            createdAt: /* @__PURE__ */ new Date("2025-01-03T10:31:00Z")
          },
          {
            id: 2,
            organizationId: "default-org",
            messageId: 2,
            serviceRequestId: 1,
            taskId: null,
            recipientId,
            recipientRole: "staff",
            notificationType: "service_request",
            title: "New Service Request - Massage Booking",
            message: "Guest Mike Chen requested massage service for tomorrow evening.",
            isRead: true,
            readAt: /* @__PURE__ */ new Date("2025-01-03T11:00:00Z"),
            createdAt: /* @__PURE__ */ new Date("2025-01-03T09:46:00Z")
          }
        ].filter((notification) => {
          if (filters.notificationType && notification.notificationType !== filters.notificationType) return false;
          if (filters.isRead !== void 0 && notification.isRead !== filters.isRead) return false;
          return true;
        });
      }
      async createGuestCommunicationNotification(notificationData) {
        return {
          id: Date.now(),
          ...notificationData,
          isRead: false,
          createdAt: /* @__PURE__ */ new Date()
        };
      }
      async markNotificationAsRead(id) {
        return {
          id,
          isRead: true,
          readAt: /* @__PURE__ */ new Date()
        };
      }
      async getUnreadNotificationCount(recipientId) {
        const notifications2 = await this.getGuestCommunicationNotifications(recipientId);
        return notifications2.filter((n) => !n.isRead).length;
      }
      // Guest Portal Settings Management
      async getGuestPortalSettings(organizationId2, propertyId) {
        return {
          id: 1,
          organizationId: organizationId2,
          propertyId: propertyId || null,
          enableGuestPortal: true,
          enableAiAssistant: true,
          enableServiceBooking: true,
          enableChatSystem: true,
          autoCreateTasks: true,
          aiConfidenceThreshold: "0.75",
          responseTimeTarget: 30,
          welcomeMessage: "Welcome to your luxury villa! We're here to make your stay perfect. Feel free to reach out if you need anything.",
          contactInfo: "For immediate assistance, contact us via the chat system or call +61 400 123 456",
          emergencyContact: "+61 400 999 888",
          checkInInstructions: "Your villa is ready for check-in at 3:00 PM. The door code is provided via SMS. WiFi password: VillaSunset2025",
          checkOutInstructions: "Check-out is at 11:00 AM. Please leave keys on the kitchen counter and ensure all amenities are turned off.",
          wifiPassword: "VillaSunset2025",
          localRecommendations: [
            "Patong Beach - 5 minutes walk",
            "Kata Noi Beach - 10 minutes drive",
            "Blue Elephant Restaurant - Authentic Thai cuisine",
            "Siam Niramit Show - Cultural performance",
            "Big Buddha - Must-visit attraction"
          ],
          createdAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z"),
          updatedAt: /* @__PURE__ */ new Date("2025-01-03T00:00:00Z")
        };
      }
      async updateGuestPortalSettings(organizationId2, settingsData) {
        return {
          id: 1,
          organizationId: organizationId2,
          ...settingsData,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Guest Dashboard Analytics
      async getGuestDashboardAnalytics(organizationId2, month, propertyId) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            month: month || "2025-01",
            totalMessages: 28,
            totalServiceRequests: 12,
            averageResponseTime: "18.5",
            guestSatisfactionScore: "4.6",
            topRequestedServices: ["massage", "taxi", "chef"],
            commonIssues: ["wifi", "pool_maintenance", "air_conditioning"],
            aiTaskCreationRate: "0.85",
            resolutionRate: "0.94",
            createdAt: /* @__PURE__ */ new Date("2025-01-03T00:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-03T12:00:00Z")
          }
        ];
      }
      async updateGuestDashboardAnalytics(organizationId2, month, propertyId) {
        return {
          organizationId: organizationId2,
          propertyId,
          month,
          updated: true,
          lastUpdated: /* @__PURE__ */ new Date()
        };
      }
      // AI Processing Simulation Methods
      async processMessageForKeywords(messageContent) {
        const keywords = [];
        const lowerContent = messageContent.toLowerCase();
        if (lowerContent.includes("pool") || lowerContent.includes("swimming")) keywords.push("pool");
        if (lowerContent.includes("ac") || lowerContent.includes("air conditioning") || lowerContent.includes("cold") || lowerContent.includes("hot")) keywords.push("air_conditioning");
        if (lowerContent.includes("wifi") || lowerContent.includes("internet")) keywords.push("wifi");
        if (lowerContent.includes("clean") || lowerContent.includes("dirty")) keywords.push("cleaning");
        if (lowerContent.includes("broken") || lowerContent.includes("not working")) keywords.push("maintenance");
        if (lowerContent.includes("massage")) keywords.push("massage");
        if (lowerContent.includes("taxi") || lowerContent.includes("transport")) keywords.push("transportation");
        return {
          keywords,
          sentiment: lowerContent.includes("great") || lowerContent.includes("amazing") ? "positive" : lowerContent.includes("terrible") || lowerContent.includes("awful") ? "negative" : "neutral",
          confidence: Math.random() * 0.3 + 0.7,
          // 0.7-1.0
          priority: keywords.includes("broken") || lowerContent.includes("urgent") ? "urgent" : "normal",
          suggestions: keywords.length > 0 ? [`Create ${keywords[0]} task`, "Notify relevant staff"] : []
        };
      }
      async generateTaskFromMessage(messageId, messageData, aiAnalysis) {
        const departmentMap = {
          pool: "pool",
          air_conditioning: "maintenance",
          wifi: "general",
          cleaning: "cleaning",
          maintenance: "maintenance",
          massage: "general",
          transportation: "general"
        };
        const primaryKeyword = aiAnalysis.keywords[0];
        const department = departmentMap[primaryKeyword] || "general";
        const urgency = aiAnalysis.priority === "urgent" ? "critical" : "medium";
        const taskData = {
          organizationId: messageData.organizationId,
          messageId,
          guestId: messageData.guestId,
          propertyId: messageData.propertyId,
          department,
          taskType: "issue_report",
          urgency,
          aiDescription: `Guest reported: ${messageData.messageContent}`,
          aiKeywords: aiAnalysis.keywords,
          confidence: aiAnalysis.confidence,
          status: "pending"
        };
        return await this.createAiGeneratedTask(taskData);
      }
      // ==================== STAFF CLOCK-IN & OVERTIME TRACKER ====================
      // Staff Work Clock Methods
      async clockIn(clockData) {
        const [newClock] = await db.insert(staffWorkClocks).values(clockData).returning();
        return newClock;
      }
      async clockOut(organizationId2, userId, clockOutNotes) {
        const [updated] = await db.update(staffWorkClocks).set({
          clockOutTime: /* @__PURE__ */ new Date(),
          clockOutNotes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and3(
            eq2(staffWorkClocks.organizationId, organizationId2),
            eq2(staffWorkClocks.userId, userId),
            isNull2(staffWorkClocks.clockOutTime)
          )
        ).returning();
        return updated;
      }
      async getActiveClock(organizationId2, userId) {
        const [activeClock] = await db.select().from(staffWorkClocks).where(
          and3(
            eq2(staffWorkClocks.organizationId, organizationId2),
            eq2(staffWorkClocks.userId, userId),
            isNull2(staffWorkClocks.clockOutTime)
          )
        );
        return activeClock;
      }
      async getStaffClockHistory(organizationId2, filters) {
        let query = db.select().from(staffWorkClocks).where(eq2(staffWorkClocks.organizationId, organizationId2));
        if (filters?.userId) {
          query = query.where(eq2(staffWorkClocks.userId, filters.userId));
        }
        if (filters?.startDate) {
          query = query.where(gte2(staffWorkClocks.clockInTime, filters.startDate));
        }
        if (filters?.endDate) {
          query = query.where(lte2(staffWorkClocks.clockInTime, filters.endDate));
        }
        if (filters?.clockType) {
          query = query.where(eq2(staffWorkClocks.clockType, filters.clockType));
        }
        return query.orderBy(desc2(staffWorkClocks.clockInTime));
      }
      // Staff Clock Settings Methods
      async getStaffClockSettings(organizationId2) {
        const [settings] = await db.select().from(staffClockSettings).where(eq2(staffClockSettings.organizationId, organizationId2));
        return settings;
      }
      async updateStaffClockSettings(organizationId2, settings) {
        const existing = await this.getStaffClockSettings(organizationId2);
        if (existing) {
          const [updated] = await db.update(staffClockSettings).set({ ...settings, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffClockSettings.organizationId, organizationId2)).returning();
          return updated;
        } else {
          const [created] = await db.insert(staffClockSettings).values({ organizationId: organizationId2, ...settings }).returning();
          return created;
        }
      }
      // Staff Time Summary Methods
      async createStaffTimeSummary(summary) {
        const [newSummary] = await db.insert(staffTimeSummaries).values(summary).returning();
        return newSummary;
      }
      async getStaffTimeSummaries(organizationId2, filters) {
        let query = db.select().from(staffTimeSummaries).where(eq2(staffTimeSummaries.organizationId, organizationId2));
        if (filters?.userId) {
          query = query.where(eq2(staffTimeSummaries.userId, filters.userId));
        }
        if (filters?.periodType) {
          query = query.where(eq2(staffTimeSummaries.periodType, filters.periodType));
        }
        if (filters?.periodStart) {
          query = query.where(gte2(staffTimeSummaries.periodStart, filters.periodStart));
        }
        if (filters?.periodEnd) {
          query = query.where(lte2(staffTimeSummaries.periodEnd, filters.periodEnd));
        }
        return query.orderBy(desc2(staffTimeSummaries.periodStart));
      }
      async updateStaffTimeSummary(id, updates) {
        const [updated] = await db.update(staffTimeSummaries).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffTimeSummaries.id, id)).returning();
        return updated;
      }
      // Staff Clock Audit Log Methods
      async createStaffClockAuditLog(auditData) {
        const [newAudit] = await db.insert(staffClockAuditLog).values(auditData).returning();
        return newAudit;
      }
      async getStaffClockAuditLogs(organizationId2, filters) {
        let query = db.select().from(staffClockAuditLog).where(eq2(staffClockAuditLog.organizationId, organizationId2));
        if (filters?.actionType) {
          query = query.where(eq2(staffClockAuditLog.actionType, filters.actionType));
        }
        if (filters?.performedBy) {
          query = query.where(eq2(staffClockAuditLog.performedBy, filters.performedBy));
        }
        if (filters?.affectedUserId) {
          query = query.where(eq2(staffClockAuditLog.affectedUserId, filters.affectedUserId));
        }
        if (filters?.startDate) {
          query = query.where(gte2(staffClockAuditLog.createdAt, filters.startDate));
        }
        if (filters?.endDate) {
          query = query.where(lte2(staffClockAuditLog.createdAt, filters.endDate));
        }
        return query.orderBy(desc2(staffClockAuditLog.createdAt));
      }
      // Helper Methods for Overtime Calculations
      async calculateOvertimeForPeriod(organizationId2, userId, startDate, endDate) {
        const clocks = await this.getStaffClockHistory(organizationId2, {
          userId,
          startDate,
          endDate
        });
        const settings = await this.getStaffClockSettings(organizationId2);
        const dailyHoursLimit = settings?.dailyHoursLimit || 8;
        const weeklyHoursLimit = settings?.weeklyHoursLimit || 40;
        let totalHours = 0;
        let overtimeHours = 0;
        let emergencyVisits = 0;
        let afterHoursTotal = 0;
        clocks.forEach((clock) => {
          if (clock.clockOutTime) {
            const duration = (new Date(clock.clockOutTime).getTime() - new Date(clock.clockInTime).getTime()) / (1e3 * 60 * 60);
            totalHours += duration;
            if (clock.isEmergencyVisit) {
              emergencyVisits++;
            }
            if (clock.isAfterHours) {
              afterHoursTotal += duration;
            }
          }
        });
        const regularHours = Math.min(totalHours, weeklyHoursLimit);
        overtimeHours = Math.max(0, totalHours - weeklyHoursLimit);
        return {
          regularHours,
          overtimeHours,
          totalHours,
          emergencyVisits,
          afterHoursTotal
        };
      }
      async generateStaffTimeReport(organizationId2, filters) {
        const startDate = filters?.startDate || new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1);
        const endDate = filters?.endDate || /* @__PURE__ */ new Date();
        const staffUsers = filters?.userId ? [{ id: filters.userId, username: "Staff User", role: "staff" }] : await this.getUsersByRole(organizationId2, "staff");
        const staffReports = await Promise.all(
          staffUsers.map(async (user) => {
            const overtime = await this.calculateOvertimeForPeriod(organizationId2, user.id, startDate, endDate);
            const settings = await this.getStaffClockSettings(organizationId2);
            const hourlyRate = settings?.defaultHourlyRate || 25;
            const overtimeMultiplier = settings?.overtimeMultiplier || 1.5;
            const estimatedPay = overtime.regularHours * hourlyRate + overtime.overtimeHours * hourlyRate * overtimeMultiplier;
            return {
              userId: user.id,
              userName: user.username || user.email || "Unknown User",
              regularHours: overtime.regularHours,
              overtimeHours: overtime.overtimeHours,
              totalHours: overtime.totalHours,
              emergencyVisits: overtime.emergencyVisits,
              afterHoursTotal: overtime.afterHoursTotal,
              estimatedPay
            };
          })
        );
        const totals = staffReports.reduce(
          (acc, report) => ({
            totalRegularHours: acc.totalRegularHours + report.regularHours,
            totalOvertimeHours: acc.totalOvertimeHours + report.overtimeHours,
            totalEstimatedPay: acc.totalEstimatedPay + report.estimatedPay
          }),
          { totalRegularHours: 0, totalOvertimeHours: 0, totalEstimatedPay: 0 }
        );
        return {
          reportPeriod: `${startDate.toISOString().split("T")[0]} to ${endDate.toISOString().split("T")[0]}`,
          staffReports,
          ...totals
        };
      }
      // ==================== MAINTENANCE SUGGESTIONS & APPROVAL FLOW ====================
      // Maintenance suggestions operations
      async getMaintenanceSuggestions(organizationId2, filters) {
        let query = db.select().from(maintenanceSuggestions).where(eq2(maintenanceSuggestions.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(maintenanceSuggestions.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          query = query.where(eq2(maintenanceSuggestions.status, filters.status));
        }
        if (filters?.submittedBy) {
          query = query.where(eq2(maintenanceSuggestions.submittedBy, filters.submittedBy));
        }
        return query.orderBy(desc2(maintenanceSuggestions.createdAt));
      }
      async getMaintenanceSuggestion(id) {
        const [suggestion] = await db.select().from(maintenanceSuggestions).where(eq2(maintenanceSuggestions.id, id));
        return suggestion;
      }
      async createMaintenanceSuggestion(suggestion) {
        const [newSuggestion] = await db.insert(maintenanceSuggestions).values(suggestion).returning();
        return newSuggestion;
      }
      async updateMaintenanceSuggestion(id, suggestion) {
        const [updated] = await db.update(maintenanceSuggestions).set({ ...suggestion, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(maintenanceSuggestions.id, id)).returning();
        return updated;
      }
      async deleteMaintenanceSuggestion(id) {
        const result = await db.delete(maintenanceSuggestions).where(eq2(maintenanceSuggestions.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Owner approval workflow
      async approveMaintenanceSuggestion(id, ownerId, comments) {
        const [updated] = await db.update(maintenanceSuggestions).set({
          status: "approved",
          ownerResponse: "approved",
          ownerComments: comments,
          ownerRespondedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(maintenanceSuggestions.id, id)).returning();
        if (updated) {
          await this.createMaintenanceApprovalLog({
            organizationId: updated.organizationId,
            suggestionId: id,
            actionType: "approved",
            actionBy: ownerId,
            actionByRole: "owner",
            newStatus: "approved",
            comments: comments || ""
          });
        }
        return updated;
      }
      async declineMaintenanceSuggestion(id, ownerId, comments) {
        const [updated] = await db.update(maintenanceSuggestions).set({
          status: "declined",
          ownerResponse: "declined",
          ownerComments: comments,
          ownerRespondedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(maintenanceSuggestions.id, id)).returning();
        if (updated) {
          await this.createMaintenanceApprovalLog({
            organizationId: updated.organizationId,
            suggestionId: id,
            actionType: "declined",
            actionBy: ownerId,
            actionByRole: "owner",
            newStatus: "declined",
            comments: comments || ""
          });
        }
        return updated;
      }
      // Approval logs
      async getMaintenanceApprovalLogs(organizationId2, suggestionId) {
        let query = db.select().from(maintenanceApprovalLogs).where(eq2(maintenanceApprovalLogs.organizationId, organizationId2));
        if (suggestionId) {
          query = query.where(eq2(maintenanceApprovalLogs.suggestionId, suggestionId));
        }
        return query.orderBy(desc2(maintenanceApprovalLogs.createdAt));
      }
      async createMaintenanceApprovalLog(log2) {
        const [newLog] = await db.insert(maintenanceApprovalLogs).values(log2).returning();
        return newLog;
      }
      // Settings
      async getMaintenanceSuggestionSettings(organizationId2) {
        const [settings] = await db.select().from(maintenanceSuggestionSettings).where(eq2(maintenanceSuggestionSettings.organizationId, organizationId2));
        return settings;
      }
      async updateMaintenanceSuggestionSettings(organizationId2, settings) {
        const [existing] = await db.select().from(maintenanceSuggestionSettings).where(eq2(maintenanceSuggestionSettings.organizationId, organizationId2));
        if (existing) {
          const [updated] = await db.update(maintenanceSuggestionSettings).set({ ...settings, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(maintenanceSuggestionSettings.organizationId, organizationId2)).returning();
          return updated;
        } else {
          const [newSettings] = await db.insert(maintenanceSuggestionSettings).values({ organizationId: organizationId2, ...settings }).returning();
          return newSettings;
        }
      }
      // Timeline entries
      async createMaintenanceTimelineEntry(entry) {
        const [newEntry] = await db.insert(maintenanceTimelineEntries).values(entry).returning();
        return newEntry;
      }
      // Owner-specific methods for dashboard
      async getOwnerMaintenanceSuggestions(organizationId2, ownerId) {
        const ownerProperties = await db.select({ id: properties.id }).from(properties).where(and3(
          eq2(properties.organizationId, organizationId2),
          eq2(properties.ownerId, ownerId)
        ));
        const propertyIds = ownerProperties.map((p) => p.id);
        if (propertyIds.length === 0) {
          return [];
        }
        return await db.select().from(maintenanceSuggestions).where(and3(
          eq2(maintenanceSuggestions.organizationId, organizationId2),
          sql3`${maintenanceSuggestions.propertyId} IN (${propertyIds.join(",")})`
        )).orderBy(desc2(maintenanceSuggestions.createdAt));
      }
      async getPendingOwnerApprovals(organizationId2, ownerId) {
        const ownerProperties = await db.select({ id: properties.id }).from(properties).where(and3(
          eq2(properties.organizationId, organizationId2),
          eq2(properties.ownerId, ownerId)
        ));
        const propertyIds = ownerProperties.map((p) => p.id);
        if (propertyIds.length === 0) {
          return [];
        }
        return await db.select().from(maintenanceSuggestions).where(and3(
          eq2(maintenanceSuggestions.organizationId, organizationId2),
          eq2(maintenanceSuggestions.status, "pending"),
          sql3`${maintenanceSuggestions.propertyId} IN (${propertyIds.join(",")})`
        )).orderBy(desc2(maintenanceSuggestions.urgencyLevel), desc2(maintenanceSuggestions.createdAt));
      }
      // ===== GUEST MESSAGING SYSTEM =====
      // Guest Messages Operations
      async getGuestMessages(organizationId2, guestId) {
        return await db.select().from(guestMessages).where(and3(
          eq2(guestMessages.organizationId, organizationId2),
          eq2(guestMessages.guestId, guestId)
        )).orderBy(desc2(guestMessages.createdAt));
      }
      async createGuestMessage(message) {
        const [newMessage] = await db.insert(guestMessages).values({
          organizationId: message.organizationId || "default-org",
          guestId: message.guestId,
          guestName: message.guestName,
          guestEmail: message.guestEmail,
          bookingId: message.bookingId,
          propertyId: message.propertyId,
          messageContent: message.messageContent,
          messageType: message.messageType,
          priority: message.priority,
          status: "new",
          aiProcessed: false,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        setTimeout(() => {
          this.processMessageWithAI(newMessage);
        }, 2e3);
        return newMessage;
      }
      async updateGuestMessage(id, updates) {
        const [updated] = await db.update(guestMessages).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(guestMessages.id, id)).returning();
        return updated;
      }
      // AI Processing for Guest Messages
      async processMessageWithAI(message) {
        const keywords = this.extractKeywords(message.messageContent);
        const sentiment = this.analyzeSentiment(message.messageContent);
        const aiResponse = this.generateAIResponse(message.messageContent, keywords);
        const urgentIssue = this.detectUrgentIssue(message.messageContent, keywords);
        await this.updateGuestMessage(message.id, {
          aiProcessed: true,
          aiKeywords: keywords,
          aiSentiment: sentiment,
          aiConfidence: 0.85,
          aiSuggestions: aiResponse.suggestions,
          staffResponse: aiResponse.response,
          respondedBy: "ai-assistant",
          respondedAt: /* @__PURE__ */ new Date(),
          status: "acknowledged"
        });
        if (urgentIssue) {
          await this.createAIGeneratedTask({
            organizationId: message.organizationId,
            messageId: message.id,
            guestId: message.guestId,
            propertyId: message.propertyId || 1,
            department: this.routeToDepartment(keywords),
            taskType: "issue_report",
            urgency: urgentIssue.urgency,
            aiDescription: urgentIssue.description,
            aiKeywords: keywords,
            confidence: 0.9,
            status: "pending"
          });
        }
      }
      extractKeywords(content) {
        const keywords = [];
        const text4 = content.toLowerCase();
        if (text4.includes("ac") || text4.includes("air") || text4.includes("conditioning") || text4.includes("cold") || text4.includes("hot") || text4.includes("temperature")) {
          keywords.push("air_conditioning");
        }
        if (text4.includes("pool") || text4.includes("swimming") || text4.includes("water") || text4.includes("chlorine") || text4.includes("filter")) {
          keywords.push("pool");
        }
        if (text4.includes("clean") || text4.includes("dirty") || text4.includes("mess") || text4.includes("towel") || text4.includes("linen")) {
          keywords.push("cleaning");
        }
        if (text4.includes("broken") || text4.includes("repair") || text4.includes("fix") || text4.includes("maintenance") || text4.includes("not working")) {
          keywords.push("maintenance");
        }
        if (text4.includes("urgent") || text4.includes("emergency") || text4.includes("immediately") || text4.includes("asap")) {
          keywords.push("urgent");
        }
        return keywords;
      }
      analyzeSentiment(content) {
        const text4 = content.toLowerCase();
        const positiveWords = ["good", "great", "excellent", "amazing", "wonderful", "perfect", "love", "beautiful", "fantastic"];
        const negativeWords = ["bad", "terrible", "awful", "horrible", "broken", "dirty", "disappointed", "problem", "issue", "complaint"];
        let positiveCount = 0;
        let negativeCount = 0;
        positiveWords.forEach((word) => {
          if (text4.includes(word)) positiveCount++;
        });
        negativeWords.forEach((word) => {
          if (text4.includes(word)) negativeCount++;
        });
        if (positiveCount > negativeCount) return "positive";
        if (negativeCount > positiveCount) return "negative";
        return "neutral";
      }
      generateAIResponse(content, keywords) {
        const text4 = content.toLowerCase();
        if (keywords.includes("air_conditioning")) {
          return {
            response: "I understand you're having an issue with the air conditioning. I've notified our maintenance team who will check on this within the next 2 hours. In the meantime, you can try adjusting the thermostat or checking if the unit is properly plugged in.",
            suggestions: [
              "Check thermostat settings",
              "Ensure AC unit is plugged in",
              "Try switching between heating and cooling modes",
              "Clean or replace air filter if accessible"
            ]
          };
        }
        if (keywords.includes("pool")) {
          return {
            response: "Thank you for letting us know about the pool issue. Our pool maintenance team has been notified and will address this within the next 4 hours. Pool safety is our top priority.",
            suggestions: [
              "Check pool equipment is turned on",
              "Avoid using pool until maintenance arrives",
              "Report any safety concerns immediately",
              "Check pool chemicals are balanced"
            ]
          };
        }
        if (keywords.includes("cleaning")) {
          return {
            response: "I apologize for the cleaning issue. Our housekeeping team has been notified and will address this immediately. We'll also provide fresh linens and towels within the next hour.",
            suggestions: [
              "Request additional cleaning supplies",
              "Schedule extra housekeeping visit",
              "Report specific areas that need attention",
              "Request fresh linens and towels"
            ]
          };
        }
        if (keywords.includes("maintenance")) {
          return {
            response: "I've received your maintenance request and our technical team has been notified. They'll investigate and resolve the issue within the next 2-4 hours. We'll keep you updated on the progress.",
            suggestions: [
              "Provide photos of the issue if possible",
              "Avoid using the affected item until repaired",
              "Report any safety concerns immediately",
              "Request alternative solutions if needed"
            ]
          };
        }
        return {
          response: "Thank you for your message! I've received your inquiry and our team will respond shortly. If this is urgent, please don't hesitate to call our 24/7 support line.",
          suggestions: [
            "Contact support for urgent matters",
            "Check our local area recommendations",
            "Review property amenities and instructions",
            "Browse available additional services"
          ]
        };
      }
      detectUrgentIssue(content, keywords) {
        const text4 = content.toLowerCase();
        if (text4.includes("emergency") || text4.includes("safety") || text4.includes("danger") || text4.includes("leak")) {
          return {
            urgency: "critical",
            description: "Emergency safety issue requiring immediate attention"
          };
        }
        if (keywords.includes("air_conditioning") && (text4.includes("hot") || text4.includes("not working"))) {
          return {
            urgency: "high",
            description: "Air conditioning malfunction - guest comfort priority"
          };
        }
        if (keywords.includes("pool") && (text4.includes("broken") || text4.includes("dangerous") || text4.includes("chemical"))) {
          return {
            urgency: "high",
            description: "Pool safety or equipment issue requiring immediate attention"
          };
        }
        if (keywords.includes("urgent") || text4.includes("immediately") || text4.includes("asap")) {
          return {
            urgency: "high",
            description: "Urgent guest request requiring priority response"
          };
        }
        return null;
      }
      routeToDepartment(keywords) {
        if (keywords.includes("air_conditioning")) return "maintenance";
        if (keywords.includes("pool")) return "pool";
        if (keywords.includes("cleaning")) return "cleaning";
        if (keywords.includes("maintenance")) return "maintenance";
        return "general";
      }
      // Guest Service Requests Operations
      async getGuestServiceRequests(organizationId2, guestId) {
        return await db.select().from(guestServiceRequests).where(and3(
          eq2(guestServiceRequests.organizationId, organizationId2),
          eq2(guestServiceRequests.guestId, guestId)
        )).orderBy(desc2(guestServiceRequests.createdAt));
      }
      async createGuestServiceRequest(request) {
        const [newRequest] = await db.insert(guestServiceRequests).values({
          organizationId: request.organizationId || "default-org",
          guestId: request.guestId,
          guestName: request.guestName,
          bookingId: request.bookingId,
          propertyId: request.propertyId,
          serviceType: request.serviceType,
          serviceName: request.serviceName,
          requestedDate: request.requestedDate,
          requestedTime: request.requestedTime,
          numberOfGuests: request.numberOfGuests,
          specialRequests: request.specialRequests,
          estimatedCost: request.estimatedCost,
          currency: request.currency,
          paymentMethod: request.paymentMethod,
          status: "pending",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        setTimeout(() => {
          this.updateGuestServiceRequest(newRequest.id, {
            status: "confirmed",
            confirmedBy: "system",
            confirmedAt: /* @__PURE__ */ new Date()
          });
        }, 3e3);
        return newRequest;
      }
      async updateGuestServiceRequest(id, updates) {
        const [updated] = await db.update(guestServiceRequests).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(guestServiceRequests.id, id)).returning();
        return updated;
      }
      // AI Generated Tasks Operations
      async createAIGeneratedTask(task) {
        const [newTask] = await db.insert(aiGeneratedTasks).values({
          organizationId: task.organizationId,
          messageId: task.messageId,
          guestId: task.guestId,
          propertyId: task.propertyId,
          department: task.department,
          taskType: task.taskType,
          urgency: task.urgency,
          aiDescription: task.aiDescription,
          aiKeywords: task.aiKeywords,
          confidence: task.confidence,
          status: "pending",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        setTimeout(() => {
          this.assignAITask(newTask);
        }, 1e3);
        return newTask;
      }
      async assignAITask(task) {
        let assignedTo = "maintenance-team";
        switch (task.department) {
          case "maintenance":
            assignedTo = "maintenance-team";
            break;
          case "pool":
            assignedTo = "pool-team";
            break;
          case "cleaning":
            assignedTo = "housekeeping-team";
            break;
          default:
            assignedTo = "portfolio-manager";
        }
        await db.update(aiGeneratedTasks).set({
          assignedTo,
          status: "approved",
          approvedBy: "ai-system",
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(aiGeneratedTasks.id, task.id));
      }
      async getAIGeneratedTasks(organizationId2) {
        return await db.select().from(aiGeneratedTasks).where(eq2(aiGeneratedTasks.organizationId, organizationId2)).orderBy(desc2(aiGeneratedTasks.createdAt));
      }
      // Mock guest bookings for demo purposes
      async getGuestBookings(guestId) {
        return [
          {
            id: 1,
            guestName: "John Smith",
            propertyId: 1,
            propertyName: "Luxury Beach Villa",
            checkIn: /* @__PURE__ */ new Date("2024-07-05"),
            checkOut: /* @__PURE__ */ new Date("2024-07-12"),
            status: "confirmed"
          },
          {
            id: 2,
            guestName: "John Smith",
            propertyId: 2,
            propertyName: "Mountain Retreat",
            checkIn: /* @__PURE__ */ new Date("2024-08-15"),
            checkOut: /* @__PURE__ */ new Date("2024-08-22"),
            status: "confirmed"
          }
        ];
      }
      // ===== ADD-ON SERVICES ENGINE STORAGE METHODS =====
      // Service catalog management
      async getAddonServiceCatalog(organizationId2, filters) {
        const mockCatalog = [
          {
            id: 1,
            organizationId: organizationId2,
            serviceName: "Phi Phi Island Day Trip",
            category: "tours",
            description: "Full day tour to Phi Phi Islands including Maya Bay, snorkeling, and lunch",
            basePrice: "1800.00",
            currency: "THB",
            duration: 480,
            imageUrl: "/images/phi-phi-tour.jpg",
            maxGuests: 8,
            advanceBookingHours: 24,
            providerName: "Phuket Island Tours",
            providerContact: "+66 76 123 456",
            commissionRate: "15.00",
            isActive: true,
            createdBy: "demo-admin",
            displayOrder: 1,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 2,
            organizationId: organizationId2,
            serviceName: "James Bond Island Tour",
            category: "tours",
            description: "Visit famous James Bond Island and Phang Nga Bay by longtail boat",
            basePrice: "1500.00",
            currency: "THB",
            duration: 360,
            imageUrl: "/images/james-bond-tour.jpg",
            maxGuests: 6,
            advanceBookingHours: 24,
            providerName: "Phang Nga Adventures",
            providerContact: "+66 76 234 567",
            commissionRate: "15.00",
            isActive: true,
            createdBy: "demo-admin",
            displayOrder: 2,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 3,
            organizationId: organizationId2,
            serviceName: "Private Thai Cooking Class",
            category: "chef",
            description: "Learn to cook authentic Thai dishes with a professional chef at your villa",
            basePrice: "3500.00",
            currency: "THB",
            duration: 180,
            imageUrl: "/images/cooking-class.jpg",
            maxGuests: 6,
            advanceBookingHours: 48,
            providerName: "Chef Somchai",
            providerContact: "+66 81 345 678",
            commissionRate: "20.00",
            isActive: true,
            createdBy: "demo-admin",
            displayOrder: 3,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 4,
            organizationId: organizationId2,
            serviceName: "BBQ Dinner Service",
            category: "chef",
            description: "Private BBQ dinner preparation and service for up to 8 guests",
            basePrice: "2800.00",
            currency: "THB",
            duration: 240,
            imageUrl: "/images/bbq-service.jpg",
            maxGuests: 8,
            advanceBookingHours: 24,
            providerName: "Grill Masters Phuket",
            providerContact: "+66 81 456 789",
            commissionRate: "20.00",
            isActive: true,
            createdBy: "demo-admin",
            displayOrder: 4,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 5,
            organizationId: organizationId2,
            serviceName: "Airport Transfer (Van)",
            category: "transport",
            description: "Private van transfer between Phuket Airport and villa (up to 8 passengers)",
            basePrice: "800.00",
            currency: "THB",
            duration: 60,
            imageUrl: "/images/airport-transfer.jpg",
            maxGuests: 8,
            advanceBookingHours: 12,
            providerName: "Phuket Airport Transfers",
            providerContact: "+66 76 567 890",
            commissionRate: "12.00",
            isActive: true,
            createdBy: "demo-admin",
            displayOrder: 5,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 6,
            organizationId: organizationId2,
            serviceName: "Motorbike Rental (Daily)",
            category: "transport",
            description: "Honda PCX 150cc motorbike rental for one day including helmet",
            basePrice: "300.00",
            currency: "THB",
            duration: 1440,
            imageUrl: "/images/motorbike-rental.jpg",
            maxGuests: 2,
            advanceBookingHours: 4,
            providerName: "Phuket Bike Rental",
            providerContact: "+66 81 678 901",
            commissionRate: "12.00",
            isActive: true,
            createdBy: "demo-admin",
            displayOrder: 6,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 7,
            organizationId: organizationId2,
            serviceName: "Traditional Thai Massage (60 min)",
            category: "massage",
            description: "Authentic Thai massage performed by certified therapist at your villa",
            basePrice: "800.00",
            currency: "THB",
            duration: 60,
            imageUrl: "/images/thai-massage.jpg",
            maxGuests: 2,
            advanceBookingHours: 6,
            providerName: "Villa Spa Services",
            providerContact: "+66 81 789 012",
            commissionRate: "25.00",
            isActive: true,
            createdBy: "demo-admin",
            displayOrder: 7,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 8,
            organizationId: organizationId2,
            serviceName: "Couple's Oil Massage (90 min)",
            category: "massage",
            description: "Relaxing oil massage for couples in the comfort of your villa",
            basePrice: "1800.00",
            currency: "THB",
            duration: 90,
            imageUrl: "/images/couples-massage.jpg",
            maxGuests: 2,
            advanceBookingHours: 12,
            providerName: "Luxury Spa Phuket",
            providerContact: "+66 81 890 123",
            commissionRate: "25.00",
            isActive: true,
            createdBy: "demo-admin",
            displayOrder: 8,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 9,
            organizationId: organizationId2,
            serviceName: "Snorkeling Gear Set",
            category: "rental",
            description: "Complete snorkeling equipment set for one day (mask, fins, snorkel)",
            basePrice: "200.00",
            currency: "THB",
            duration: 1440,
            imageUrl: "/images/snorkel-gear.jpg",
            maxGuests: 4,
            advanceBookingHours: 2,
            providerName: "Phuket Water Sports",
            providerContact: "+66 76 901 234",
            commissionRate: "10.00",
            isActive: true,
            createdBy: "demo-admin",
            displayOrder: 9,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 10,
            organizationId: organizationId2,
            serviceName: "Welcome Grocery Package",
            category: "grocery",
            description: "Essential groceries delivered before arrival (milk, bread, fruits, water)",
            basePrice: "1200.00",
            currency: "THB",
            duration: 30,
            imageUrl: "/images/grocery-package.jpg",
            maxGuests: 8,
            advanceBookingHours: 24,
            providerName: "Villa Provisions",
            providerContact: "+66 81 012 345",
            commissionRate: "8.00",
            isActive: true,
            createdBy: "demo-admin",
            displayOrder: 10,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          }
        ];
        let filtered = mockCatalog;
        if (filters?.category) {
          filtered = filtered.filter((service) => service.category === filters.category);
        }
        if (filters?.isActive !== void 0) {
          filtered = filtered.filter((service) => service.isActive === filters.isActive);
        }
        return filtered;
      }
      async getAddonServiceCatalogItem(id) {
        const catalog = await this.getAddonServiceCatalog("default");
        return catalog.find((service) => service.id === id);
      }
      async createAddonServiceCatalogItem(service) {
        const catalog = await this.getAddonServiceCatalog("default");
        const newId = Math.max(...catalog.map((s) => s.id)) + 1;
        const newService = {
          id: newId,
          ...service,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newService;
      }
      async updateAddonServiceCatalogItem(id, updates) {
        const service = await this.getAddonServiceCatalogItem(id);
        if (!service) return void 0;
        return {
          ...service,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async deleteAddonServiceCatalogItem(id) {
        return true;
      }
      // Service categories
      async getAddonServiceCategories(organizationId2) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            categoryName: "tours",
            categoryIcon: "\u{1F3DD}\uFE0F",
            categoryColor: "#3B82F6",
            defaultBillingRule: "guest_charged",
            defaultCommissionRate: "15.00",
            description: "Island tours, cultural experiences, and sightseeing",
            displayOrder: 1,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 2,
            organizationId: organizationId2,
            categoryName: "chef",
            categoryIcon: "\u{1F468}\u200D\u{1F373}",
            categoryColor: "#F59E0B",
            defaultBillingRule: "guest_charged",
            defaultCommissionRate: "20.00",
            description: "Private chef services and catering",
            displayOrder: 2,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 3,
            organizationId: organizationId2,
            categoryName: "transport",
            categoryIcon: "\u{1F697}",
            categoryColor: "#10B981",
            defaultBillingRule: "guest_charged",
            defaultCommissionRate: "12.00",
            description: "Airport transfers, car rentals, and transportation",
            displayOrder: 3,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 4,
            organizationId: organizationId2,
            categoryName: "massage",
            categoryIcon: "\u{1F486}\u200D\u2640\uFE0F",
            categoryColor: "#8B5CF6",
            defaultBillingRule: "guest_charged",
            defaultCommissionRate: "25.00",
            description: "Spa services and therapeutic massage",
            displayOrder: 4,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 5,
            organizationId: organizationId2,
            categoryName: "rental",
            categoryIcon: "\u{1F3CA}\u200D\u2642\uFE0F",
            categoryColor: "#06B6D4",
            defaultBillingRule: "guest_charged",
            defaultCommissionRate: "10.00",
            description: "Equipment rentals and recreational gear",
            displayOrder: 5,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 6,
            organizationId: organizationId2,
            categoryName: "grocery",
            categoryIcon: "\u{1F6D2}",
            categoryColor: "#EF4444",
            defaultBillingRule: "guest_charged",
            defaultCommissionRate: "8.00",
            description: "Grocery delivery and provisioning services",
            displayOrder: 6,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 7,
            organizationId: organizationId2,
            categoryName: "baby",
            categoryIcon: "\u{1F476}",
            categoryColor: "#F97316",
            defaultBillingRule: "owner_charged",
            defaultCommissionRate: "5.00",
            description: "Baby equipment rental and childcare services",
            displayOrder: 7,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 8,
            organizationId: organizationId2,
            categoryName: "photography",
            categoryIcon: "\u{1F4F8}",
            categoryColor: "#EC4899",
            defaultBillingRule: "guest_charged",
            defaultCommissionRate: "18.00",
            description: "Professional photography and videography",
            displayOrder: 8,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 9,
            organizationId: organizationId2,
            categoryName: "airport",
            categoryIcon: "\u2708\uFE0F",
            categoryColor: "#6366F1",
            defaultBillingRule: "guest_charged",
            defaultCommissionRate: "10.00",
            description: "Airport transfer and travel assistance",
            displayOrder: 9,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 10,
            organizationId: organizationId2,
            categoryName: "events",
            categoryIcon: "\u{1F389}",
            categoryColor: "#84CC16",
            defaultBillingRule: "guest_charged",
            defaultCommissionRate: "22.00",
            description: "Event planning and special occasion services",
            displayOrder: 10,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          }
        ];
      }
      async getAddonServiceCategory(id) {
        const categories = await this.getAddonServiceCategories("default");
        return categories.find((cat) => cat.id === id);
      }
      async createAddonServiceCategory(category) {
        const categories = await this.getAddonServiceCategories("default");
        const newId = Math.max(...categories.map((c) => c.id)) + 1;
        return {
          id: newId,
          ...category,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async updateAddonServiceCategory(id, updates) {
        const category = await this.getAddonServiceCategory(id);
        if (!category) return void 0;
        return {
          ...category,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async deleteAddonServiceCategory(id) {
        return true;
      }
      // Service bookings
      async getAddonServiceBookings(organizationId2, filters) {
        const mockBookings = [
          {
            id: 1,
            organizationId: organizationId2,
            serviceId: 1,
            propertyId: 1,
            guestName: "John Smith",
            guestEmail: "john.smith@email.com",
            guestPhone: "+1 555 123 4567",
            guestCount: 4,
            serviceDate: "2025-01-15",
            serviceTime: "08:00",
            totalAmount: "7200.00",
            billingRule: "guest_charged",
            billingType: "charged",
            paymentStatus: "paid",
            paymentMethod: "card",
            status: "confirmed",
            commissionAmount: "1080.00",
            bookedBy: "demo-staff",
            confirmedBy: "demo-admin",
            confirmedAt: /* @__PURE__ */ new Date("2025-01-10T10:00:00Z"),
            currency: "THB",
            specialRequests: null,
            internalNotes: null,
            completedAt: null,
            completionNotes: null,
            cancellationReason: null,
            createdAt: /* @__PURE__ */ new Date("2025-01-08"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-10")
          },
          {
            id: 2,
            organizationId: organizationId2,
            serviceId: 3,
            propertyId: 2,
            guestName: "Sarah Johnson",
            guestEmail: "sarah.j@email.com",
            guestPhone: "+44 20 1234 5678",
            guestCount: 2,
            serviceDate: "2025-01-18",
            serviceTime: "15:00",
            totalAmount: "3500.00",
            billingRule: "guest_charged",
            billingType: "charged",
            paymentStatus: "pending",
            status: "pending",
            commissionAmount: "700.00",
            bookedBy: "demo-staff",
            confirmedBy: null,
            confirmedAt: null,
            currency: "THB",
            specialRequests: "Vegetarian cooking class preferred",
            internalNotes: null,
            completedAt: null,
            completionNotes: null,
            cancellationReason: null,
            paymentMethod: null,
            createdAt: /* @__PURE__ */ new Date("2025-01-15"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-15")
          },
          {
            id: 3,
            organizationId: organizationId2,
            serviceId: 7,
            propertyId: 1,
            guestName: "Mike Wilson",
            guestEmail: "mike.w@email.com",
            guestPhone: "+1 555 987 6543",
            guestCount: 2,
            serviceDate: "2025-01-20",
            serviceTime: "19:00",
            totalAmount: "1600.00",
            billingRule: "complimentary",
            billingType: "owner_gift",
            paymentStatus: "paid",
            status: "confirmed",
            commissionAmount: "400.00",
            bookedBy: "demo-staff",
            confirmedBy: "demo-admin",
            confirmedAt: /* @__PURE__ */ new Date("2025-01-15T14:30:00Z"),
            currency: "THB",
            specialRequests: null,
            internalNotes: "VIP guest - owner covering as welcome gift",
            completedAt: null,
            completionNotes: null,
            cancellationReason: null,
            paymentMethod: "complimentary",
            createdAt: /* @__PURE__ */ new Date("2025-01-12"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-15")
          }
        ];
        let filtered = mockBookings;
        if (filters?.propertyId) {
          filtered = filtered.filter((booking) => booking.propertyId === filters.propertyId);
        }
        if (filters?.status) {
          filtered = filtered.filter((booking) => booking.status === filters.status);
        }
        if (filters?.billingRule) {
          filtered = filtered.filter((booking) => booking.billingRule === filters.billingRule);
        }
        return filtered;
      }
      async getAddonServiceBooking(id) {
        const bookings3 = await this.getAddonServiceBookings("default");
        return bookings3.find((booking) => booking.id === id);
      }
      async createAddonServiceBooking(booking) {
        const bookings3 = await this.getAddonServiceBookings("default");
        const newId = Math.max(...bookings3.map((b) => b.id)) + 1;
        return {
          id: newId,
          ...booking,
          status: "pending",
          paymentStatus: "pending",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async updateAddonServiceBooking(id, updates) {
        const booking = await this.getAddonServiceBooking(id);
        if (!booking) return void 0;
        return {
          ...booking,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async deleteAddonServiceBooking(id) {
        return true;
      }
      async confirmAddonServiceBooking(id, confirmedBy) {
        const booking = await this.getAddonServiceBooking(id);
        if (!booking) return void 0;
        return {
          ...booking,
          status: "confirmed",
          confirmedBy,
          confirmedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async completeAddonServiceBooking(id, completedAt, notes) {
        const booking = await this.getAddonServiceBooking(id);
        if (!booking) return void 0;
        return {
          ...booking,
          status: "completed",
          completedAt,
          completionNotes: notes || null,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Service commissions
      async getAddonServiceCommissions(organizationId2, filters) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            bookingId: 1,
            serviceId: 1,
            category: "tours",
            staffId: "demo-staff",
            commissionAmount: "1080.00",
            commissionRate: "15.00",
            paymentStatus: "paid",
            paymentDate: /* @__PURE__ */ new Date("2025-01-16T10:00:00Z"),
            paymentMethod: "bank_transfer",
            notes: "Commission for Phi Phi Island tour booking",
            createdAt: /* @__PURE__ */ new Date("2025-01-08"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-16")
          },
          {
            id: 2,
            organizationId: organizationId2,
            bookingId: 2,
            serviceId: 3,
            category: "chef",
            staffId: "demo-staff",
            commissionAmount: "700.00",
            commissionRate: "20.00",
            paymentStatus: "pending",
            paymentDate: null,
            paymentMethod: null,
            notes: "Commission for Thai cooking class booking",
            createdAt: /* @__PURE__ */ new Date("2025-01-15"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-15")
          }
        ];
      }
      async getAddonServiceCommission(id) {
        const commissions = await this.getAddonServiceCommissions("default");
        return commissions.find((commission) => commission.id === id);
      }
      async createAddonServiceCommission(commission) {
        const commissions = await this.getAddonServiceCommissions("default");
        const newId = Math.max(...commissions.map((c) => c.id)) + 1;
        return {
          id: newId,
          ...commission,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async updateAddonServiceCommission(id, updates) {
        const commission = await this.getAddonServiceCommission(id);
        if (!commission) return void 0;
        return {
          ...commission,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async processCommissionPayment(id, paymentDate, paymentMethod) {
        const commission = await this.getAddonServiceCommission(id);
        if (!commission) return void 0;
        return {
          ...commission,
          paymentStatus: "paid",
          paymentDate,
          paymentMethod,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Service reports
      async getAddonServiceReports(organizationId2, filters) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            reportMonth: "2024-12",
            category: "tours",
            totalBookings: 8,
            totalRevenue: "14400.00",
            totalCommissions: "2160.00",
            guestChargedRevenue: "14400.00",
            ownerChargedRevenue: "0.00",
            companyExpenseAmount: "0.00",
            complimentaryAmount: "0.00",
            averageBookingValue: "1800.00",
            topService: "Phi Phi Island Day Trip",
            createdAt: /* @__PURE__ */ new Date("2024-12-31"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-31")
          },
          {
            id: 2,
            organizationId: organizationId2,
            reportMonth: "2024-12",
            category: "chef",
            totalBookings: 5,
            totalRevenue: "17500.00",
            totalCommissions: "3500.00",
            guestChargedRevenue: "17500.00",
            ownerChargedRevenue: "0.00",
            companyExpenseAmount: "0.00",
            complimentaryAmount: "0.00",
            averageBookingValue: "3500.00",
            topService: "Private Thai Cooking Class",
            createdAt: /* @__PURE__ */ new Date("2024-12-31"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-31")
          },
          {
            id: 3,
            organizationId: organizationId2,
            reportMonth: "2024-12",
            category: "massage",
            totalBookings: 12,
            totalRevenue: "9600.00",
            totalCommissions: "2400.00",
            guestChargedRevenue: "6400.00",
            ownerChargedRevenue: "0.00",
            companyExpenseAmount: "0.00",
            complimentaryAmount: "3200.00",
            averageBookingValue: "800.00",
            topService: "Traditional Thai Massage",
            createdAt: /* @__PURE__ */ new Date("2024-12-31"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-31")
          }
        ];
      }
      async getAddonServiceReport(id) {
        const reports2 = await this.getAddonServiceReports("default");
        return reports2.find((report) => report.id === id);
      }
      async generateMonthlyServiceReport(organizationId2, reportMonth) {
        return await this.getAddonServiceReports(organizationId2, { reportMonth });
      }
      async getServiceCategorySummary(organizationId2, startDate, endDate) {
        const bookings3 = await this.getAddonServiceBookings(organizationId2);
        return {
          totalBookings: bookings3.length,
          totalRevenue: bookings3.reduce((sum4, booking) => sum4 + parseFloat(booking.totalAmount), 0),
          totalCommissions: bookings3.reduce((sum4, booking) => sum4 + parseFloat(booking.commissionAmount || "0"), 0),
          categoryBreakdown: [
            { category: "tours", bookings: 8, revenue: 14400 },
            { category: "chef", bookings: 5, revenue: 17500 },
            { category: "massage", bookings: 12, revenue: 9600 }
          ],
          billingRuleBreakdown: [
            { rule: "guest_charged", bookings: 20, revenue: 35e3 },
            { rule: "owner_charged", bookings: 3, revenue: 2400 },
            { rule: "complimentary", bookings: 2, revenue: 3200 }
          ]
        };
      }
      // Billing rules
      async getAddonBillingRules(organizationId2, filters) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            ruleName: "Guest Pays Standard Services",
            category: "tours",
            billingRule: "guest_charged",
            billingType: "charged",
            autoApply: true,
            isActive: true,
            priority: 1,
            conditions: null,
            createdBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 2,
            organizationId: organizationId2,
            ruleName: "Owner Covers Baby Equipment",
            category: "baby",
            billingRule: "owner_charged",
            billingType: "charged",
            autoApply: true,
            isActive: true,
            priority: 1,
            conditions: null,
            createdBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 3,
            organizationId: organizationId2,
            ruleName: "Complimentary Welcome Groceries",
            category: "grocery",
            billingRule: "complimentary",
            billingType: "company_gift",
            autoApply: false,
            isActive: true,
            priority: 2,
            conditions: null,
            createdBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          },
          {
            id: 4,
            organizationId: organizationId2,
            ruleName: "VIP Guest Massage Gift",
            category: "massage",
            billingRule: "complimentary",
            billingType: "owner_gift",
            autoApply: false,
            isActive: true,
            priority: 3,
            conditions: { vipGuest: true, stayLength: { min: 7 } },
            createdBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2024-12-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-01")
          }
        ];
      }
      async getAddonBillingRule(id) {
        const rules = await this.getAddonBillingRules("default");
        return rules.find((rule) => rule.id === id);
      }
      async createAddonBillingRule(rule) {
        const rules = await this.getAddonBillingRules("default");
        const newId = Math.max(...rules.map((r) => r.id)) + 1;
        return {
          id: newId,
          ...rule,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async updateAddonBillingRule(id, updates) {
        const rule = await this.getAddonBillingRule(id);
        if (!rule) return void 0;
        return {
          ...rule,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async deleteAddonBillingRule(id) {
        return true;
      }
      async applyBillingRule(serviceId, bookingData) {
        return {
          billingRule: "guest_charged",
          billingType: "charged"
        };
      }
      // Finance integration stubs
      async createFinanceRecordFromBooking(bookingId) {
        return {};
      }
      async updateOwnerBalanceFromService(bookingId) {
      }
      async processServiceRefund(bookingId, refundAmount, reason) {
        const booking = await this.getAddonServiceBooking(bookingId);
        if (!booking) return void 0;
        return {
          ...booking,
          status: "refunded",
          cancellationReason: reason,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Service availability stubs
      async getAddonServiceAvailability(serviceId, filters) {
        return [];
      }
      async createAddonServiceAvailability(availability) {
        return {};
      }
      async updateAddonServiceAvailability(id, updates) {
        return {};
      }
      async blockServiceAvailability(serviceId, dateRange, reason) {
        return {};
      }
      // ===== STAFF ADVANCE SALARY & OVERTIME TRACKER OPERATIONS =====
      // Staff overtime sessions
      async getStaffOvertimeSessions(organizationId2, filters) {
        const mockSessions = [
          {
            id: 1,
            organizationId: organizationId2,
            staffId: "demo-staff",
            sessionDate: "2024-01-15",
            clockInTime: /* @__PURE__ */ new Date("2024-01-15T20:30:00Z"),
            clockOutTime: /* @__PURE__ */ new Date("2024-01-15T23:30:00Z"),
            totalHours: "3.00",
            taskId: 1,
            taskDescription: "Emergency pump repair at Villa Sunset",
            workLocation: "Villa Sunset - Pool Area",
            workType: "emergency",
            isEmergency: true,
            isAfterHours: true,
            emergencyReason: "Pool pump malfunction causing water overflow",
            status: "approved",
            approvedBy: "demo-admin",
            approvedAt: /* @__PURE__ */ new Date("2024-01-16T08:00:00Z"),
            compensationType: "paid",
            compensationAmount: "450.00",
            compensationRate: "150.00",
            staffNotes: "Required emergency tools from hardware store",
            adminNotes: "Excellent response time, approved full overtime rate",
            proofImages: ["emergency_repair_before.jpg", "emergency_repair_after.jpg"],
            createdAt: /* @__PURE__ */ new Date("2024-01-15T20:30:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2024-01-16T08:00:00Z")
          },
          {
            id: 2,
            organizationId: organizationId2,
            staffId: "demo-staff",
            sessionDate: "2024-01-20",
            clockInTime: /* @__PURE__ */ new Date("2024-01-20T19:00:00Z"),
            clockOutTime: /* @__PURE__ */ new Date("2024-01-20T21:30:00Z"),
            totalHours: "2.50",
            taskDescription: "Deep cleaning Property before VIP guest arrival",
            workLocation: "Property",
            workType: "overtime",
            isEmergency: false,
            isAfterHours: false,
            status: "pending",
            compensationType: void 0,
            staffNotes: "Extra attention to master bedroom and kitchen",
            createdAt: /* @__PURE__ */ new Date("2024-01-20T19:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2024-01-20T21:30:00Z")
          },
          {
            id: 3,
            organizationId: organizationId2,
            staffId: "demo-staff",
            sessionDate: "2024-01-25",
            clockInTime: /* @__PURE__ */ new Date("2024-01-25T21:15:00Z"),
            clockOutTime: /* @__PURE__ */ new Date("2024-01-26T02:00:00Z"),
            totalHours: "4.75",
            taskDescription: "Garden lighting repair for evening event",
            workLocation: "Villa Paradise - Garden",
            workType: "special_project",
            isEmergency: false,
            isAfterHours: true,
            status: "approved",
            approvedBy: "demo-admin",
            approvedAt: /* @__PURE__ */ new Date("2024-01-26T09:00:00Z"),
            compensationType: "time_off",
            staffNotes: "Completed before guest event started at 7 PM",
            adminNotes: "Great job completing before guest arrival",
            createdAt: /* @__PURE__ */ new Date("2024-01-25T21:15:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2024-01-26T09:00:00Z")
          }
        ];
        return mockSessions.filter((session3) => {
          if (filters?.staffId && session3.staffId !== filters.staffId) return false;
          if (filters?.status && session3.status !== filters.status) return false;
          if (filters?.isEmergency !== void 0 && session3.isEmergency !== filters.isEmergency) return false;
          if (filters?.isAfterHours !== void 0 && session3.isAfterHours !== filters.isAfterHours) return false;
          if (filters?.dateFrom && session3.sessionDate < filters.dateFrom) return false;
          if (filters?.dateTo && session3.sessionDate > filters.dateTo) return false;
          return true;
        });
      }
      async createStaffOvertimeSession(session3) {
        const newSession = {
          id: Math.floor(Math.random() * 1e4),
          ...session3,
          totalHours: void 0,
          status: "pending",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newSession;
      }
      async updateStaffOvertimeSession(id, updates) {
        if (updates.clockOutTime && !updates.totalHours) {
          const sessions2 = await this.getStaffOvertimeSessions("default");
          const session3 = sessions2.find((s) => s.id === id);
          if (session3 && session3.clockInTime) {
            const clockIn = new Date(session3.clockInTime);
            const clockOut = new Date(updates.clockOutTime);
            const diffMs = clockOut.getTime() - clockIn.getTime();
            const hours = diffMs / (1e3 * 60 * 60);
            updates.totalHours = hours.toFixed(2);
          }
        }
        return {
          id,
          organizationId: "default",
          staffId: "demo-staff",
          sessionDate: "2024-01-01",
          clockInTime: /* @__PURE__ */ new Date(),
          status: "pending",
          workType: "overtime",
          isEmergency: false,
          isAfterHours: false,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          ...updates
        };
      }
      async approveOvertimeSession(id, approvedBy, compensationType, compensationAmount, adminNotes) {
        return this.updateStaffOvertimeSession(id, {
          status: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          compensationType,
          compensationAmount: compensationAmount?.toString(),
          adminNotes
        });
      }
      // Staff advance requests
      async getStaffAdvanceRequests(organizationId2, filters) {
        const mockRequests = [
          {
            id: 1,
            organizationId: organizationId2,
            staffId: "demo-staff",
            requestDate: "2024-01-10",
            requestedAmount: "5000.00",
            currency: "THB",
            reason: "Medical emergency for family member - need to pay hospital bills urgently",
            urgencyLevel: "urgent",
            status: "approved",
            requestedBy: "demo-staff",
            reviewedBy: "demo-admin",
            approvedBy: "demo-admin",
            reviewedAt: /* @__PURE__ */ new Date("2024-01-11T10:00:00Z"),
            approvedAt: /* @__PURE__ */ new Date("2024-01-11T10:30:00Z"),
            paymentMethod: "bank_transfer",
            paymentDate: /* @__PURE__ */ new Date("2024-01-11T14:00:00Z"),
            paymentReference: "ADV-2024-001",
            deductionStartMonth: "2024-02",
            deductionMonths: 2,
            monthlyDeductionAmount: "2500.00",
            remainingBalance: "2500.00",
            staffNotes: "Will provide medical bills as proof if needed",
            adminNotes: "Approved due to medical emergency, split repayment over 2 months",
            financeRecordId: 1001,
            createdAt: /* @__PURE__ */ new Date("2024-01-10T16:30:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2024-01-11T14:00:00Z")
          },
          {
            id: 2,
            organizationId: organizationId2,
            staffId: "demo-staff",
            requestDate: "2024-01-20",
            requestedAmount: "3000.00",
            currency: "THB",
            reason: "Motorcycle repair needed for commuting to work",
            urgencyLevel: "high",
            status: "pending",
            requestedBy: "demo-staff",
            deductionMonths: 1,
            staffNotes: "Motorcycle is essential for reaching remote villa locations",
            createdAt: /* @__PURE__ */ new Date("2024-01-20T09:15:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2024-01-20T09:15:00Z")
          },
          {
            id: 3,
            organizationId: organizationId2,
            staffId: "demo-staff",
            requestDate: "2024-01-05",
            requestedAmount: "2000.00",
            currency: "THB",
            reason: "Child school fees payment due",
            urgencyLevel: "normal",
            status: "rejected",
            requestedBy: "demo-staff",
            reviewedBy: "demo-admin",
            reviewedAt: /* @__PURE__ */ new Date("2024-01-06T11:00:00Z"),
            deductionMonths: 1,
            rejectionReason: "Request made too soon after previous advance. Please wait at least 3 months between requests.",
            staffNotes: "School fees deadline approaching",
            adminNotes: "Policy requires 3-month gap between advances",
            createdAt: /* @__PURE__ */ new Date("2024-01-05T14:20:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2024-01-06T11:00:00Z")
          }
        ];
        return mockRequests.filter((request) => {
          if (filters?.staffId && request.staffId !== filters.staffId) return false;
          if (filters?.status && request.status !== filters.status) return false;
          if (filters?.urgencyLevel && request.urgencyLevel !== filters.urgencyLevel) return false;
          if (filters?.dateFrom && request.requestDate < filters.dateFrom) return false;
          if (filters?.dateTo && request.requestDate > filters.dateTo) return false;
          return true;
        });
      }
      async createStaffAdvanceRequest(request) {
        const newRequest = {
          id: Math.floor(Math.random() * 1e4),
          ...request,
          status: "pending",
          deductionMonths: request.deductionMonths || 1,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newRequest;
      }
      async updateStaffAdvanceRequest(id, updates) {
        return {
          id,
          organizationId: "default",
          staffId: "demo-staff",
          requestDate: "2024-01-01",
          requestedAmount: "1000.00",
          currency: "THB",
          reason: "Test request",
          urgencyLevel: "normal",
          status: "pending",
          requestedBy: "demo-staff",
          deductionMonths: 1,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          ...updates
        };
      }
      async approveAdvanceRequest(id, approvedBy, paymentMethod, deductionStartMonth, adminNotes) {
        const requests = await this.getStaffAdvanceRequests("default");
        const request = requests.find((r) => r.id === id);
        if (!request) return void 0;
        const monthlyDeductionAmount = (parseFloat(request.requestedAmount) / request.deductionMonths).toFixed(2);
        return this.updateStaffAdvanceRequest(id, {
          status: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          paymentMethod,
          deductionStartMonth,
          monthlyDeductionAmount,
          remainingBalance: request.requestedAmount,
          adminNotes
        });
      }
      async rejectAdvanceRequest(id, reviewedBy, rejectionReason) {
        return this.updateStaffAdvanceRequest(id, {
          status: "rejected",
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          rejectionReason
        });
      }
      // Staff salary deductions
      async getStaffSalaryDeductions(organizationId2, filters) {
        const mockDeductions = [
          {
            id: 1,
            organizationId: organizationId2,
            staffId: "demo-staff",
            advanceRequestId: 1,
            deductionMonth: "2024-02",
            deductionAmount: "2500.00",
            deductionType: "advance_repayment",
            description: "Advance repayment (1/2) - Medical emergency",
            processedBy: "demo-admin",
            processedAt: /* @__PURE__ */ new Date("2024-02-01T10:00:00Z"),
            payrollCycle: "monthly",
            createdAt: /* @__PURE__ */ new Date("2024-02-01T10:00:00Z")
          },
          {
            id: 2,
            organizationId: organizationId2,
            staffId: "demo-staff",
            advanceRequestId: 1,
            deductionMonth: "2024-03",
            deductionAmount: "2500.00",
            deductionType: "advance_repayment",
            description: "Advance repayment (2/2) - Medical emergency",
            payrollCycle: "monthly",
            createdAt: /* @__PURE__ */ new Date("2024-03-01T00:00:00Z")
          }
        ];
        return mockDeductions.filter((deduction) => {
          if (filters?.staffId && deduction.staffId !== filters.staffId) return false;
          if (filters?.deductionMonth && deduction.deductionMonth !== filters.deductionMonth) return false;
          if (filters?.deductionType && deduction.deductionType !== filters.deductionType) return false;
          return true;
        });
      }
      async createStaffSalaryDeduction(deduction) {
        const newDeduction = {
          id: Math.floor(Math.random() * 1e4),
          ...deduction,
          createdAt: /* @__PURE__ */ new Date()
        };
        return newDeduction;
      }
      // Staff compensation time
      async getStaffCompensationTime(organizationId2, filters) {
        const mockCompTime = [
          {
            id: 1,
            organizationId: organizationId2,
            staffId: "demo-staff",
            overtimeSessionId: 3,
            compensationDate: "2024-01-26",
            hoursEarned: "4.75",
            hoursUsed: "0.00",
            hoursRemaining: "4.75",
            expiresAt: "2024-04-26",
            isExpired: false,
            createdAt: /* @__PURE__ */ new Date("2024-01-26T09:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2024-01-26T09:00:00Z")
          }
        ];
        return mockCompTime.filter((compTime) => {
          if (filters?.staffId && compTime.staffId !== filters.staffId) return false;
          if (filters?.isExpired !== void 0 && compTime.isExpired !== filters.isExpired) return false;
          return true;
        });
      }
      async createStaffCompensationTime(compensationTime) {
        const newCompTime = {
          id: Math.floor(Math.random() * 1e4),
          ...compensationTime,
          hoursUsed: "0.00",
          hoursRemaining: compensationTime.hoursEarned,
          isExpired: false,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newCompTime;
      }
      // Staff monthly summary
      async getStaffMonthlySummary(organizationId2, staffId, month) {
        const [year, monthNum] = month.split("-").map(Number);
        const mockSummary = {
          id: 1,
          organizationId: organizationId2,
          staffId,
          summaryMonth: month,
          summaryYear: year,
          regularHours: "160.00",
          // Standard 40h/week * 4 weeks
          overtimeHours: "12.25",
          // Sum of overtime sessions
          emergencyHours: "3.00",
          // Emergency session hours
          afterHoursCount: 2,
          // Tasks after 8 PM
          totalOvertimePay: "450.00",
          // Paid overtime compensation
          totalCompensationTime: "4.75",
          // Time off compensation hours
          compensationTimeUsed: "0.00",
          advanceRequestsCount: 2,
          // Number of requests this month
          totalAdvanceAmount: "8000.00",
          // Total amount requested
          advanceRepaymentAmount: "2500.00",
          // Amount deducted for repayment
          tasksCompleted: 28,
          // Monthly task completion
          emergencyResponseTime: "15.50",
          // Average response time in minutes
          reliabilityScore: "94.50",
          // Performance score out of 100
          reportGenerated: false,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return mockSummary;
      }
      async createStaffMonthlySummary(summary) {
        const newSummary = {
          id: Math.floor(Math.random() * 1e4),
          ...summary,
          regularHours: summary.regularHours || "0.00",
          overtimeHours: summary.overtimeHours || "0.00",
          emergencyHours: summary.emergencyHours || "0.00",
          afterHoursCount: summary.afterHoursCount || 0,
          totalOvertimePay: summary.totalOvertimePay || "0.00",
          totalCompensationTime: summary.totalCompensationTime || "0.00",
          compensationTimeUsed: summary.compensationTimeUsed || "0.00",
          advanceRequestsCount: summary.advanceRequestsCount || 0,
          totalAdvanceAmount: summary.totalAdvanceAmount || "0.00",
          advanceRepaymentAmount: summary.advanceRepaymentAmount || "0.00",
          tasksCompleted: summary.tasksCompleted || 0,
          reportGenerated: false,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newSummary;
      }
      // Staff notification settings
      async getStaffNotificationSettings(organizationId2, staffId) {
        const mockSettings = {
          id: 1,
          organizationId: organizationId2,
          staffId,
          overtimeReminders: true,
          advanceStatusUpdates: true,
          payrollNotifications: true,
          emergencyTaskAlerts: true,
          emailNotifications: true,
          smsNotifications: false,
          appPushNotifications: true,
          reminderFrequency: "daily",
          quietHoursStart: "22:00",
          quietHoursEnd: "08:00",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return mockSettings;
      }
      async updateStaffNotificationSettings(organizationId2, staffId, updates) {
        const existing = await this.getStaffNotificationSettings(organizationId2, staffId);
        return {
          ...existing,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Generate monthly report
      async generateStaffMonthlyReport(organizationId2, staffId, month) {
        const summary = await this.getStaffMonthlySummary(organizationId2, staffId, month);
        if (!summary) {
          throw new Error("No summary data available for the specified month");
        }
        const reportUrl = `/reports/staff-monthly-${staffId}-${month}.pdf`;
        const updatedSummary = await this.updateStaffMonthlySummary(summary.id, {
          reportGenerated: true,
          reportUrl
        });
        return {
          reportUrl,
          summary: updatedSummary || summary
        };
      }
      async updateStaffMonthlySummary(id, updates) {
        return {
          id,
          organizationId: "default",
          staffId: "demo-staff",
          summaryMonth: "2024-01",
          summaryYear: 2024,
          regularHours: "160.00",
          overtimeHours: "12.25",
          emergencyHours: "3.00",
          afterHoursCount: 2,
          totalOvertimePay: "450.00",
          totalCompensationTime: "4.75",
          compensationTimeUsed: "0.00",
          advanceRequestsCount: 2,
          totalAdvanceAmount: "8000.00",
          advanceRepaymentAmount: "2500.00",
          tasksCompleted: 28,
          emergencyResponseTime: "15.50",
          reliabilityScore: "94.50",
          reportGenerated: false,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          ...updates
        };
      }
      // ===== STAFF PROFILE & PAYROLL LOGGING METHODS =====
      async getStaffProfiles(organizationId2, filters) {
        const conditions = [eq2(staffProfiles.organizationId, organizationId2)];
        if (filters?.department) {
          conditions.push(eq2(staffProfiles.department, filters.department));
        }
        if (filters?.isActive !== void 0) {
          conditions.push(eq2(staffProfiles.isActive, filters.isActive));
        }
        return await db.select().from(staffProfiles).where(and3(...conditions));
      }
      async getStaffProfile(organizationId2, staffId) {
        const [profile] = await db.select().from(staffProfiles).where(and3(eq2(staffProfiles.organizationId, organizationId2), eq2(staffProfiles.staffId, staffId)));
        return profile;
      }
      async createStaffProfile(profile) {
        const [newProfile] = await db.insert(staffProfiles).values(profile).returning();
        return newProfile;
      }
      async updateStaffProfile(organizationId2, staffId, updates) {
        const [updated] = await db.update(staffProfiles).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(and3(eq2(staffProfiles.organizationId, organizationId2), eq2(staffProfiles.staffId, staffId))).returning();
        return updated;
      }
      // Monthly Payroll Records
      async getMonthlyPayrollRecords(organizationId2, filters) {
        const conditions = [eq2(monthlyPayrollRecords.organizationId, organizationId2)];
        if (filters?.staffId) {
          conditions.push(eq2(monthlyPayrollRecords.staffId, filters.staffId));
        }
        if (filters?.payrollPeriod) {
          conditions.push(eq2(monthlyPayrollRecords.payrollPeriod, filters.payrollPeriod));
        }
        if (filters?.status) {
          conditions.push(eq2(monthlyPayrollRecords.status, filters.status));
        }
        return await db.select().from(monthlyPayrollRecords).where(and3(...conditions)).orderBy(desc2(monthlyPayrollRecords.payrollPeriod));
      }
      async createMonthlyPayrollRecord(record) {
        const [newRecord] = await db.insert(monthlyPayrollRecords).values(record).returning();
        return newRecord;
      }
      async updateMonthlyPayrollRecord(organizationId2, recordId, updates) {
        const [updated] = await db.update(monthlyPayrollRecords).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(and3(eq2(monthlyPayrollRecords.organizationId, organizationId2), eq2(monthlyPayrollRecords.id, recordId))).returning();
        return updated;
      }
      // Task Performance Logs
      async getTaskPerformanceLogs(organizationId2, filters) {
        const conditions = [eq2(taskPerformanceLogs.organizationId, organizationId2)];
        if (filters?.staffId) {
          conditions.push(eq2(taskPerformanceLogs.staffId, filters.staffId));
        }
        if (filters?.taskId) {
          conditions.push(eq2(taskPerformanceLogs.taskId, filters.taskId));
        }
        if (filters?.propertyId) {
          conditions.push(eq2(taskPerformanceLogs.propertyId, filters.propertyId));
        }
        return await db.select().from(taskPerformanceLogs).where(and3(...conditions)).orderBy(desc2(taskPerformanceLogs.completedAt));
      }
      async createTaskPerformanceLog(log2) {
        const [newLog] = await db.insert(taskPerformanceLogs).values(log2).returning();
        return newLog;
      }
      // Attendance Records
      async getAttendanceRecords(organizationId2, filters) {
        const conditions = [eq2(attendanceRecords.organizationId, organizationId2)];
        if (filters?.staffId) {
          conditions.push(eq2(attendanceRecords.staffId, filters.staffId));
        }
        if (filters?.workDate) {
          conditions.push(eq2(attendanceRecords.workDate, filters.workDate));
        }
        if (filters?.status) {
          conditions.push(eq2(attendanceRecords.status, filters.status));
        }
        return await db.select().from(attendanceRecords).where(and3(...conditions)).orderBy(desc2(attendanceRecords.workDate));
      }
      async createAttendanceRecord(record) {
        const [newRecord] = await db.insert(attendanceRecords).values(record).returning();
        return newRecord;
      }
      async updateAttendanceRecord(organizationId2, recordId, updates) {
        const [updated] = await db.update(attendanceRecords).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(and3(eq2(attendanceRecords.organizationId, organizationId2), eq2(attendanceRecords.id, recordId))).returning();
        return updated;
      }
      // Leave Requests
      async getLeaveRequests(organizationId2, filters) {
        const conditions = [eq2(leaveRequests.organizationId, organizationId2)];
        if (filters?.staffId) {
          conditions.push(eq2(leaveRequests.staffId, filters.staffId));
        }
        if (filters?.status) {
          conditions.push(eq2(leaveRequests.status, filters.status));
        }
        return await db.select().from(leaveRequests).where(and3(...conditions)).orderBy(desc2(leaveRequests.requestedAt));
      }
      async createLeaveRequest(request) {
        const [newRequest] = await db.insert(leaveRequests).values(request).returning();
        return newRequest;
      }
      async updateLeaveRequest(organizationId2, requestId, updates) {
        const [updated] = await db.update(leaveRequests).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(and3(eq2(leaveRequests.organizationId, organizationId2), eq2(leaveRequests.id, requestId))).returning();
        return updated;
      }
      // Staff Commissions
      async getStaffCommissions(organizationId2, filters) {
        const conditions = [eq2(staffCommissions.organizationId, organizationId2)];
        if (filters?.staffId) {
          conditions.push(eq2(staffCommissions.staffId, filters.staffId));
        }
        if (filters?.payrollPeriod) {
          conditions.push(eq2(staffCommissions.payrollPeriod, filters.payrollPeriod));
        }
        if (filters?.isPaid !== void 0) {
          conditions.push(eq2(staffCommissions.isPaid, filters.isPaid));
        }
        return await db.select().from(staffCommissions).where(and3(...conditions)).orderBy(desc2(staffCommissions.earnedDate));
      }
      async createStaffCommission(commission) {
        const [newCommission] = await db.insert(staffCommissions).values(commission).returning();
        return newCommission;
      }
      async updateStaffCommission(organizationId2, commissionId, updates) {
        const [updated] = await db.update(staffCommissions).set(updates).where(and3(eq2(staffCommissions.organizationId, organizationId2), eq2(staffCommissions.id, commissionId))).returning();
        return updated;
      }
      // Pay Slips
      async getPaySlips(organizationId2, filters) {
        const conditions = [eq2(paySlips.organizationId, organizationId2)];
        if (filters?.staffId) {
          conditions.push(eq2(paySlips.staffId, filters.staffId));
        }
        if (filters?.period) {
          conditions.push(eq2(paySlips.period, filters.period));
        }
        if (filters?.status) {
          conditions.push(eq2(paySlips.status, filters.status));
        }
        return await db.select().from(paySlips).where(and3(...conditions)).orderBy(desc2(paySlips.period));
      }
      async createPaySlip(paySlip) {
        const [newPaySlip] = await db.insert(paySlips).values(paySlip).returning();
        return newPaySlip;
      }
      async updatePaySlip(organizationId2, paySlipId, updates) {
        const [updated] = await db.update(paySlips).set(updates).where(and3(eq2(paySlips.organizationId, organizationId2), eq2(paySlips.id, paySlipId))).returning();
        return updated;
      }
      // Analytics Methods
      async getStaffAnalytics(organizationId2, staffId) {
        const baseConditions = [eq2(staffProfiles.organizationId, organizationId2)];
        if (staffId) {
          baseConditions.push(eq2(staffProfiles.staffId, staffId));
        }
        const staffOverview = await db.select({
          department: staffProfiles.department,
          totalStaff: count(staffProfiles.id),
          avgRating: avg(staffProfiles.averageRating),
          totalHours: sum(staffProfiles.totalHoursWorked),
          totalEarnings: sum(staffProfiles.totalEarnings)
        }).from(staffProfiles).where(and3(...baseConditions)).groupBy(staffProfiles.department);
        return { staffOverview };
      }
      // ===== STAFF ADVANCE & OVERTIME TRACKING METHODS =====
      // Salary Advance Request Methods
      async getStaffAdvanceRequests(organizationId2, filters) {
        const conditions = [eq2(staffAdvanceRequests.organizationId, organizationId2)];
        if (filters?.staffId) {
          conditions.push(eq2(staffAdvanceRequests.staffId, filters.staffId));
        }
        if (filters?.status) {
          conditions.push(eq2(staffAdvanceRequests.status, filters.status));
        }
        if (filters?.reviewedBy) {
          conditions.push(eq2(staffAdvanceRequests.reviewedBy, filters.reviewedBy));
        }
        return await db.select().from(staffAdvanceRequests).where(and3(...conditions)).orderBy(desc2(staffAdvanceRequests.requestDate));
      }
      async getStaffAdvanceRequest(id) {
        const [request] = await db.select().from(staffAdvanceRequests).where(eq2(staffAdvanceRequests.id, id));
        return request;
      }
      async createStaffAdvanceRequest(request) {
        const [newRequest] = await db.insert(staffAdvanceRequests).values(request).returning();
        return newRequest;
      }
      async updateStaffAdvanceRequest(id, updates) {
        const [updated] = await db.update(staffAdvanceRequests).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffAdvanceRequests.id, id)).returning();
        return updated;
      }
      async approveStaffAdvanceRequest(id, reviewedBy, reviewNotes, paidAmount) {
        const [updated] = await db.update(staffAdvanceRequests).set({
          status: "approved",
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          reviewNotes,
          paidAmount,
          paymentStatus: paidAmount ? "paid" : "not_paid",
          paidDate: paidAmount ? /* @__PURE__ */ new Date() : null,
          remainingBalance: paidAmount,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(staffAdvanceRequests.id, id)).returning();
        return updated;
      }
      async rejectStaffAdvanceRequest(id, reviewedBy, reviewNotes) {
        const [updated] = await db.update(staffAdvanceRequests).set({
          status: "rejected",
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          reviewNotes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(staffAdvanceRequests.id, id)).returning();
        return updated;
      }
      // Overtime Log Methods
      async getStaffOvertimeLogs(organizationId2, filters) {
        const conditions = [eq2(staffOvertimeLogs.organizationId, organizationId2)];
        if (filters?.staffId) {
          conditions.push(eq2(staffOvertimeLogs.staffId, filters.staffId));
        }
        if (filters?.status) {
          conditions.push(eq2(staffOvertimeLogs.status, filters.status));
        }
        if (filters?.workDate) {
          conditions.push(eq2(staffOvertimeLogs.workDate, filters.workDate));
        }
        if (filters?.propertyId) {
          conditions.push(eq2(staffOvertimeLogs.propertyId, filters.propertyId));
        }
        return await db.select().from(staffOvertimeLogs).where(and3(...conditions)).orderBy(desc2(staffOvertimeLogs.workDate));
      }
      async getStaffOvertimeLog(id) {
        const [log2] = await db.select().from(staffOvertimeLogs).where(eq2(staffOvertimeLogs.id, id));
        return log2;
      }
      async createStaffOvertimeLog(log2) {
        const [newLog] = await db.insert(staffOvertimeLogs).values(log2).returning();
        return newLog;
      }
      async updateStaffOvertimeLog(id, updates) {
        const [updated] = await db.update(staffOvertimeLogs).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffOvertimeLogs.id, id)).returning();
        return updated;
      }
      async approveStaffOvertimeLog(id, approvedBy, compensationType, compensationAmount, timeOffHours, approvalNotes) {
        const [updated] = await db.update(staffOvertimeLogs).set({
          status: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          compensationType,
          compensationAmount,
          timeOffHours,
          approvalNotes,
          paymentStatus: compensationType === "overtime_pay" ? "pending" : "credited",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(staffOvertimeLogs.id, id)).returning();
        return updated;
      }
      async rejectStaffOvertimeLog(id, approvedBy, approvalNotes) {
        const [updated] = await db.update(staffOvertimeLogs).set({
          status: "rejected",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          approvalNotes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(staffOvertimeLogs.id, id)).returning();
        return updated;
      }
      // Overtime Settings Methods
      async getStaffOvertimeSettings(organizationId2, staffId) {
        const conditions = [eq2(staffOvertimeSettings.organizationId, organizationId2)];
        if (staffId) {
          conditions.push(
            or(
              eq2(staffOvertimeSettings.staffId, staffId),
              eq2(staffOvertimeSettings.isGlobalSetting, true)
            )
          );
        }
        return await db.select().from(staffOvertimeSettings).where(and3(...conditions)).orderBy(desc2(staffOvertimeSettings.isGlobalSetting));
      }
      async createStaffOvertimeSettings(settings) {
        const [newSettings] = await db.insert(staffOvertimeSettings).values(settings).returning();
        return newSettings;
      }
      async updateStaffOvertimeSettings(id, updates) {
        const [updated] = await db.update(staffOvertimeSettings).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffOvertimeSettings.id, id)).returning();
        return updated;
      }
      // Monthly Summary Methods
      async getStaffMonthlySummary(organizationId2, staffId, summaryPeriod) {
        const [summary] = await db.select().from(staffMonthlySummary).where(
          and3(
            eq2(staffMonthlySummary.organizationId, organizationId2),
            eq2(staffMonthlySummary.staffId, staffId),
            eq2(staffMonthlySummary.summaryPeriod, summaryPeriod)
          )
        );
        return summary;
      }
      async createOrUpdateStaffMonthlySummary(summary) {
        const [existing] = await db.select().from(staffMonthlySummary).where(
          and3(
            eq2(staffMonthlySummary.organizationId, summary.organizationId),
            eq2(staffMonthlySummary.staffId, summary.staffId),
            eq2(staffMonthlySummary.summaryPeriod, summary.summaryPeriod)
          )
        );
        if (existing) {
          const [updated] = await db.update(staffMonthlySummary).set({ ...summary, lastUpdated: /* @__PURE__ */ new Date() }).where(eq2(staffMonthlySummary.id, existing.id)).returning();
          return updated;
        } else {
          const [created] = await db.insert(staffMonthlySummary).values(summary).returning();
          return created;
        }
      }
      async calculateStaffMonthlySummary(organizationId2, staffId, year, month) {
        const summaryPeriod = `${year}-${month.toString().padStart(2, "0")}`;
        const advanceRequests = await this.getStaffAdvanceRequests(organizationId2, { staffId });
        const monthlyAdvances = advanceRequests.filter((req) => {
          const requestDate = new Date(req.requestDate);
          return requestDate.getFullYear() === year && requestDate.getMonth() + 1 === month;
        });
        const totalAdvanceRequests = monthlyAdvances.length;
        const approvedAdvances = monthlyAdvances.filter((req) => req.status === "approved").reduce((sum4, req) => sum4 + parseFloat(req.paidAmount || "0"), 0);
        const pendingAdvances = monthlyAdvances.filter((req) => req.status === "pending").reduce((sum4, req) => sum4 + parseFloat(req.requestAmount), 0);
        const remainingAdvanceBalance = monthlyAdvances.filter((req) => req.status === "approved" && parseFloat(req.remainingBalance || "0") > 0).reduce((sum4, req) => sum4 + parseFloat(req.remainingBalance || "0"), 0);
        const overtimeLogs = await this.getStaffOvertimeLogs(organizationId2, { staffId });
        const monthlyOvertimes = overtimeLogs.filter((log2) => {
          const workDate = new Date(log2.workDate);
          return workDate.getFullYear() === year && workDate.getMonth() + 1 === month;
        });
        const totalOvertimeHours = monthlyOvertimes.reduce((sum4, log2) => sum4 + parseFloat(log2.totalHours), 0);
        const approvedOvertimeHours = monthlyOvertimes.filter((log2) => log2.status === "approved").reduce((sum4, log2) => sum4 + parseFloat(log2.totalHours), 0);
        const pendingOvertimeHours = monthlyOvertimes.filter((log2) => log2.status === "pending").reduce((sum4, log2) => sum4 + parseFloat(log2.totalHours), 0);
        const overtimeEarnings = monthlyOvertimes.filter((log2) => log2.status === "approved" && log2.compensationType === "overtime_pay").reduce((sum4, log2) => sum4 + parseFloat(log2.compensationAmount || "0"), 0);
        const timeOffCredits = monthlyOvertimes.filter((log2) => log2.status === "approved" && log2.compensationType === "time_off_credit").reduce((sum4, log2) => sum4 + parseFloat(log2.timeOffHours || "0"), 0);
        const emergencyTasks = monthlyOvertimes.filter((log2) => log2.isEmergency).length;
        const afterHoursTasks = monthlyOvertimes.length;
        const summaryData = {
          organizationId: organizationId2,
          staffId,
          summaryYear: year,
          summaryMonth: month,
          summaryPeriod,
          totalAdvanceRequests,
          approvedAdvances: approvedAdvances.toString(),
          pendingAdvances: pendingAdvances.toString(),
          remainingAdvanceBalance: remainingAdvanceBalance.toString(),
          totalOvertimeHours: totalOvertimeHours.toString(),
          approvedOvertimeHours: approvedOvertimeHours.toString(),
          pendingOvertimeHours: pendingOvertimeHours.toString(),
          overtimeEarnings: overtimeEarnings.toString(),
          timeOffCredits: timeOffCredits.toString(),
          emergencyTasks,
          afterHoursTasks
        };
        return await this.createOrUpdateStaffMonthlySummary(summaryData);
      }
      // Dashboard Analytics Methods
      async getStaffAdvanceOverview(organizationId2, staffId) {
        const requests = await this.getStaffAdvanceRequests(organizationId2, { staffId });
        const pendingRequests = requests.filter((req) => req.status === "pending");
        const approvedRequests = requests.filter((req) => req.status === "approved");
        const totalApprovedAmount = approvedRequests.reduce((sum4, req) => sum4 + parseFloat(req.paidAmount || "0"), 0);
        const totalRemainingBalance = approvedRequests.reduce((sum4, req) => sum4 + parseFloat(req.remainingBalance || "0"), 0);
        return {
          totalPendingRequests: pendingRequests.length,
          totalApprovedAmount,
          totalRemainingBalance,
          recentRequests: requests.slice(0, 5)
        };
      }
      async getStaffOvertimeOverview(organizationId2, staffId) {
        const logs = await this.getStaffOvertimeLogs(organizationId2, { staffId });
        const pendingLogs = logs.filter((log2) => log2.status === "pending");
        const approvedLogs = logs.filter((log2) => log2.status === "approved");
        const totalPendingHours = pendingLogs.reduce((sum4, log2) => sum4 + parseFloat(log2.totalHours), 0);
        const totalApprovedHours = approvedLogs.reduce((sum4, log2) => sum4 + parseFloat(log2.totalHours), 0);
        const totalOvertimeEarnings = approvedLogs.filter((log2) => log2.compensationType === "overtime_pay").reduce((sum4, log2) => sum4 + parseFloat(log2.compensationAmount || "0"), 0);
        const totalTimeOffCredits = approvedLogs.filter((log2) => log2.compensationType === "time_off_credit").reduce((sum4, log2) => sum4 + parseFloat(log2.timeOffHours || "0"), 0);
        return {
          totalPendingHours,
          totalApprovedHours,
          totalOvertimeEarnings,
          totalTimeOffCredits,
          recentLogs: logs.slice(0, 5)
        };
      }
      // ===== MULTI-CURRENCY FINANCE + QUICKBOOKS INTEGRATION =====
      // Currency exchange rates operations
      async getCurrencyExchangeRates(organizationId2, filters) {
        let query = db.select().from(currencyExchangeRates).where(eq2(currencyExchangeRates.organizationId, organizationId2));
        if (filters?.fromCurrency) {
          query = query.where(eq2(currencyExchangeRates.fromCurrency, filters.fromCurrency));
        }
        if (filters?.toCurrency) {
          query = query.where(eq2(currencyExchangeRates.toCurrency, filters.toCurrency));
        }
        if (filters?.rateDate) {
          query = query.where(eq2(currencyExchangeRates.rateDate, filters.rateDate));
        }
        return await query.orderBy(desc2(currencyExchangeRates.rateDate), desc2(currencyExchangeRates.createdAt));
      }
      async getCurrencyExchangeRate(id) {
        const [rate] = await db.select().from(currencyExchangeRates).where(eq2(currencyExchangeRates.id, id));
        return rate;
      }
      async createCurrencyExchangeRate(rate) {
        const [newRate] = await db.insert(currencyExchangeRates).values(rate).returning();
        return newRate;
      }
      async updateCurrencyExchangeRate(id, rate) {
        const [updatedRate] = await db.update(currencyExchangeRates).set({ ...rate, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(currencyExchangeRates.id, id)).returning();
        return updatedRate;
      }
      async deleteCurrencyExchangeRate(id) {
        const result = await db.delete(currencyExchangeRates).where(eq2(currencyExchangeRates.id, id));
        return result.rowCount > 0;
      }
      async getLatestExchangeRate(fromCurrency, toCurrency) {
        const [rate] = await db.select().from(currencyExchangeRates).where(
          and3(
            eq2(currencyExchangeRates.fromCurrency, fromCurrency),
            eq2(currencyExchangeRates.toCurrency, toCurrency),
            eq2(currencyExchangeRates.isActive, true)
          )
        ).orderBy(desc2(currencyExchangeRates.rateDate)).limit(1);
        return rate;
      }
      // Multi-currency finances operations
      async getMultiCurrencyFinances(organizationId2, filters) {
        let query = db.select().from(multiCurrencyFinances).where(eq2(multiCurrencyFinances.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(multiCurrencyFinances.propertyId, filters.propertyId));
        }
        if (filters?.ownerId) {
          query = query.where(eq2(multiCurrencyFinances.ownerId, filters.ownerId));
        }
        if (filters?.category) {
          query = query.where(eq2(multiCurrencyFinances.category, filters.category));
        }
        if (filters?.fromDate) {
          query = query.where(gte2(multiCurrencyFinances.transactionDate, filters.fromDate.toISOString().split("T")[0]));
        }
        if (filters?.toDate) {
          query = query.where(lte2(multiCurrencyFinances.transactionDate, filters.toDate.toISOString().split("T")[0]));
        }
        if (filters?.currency) {
          query = query.where(eq2(multiCurrencyFinances.originalCurrency, filters.currency));
        }
        return await query.orderBy(desc2(multiCurrencyFinances.transactionDate), desc2(multiCurrencyFinances.createdAt));
      }
      async getMultiCurrencyFinance(id) {
        const [finance] = await db.select().from(multiCurrencyFinances).where(eq2(multiCurrencyFinances.id, id));
        return finance;
      }
      async createMultiCurrencyFinance(finance) {
        const [newFinance] = await db.insert(multiCurrencyFinances).values(finance).returning();
        return newFinance;
      }
      async updateMultiCurrencyFinance(id, finance) {
        const [updatedFinance] = await db.update(multiCurrencyFinances).set({ ...finance, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(multiCurrencyFinances.id, id)).returning();
        return updatedFinance;
      }
      async deleteMultiCurrencyFinance(id) {
        const result = await db.delete(multiCurrencyFinances).where(eq2(multiCurrencyFinances.id, id));
        return result.rowCount > 0;
      }
      async convertCurrency(amount, fromCurrency, toCurrency, exchangeRateId) {
        let rate;
        if (exchangeRateId) {
          rate = await this.getCurrencyExchangeRate(exchangeRateId);
        } else {
          rate = await this.getLatestExchangeRate(fromCurrency, toCurrency);
        }
        if (!rate) {
          throw new Error(`Exchange rate not found for ${fromCurrency} to ${toCurrency}`);
        }
        const exchangeRateValue = parseFloat(rate.exchangeRate);
        const convertedAmount = amount * exchangeRateValue;
        return {
          convertedAmount,
          exchangeRate: exchangeRateValue,
          rateId: rate.id
        };
      }
      // QuickBooks integration operations
      async getQuickbooksIntegration(organizationId2) {
        const [integration] = await db.select().from(quickbooksIntegration).where(eq2(quickbooksIntegration.organizationId, organizationId2));
        return integration;
      }
      async createQuickbooksIntegration(integration) {
        const [newIntegration] = await db.insert(quickbooksIntegration).values(integration).returning();
        return newIntegration;
      }
      async updateQuickbooksIntegration(organizationId2, integration) {
        const [updatedIntegration] = await db.update(quickbooksIntegration).set({ ...integration, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(quickbooksIntegration.organizationId, organizationId2)).returning();
        return updatedIntegration;
      }
      async deleteQuickbooksIntegration(organizationId2) {
        const result = await db.delete(quickbooksIntegration).where(eq2(quickbooksIntegration.organizationId, organizationId2));
        return result.rowCount > 0;
      }
      async updateQuickbooksSync(organizationId2, lastSyncAt, errorMessage) {
        const updateData = {
          lastSyncAt,
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (errorMessage) {
          updateData.lastError = errorMessage;
          updateData.errorCount = sql3`${quickbooksIntegration.errorCount} + 1`;
        } else {
          updateData.lastError = null;
          updateData.errorCount = 0;
        }
        const [updatedIntegration] = await db.update(quickbooksIntegration).set(updateData).where(eq2(quickbooksIntegration.organizationId, organizationId2)).returning();
        return updatedIntegration;
      }
      // Property finance settings operations
      async getPropertyFinanceSettings(organizationId2, filters) {
        let query = db.select().from(propertyFinanceSettings).where(eq2(propertyFinanceSettings.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(propertyFinanceSettings.propertyId, filters.propertyId));
        }
        if (filters?.ownerId) {
          query = query.where(eq2(propertyFinanceSettings.ownerId, filters.ownerId));
        }
        return await query.orderBy(propertyFinanceSettings.propertyId);
      }
      async getPropertyFinanceSetting(id) {
        const [settings] = await db.select().from(propertyFinanceSettings).where(eq2(propertyFinanceSettings.id, id));
        return settings;
      }
      async createPropertyFinanceSettings(settings) {
        const [newSettings] = await db.insert(propertyFinanceSettings).values(settings).returning();
        return newSettings;
      }
      async updatePropertyFinanceSettings(id, settings) {
        const [updatedSettings] = await db.update(propertyFinanceSettings).set({ ...settings, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyFinanceSettings.id, id)).returning();
        return updatedSettings;
      }
      async deletePropertyFinanceSettings(id) {
        const result = await db.delete(propertyFinanceSettings).where(eq2(propertyFinanceSettings.id, id));
        return result.rowCount > 0;
      }
      // Finance export logs operations
      async getFinanceExportLogs(organizationId2, filters) {
        let query = db.select().from(financeExportLogs).where(eq2(financeExportLogs.organizationId, organizationId2));
        if (filters?.exportType) {
          query = query.where(eq2(financeExportLogs.exportType, filters.exportType));
        }
        if (filters?.dateRange) {
          query = query.where(eq2(financeExportLogs.dateRange, filters.dateRange));
        }
        if (filters?.requestedBy) {
          query = query.where(eq2(financeExportLogs.requestedBy, filters.requestedBy));
        }
        if (filters?.status) {
          query = query.where(eq2(financeExportLogs.status, filters.status));
        }
        return await query.orderBy(desc2(financeExportLogs.createdAt));
      }
      async getFinanceExportLog(id) {
        const [log2] = await db.select().from(financeExportLogs).where(eq2(financeExportLogs.id, id));
        return log2;
      }
      async createFinanceExportLog(log2) {
        const [newLog] = await db.insert(financeExportLogs).values(log2).returning();
        return newLog;
      }
      async updateFinanceExportLog(id, log2) {
        const [updatedLog] = await db.update(financeExportLogs).set(log2).where(eq2(financeExportLogs.id, id)).returning();
        return updatedLog;
      }
      async deleteFinanceExportLog(id) {
        const result = await db.delete(financeExportLogs).where(eq2(financeExportLogs.id, id));
        return result.rowCount > 0;
      }
      // Finance report templates operations
      async getFinanceReportTemplates(organizationId2, filters) {
        let query = db.select().from(financeReportTemplates).where(eq2(financeReportTemplates.organizationId, organizationId2));
        if (filters?.templateType) {
          query = query.where(eq2(financeReportTemplates.templateType, filters.templateType));
        }
        if (filters?.createdBy) {
          query = query.where(eq2(financeReportTemplates.createdBy, filters.createdBy));
        }
        if (filters?.isDefault !== void 0) {
          query = query.where(eq2(financeReportTemplates.isDefault, filters.isDefault));
        }
        return await query.orderBy(financeReportTemplates.templateName);
      }
      async getFinanceReportTemplate(id) {
        const [template] = await db.select().from(financeReportTemplates).where(eq2(financeReportTemplates.id, id));
        return template;
      }
      async createFinanceReportTemplate(template) {
        const [newTemplate] = await db.insert(financeReportTemplates).values(template).returning();
        return newTemplate;
      }
      async updateFinanceReportTemplate(id, template) {
        const [updatedTemplate] = await db.update(financeReportTemplates).set({ ...template, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(financeReportTemplates.id, id)).returning();
        return updatedTemplate;
      }
      async deleteFinanceReportTemplate(id) {
        const result = await db.delete(financeReportTemplates).where(eq2(financeReportTemplates.id, id));
        return result.rowCount > 0;
      }
      // Occupancy rates operations
      async getOccupancyRates(organizationId2, filters) {
        let query = db.select().from(occupancyRates).where(eq2(occupancyRates.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(occupancyRates.propertyId, filters.propertyId));
        }
        if (filters?.periodType) {
          query = query.where(eq2(occupancyRates.periodType, filters.periodType));
        }
        if (filters?.periodValue) {
          query = query.where(eq2(occupancyRates.periodValue, filters.periodValue));
        }
        return await query.orderBy(desc2(occupancyRates.periodValue));
      }
      async getOccupancyRate(id) {
        const [rate] = await db.select().from(occupancyRates).where(eq2(occupancyRates.id, id));
        return rate;
      }
      async createOccupancyRate(rate) {
        const [newRate] = await db.insert(occupancyRates).values(rate).returning();
        return newRate;
      }
      async updateOccupancyRate(id, rate) {
        const [updatedRate] = await db.update(occupancyRates).set(rate).where(eq2(occupancyRates.id, id)).returning();
        return updatedRate;
      }
      async deleteOccupancyRate(id) {
        const result = await db.delete(occupancyRates).where(eq2(occupancyRates.id, id));
        return result.rowCount > 0;
      }
      async calculateOccupancyRate(propertyId, periodType, periodValue) {
        const mockRate = {
          organizationId: "default-org",
          propertyId,
          periodType,
          periodValue,
          totalDays: 30,
          occupiedDays: 22,
          occupancyRate: "73.33",
          totalRevenue: "45000.00",
          currency: "THB",
          averageDailyRate: "2045.45",
          revenuePerAvailableRoom: "1500.00",
          totalBookings: 8,
          averageStayLength: "2.8",
          calculatedBy: "system"
        };
        return await this.createOccupancyRate(mockRate);
      }
      // Finance reporting and analytics
      async generateFinancialReport(organizationId2, filters) {
        const finances3 = await this.getMultiCurrencyFinances(organizationId2, {
          propertyId: filters.propertyIds?.[0],
          ownerId: filters.ownerIds?.[0],
          currency: filters.currencies?.[0]
        });
        const income = finances3.filter((f) => f.category === "income").reduce((sum4, f) => sum4 + parseFloat(f.thbAmount), 0);
        const expenses = finances3.filter((f) => f.category === "expense").reduce((sum4, f) => sum4 + parseFloat(f.thbAmount), 0);
        const currencyBreakdown = finances3.reduce((acc, finance) => {
          const existing = acc.find((c) => c.currency === finance.originalCurrency);
          if (existing) {
            existing.totalAmount += parseFloat(finance.originalAmount);
            existing.thbEquivalent += parseFloat(finance.thbAmount);
          } else {
            acc.push({
              currency: finance.originalCurrency,
              totalAmount: parseFloat(finance.originalAmount),
              thbEquivalent: parseFloat(finance.thbAmount)
            });
          }
          return acc;
        }, []);
        return {
          reportData: finances3,
          summary: {
            totalIncome: income,
            totalExpenses: expenses,
            netProfit: income - expenses,
            currencyBreakdown
          }
        };
      }
      // Export operations
      async exportFinancialData(organizationId2, exportRequest) {
        const exportLog = await this.createFinanceExportLog({
          organizationId: organizationId2,
          exportType: exportRequest.exportType,
          exportFormat: exportRequest.format,
          dateRange: exportRequest.dateRange,
          propertyIds: exportRequest.filters.propertyIds,
          ownerIds: exportRequest.filters.ownerIds,
          currencies: exportRequest.filters.currencies,
          categories: exportRequest.filters.categories,
          requestedBy: "system",
          // This should be passed from the request
          status: "pending"
        });
        const fileName = `finance_export_${exportRequest.dateRange}_${Date.now()}.${exportRequest.exportType === "excel" ? "xlsx" : exportRequest.exportType === "csv" ? "csv" : "pdf"}`;
        const fileUrl = `/exports/${fileName}`;
        const fileSize = 2048;
        const recordCount = 150;
        await this.updateFinanceExportLog(exportLog.id, {
          status: "completed",
          fileUrl,
          fileName,
          fileSize,
          recordCount,
          completedAt: /* @__PURE__ */ new Date(),
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3)
          // 7 days
        });
        return { fileUrl, fileName, fileSize, recordCount };
      }
      // ===== AUTOMATED INVOICE CREATOR TOOL OPERATIONS =====
      // Invoice Templates
      async getInvoiceTemplates(organizationId2, filters) {
        let query = db.select().from(invoiceTemplates).where(eq2(invoiceTemplates.organizationId, organizationId2));
        if (filters?.templateType) {
          query = query.where(eq2(invoiceTemplates.templateType, filters.templateType));
        }
        if (filters?.isActive !== void 0) {
          query = query.where(eq2(invoiceTemplates.isActive, filters.isActive));
        }
        return await query.orderBy(asc(invoiceTemplates.templateName));
      }
      async getInvoiceTemplateById(id) {
        const [template] = await db.select().from(invoiceTemplates).where(eq2(invoiceTemplates.id, id));
        return template;
      }
      async createInvoiceTemplate(template) {
        const [newTemplate] = await db.insert(invoiceTemplates).values(template).returning();
        return newTemplate;
      }
      async updateInvoiceTemplate(id, template) {
        const [updatedTemplate] = await db.update(invoiceTemplates).set({ ...template, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(invoiceTemplates.id, id)).returning();
        return updatedTemplate;
      }
      async deleteInvoiceTemplate(id) {
        const result = await db.delete(invoiceTemplates).where(eq2(invoiceTemplates.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Generated Invoices
      async getGeneratedInvoices(organizationId2, filters) {
        let query = db.select().from(generatedInvoices).where(eq2(generatedInvoices.organizationId, organizationId2));
        if (filters?.status) {
          query = query.where(eq2(generatedInvoices.status, filters.status));
        }
        if (filters?.paymentStatus) {
          query = query.where(eq2(generatedInvoices.paymentStatus, filters.paymentStatus));
        }
        if (filters?.senderType) {
          query = query.where(eq2(generatedInvoices.senderType, filters.senderType));
        }
        if (filters?.receiverType) {
          query = query.where(eq2(generatedInvoices.receiverType, filters.receiverType));
        }
        if (filters?.startDate) {
          query = query.where(gte2(generatedInvoices.invoiceDate, filters.startDate));
        }
        if (filters?.endDate) {
          query = query.where(lte2(generatedInvoices.invoiceDate, filters.endDate));
        }
        return await query.orderBy(desc2(generatedInvoices.createdAt));
      }
      async getGeneratedInvoiceById(id) {
        const [invoice] = await db.select().from(generatedInvoices).where(eq2(generatedInvoices.id, id));
        return invoice;
      }
      async getInvoiceByNumber(invoiceNumber) {
        const [invoice] = await db.select().from(generatedInvoices).where(eq2(generatedInvoices.invoiceNumber, invoiceNumber));
        return invoice;
      }
      async createGeneratedInvoice(invoice) {
        const [newInvoice] = await db.insert(generatedInvoices).values(invoice).returning();
        return newInvoice;
      }
      async updateGeneratedInvoice(id, invoice) {
        const [updatedInvoice] = await db.update(generatedInvoices).set({ ...invoice, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(generatedInvoices.id, id)).returning();
        return updatedInvoice;
      }
      async markInvoiceAsPaid(id, paymentData) {
        const [updatedInvoice] = await db.update(generatedInvoices).set({
          ...paymentData,
          status: "paid",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(generatedInvoices.id, id)).returning();
        return updatedInvoice;
      }
      // Invoice Line Items
      async getInvoiceLineItems(invoiceId) {
        return await db.select().from(invoiceLineItems).where(eq2(invoiceLineItems.invoiceId, invoiceId)).orderBy(asc(invoiceLineItems.id));
      }
      async addInvoiceLineItem(lineItem) {
        const [newLineItem] = await db.insert(invoiceLineItems).values(lineItem).returning();
        return newLineItem;
      }
      async updateInvoiceLineItem(id, lineItem) {
        const [updatedLineItem] = await db.update(invoiceLineItems).set(lineItem).where(eq2(invoiceLineItems.id, id)).returning();
        return updatedLineItem;
      }
      async deleteInvoiceLineItem(id) {
        const result = await db.delete(invoiceLineItems).where(eq2(invoiceLineItems.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Invoice Booking Links
      async getInvoiceBookingLinks(invoiceId) {
        return await db.select().from(invoiceBookingLinks).where(eq2(invoiceBookingLinks.invoiceId, invoiceId)).orderBy(asc(invoiceBookingLinks.id));
      }
      async addInvoiceBookingLink(bookingLink) {
        const [newBookingLink] = await db.insert(invoiceBookingLinks).values(bookingLink).returning();
        return newBookingLink;
      }
      // Invoice Service Links
      async getInvoiceServiceLinks(invoiceId) {
        return await db.select().from(invoiceServiceLinks).where(eq2(invoiceServiceLinks.invoiceId, invoiceId)).orderBy(asc(invoiceServiceLinks.id));
      }
      async addInvoiceServiceLink(serviceLink) {
        const [newServiceLink] = await db.insert(invoiceServiceLinks).values(serviceLink).returning();
        return newServiceLink;
      }
      // Invoice Generation Utilities
      async generateInvoiceNumber(organizationId2) {
        const today = /* @__PURE__ */ new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, "0");
        const startOfMonth = `${year}-${month}-01`;
        const endOfMonth = `${year}-${month}-31`;
        const monthlyInvoices = await db.select({ count: sql3`count(*)` }).from(generatedInvoices).where(
          and3(
            eq2(generatedInvoices.organizationId, organizationId2),
            gte2(generatedInvoices.invoiceDate, startOfMonth),
            lte2(generatedInvoices.invoiceDate, endOfMonth)
          )
        );
        const sequence = (monthlyInvoices[0]?.count || 0) + 1;
        return `INV-${year}${month}-${String(sequence).padStart(4, "0")}`;
      }
      // Booking Data for Invoice Generation
      async getBookingsForInvoice(organizationId2, filters) {
        let query = db.select({
          id: bookings.id,
          propertyId: bookings.propertyId,
          guestName: bookings.guestName,
          checkIn: bookings.checkIn,
          checkOut: bookings.checkOut,
          totalAmount: bookings.totalAmount,
          currency: bookings.currency,
          status: bookings.status,
          // Add property information
          propertyName: properties.name,
          propertyAddress: properties.address,
          // Add owner information
          ownerId: properties.ownerId
        }).from(bookings).leftJoin(properties, eq2(bookings.propertyId, properties.id)).where(
          and3(
            eq2(bookings.organizationId, organizationId2),
            gte2(bookings.checkIn, filters.startDate),
            lte2(bookings.checkOut, filters.endDate),
            eq2(bookings.status, "confirmed")
          )
        );
        if (filters.propertyIds && filters.propertyIds.length > 0) {
          query = query.where(inArray(bookings.propertyId, filters.propertyIds));
        }
        if (filters.ownerId) {
          query = query.where(eq2(properties.ownerId, filters.ownerId));
        }
        return await query.orderBy(asc(bookings.checkIn));
      }
      // Add-on Services for Invoice Generation
      async getAddonServicesForInvoice(organizationId2, filters) {
        let query = db.select({
          id: guestAddonBookings.id,
          serviceId: guestAddonBookings.serviceId,
          propertyId: guestAddonBookings.propertyId,
          serviceName: guestAddonServices.serviceName,
          serviceDate: guestAddonBookings.serviceDate,
          totalAmount: guestAddonBookings.totalAmount,
          billingRoute: guestAddonBookings.billingRoute,
          status: guestAddonBookings.status,
          guestName: guestAddonBookings.guestName
        }).from(guestAddonBookings).leftJoin(guestAddonServices, eq2(guestAddonBookings.serviceId, guestAddonServices.id)).where(
          and3(
            eq2(guestAddonBookings.organizationId, organizationId2),
            gte2(guestAddonBookings.serviceDate, filters.startDate),
            lte2(guestAddonBookings.serviceDate, filters.endDate),
            eq2(guestAddonBookings.status, "completed")
          )
        );
        if (filters.propertyIds && filters.propertyIds.length > 0) {
          query = query.where(inArray(guestAddonBookings.propertyId, filters.propertyIds));
        }
        if (filters.billingRoute) {
          query = query.where(eq2(guestAddonBookings.billingRoute, filters.billingRoute));
        }
        return await query.orderBy(asc(guestAddonBookings.serviceDate));
      }
      // Commission Data for Portfolio Manager Invoices
      async getCommissionDataForInvoice(organizationId2, filters) {
        const bookings3 = await this.getBookingsForInvoice(organizationId2, {
          startDate: filters.startDate,
          endDate: filters.endDate,
          propertyIds: filters.propertyIds,
          portfolioManagerId: filters.portfolioManagerId
        });
        return bookings3.map((booking) => ({
          ...booking,
          managementCommission: parseFloat(booking.totalAmount) * 0.3,
          // 30% management fee
          portfolioManagerShare: parseFloat(booking.totalAmount) * 0.15
          // 50% of management goes to PM
        }));
      }
      // Invoice Analytics
      async getInvoiceAnalytics(organizationId2, dateRange) {
        let query = db.select({
          totalInvoices: sql3`count(*)`,
          totalAmount: sql3`sum(${generatedInvoices.totalAmount})`,
          paidAmount: sql3`sum(case when ${generatedInvoices.paymentStatus} = 'paid' then ${generatedInvoices.totalAmount} else 0 end)`,
          unpaidAmount: sql3`sum(case when ${generatedInvoices.paymentStatus} = 'unpaid' then ${generatedInvoices.totalAmount} else 0 end)`
        }).from(generatedInvoices).where(eq2(generatedInvoices.organizationId, organizationId2));
        if (dateRange) {
          query = query.where(
            and3(
              gte2(generatedInvoices.invoiceDate, dateRange.startDate),
              lte2(generatedInvoices.invoiceDate, dateRange.endDate)
            )
          );
        }
        const [analytics] = await query;
        return analytics;
      }
      // ===== AUTOMATED INVOICE CREATOR TOOL OPERATIONS =====
      // Invoice Templates
      async getInvoiceTemplates(organizationId2, filters) {
        let query = db.select().from(invoiceTemplates).where(eq2(invoiceTemplates.organizationId, organizationId2));
        if (filters?.templateType) {
          query = query.where(eq2(invoiceTemplates.templateType, filters.templateType));
        }
        if (filters?.isActive !== void 0) {
          query = query.where(eq2(invoiceTemplates.isActive, filters.isActive));
        }
        return await query;
      }
      async createInvoiceTemplate(template) {
        const [newTemplate] = await db.insert(invoiceTemplates).values(template).returning();
        return newTemplate;
      }
      async updateInvoiceTemplate(id, updates) {
        const [updatedTemplate] = await db.update(invoiceTemplates).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(invoiceTemplates.id, id)).returning();
        return updatedTemplate;
      }
      async deleteInvoiceTemplate(id) {
        await db.delete(invoiceTemplates).where(eq2(invoiceTemplates.id, id));
      }
      // Generated Invoices
      async getInvoices(organizationId2, filters) {
        let query = db.select().from(generatedInvoices).where(eq2(generatedInvoices.organizationId, organizationId2));
        if (filters?.status) {
          query = query.where(eq2(generatedInvoices.status, filters.status));
        }
        if (filters?.senderType) {
          query = query.where(eq2(generatedInvoices.senderType, filters.senderType));
        }
        if (filters?.receiverType) {
          query = query.where(eq2(generatedInvoices.receiverType, filters.receiverType));
        }
        if (filters?.periodStart) {
          query = query.where(gte2(generatedInvoices.periodStart, filters.periodStart));
        }
        if (filters?.periodEnd) {
          query = query.where(lte2(generatedInvoices.periodEnd, filters.periodEnd));
        }
        return await query.orderBy(desc2(generatedInvoices.createdAt));
      }
      async getInvoiceById(id) {
        const [invoice] = await db.select().from(generatedInvoices).where(eq2(generatedInvoices.id, id));
        return invoice;
      }
      async createInvoice(invoice) {
        const [newInvoice] = await db.insert(generatedInvoices).values(invoice).returning();
        return newInvoice;
      }
      async updateInvoice(id, updates) {
        const [updatedInvoice] = await db.update(generatedInvoices).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(generatedInvoices.id, id)).returning();
        return updatedInvoice;
      }
      async deleteInvoice(id) {
        await db.delete(generatedInvoices).where(eq2(generatedInvoices.id, id));
      }
      // Invoice Line Items
      async getInvoiceLineItems(invoiceId) {
        return await db.select().from(invoiceLineItems).where(eq2(invoiceLineItems.invoiceId, invoiceId));
      }
      async createInvoiceLineItem(lineItem) {
        const [newLineItem] = await db.insert(invoiceLineItems).values(lineItem).returning();
        return newLineItem;
      }
      async updateInvoiceLineItem(id, updates) {
        const [updatedLineItem] = await db.update(invoiceLineItems).set(updates).where(eq2(invoiceLineItems.id, id)).returning();
        return updatedLineItem;
      }
      async deleteInvoiceLineItem(id) {
        await db.delete(invoiceLineItems).where(eq2(invoiceLineItems.id, id));
      }
      // Invoice Booking Links
      async getInvoiceBookingLinks(invoiceId) {
        return await db.select().from(invoiceBookingLinks).where(eq2(invoiceBookingLinks.invoiceId, invoiceId));
      }
      async createInvoiceBookingLink(link) {
        const [newLink] = await db.insert(invoiceBookingLinks).values(link).returning();
        return newLink;
      }
      // Invoice Service Links
      async getInvoiceServiceLinks(invoiceId) {
        return await db.select().from(invoiceServiceLinks).where(eq2(invoiceServiceLinks.invoiceId, invoiceId));
      }
      async createInvoiceServiceLink(link) {
        const [newLink] = await db.insert(invoiceServiceLinks).values(link).returning();
        return newLink;
      }
      // Invoice Analytics
      async getInvoiceAnalytics(organizationId2, filters) {
        let baseQuery = db.select().from(generatedInvoices).where(eq2(generatedInvoices.organizationId, organizationId2));
        if (filters?.startDate) {
          baseQuery = baseQuery.where(gte2(generatedInvoices.invoiceDate, filters.startDate));
        }
        if (filters?.endDate) {
          baseQuery = baseQuery.where(lte2(generatedInvoices.invoiceDate, filters.endDate));
        }
        const invoices2 = await baseQuery;
        const totalInvoices = invoices2.length;
        const totalAmount = invoices2.reduce((sum4, inv) => sum4 + parseFloat(inv.totalAmount), 0);
        const paidInvoices = invoices2.filter((inv) => inv.paymentStatus === "paid");
        const paidAmount = paidInvoices.reduce((sum4, inv) => sum4 + parseFloat(inv.totalAmount), 0);
        const unpaidAmount = totalAmount - paidAmount;
        const averageInvoiceValue = totalInvoices > 0 ? totalAmount / totalInvoices : 0;
        const monthlyMap = /* @__PURE__ */ new Map();
        invoices2.forEach((invoice) => {
          const month = new Date(invoice.invoiceDate).toISOString().slice(0, 7);
          if (!monthlyMap.has(month)) {
            monthlyMap.set(month, { totalInvoices: 0, totalAmount: 0, paidAmount: 0 });
          }
          const monthData = monthlyMap.get(month);
          monthData.totalInvoices++;
          monthData.totalAmount += parseFloat(invoice.totalAmount);
          if (invoice.paymentStatus === "paid") {
            monthData.paidAmount += parseFloat(invoice.totalAmount);
          }
        });
        const monthlyBreakdown = Array.from(monthlyMap.entries()).map(([month, data]) => ({
          month,
          ...data
        })).sort((a, b) => a.month.localeCompare(b.month));
        return {
          totalInvoices,
          totalAmount,
          paidAmount,
          unpaidAmount,
          averageInvoiceValue,
          monthlyBreakdown
        };
      }
      // Utility method to generate next invoice number
      async generateInvoiceNumber(organizationId2) {
        const currentDate = /* @__PURE__ */ new Date();
        const year = currentDate.getFullYear();
        const month = String(currentDate.getMonth() + 1).padStart(2, "0");
        const monthStart = `${year}-${month}-01`;
        const monthEnd = `${year}-${month}-31`;
        const invoicesThisMonth = await db.select().from(generatedInvoices).where(
          and3(
            eq2(generatedInvoices.organizationId, organizationId2),
            gte2(generatedInvoices.invoiceDate, monthStart),
            lte2(generatedInvoices.invoiceDate, monthEnd)
          )
        );
        const sequence = invoicesThisMonth.length + 1;
        return `INV-${year}${month}-${String(sequence).padStart(4, "0")}`;
      }
      // ===== COMMUNICATION SYSTEM OPERATIONS =====
      // Communication Channels
      async getCommunicationChannels(organizationId2, filters) {
        let query = db.select().from(communicationChannels).where(eq2(communicationChannels.organizationId, organizationId2));
        if (filters?.channelType) {
          query = query.where(eq2(communicationChannels.channelType, filters.channelType));
        }
        if (filters?.department) {
          query = query.where(eq2(communicationChannels.department, filters.department));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(communicationChannels.propertyId, filters.propertyId));
        }
        return await query.where(eq2(communicationChannels.isActive, true)).orderBy(asc(communicationChannels.name));
      }
      async createCommunicationChannel(channelData) {
        const [channel] = await db.insert(communicationChannels).values(channelData).returning();
        return channel;
      }
      async updateCommunicationChannel(id, updates) {
        const [channel] = await db.update(communicationChannels).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(communicationChannels.id, id)).returning();
        return channel;
      }
      // Channel Members
      async getChannelMembers(channelId) {
        return await db.select().from(channelMembers).where(eq2(channelMembers.channelId, channelId));
      }
      async addChannelMember(memberData) {
        const [member] = await db.insert(channelMembers).values(memberData).returning();
        return member;
      }
      async removeChannelMember(channelId, userId) {
        await db.delete(channelMembers).where(and3(eq2(channelMembers.channelId, channelId), eq2(channelMembers.userId, userId)));
      }
      async updateLastReadAt(channelId, userId) {
        await db.update(channelMembers).set({ lastReadAt: /* @__PURE__ */ new Date() }).where(and3(eq2(channelMembers.channelId, channelId), eq2(channelMembers.userId, userId)));
      }
      // Internal Messages
      async getInternalMessages(channelId, limit = 50, offset = 0) {
        return await db.select().from(internalMessages).where(and3(eq2(internalMessages.channelId, channelId), isNull2(internalMessages.deletedAt))).orderBy(desc2(internalMessages.sentAt)).limit(limit).offset(offset);
      }
      async createInternalMessage(messageData) {
        const [message] = await db.insert(internalMessages).values(messageData).returning();
        if (messageData.logToPropertyTimeline && messageData.relatedPropertyId) {
          await this.createCommunicationLog({
            organizationId: messageData.organizationId,
            logType: "property_activity",
            sourceType: "internal_message",
            sourceId: message.id,
            propertyId: messageData.relatedPropertyId,
            userId: messageData.senderId,
            summary: `Internal message: ${messageData.message.substring(0, 100)}...`,
            details: messageData.message,
            attachmentUrl: messageData.attachmentUrl
          });
        }
        return message;
      }
      async markMessageAsImportant(messageId) {
        await db.update(internalMessages).set({ isImportant: true }).where(eq2(internalMessages.id, messageId));
      }
      async deleteInternalMessage(messageId) {
        await db.update(internalMessages).set({ deletedAt: /* @__PURE__ */ new Date() }).where(eq2(internalMessages.id, messageId));
      }
      // Owner  PM Communication
      async getOwnerPmCommunication(organizationId2, filters) {
        let query = db.select().from(ownerPmCommunication).where(eq2(ownerPmCommunication.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(ownerPmCommunication.propertyId, filters.propertyId));
        }
        if (filters?.senderId) {
          query = query.where(eq2(ownerPmCommunication.senderId, filters.senderId));
        }
        if (filters?.recipientId) {
          query = query.where(eq2(ownerPmCommunication.recipientId, filters.recipientId));
        }
        if (filters?.status) {
          query = query.where(eq2(ownerPmCommunication.status, filters.status));
        }
        return await query.orderBy(desc2(ownerPmCommunication.sentAt));
      }
      async createOwnerPmCommunication(communicationData) {
        const [communication] = await db.insert(ownerPmCommunication).values(communicationData).returning();
        await this.createCommunicationLog({
          organizationId: communicationData.organizationId,
          logType: "property_activity",
          sourceType: "owner_pm_communication",
          sourceId: communication.id,
          propertyId: communicationData.propertyId,
          userId: communicationData.senderId,
          summary: `${communicationData.senderType.toUpperCase()} \u2192 ${communicationData.recipientType.toUpperCase()}: ${communicationData.subject || "Update"}`,
          details: communicationData.message,
          attachmentUrl: communicationData.attachmentUrl
        });
        return communication;
      }
      async markOwnerPmCommunicationAsRead(communicationId) {
        await db.update(ownerPmCommunication).set({ status: "read", readAt: /* @__PURE__ */ new Date() }).where(eq2(ownerPmCommunication.id, communicationId));
      }
      async approveOwnerPmRequest(communicationId, approvedBy) {
        await db.update(ownerPmCommunication).set({
          approvalStatus: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          status: "approved"
        }).where(eq2(ownerPmCommunication.id, communicationId));
      }
      async rejectOwnerPmRequest(communicationId, approvedBy) {
        await db.update(ownerPmCommunication).set({
          approvalStatus: "rejected",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          status: "rejected"
        }).where(eq2(ownerPmCommunication.id, communicationId));
      }
      // Guest Smart Requests
      async getGuestSmartRequests(organizationId2, filters) {
        let query = db.select().from(guestSmartRequests).where(eq2(guestSmartRequests.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(guestSmartRequests.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          query = query.where(eq2(guestSmartRequests.status, filters.status));
        }
        if (filters?.urgencyLevel) {
          query = query.where(eq2(guestSmartRequests.urgencyLevel, filters.urgencyLevel));
        }
        if (filters?.routedToDepartment) {
          query = query.where(eq2(guestSmartRequests.routedToDepartment, filters.routedToDepartment));
        }
        return await query.orderBy(desc2(guestSmartRequests.createdAt));
      }
      async createGuestSmartRequest(requestData) {
        const aiAnalysis = this.generateAIAnalysis(requestData.requestCategory, requestData.description);
        const routedToDepartment = this.routeRequestToDepartment(requestData.requestCategory, requestData.requestSubcategory);
        const autoReplyMessage = this.generateAutoReply(requestData.requestCategory, requestData.urgencyLevel || "medium");
        const [request] = await db.insert(guestSmartRequests).values({
          ...requestData,
          aiAnalysis,
          aiConfidence: 0.85,
          // Mock confidence score
          routedToDepartment,
          autoReplyMessage,
          estimatedResolutionTime: this.getEstimatedResolutionTime(requestData.requestCategory, requestData.urgencyLevel || "medium")
        }).returning();
        await this.createCommunicationLog({
          organizationId: requestData.organizationId,
          logType: "guest_stay",
          sourceType: "guest_request",
          sourceId: request.id,
          propertyId: requestData.propertyId,
          bookingId: requestData.bookingId || void 0,
          userId: "system",
          // System-generated log
          summary: `Guest request: ${requestData.requestCategory} - ${requestData.urgencyLevel} priority`,
          details: requestData.description
        });
        return request;
      }
      async acknowledgeGuestRequest(requestId, assignedUserId) {
        await db.update(guestSmartRequests).set({
          status: "acknowledged",
          assignedToUserId: assignedUserId,
          acknowledgedAt: /* @__PURE__ */ new Date()
        }).where(eq2(guestSmartRequests.id, requestId));
      }
      async updateGuestRequestStatus(requestId, status, internalNotes) {
        const updates = { status };
        if (status === "resolved") {
          updates.resolvedAt = /* @__PURE__ */ new Date();
          updates.actualResolutionTime = /* @__PURE__ */ new Date();
        }
        if (internalNotes) {
          updates.internalNotes = internalNotes;
        }
        await db.update(guestSmartRequests).set(updates).where(eq2(guestSmartRequests.id, requestId));
      }
      async rateGuestRequest(requestId, rating, feedback) {
        await db.update(guestSmartRequests).set({
          guestSatisfactionRating: rating,
          guestFeedback: feedback
        }).where(eq2(guestSmartRequests.id, requestId));
      }
      // Communication Logs
      async createCommunicationLog(logData) {
        const [log2] = await db.insert(communicationLogs).values(logData).returning();
        return log2;
      }
      async getCommunicationLogs(organizationId2, filters) {
        let query = db.select().from(communicationLogs).where(eq2(communicationLogs.organizationId, organizationId2));
        if (filters?.logType) {
          query = query.where(eq2(communicationLogs.logType, filters.logType));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(communicationLogs.propertyId, filters.propertyId));
        }
        if (filters?.bookingId) {
          query = query.where(eq2(communicationLogs.bookingId, filters.bookingId));
        }
        if (filters?.isArchived !== void 0) {
          query = query.where(eq2(communicationLogs.isArchived, filters.isArchived));
        }
        return await query.orderBy(desc2(communicationLogs.createdAt));
      }
      async archiveCommunicationLogs(organizationId2, olderThanDays = 30) {
        const cutoffDate = /* @__PURE__ */ new Date();
        cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
        const result = await db.update(communicationLogs).set({ isArchived: true, archivedAt: /* @__PURE__ */ new Date() }).where(
          and3(
            eq2(communicationLogs.organizationId, organizationId2),
            lt(communicationLogs.createdAt, cutoffDate),
            eq2(communicationLogs.isArchived, false)
          )
        );
        return result.rowCount || 0;
      }
      // Smart Request Configuration
      async getSmartRequestConfig(organizationId2, category) {
        let query = db.select().from(smartRequestConfig).where(eq2(smartRequestConfig.organizationId, organizationId2));
        if (category) {
          query = query.where(eq2(smartRequestConfig.category, category));
        }
        return await query.where(eq2(smartRequestConfig.isActive, true));
      }
      async createSmartRequestConfig(configData) {
        const [config] = await db.insert(smartRequestConfig).values(configData).returning();
        return config;
      }
      async updateSmartRequestConfig(id, updates) {
        const [config] = await db.update(smartRequestConfig).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(smartRequestConfig.id, id)).returning();
        return config;
      }
      // Missing Staff Tables Methods (fixing database errors)
      async getStaffAdvanceRequests(organizationId2, filters) {
        let query = db.select().from(staffAdvanceRequests).where(eq2(staffAdvanceRequests.organizationId, organizationId2));
        if (filters?.staffId) {
          query = query.where(eq2(staffAdvanceRequests.staffId, filters.staffId));
        }
        if (filters?.status) {
          query = query.where(eq2(staffAdvanceRequests.status, filters.status));
        }
        return await query.orderBy(desc2(staffAdvanceRequests.requestDate));
      }
      async createStaffAdvanceRequest(requestData) {
        const [request] = await db.insert(staffAdvanceRequests).values(requestData).returning();
        return request;
      }
      async updateStaffAdvanceRequest(id, updates) {
        const [request] = await db.update(staffAdvanceRequests).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffAdvanceRequests.id, id)).returning();
        return request;
      }
      async getStaffClockEntries(organizationId2, filters) {
        let query = db.select().from(staffClockEntries).where(eq2(staffClockEntries.organizationId, organizationId2));
        if (filters?.staffId) {
          query = query.where(eq2(staffClockEntries.staffId, filters.staffId));
        }
        if (filters?.workDate) {
          query = query.where(eq2(staffClockEntries.workDate, filters.workDate));
        }
        if (filters?.status) {
          query = query.where(eq2(staffClockEntries.status, filters.status));
        }
        return await query.orderBy(desc2(staffClockEntries.workDate), desc2(staffClockEntries.clockInTime));
      }
      async createStaffClockEntry(entryData) {
        const [entry] = await db.insert(staffClockEntries).values(entryData).returning();
        return entry;
      }
      async updateStaffClockEntry(id, updates) {
        const [entry] = await db.update(staffClockEntries).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffClockEntries.id, id)).returning();
        return entry;
      }
      // Helper methods for AI processing
      generateAIAnalysis(category, description) {
        const analyses = {
          "ac_water_electricity": "Technical issue detected. Requires immediate maintenance attention. High priority routing to technical team.",
          "extra_cleaning": "Housekeeping request identified. Standard cleaning protocol applicable. Route to housekeeping supervisor.",
          "order_services": "Service order request. Requires concierge coordination. Standard fulfillment process.",
          "other": "General inquiry requiring manual review and appropriate department routing."
        };
        return analyses[category] || analyses["other"];
      }
      routeRequestToDepartment(category, subcategory) {
        const routing = {
          "ac_water_electricity": "maintenance",
          "extra_cleaning": "cleaning",
          "order_services": "concierge",
          "other": "concierge"
        };
        return routing[category] || "concierge";
      }
      generateAutoReply(category, urgencyLevel) {
        const urgencyResponseTime = {
          "emergency": "within 30 minutes",
          "high": "within 1 hour",
          "medium": "within 2 hours",
          "low": "within 4 hours"
        };
        const categoryMessages = {
          "ac_water_electricity": "We've received your technical support request and our maintenance team has been notified.",
          "extra_cleaning": "Your cleaning request has been forwarded to our housekeeping team.",
          "order_services": "Thank you for your service request. Our concierge team will contact you shortly.",
          "other": "We've received your request and will respond appropriately."
        };
        const timeframe = urgencyResponseTime[urgencyLevel] || urgencyResponseTime["medium"];
        const baseMessage = categoryMessages[category] || categoryMessages["other"];
        return `${baseMessage} You can expect a response ${timeframe}. Thank you for staying with us!`;
      }
      getEstimatedResolutionTime(category, urgencyLevel) {
        const resolutionTimes = {
          "ac_water_electricity": {
            "emergency": "30 minutes",
            "high": "1 hour",
            "medium": "2 hours",
            "low": "4 hours"
          },
          "extra_cleaning": {
            "emergency": "1 hour",
            "high": "2 hours",
            "medium": "4 hours",
            "low": "8 hours"
          },
          "order_services": {
            "emergency": "1 hour",
            "high": "2 hours",
            "medium": "4 hours",
            "low": "24 hours"
          },
          "other": {
            "emergency": "1 hour",
            "high": "2 hours",
            "medium": "4 hours",
            "low": "24 hours"
          }
        };
        return resolutionTimes[category]?.[urgencyLevel] || resolutionTimes["other"][urgencyLevel] || "4 hours";
      }
      // ===== OWNER INVOICING & PAYOUT SYSTEM =====
      // ===== OWNER BALANCE MANAGEMENT =====
      // Get/create owner balance for a property
      async getOwnerBalance(organizationId2, ownerId, propertyId, month, year) {
        const currentMonth = month || (/* @__PURE__ */ new Date()).getMonth() + 1;
        const currentYear = year || (/* @__PURE__ */ new Date()).getFullYear();
        let query = db.select().from(ownerBalances).where(
          and3(
            eq2(ownerBalances.organizationId, organizationId2),
            eq2(ownerBalances.ownerId, ownerId),
            eq2(ownerBalances.balanceMonth, currentMonth),
            eq2(ownerBalances.balanceYear, currentYear)
          )
        );
        if (propertyId) {
          query = query.where(eq2(ownerBalances.propertyId, propertyId));
        }
        const [balance] = await query;
        return balance;
      }
      // Calculate and update owner balance
      async calculateOwnerBalance(organizationId2, ownerId, propertyId) {
        const currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
        const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        const rentalIncome = await this.getOwnerRentalIncome(organizationId2, ownerId, propertyId, currentMonth, currentYear);
        const expenses = await this.getOwnerExpenses(organizationId2, ownerId, propertyId, currentMonth, currentYear);
        const currentBalance = rentalIncome.total - expenses.totalExpenses - expenses.managementFees;
        const balanceData = {
          organizationId: organizationId2,
          ownerId,
          propertyId,
          currentBalance: currentBalance.toString(),
          monthlyRentalIncome: rentalIncome.total.toString(),
          monthlyServiceCharges: rentalIncome.serviceCharges.toString(),
          totalExpenses: expenses.totalExpenses.toString(),
          managementFees: expenses.managementFees.toString(),
          monthlyUtilities: expenses.utilities.toString(),
          monthlyMaintenance: expenses.maintenance.toString(),
          balanceMonth: currentMonth,
          balanceYear: currentYear,
          status: "current",
          processedBy: "system"
        };
        const existing = await this.getOwnerBalance(organizationId2, ownerId, propertyId, currentMonth, currentYear);
        if (existing) {
          const [updated] = await db.update(ownerBalances).set({ ...balanceData, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(ownerBalances.id, existing.id)).returning();
          return updated;
        } else {
          const [created] = await db.insert(ownerBalances).values(balanceData).returning();
          return created;
        }
      }
      // Get owner rental income breakdown
      async getOwnerRentalIncome(organizationId2, ownerId, propertyId, month, year) {
        const startDate = new Date(year || (/* @__PURE__ */ new Date()).getFullYear(), (month || (/* @__PURE__ */ new Date()).getMonth() + 1) - 1, 1);
        const endDate = new Date(year || (/* @__PURE__ */ new Date()).getFullYear(), month || (/* @__PURE__ */ new Date()).getMonth() + 1, 0);
        let query = db.select().from(finances).where(
          and3(
            eq2(finances.organizationId, organizationId2),
            eq2(finances.type, "income"),
            gte2(finances.date, startDate.toISOString().split("T")[0]),
            lte2(finances.date, endDate.toISOString().split("T")[0])
          )
        );
        if (propertyId) {
          query = query.where(eq2(finances.propertyId, propertyId));
        }
        const incomeRecords = await query;
        const total = incomeRecords.reduce((sum4, record) => sum4 + parseFloat(record.amount), 0);
        const serviceCharges = incomeRecords.filter((record) => record.category === "service").reduce((sum4, record) => sum4 + parseFloat(record.amount), 0);
        return {
          total,
          serviceCharges,
          directBookings: total * 0.3,
          // Simplified calculation
          platformBookings: total * 0.7
        };
      }
      // Get owner expenses breakdown
      async getOwnerExpenses(organizationId2, ownerId, propertyId, month, year) {
        const startDate = new Date(year || (/* @__PURE__ */ new Date()).getFullYear(), (month || (/* @__PURE__ */ new Date()).getMonth() + 1) - 1, 1);
        const endDate = new Date(year || (/* @__PURE__ */ new Date()).getFullYear(), month || (/* @__PURE__ */ new Date()).getMonth() + 1, 0);
        let query = db.select().from(finances).where(
          and3(
            eq2(finances.organizationId, organizationId2),
            eq2(finances.type, "expense"),
            gte2(finances.date, startDate.toISOString().split("T")[0]),
            lte2(finances.date, endDate.toISOString().split("T")[0])
          )
        );
        if (propertyId) {
          query = query.where(eq2(finances.propertyId, propertyId));
        }
        const expenseRecords = await query;
        const utilities = expenseRecords.filter((record) => record.category === "utilities").reduce((sum4, record) => sum4 + parseFloat(record.amount), 0);
        const maintenance = expenseRecords.filter((record) => record.category === "maintenance").reduce((sum4, record) => sum4 + parseFloat(record.amount), 0);
        const cleaning = expenseRecords.filter((record) => record.category === "cleaning").reduce((sum4, record) => sum4 + parseFloat(record.amount), 0);
        const managementFees = expenseRecords.filter((record) => record.category === "management_fee").reduce((sum4, record) => sum4 + parseFloat(record.amount), 0);
        const totalExpenses = utilities + maintenance + cleaning;
        return {
          totalExpenses,
          managementFees,
          utilities,
          maintenance,
          cleaning
        };
      }
      // ===== OWNER PAYOUT REQUESTS =====
      // Create payout request
      async createOwnerPayoutRequest(request) {
        const [newRequest] = await db.insert(ownerPayoutRequests).values(request).returning();
        return newRequest;
      }
      // Get owner payout requests
      async getOwnerPayoutRequests(organizationId2, filters) {
        let query = db.select().from(ownerPayoutRequests).where(eq2(ownerPayoutRequests.organizationId, organizationId2));
        if (filters?.ownerId) {
          query = query.where(eq2(ownerPayoutRequests.ownerId, filters.ownerId));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(ownerPayoutRequests.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          query = query.where(eq2(ownerPayoutRequests.status, filters.status));
        }
        return query.orderBy(desc2(ownerPayoutRequests.createdAt));
      }
      // Update payout request status
      async updatePayoutRequestStatus(requestId, status, updateData) {
        const [updated] = await db.update(ownerPayoutRequests).set({
          status,
          ...updateData,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerPayoutRequests.id, requestId)).returning();
        return updated;
      }
      // ===== OWNER INVOICE MANAGEMENT =====
      // Create owner invoice
      async createOwnerInvoice(invoice) {
        const invoiceNumber = await this.generateOwnerInvoiceNumber(invoice.organizationId);
        const [newInvoice] = await db.insert(ownerInvoices).values({
          ...invoice,
          invoiceNumber
        }).returning();
        return newInvoice;
      }
      // Generate unique invoice number
      async generateOwnerInvoiceNumber(organizationId2) {
        const year = (/* @__PURE__ */ new Date()).getFullYear();
        const month = ((/* @__PURE__ */ new Date()).getMonth() + 1).toString().padStart(2, "0");
        const existingCount = await db.select({ count: sql3`count(*)` }).from(ownerInvoices).where(
          and3(
            eq2(ownerInvoices.organizationId, organizationId2),
            sql3`EXTRACT(YEAR FROM ${ownerInvoices.createdAt}) = ${year}`,
            sql3`EXTRACT(MONTH FROM ${ownerInvoices.createdAt}) = ${month}`
          )
        );
        const sequence = (existingCount[0]?.count || 0) + 1;
        return `OWN-${year}${month}-${sequence.toString().padStart(4, "0")}`;
      }
      // Get owner invoices
      async getOwnerInvoices(organizationId2, filters) {
        let query = db.select().from(ownerInvoices).where(eq2(ownerInvoices.organizationId, organizationId2));
        if (filters?.fromPartyId) {
          query = query.where(eq2(ownerInvoices.fromPartyId, filters.fromPartyId));
        }
        if (filters?.toPartyId) {
          query = query.where(eq2(ownerInvoices.toPartyId, filters.toPartyId));
        }
        if (filters?.status) {
          query = query.where(eq2(ownerInvoices.status, filters.status));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(ownerInvoices.propertyId, filters.propertyId));
        }
        if (filters?.invoiceType) {
          query = query.where(eq2(ownerInvoices.invoiceType, filters.invoiceType));
        }
        return query.orderBy(desc2(ownerInvoices.createdAt));
      }
      // Add line item to invoice
      async addOwnerInvoiceLineItem(lineItem) {
        const [newLineItem] = await db.insert(ownerInvoiceLineItems).values(lineItem).returning();
        await this.recalculateInvoiceTotals(lineItem.invoiceId);
        return newLineItem;
      }
      // Get invoice line items
      async getOwnerInvoiceLineItems(invoiceId) {
        return db.select().from(ownerInvoiceLineItems).where(eq2(ownerInvoiceLineItems.invoiceId, invoiceId)).orderBy(asc(ownerInvoiceLineItems.createdAt));
      }
      // Recalculate invoice totals
      async recalculateInvoiceTotals(invoiceId) {
        const lineItems = await this.getOwnerInvoiceLineItems(invoiceId);
        const subtotal = lineItems.reduce((sum4, item) => sum4 + parseFloat(item.lineTotal), 0);
        const taxAmount = lineItems.reduce((sum4, item) => sum4 + parseFloat(item.taxAmount || "0"), 0);
        const totalAmount = subtotal + taxAmount;
        await db.update(ownerInvoices).set({
          subtotal: subtotal.toString(),
          taxAmount: taxAmount.toString(),
          totalAmount: totalAmount.toString(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerInvoices.id, invoiceId));
      }
      // ===== AUTO-INVOICE GENERATION =====
      // Generate invoice from booking data
      async generateInvoiceFromBookings(organizationId2, ownerId, propertyId, periodStart, periodEnd, generatedBy) {
        const bookingIncome = await this.getBookingIncomeForPeriod(organizationId2, propertyId, periodStart, periodEnd);
        const serviceCharges = await this.getServiceChargesForPeriod(organizationId2, propertyId, periodStart, periodEnd);
        const invoice = await this.createOwnerInvoice({
          organizationId: organizationId2,
          fromParty: "management",
          fromPartyId: generatedBy,
          toParty: "owner",
          toPartyId: ownerId,
          propertyId,
          invoiceDate: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
          dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
          // 30 days
          periodStart,
          periodEnd,
          subtotal: "0",
          totalAmount: "0",
          invoiceType: "revenue_share",
          category: "rental_income",
          description: `Revenue share for ${periodStart} to ${periodEnd}`,
          isAutoGenerated: true,
          sourceBookingIds: bookingIncome.bookingIds,
          sourceServiceIds: serviceCharges.serviceIds,
          generatedBy
        });
        for (const income of bookingIncome.items) {
          await this.addOwnerInvoiceLineItem({
            organizationId: organizationId2,
            invoiceId: invoice.id,
            description: income.description,
            category: "rental",
            quantity: "1",
            unitPrice: income.amount.toString(),
            lineTotal: income.amount.toString(),
            chargeType: "owner_billable",
            sourceType: "booking",
            sourceId: income.bookingId,
            serviceDate: income.date,
            taxable: true
          });
        }
        for (const service of serviceCharges.items) {
          await this.addOwnerInvoiceLineItem({
            organizationId: organizationId2,
            invoiceId: invoice.id,
            description: service.description,
            category: service.category,
            quantity: "1",
            unitPrice: service.amount.toString(),
            lineTotal: service.amount.toString(),
            chargeType: service.chargeType,
            sourceType: "service",
            sourceId: service.serviceId,
            serviceDate: service.date,
            taxable: true
          });
        }
        return invoice;
      }
      // Get booking income for period
      async getBookingIncomeForPeriod(organizationId2, propertyId, startDate, endDate) {
        const bookings3 = await db.select().from(bookings3).where(
          and3(
            eq2(bookings3.organizationId, organizationId2),
            eq2(bookings3.propertyId, propertyId),
            gte2(bookings3.checkIn, startDate),
            lte2(bookings3.checkOut, endDate),
            eq2(bookings3.status, "confirmed")
          )
        );
        const items = bookings3.map((booking) => ({
          bookingId: booking.id,
          description: `Rental Income - ${booking.guestName} (${booking.checkIn} to ${booking.checkOut})`,
          amount: parseFloat(booking.totalAmount || "0"),
          date: booking.checkIn
        }));
        return {
          items,
          bookingIds: bookings3.map((b) => b.id)
        };
      }
      // Get service charges for period
      async getServiceChargesForPeriod(organizationId2, propertyId, startDate, endDate) {
        const services = await db.select().from(guestAddonBookings).where(
          and3(
            eq2(guestAddonBookings.organizationId, organizationId2),
            eq2(guestAddonBookings.propertyId, propertyId),
            gte2(guestAddonBookings.serviceDate || guestAddonBookings.createdAt, startDate),
            lte2(guestAddonBookings.serviceDate || guestAddonBookings.createdAt, endDate),
            eq2(guestAddonBookings.status, "completed")
          )
        );
        const items = services.map((service) => ({
          serviceId: service.id,
          description: `Service Charge - ${service.serviceId} (${service.serviceDate})`,
          amount: parseFloat(service.totalAmount || "0"),
          date: service.serviceDate || service.createdAt.toISOString().split("T")[0],
          category: "addon",
          chargeType: "owner_billable"
        }));
        return {
          items,
          serviceIds: services.map((s) => s.id)
        };
      }
      // ===== PORTFOLIO MANAGER COMMISSIONS =====
      // Create/update PM commission
      async updatePortfolioManagerCommission(commission) {
        const existing = await db.select().from(portfolioManagerCommissions).where(
          and3(
            eq2(portfolioManagerCommissions.organizationId, commission.organizationId),
            eq2(portfolioManagerCommissions.portfolioManagerId, commission.portfolioManagerId),
            eq2(portfolioManagerCommissions.commissionMonth, commission.commissionMonth),
            eq2(portfolioManagerCommissions.commissionYear, commission.commissionYear)
          )
        );
        if (existing.length > 0) {
          const [updated] = await db.update(portfolioManagerCommissions).set({ ...commission, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(portfolioManagerCommissions.id, existing[0].id)).returning();
          return updated;
        } else {
          const [created] = await db.insert(portfolioManagerCommissions).values(commission).returning();
          return created;
        }
      }
      // Get PM commissions
      async getPortfolioManagerCommissions(organizationId2, filters) {
        let query = db.select().from(portfolioManagerCommissions).where(eq2(portfolioManagerCommissions.organizationId, organizationId2));
        if (filters?.portfolioManagerId) {
          query = query.where(eq2(portfolioManagerCommissions.portfolioManagerId, filters.portfolioManagerId));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(portfolioManagerCommissions.propertyId, filters.propertyId));
        }
        if (filters?.month) {
          query = query.where(eq2(portfolioManagerCommissions.commissionMonth, filters.month));
        }
        if (filters?.year) {
          query = query.where(eq2(portfolioManagerCommissions.commissionYear, filters.year));
        }
        if (filters?.status) {
          query = query.where(eq2(portfolioManagerCommissions.status, filters.status));
        }
        return query.orderBy(desc2(portfolioManagerCommissions.createdAt));
      }
      // ===== SERVICE CHARGE CONFIGURATIONS =====
      // Create/update service charge config
      async updateServiceChargeConfig(config) {
        const existing = await db.select().from(serviceChargeConfigs).where(
          and3(
            eq2(serviceChargeConfigs.organizationId, config.organizationId),
            eq2(serviceChargeConfigs.serviceName, config.serviceName),
            config.propertyId ? eq2(serviceChargeConfigs.propertyId, config.propertyId) : isNull2(serviceChargeConfigs.propertyId)
          )
        );
        if (existing.length > 0) {
          const [updated] = await db.update(serviceChargeConfigs).set({ ...config, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(serviceChargeConfigs.id, existing[0].id)).returning();
          return updated;
        } else {
          const [created] = await db.insert(serviceChargeConfigs).values(config).returning();
          return created;
        }
      }
      // Get service charge configs
      async getServiceChargeConfigs(organizationId2, filters) {
        let query = db.select().from(serviceChargeConfigs).where(eq2(serviceChargeConfigs.organizationId, organizationId2));
        if (filters?.serviceName) {
          query = query.where(eq2(serviceChargeConfigs.serviceName, filters.serviceName));
        }
        if (filters?.serviceCategory) {
          query = query.where(eq2(serviceChargeConfigs.serviceCategory, filters.serviceCategory));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(serviceChargeConfigs.propertyId, filters.propertyId));
        }
        if (filters?.isActive !== void 0) {
          query = query.where(eq2(serviceChargeConfigs.isActive, filters.isActive));
        }
        return query.orderBy(asc(serviceChargeConfigs.serviceName));
      }
      // ===== FINANCIAL SUMMARY REPORTS =====
      // Create financial summary report
      async createFinancialSummaryReport(report) {
        const [newReport] = await db.insert(financialSummaryReports).values(report).returning();
        return newReport;
      }
      // Generate monthly financial summary
      async generateMonthlyFinancialSummary(organizationId2, month, year, generatedBy) {
        const rentalIncome = await this.calculateTotalRentalIncome(organizationId2, month, year);
        const serviceIncome = await this.calculateTotalServiceIncome(organizationId2, month, year);
        const addonIncome = await this.calculateTotalAddonIncome(organizationId2, month, year);
        const commissions = await this.calculateTotalCommissions(organizationId2, month, year);
        const payouts = await this.calculateTotalPayouts(organizationId2, month, year);
        const reportData = {
          organizationId: organizationId2,
          reportType: "monthly",
          reportMonth: month,
          reportYear: year,
          totalRentalIncome: rentalIncome.total.toString(),
          totalServiceIncome: serviceIncome.total.toString(),
          totalAddonIncome: addonIncome.total.toString(),
          cleaningRevenue: serviceIncome.cleaning.toString(),
          maintenanceRevenue: serviceIncome.maintenance.toString(),
          gardenPoolRevenue: serviceIncome.garden.toString(),
          chefServiceRevenue: addonIncome.chef.toString(),
          taxiServiceRevenue: addonIncome.taxi.toString(),
          tourServiceRevenue: addonIncome.tours.toString(),
          massageServiceRevenue: addonIncome.massage.toString(),
          totalCommissionsEarned: commissions.total.toString(),
          portfolioManagerCommissions: commissions.pm.toString(),
          retailAgentCommissions: commissions.retail.toString(),
          referralAgentCommissions: commissions.referral.toString(),
          totalOwnerPayouts: payouts.owners.toString(),
          totalAgentPayouts: payouts.agents.toString(),
          status: "completed",
          generatedBy
        };
        const [report] = await db.insert(financialSummaryReports).values(reportData).returning();
        return report;
      }
      // Calculate financial metrics for reports
      async calculateTotalRentalIncome(organizationId2, month, year) {
        const startDate = new Date(year, month - 1, 1);
        const endDate = new Date(year, month, 0);
        const income = await db.select({ total: sql3`sum(cast(amount as decimal))` }).from(finances).where(
          and3(
            eq2(finances.organizationId, organizationId2),
            eq2(finances.type, "income"),
            eq2(finances.category, "rental"),
            gte2(finances.date, startDate.toISOString().split("T")[0]),
            lte2(finances.date, endDate.toISOString().split("T")[0])
          )
        );
        return { total: income[0]?.total || 0 };
      }
      async calculateTotalServiceIncome(organizationId2, month, year) {
        const startDate = new Date(year, month - 1, 1);
        const endDate = new Date(year, month, 0);
        const serviceIncome = await db.select().from(finances).where(
          and3(
            eq2(finances.organizationId, organizationId2),
            eq2(finances.type, "income"),
            eq2(finances.category, "service"),
            gte2(finances.date, startDate.toISOString().split("T")[0]),
            lte2(finances.date, endDate.toISOString().split("T")[0])
          )
        );
        const cleaning = serviceIncome.filter((s) => s.description?.includes("cleaning")).reduce((sum4, s) => sum4 + parseFloat(s.amount), 0);
        const maintenance = serviceIncome.filter((s) => s.description?.includes("maintenance")).reduce((sum4, s) => sum4 + parseFloat(s.amount), 0);
        const garden = serviceIncome.filter((s) => s.description?.includes("garden") || s.description?.includes("pool")).reduce((sum4, s) => sum4 + parseFloat(s.amount), 0);
        const total = serviceIncome.reduce((sum4, s) => sum4 + parseFloat(s.amount), 0);
        return { total, cleaning, maintenance, garden };
      }
      async calculateTotalAddonIncome(organizationId2, month, year) {
        const startDate = new Date(year, month - 1, 1);
        const endDate = new Date(year, month, 0);
        const addonIncome = await db.select().from(guestAddonBookings).where(
          and3(
            eq2(guestAddonBookings.organizationId, organizationId2),
            eq2(guestAddonBookings.status, "completed"),
            gte2(guestAddonBookings.serviceDate || guestAddonBookings.createdAt, startDate.toISOString().split("T")[0]),
            lte2(guestAddonBookings.serviceDate || guestAddonBookings.createdAt, endDate.toISOString().split("T")[0])
          )
        );
        const chef = addonIncome.filter((a) => a.serviceId === 1).reduce((sum4, a) => sum4 + parseFloat(a.totalAmount || "0"), 0);
        const taxi = addonIncome.filter((a) => a.serviceId === 2).reduce((sum4, a) => sum4 + parseFloat(a.totalAmount || "0"), 0);
        const tours = addonIncome.filter((a) => a.serviceId === 3).reduce((sum4, a) => sum4 + parseFloat(a.totalAmount || "0"), 0);
        const massage = addonIncome.filter((a) => a.serviceId === 4).reduce((sum4, a) => sum4 + parseFloat(a.totalAmount || "0"), 0);
        const total = addonIncome.reduce((sum4, a) => sum4 + parseFloat(a.totalAmount || "0"), 0);
        return { total, chef, taxi, tours, massage };
      }
      async calculateTotalCommissions(organizationId2, month, year) {
        const pmCommissions = await db.select({ total: sql3`sum(cast(commission_earned as decimal))` }).from(portfolioManagerCommissions).where(
          and3(
            eq2(portfolioManagerCommissions.organizationId, organizationId2),
            eq2(portfolioManagerCommissions.commissionMonth, month),
            eq2(portfolioManagerCommissions.commissionYear, year)
          )
        );
        const agentCommissions = await db.select().from(commissionLog).where(
          and3(
            eq2(commissionLog.organizationId, organizationId2),
            eq2(commissionLog.commissionMonth, month),
            eq2(commissionLog.commissionYear, year),
            eq2(commissionLog.status, "paid")
          )
        );
        const retail = agentCommissions.filter((c) => c.agentType === "retail-agent").reduce((sum4, c) => sum4 + parseFloat(c.commissionAmount), 0);
        const referral = agentCommissions.filter((c) => c.agentType === "referral-agent").reduce((sum4, c) => sum4 + parseFloat(c.commissionAmount), 0);
        const pm = pmCommissions[0]?.total || 0;
        const total = pm + retail + referral;
        return { total, pm, retail, referral };
      }
      async calculateTotalPayouts(organizationId2, month, year) {
        const startDate = new Date(year, month - 1, 1);
        const endDate = new Date(year, month, 0);
        const ownerPayouts2 = await db.select({ total: sql3`sum(cast(requested_amount as decimal))` }).from(ownerPayoutRequests).where(
          and3(
            eq2(ownerPayoutRequests.organizationId, organizationId2),
            eq2(ownerPayoutRequests.status, "completed"),
            gte2(ownerPayoutRequests.ownerConfirmedAt, startDate),
            lte2(ownerPayoutRequests.ownerConfirmedAt, endDate)
          )
        );
        const agentPayouts2 = await db.select({ total: sql3`sum(cast(payout_amount as decimal))` }).from(agentPayouts2).where(
          and3(
            eq2(agentPayouts2.organizationId, organizationId2),
            eq2(agentPayouts2.payoutStatus, "paid"),
            gte2(agentPayouts2.paidAt, startDate),
            lte2(agentPayouts2.paidAt, endDate)
          )
        );
        return {
          owners: ownerPayouts2[0]?.total || 0,
          agents: agentPayouts2[0]?.total || 0
        };
      }
      // Get financial summary reports
      async getFinancialSummaryReports(organizationId2, filters) {
        let query = db.select().from(financialSummaryReports).where(eq2(financialSummaryReports.organizationId, organizationId2));
        if (filters?.reportType) {
          query = query.where(eq2(financialSummaryReports.reportType, filters.reportType));
        }
        if (filters?.month) {
          query = query.where(eq2(financialSummaryReports.reportMonth, filters.month));
        }
        if (filters?.year) {
          query = query.where(eq2(financialSummaryReports.reportYear, filters.year));
        }
        return query.orderBy(desc2(financialSummaryReports.createdAt));
      }
      // ===== OWNER STATEMENT EXPORTS =====
      // Create owner statement export request
      async createOwnerStatementExport(exportData) {
        const [statementExport] = await db.insert(ownerStatementExports).values(exportData).returning();
        return statementExport;
      }
      // Get owner statement exports
      async getOwnerStatementExports(organizationId2, ownerId) {
        let query = db.select().from(ownerStatementExports).where(eq2(ownerStatementExports.organizationId, organizationId2));
        if (ownerId) {
          query = query.where(eq2(ownerStatementExports.ownerId, ownerId));
        }
        return query.orderBy(desc2(ownerStatementExports.createdAt));
      }
      // Update statement export status
      async updateOwnerStatementExport(id, updates) {
        const [updated] = await db.update(ownerStatementExports).set({
          ...updates,
          completedAt: updates.status === "completed" ? /* @__PURE__ */ new Date() : void 0
        }).where(eq2(ownerStatementExports.id, id)).returning();
        return updated;
      }
      // Get detailed financial data for owner statement
      async getOwnerStatementData(organizationId2, ownerId, propertyIds, startDate, endDate) {
        const earnings = await db.select({
          id: bookings.id,
          propertyId: bookings.propertyId,
          platform: bookings.platform,
          checkIn: bookings.checkInDate,
          checkOut: bookings.checkOutDate,
          guestName: bookings.guestName,
          amount: bookings.totalAmount,
          currency: bookings.currency,
          status: bookings.status
        }).from(bookings).innerJoin(properties, eq2(bookings.propertyId, properties.id)).where(
          and3(
            eq2(bookings.organizationId, organizationId2),
            eq2(properties.ownerId, ownerId),
            inArray(bookings.propertyId, propertyIds),
            gte2(bookings.checkInDate, startDate),
            lte2(bookings.checkOutDate, endDate),
            eq2(bookings.status, "confirmed")
          )
        ).orderBy(desc2(bookings.checkInDate));
        const expenses = await db.select({
          id: finances.id,
          propertyId: finances.propertyId,
          date: finances.date,
          category: finances.category,
          amount: finances.amount,
          description: finances.description,
          type: finances.type,
          source: finances.source,
          status: finances.status
        }).from(finances).where(
          and3(
            eq2(finances.organizationId, organizationId2),
            inArray(finances.propertyId, propertyIds),
            gte2(finances.date, startDate),
            lte2(finances.date, endDate),
            eq2(finances.type, "expense")
          )
        ).orderBy(desc2(finances.date));
        const addonExpenses = await db.select({
          id: guestAddonBookings.id,
          propertyId: guestAddonBookings.propertyId,
          serviceDate: guestAddonBookings.serviceDate,
          serviceName: guestAddonServices.name,
          amount: guestAddonBookings.totalAmount,
          currency: guestAddonBookings.currency,
          status: guestAddonBookings.status,
          guestName: guestAddonBookings.guestName
        }).from(guestAddonBookings).innerJoin(guestAddonServices, eq2(guestAddonBookings.serviceId, guestAddonServices.id)).where(
          and3(
            eq2(guestAddonBookings.organizationId, organizationId2),
            inArray(guestAddonBookings.propertyId, propertyIds),
            gte2(guestAddonBookings.serviceDate, startDate),
            lte2(guestAddonBookings.serviceDate, endDate),
            eq2(guestAddonBookings.status, "completed")
          )
        ).orderBy(desc2(guestAddonBookings.serviceDate));
        const commissions = await db.select({
          id: finances.id,
          propertyId: finances.propertyId,
          date: finances.date,
          amount: finances.amount,
          description: finances.description,
          category: finances.category
        }).from(finances).where(
          and3(
            eq2(finances.organizationId, organizationId2),
            inArray(finances.propertyId, propertyIds),
            gte2(finances.date, startDate),
            lte2(finances.date, endDate),
            eq2(finances.category, "management_commission")
          )
        ).orderBy(desc2(finances.date));
        const propertyDetails = await db.select().from(properties).where(
          and3(
            eq2(properties.organizationId, organizationId2),
            eq2(properties.ownerId, ownerId),
            inArray(properties.id, propertyIds)
          )
        );
        return {
          earnings,
          expenses,
          addonExpenses,
          commissions,
          propertyDetails
        };
      }
      // Calculate statement totals
      async calculateStatementTotals(organizationId2, propertyIds, startDate, endDate) {
        const [earningsResult] = await db.select({ total: sql3`COALESCE(sum(cast(total_amount as decimal)), 0)` }).from(bookings).where(
          and3(
            eq2(bookings.organizationId, organizationId2),
            inArray(bookings.propertyId, propertyIds),
            gte2(bookings.checkInDate, startDate),
            lte2(bookings.checkOutDate, endDate),
            eq2(bookings.status, "confirmed")
          )
        );
        const [expensesResult] = await db.select({ total: sql3`COALESCE(sum(cast(amount as decimal)), 0)` }).from(finances).where(
          and3(
            eq2(finances.organizationId, organizationId2),
            inArray(finances.propertyId, propertyIds),
            gte2(finances.date, startDate),
            lte2(finances.date, endDate),
            eq2(finances.type, "expense")
          )
        );
        const [commissionResult] = await db.select({ total: sql3`COALESCE(sum(cast(amount as decimal)), 0)` }).from(finances).where(
          and3(
            eq2(finances.organizationId, organizationId2),
            inArray(finances.propertyId, propertyIds),
            gte2(finances.date, startDate),
            lte2(finances.date, endDate),
            eq2(finances.category, "management_commission")
          )
        );
        const totalEarnings = earningsResult?.total || 0;
        const totalExpenses = expensesResult?.total || 0;
        const managementCommission = commissionResult?.total || 0;
        const netBalance = totalEarnings - totalExpenses - managementCommission;
        return {
          totalEarnings,
          totalExpenses,
          managementCommission,
          netBalance
        };
      }
      // ===== AUDIT TRAIL & ADMIN OVERRIDE METHODS =====
      // Audit Trail Operations
      async createAuditLog(auditData) {
        const [audit] = await db.insert(auditTrail).values(auditData).returning();
        return audit;
      }
      async getAuditTrail(organizationId2, filters) {
        let query = db.select().from(auditTrail).where(eq2(auditTrail.organizationId, organizationId2));
        if (filters?.userId) {
          query = query.where(eq2(auditTrail.userId, filters.userId));
        }
        if (filters?.entityType) {
          query = query.where(eq2(auditTrail.entityType, filters.entityType));
        }
        if (filters?.entityId) {
          query = query.where(eq2(auditTrail.entityId, filters.entityId));
        }
        if (filters?.actionType) {
          query = query.where(eq2(auditTrail.actionType, filters.actionType));
        }
        if (filters?.dateFrom) {
          query = query.where(gte2(auditTrail.createdAt, new Date(filters.dateFrom)));
        }
        if (filters?.dateTo) {
          query = query.where(lte2(auditTrail.createdAt, new Date(filters.dateTo)));
        }
        if (filters?.severity) {
          query = query.where(eq2(auditTrail.severity, filters.severity));
        }
        return query.orderBy(desc2(auditTrail.createdAt));
      }
      async getEntityChangeHistory(organizationId2, entityType, entityId) {
        return db.select().from(auditTrail).where(
          and3(
            eq2(auditTrail.organizationId, organizationId2),
            eq2(auditTrail.entityType, entityType),
            eq2(auditTrail.entityId, entityId)
          )
        ).orderBy(desc2(auditTrail.createdAt));
      }
      // Admin Override Permissions
      async createAdminPermission(permission) {
        const [perm] = await db.insert(adminOverridePermissions).values(permission).returning();
        return perm;
      }
      async getAdminPermissions(organizationId2, userId, entityType) {
        let query = db.select().from(adminOverridePermissions).where(
          and3(
            eq2(adminOverridePermissions.organizationId, organizationId2),
            eq2(adminOverridePermissions.isActive, true)
          )
        );
        if (userId) {
          query = query.where(eq2(adminOverridePermissions.userId, userId));
        }
        if (entityType) {
          query = query.where(eq2(adminOverridePermissions.entityType, entityType));
        }
        return query.orderBy(desc2(adminOverridePermissions.grantedAt));
      }
      async checkUserPermission(organizationId2, userId, entityType, permissionType) {
        const columnMap = {
          create: "canCreate",
          read: "canRead",
          update: "canUpdate",
          delete: "canDelete",
          approve: "canApprove",
          override: "canOverride",
          impersonate: "canImpersonate"
        };
        const [permission] = await db.select().from(adminOverridePermissions).where(
          and3(
            eq2(adminOverridePermissions.organizationId, organizationId2),
            eq2(adminOverridePermissions.userId, userId),
            eq2(adminOverridePermissions.entityType, entityType),
            eq2(adminOverridePermissions.isActive, true),
            sql3`${adminOverridePermissions[columnMap[permissionType]]} = true`
          )
        );
        return permission || null;
      }
      // User Impersonation
      async createImpersonationSession(session3) {
        const [impSession] = await db.insert(impersonationSessions).values(session3).returning();
        return impSession;
      }
      async getActiveImpersonationSession(sessionToken) {
        const [session3] = await db.select().from(impersonationSessions).where(
          and3(
            eq2(impersonationSessions.sessionToken, sessionToken),
            eq2(impersonationSessions.isActive, true)
          )
        );
        return session3 || null;
      }
      async endImpersonationSession(sessionToken) {
        await db.update(impersonationSessions).set({
          endedAt: /* @__PURE__ */ new Date(),
          isActive: false
        }).where(eq2(impersonationSessions.sessionToken, sessionToken));
      }
      async getImpersonationHistory(organizationId2, adminUserId, targetUserId) {
        let query = db.select().from(impersonationSessions).where(eq2(impersonationSessions.organizationId, organizationId2));
        if (adminUserId) {
          query = query.where(eq2(impersonationSessions.adminUserId, adminUserId));
        }
        if (targetUserId) {
          query = query.where(eq2(impersonationSessions.targetUserId, targetUserId));
        }
        return query.orderBy(desc2(impersonationSessions.startedAt));
      }
      // Balance Override History
      async createBalanceOverride(override) {
        const [balanceOverride] = await db.insert(balanceOverrideHistory).values(override).returning();
        return balanceOverride;
      }
      async getBalanceOverrideHistory(organizationId2, filters) {
        let query = db.select().from(balanceOverrideHistory).where(eq2(balanceOverrideHistory.organizationId, organizationId2));
        if (filters?.targetUserId) {
          query = query.where(eq2(balanceOverrideHistory.targetUserId, filters.targetUserId));
        }
        if (filters?.adminUserId) {
          query = query.where(eq2(balanceOverrideHistory.adminUserId, filters.adminUserId));
        }
        if (filters?.overrideType) {
          query = query.where(eq2(balanceOverrideHistory.overrideType, filters.overrideType));
        }
        if (filters?.entityType) {
          query = query.where(eq2(balanceOverrideHistory.entityType, filters.entityType));
        }
        if (filters?.dateFrom) {
          query = query.where(gte2(balanceOverrideHistory.createdAt, new Date(filters.dateFrom)));
        }
        if (filters?.dateTo) {
          query = query.where(lte2(balanceOverrideHistory.createdAt, new Date(filters.dateTo)));
        }
        return query.orderBy(desc2(balanceOverrideHistory.createdAt));
      }
      // Portfolio Manager Assignments
      async createPMAssignment(assignment) {
        const [pmAssignment] = await db.insert(portfolioManagerAssignments).values(assignment).returning();
        return pmAssignment;
      }
      async getPMAssignments(organizationId2, managerId, propertyId) {
        let query = db.select().from(portfolioManagerAssignments).where(
          and3(
            eq2(portfolioManagerAssignments.organizationId, organizationId2),
            eq2(portfolioManagerAssignments.isActive, true)
          )
        );
        if (managerId) {
          query = query.where(eq2(portfolioManagerAssignments.managerId, managerId));
        }
        if (propertyId) {
          query = query.where(eq2(portfolioManagerAssignments.propertyId, propertyId));
        }
        return query.orderBy(desc2(portfolioManagerAssignments.assignedAt));
      }
      async getPMPortfolioProperties(organizationId2, managerId) {
        const assignments = await db.select({ propertyId: portfolioManagerAssignments.propertyId }).from(portfolioManagerAssignments).where(
          and3(
            eq2(portfolioManagerAssignments.organizationId, organizationId2),
            eq2(portfolioManagerAssignments.managerId, managerId),
            eq2(portfolioManagerAssignments.isActive, true)
          )
        );
        return assignments.map((a) => a.propertyId);
      }
      async deactivatePMAssignment(id) {
        await db.update(portfolioManagerAssignments).set({ isActive: false }).where(eq2(portfolioManagerAssignments.id, id));
      }
      // Helper method to log admin actions with audit trail
      async logAdminAction(actionData) {
        return this.createAuditLog({
          organizationId: actionData.organizationId,
          userId: actionData.userId,
          userRole: actionData.userRole,
          userName: actionData.userName,
          actionType: actionData.actionType,
          entityType: actionData.entityType,
          entityId: actionData.entityId,
          entityDescription: actionData.entityDescription,
          oldValues: actionData.oldValues,
          newValues: actionData.newValues,
          changeReason: actionData.changeReason,
          impersonatedUserId: actionData.impersonatedUserId,
          ipAddress: actionData.ipAddress,
          userAgent: actionData.userAgent,
          severity: actionData.severity || "medium",
          isOverride: actionData.isOverride || false
        });
      }
      // ===== DOCUMENT CENTER IMPLEMENTATIONS =====
      // Property documents operations
      async getPropertyDocuments(organizationId2, filters) {
        let query = db.select().from(propertyDocuments).where(and3(
          eq2(propertyDocuments.organizationId, organizationId2),
          eq2(propertyDocuments.isActive, true)
        ));
        if (filters) {
          const conditions = [
            eq2(propertyDocuments.organizationId, organizationId2),
            eq2(propertyDocuments.isActive, true)
          ];
          if (filters.propertyId) {
            conditions.push(eq2(propertyDocuments.propertyId, filters.propertyId));
          }
          if (filters.category) {
            conditions.push(eq2(propertyDocuments.category, filters.category));
          }
          if (filters.visibility) {
            conditions.push(eq2(propertyDocuments.visibility, filters.visibility));
          }
          if (filters.hasExpiration !== void 0) {
            conditions.push(eq2(propertyDocuments.hasExpiration, filters.hasExpiration));
          }
          query = db.select().from(propertyDocuments).where(and3(...conditions));
        }
        return await query.orderBy(desc2(propertyDocuments.createdAt));
      }
      async getPropertyDocument(id) {
        const [document] = await db.select().from(propertyDocuments).where(eq2(propertyDocuments.id, id));
        return document;
      }
      async createPropertyDocument(organizationId2, documentData) {
        const [newDocument] = await db.insert(propertyDocuments).values({
          ...documentData,
          organizationId: organizationId2
        }).returning();
        return newDocument;
      }
      async updatePropertyDocument(id, document) {
        const [updatedDocument] = await db.update(propertyDocuments).set(document).where(eq2(propertyDocuments.id, id)).returning();
        return updatedDocument;
      }
      async deletePropertyDocument(id) {
        const result = await db.update(propertyDocuments).set({ isActive: false }).where(eq2(propertyDocuments.id, id));
        return result.rowCount > 0;
      }
      async getDocumentsByCategory(organizationId2, category) {
        return await db.select().from(propertyDocuments).where(and3(
          eq2(propertyDocuments.organizationId, organizationId2),
          eq2(propertyDocuments.category, category),
          eq2(propertyDocuments.isActive, true)
        )).orderBy(desc2(propertyDocuments.createdAt));
      }
      async getExpiringDocuments(organizationId2, daysAhead = 30) {
        const futureDate = /* @__PURE__ */ new Date();
        futureDate.setDate(futureDate.getDate() + daysAhead);
        return await db.select().from(propertyDocuments).where(and3(
          eq2(propertyDocuments.organizationId, organizationId2),
          eq2(propertyDocuments.hasExpiration, true),
          eq2(propertyDocuments.isActive, true),
          lte2(propertyDocuments.expirationDate, futureDate.toISOString().split("T")[0])
        )).orderBy(asc(propertyDocuments.expirationDate));
      }
      // Document access logging
      async getDocumentAccessLogs(organizationId2, filters) {
        let query = db.select().from(documentAccessLog).where(eq2(documentAccessLog.organizationId, organizationId2));
        if (filters) {
          const conditions = [eq2(documentAccessLog.organizationId, organizationId2)];
          if (filters.documentId) {
            conditions.push(eq2(documentAccessLog.documentId, filters.documentId));
          }
          if (filters.accessedBy) {
            conditions.push(eq2(documentAccessLog.accessedBy, filters.accessedBy));
          }
          if (filters.actionType) {
            conditions.push(eq2(documentAccessLog.actionType, filters.actionType));
          }
          query = db.select().from(documentAccessLog).where(and3(...conditions));
        }
        return await query.orderBy(desc2(documentAccessLog.accessedAt));
      }
      async createDocumentAccessLog(log2) {
        const [newLog] = await db.insert(documentAccessLog).values(log2).returning();
        return newLog;
      }
      // Document Center Analytics - Basic implementation
      async getDocumentCenterAnalytics(organizationId2, propertyId) {
        return {
          totalDocuments: 42,
          recentUploads: 8,
          expiringCount: 3,
          pendingApproval: 2,
          documentsByCategory: [
            { category: "contracts", count: 12 },
            { category: "licenses", count: 8 },
            { category: "manuals", count: 15 },
            { category: "floorplans", count: 7 }
          ]
        };
      }
      // ===== MAINTENANCE LOG, WARRANTY TRACKER & AI REPAIR CYCLE ALERTS =====
      // Maintenance Log Operations
      async getMaintenanceLogs(organizationId2, filters) {
        let query = db.select().from(maintenanceLog).where(eq2(maintenanceLog.organizationId, organizationId2));
        if (filters) {
          const conditions = [eq2(maintenanceLog.organizationId, organizationId2)];
          if (filters.propertyId) {
            conditions.push(eq2(maintenanceLog.propertyId, filters.propertyId));
          }
          if (filters.department) {
            conditions.push(eq2(maintenanceLog.department, filters.department));
          }
          if (filters.status) {
            conditions.push(eq2(maintenanceLog.status, filters.status));
          }
          if (filters.technicianAssigned) {
            conditions.push(eq2(maintenanceLog.technicianAssigned, filters.technicianAssigned));
          }
          if (filters.priority) {
            conditions.push(eq2(maintenanceLog.priority, filters.priority));
          }
          if (filters.startDate) {
            conditions.push(gte2(maintenanceLog.repairDate, filters.startDate));
          }
          if (filters.endDate) {
            conditions.push(lte2(maintenanceLog.repairDate, filters.endDate));
          }
          query = db.select().from(maintenanceLog).where(and3(...conditions));
        }
        return await query.orderBy(desc2(maintenanceLog.createdAt));
      }
      async createMaintenanceLog(logData) {
        const [newLog] = await db.insert(maintenanceLog).values(logData).returning();
        return newLog;
      }
      async updateMaintenanceLog(id, logData) {
        const [updatedLog] = await db.update(maintenanceLog).set({ ...logData, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(maintenanceLog.id, id)).returning();
        return updatedLog;
      }
      async getMaintenanceLogById(id) {
        const [log2] = await db.select().from(maintenanceLog).where(eq2(maintenanceLog.id, id));
        return log2;
      }
      async deleteMaintenanceLog(id) {
        await db.delete(maintenanceLog).where(eq2(maintenanceLog.id, id));
      }
      // Warranty Alerts Operations
      async getWarrantyAlerts(organizationId2, filters) {
        let query = db.select().from(warrantyAlerts).where(eq2(warrantyAlerts.organizationId, organizationId2));
        if (filters) {
          const conditions = [eq2(warrantyAlerts.organizationId, organizationId2)];
          if (filters.propertyId) {
            conditions.push(eq2(warrantyAlerts.propertyId, filters.propertyId));
          }
          if (filters.isActive !== void 0) {
            conditions.push(eq2(warrantyAlerts.isActive, filters.isActive));
          }
          if (filters.alertType) {
            conditions.push(eq2(warrantyAlerts.alertType, filters.alertType));
          }
          query = db.select().from(warrantyAlerts).where(and3(...conditions));
        }
        return await query.orderBy(desc2(warrantyAlerts.scheduledFor));
      }
      async createWarrantyAlert(alertData) {
        const [newAlert] = await db.insert(warrantyAlerts).values(alertData).returning();
        return newAlert;
      }
      async updateWarrantyAlert(id, alertData) {
        const [updatedAlert] = await db.update(warrantyAlerts).set(alertData).where(eq2(warrantyAlerts.id, id)).returning();
        return updatedAlert;
      }
      async acknowledgeWarrantyAlert(id, acknowledgedBy) {
        const [updatedAlert] = await db.update(warrantyAlerts).set({ acknowledgedBy, acknowledgedAt: /* @__PURE__ */ new Date() }).where(eq2(warrantyAlerts.id, id)).returning();
        return updatedAlert;
      }
      // AI Service Cycle Predictions Operations
      async getAiServicePredictions(organizationId2, filters) {
        let query = db.select().from(aiServiceCyclePredictions).where(eq2(aiServiceCyclePredictions.organizationId, organizationId2));
        if (filters) {
          const conditions = [eq2(aiServiceCyclePredictions.organizationId, organizationId2)];
          if (filters.propertyId) {
            conditions.push(eq2(aiServiceCyclePredictions.propertyId, filters.propertyId));
          }
          if (filters.department) {
            conditions.push(eq2(aiServiceCyclePredictions.department, filters.department));
          }
          if (filters.suggestionStatus) {
            conditions.push(eq2(aiServiceCyclePredictions.suggestionStatus, filters.suggestionStatus));
          }
          query = db.select().from(aiServiceCyclePredictions).where(and3(...conditions));
        }
        return await query.orderBy(desc2(aiServiceCyclePredictions.predictedNextServiceDate));
      }
      async createAiServicePrediction(predictionData) {
        const [newPrediction] = await db.insert(aiServiceCyclePredictions).values(predictionData).returning();
        return newPrediction;
      }
      async updateAiServicePrediction(id, predictionData) {
        const [updatedPrediction] = await db.update(aiServiceCyclePredictions).set({ ...predictionData, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(aiServiceCyclePredictions.id, id)).returning();
        return updatedPrediction;
      }
      async reviewAiSuggestion(id, reviewedBy, suggestionStatus) {
        const [updatedPrediction] = await db.update(aiServiceCyclePredictions).set({
          suggestionStatus,
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(aiServiceCyclePredictions.id, id)).returning();
        return updatedPrediction;
      }
      async convertAiSuggestionToTask(id, taskId) {
        const [updatedPrediction] = await db.update(aiServiceCyclePredictions).set({
          suggestionStatus: "converted_to_task",
          convertedToTaskId: taskId,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(aiServiceCyclePredictions.id, id)).returning();
        return updatedPrediction;
      }
      // Maintenance Cost Analytics Operations
      async getMaintenanceCostAnalytics(organizationId2, filters) {
        let query = db.select().from(maintenanceCostAnalytics).where(eq2(maintenanceCostAnalytics.organizationId, organizationId2));
        if (filters) {
          const conditions = [eq2(maintenanceCostAnalytics.organizationId, organizationId2)];
          if (filters.propertyId) {
            conditions.push(eq2(maintenanceCostAnalytics.propertyId, filters.propertyId));
          }
          if (filters.periodType) {
            conditions.push(eq2(maintenanceCostAnalytics.periodType, filters.periodType));
          }
          if (filters.startDate) {
            conditions.push(gte2(maintenanceCostAnalytics.periodStart, filters.startDate));
          }
          if (filters.endDate) {
            conditions.push(lte2(maintenanceCostAnalytics.periodEnd, filters.endDate));
          }
          query = db.select().from(maintenanceCostAnalytics).where(and3(...conditions));
        }
        return await query.orderBy(desc2(maintenanceCostAnalytics.periodStart));
      }
      async createMaintenanceCostAnalytics(analyticsData) {
        const [newAnalytics] = await db.insert(maintenanceCostAnalytics).values(analyticsData).returning();
        return newAnalytics;
      }
      async updateMaintenanceCostAnalytics(id, analyticsData) {
        const [updatedAnalytics] = await db.update(maintenanceCostAnalytics).set({ ...analyticsData, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(maintenanceCostAnalytics.id, id)).returning();
        return updatedAnalytics;
      }
      // Technician Performance Operations
      async getTechnicianPerformance(organizationId2, filters) {
        let query = db.select().from(technicianPerformance).where(eq2(technicianPerformance.organizationId, organizationId2));
        if (filters) {
          const conditions = [eq2(technicianPerformance.organizationId, organizationId2)];
          if (filters.technicianId) {
            conditions.push(eq2(technicianPerformance.technicianId, filters.technicianId));
          }
          if (filters.periodStart) {
            conditions.push(gte2(technicianPerformance.periodStart, filters.periodStart));
          }
          if (filters.periodEnd) {
            conditions.push(lte2(technicianPerformance.periodEnd, filters.periodEnd));
          }
          query = db.select().from(technicianPerformance).where(and3(...conditions));
        }
        return await query.orderBy(desc2(technicianPerformance.periodStart));
      }
      async createTechnicianPerformance(performanceData) {
        const [newPerformance] = await db.insert(technicianPerformance).values(performanceData).returning();
        return newPerformance;
      }
      async updateTechnicianPerformance(id, performanceData) {
        const [updatedPerformance] = await db.update(technicianPerformance).set({ ...performanceData, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(technicianPerformance.id, id)).returning();
        return updatedPerformance;
      }
      // Maintenance Dashboard Analytics
      async getMaintenanceDashboardAnalytics(organizationId2, propertyId) {
        const totalLogsQuery = db.select({ count: sql3`count(*)::int` }).from(maintenanceLog).where(
          propertyId ? and3(eq2(maintenanceLog.organizationId, organizationId2), eq2(maintenanceLog.propertyId, propertyId)) : eq2(maintenanceLog.organizationId, organizationId2)
        );
        const activeAlertsQuery = db.select({ count: sql3`count(*)::int` }).from(warrantyAlerts).where(
          propertyId ? and3(eq2(warrantyAlerts.organizationId, organizationId2), eq2(warrantyAlerts.propertyId, propertyId), eq2(warrantyAlerts.isActive, true)) : and3(eq2(warrantyAlerts.organizationId, organizationId2), eq2(warrantyAlerts.isActive, true))
        );
        const pendingSuggestionsQuery = db.select({ count: sql3`count(*)::int` }).from(aiServiceCyclePredictions).where(
          propertyId ? and3(eq2(aiServiceCyclePredictions.organizationId, organizationId2), eq2(aiServiceCyclePredictions.propertyId, propertyId), eq2(aiServiceCyclePredictions.suggestionStatus, "pending")) : and3(eq2(aiServiceCyclePredictions.organizationId, organizationId2), eq2(aiServiceCyclePredictions.suggestionStatus, "pending"))
        );
        const recentLogsQuery = db.select().from(maintenanceLog).where(
          propertyId ? and3(eq2(maintenanceLog.organizationId, organizationId2), eq2(maintenanceLog.propertyId, propertyId)) : eq2(maintenanceLog.organizationId, organizationId2)
        ).orderBy(desc2(maintenanceLog.createdAt)).limit(5);
        const [totalLogs] = await totalLogsQuery;
        const [activeAlerts] = await activeAlertsQuery;
        const [pendingSuggestions] = await pendingSuggestionsQuery;
        const recentLogs = await recentLogsQuery;
        const activeJobs = recentLogs.filter((log2) => log2.status === "in_progress" || log2.status === "scheduled").length;
        const completedJobs = recentLogs.filter((log2) => log2.status === "finished").length;
        const urgentJobs = recentLogs.filter((log2) => log2.priority === "urgent" && log2.status !== "finished").length;
        return {
          totalMaintenanceLogs: totalLogs.count,
          activeWarrantyAlerts: activeAlerts.count,
          pendingAiSuggestions: pendingSuggestions.count,
          thisMonthCost: 8500,
          // Mock data - would calculate from current month logs
          activeJobs,
          completedJobs,
          urgentJobs,
          averageJobDuration: 2.5,
          // Mock data - would calculate from completion times
          topDepartmentCosts: [
            // Mock data - would aggregate from logs
            { department: "pool", cost: 3200 },
            { department: "ac", cost: 2800 },
            { department: "electrical", cost: 1500 },
            { department: "plumbing", cost: 1e3 }
          ],
          recentLogs
        };
      }
      // Document analytics and summary
      async getDocumentSummary(organizationId2, propertyId) {
        const baseConditions = [
          eq2(propertyDocuments.organizationId, organizationId2),
          eq2(propertyDocuments.isActive, true)
        ];
        if (propertyId) {
          baseConditions.push(eq2(propertyDocuments.propertyId, propertyId));
        }
        const totalResult = await db.select({ count: count() }).from(propertyDocuments).where(and3(...baseConditions));
        const totalDocuments = totalResult[0]?.count || 0;
        const categoryResult = await db.select({
          category: propertyDocuments.category,
          count: count()
        }).from(propertyDocuments).where(and3(...baseConditions)).groupBy(propertyDocuments.category);
        const futureDate = /* @__PURE__ */ new Date();
        futureDate.setDate(futureDate.getDate() + 30);
        const expiringResult = await db.select({ count: count() }).from(propertyDocuments).where(and3(
          ...baseConditions,
          eq2(propertyDocuments.hasExpiration, true),
          lte2(propertyDocuments.expirationDate, futureDate.toISOString().split("T")[0])
        ));
        const expiringCount = expiringResult[0]?.count || 0;
        const weekAgo = /* @__PURE__ */ new Date();
        weekAgo.setDate(weekAgo.getDate() - 7);
        const recentResult = await db.select({ count: count() }).from(propertyDocuments).where(and3(
          ...baseConditions,
          gte2(propertyDocuments.createdAt, weekAgo)
        ));
        const recentUploads = recentResult[0]?.count || 0;
        return {
          totalDocuments,
          documentsByCategory: categoryResult,
          expiringCount,
          recentUploads
        };
      }
      // ===== PROPERTY ACCESS MANAGEMENT IMPLEMENTATION =====
      // Property Access Credentials operations
      async getPropertyAccessCredentials(organizationId2, propertyId) {
        const conditions = [
          eq2(propertyAccessCredentials.organizationId, organizationId2),
          eq2(propertyAccessCredentials.isActive, true)
        ];
        if (propertyId) {
          conditions.push(eq2(propertyAccessCredentials.propertyId, propertyId));
        }
        return await db.select().from(propertyAccessCredentials).where(and3(...conditions)).orderBy(desc2(propertyAccessCredentials.createdAt));
      }
      async getPropertyAccessCredential(id) {
        const [credential] = await db.select().from(propertyAccessCredentials).where(eq2(propertyAccessCredentials.id, id));
        return credential;
      }
      async createPropertyAccessCredential(credential) {
        const [newCredential] = await db.insert(propertyAccessCredentials).values(credential).returning();
        return newCredential;
      }
      async updatePropertyAccessCredential(id, credential) {
        const [updatedCredential] = await db.update(propertyAccessCredentials).set({
          ...credential,
          updatedAt: /* @__PURE__ */ new Date(),
          lastUpdated: /* @__PURE__ */ new Date()
        }).where(eq2(propertyAccessCredentials.id, id)).returning();
        return updatedCredential;
      }
      async deletePropertyAccessCredential(id) {
        const [deletedCredential] = await db.update(propertyAccessCredentials).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyAccessCredentials.id, id)).returning();
        return !!deletedCredential;
      }
      // Property Access Photos operations
      async getPropertyAccessPhotos(credentialId) {
        return await db.select().from(propertyAccessPhotos).where(and3(
          eq2(propertyAccessPhotos.credentialId, credentialId),
          eq2(propertyAccessPhotos.isActive, true)
        )).orderBy(desc2(propertyAccessPhotos.uploadedAt));
      }
      async createPropertyAccessPhoto(photo) {
        const [newPhoto] = await db.insert(propertyAccessPhotos).values(photo).returning();
        return newPhoto;
      }
      async deletePropertyAccessPhoto(id) {
        const [deletedPhoto] = await db.update(propertyAccessPhotos).set({ isActive: false }).where(eq2(propertyAccessPhotos.id, id)).returning();
        return !!deletedPhoto;
      }
      // Access Change Log operations
      async getAccessChangeLog(credentialId) {
        return await db.select().from(accessChangeLog).where(eq2(accessChangeLog.credentialId, credentialId)).orderBy(desc2(accessChangeLog.changedAt));
      }
      async createAccessChangeLog(log2) {
        const [newLog] = await db.insert(accessChangeLog).values(log2).returning();
        return newLog;
      }
      // Guest Access Sessions operations
      async getGuestAccessSessions(organizationId2, filters) {
        const conditions = [eq2(guestAccessSessions.organizationId, organizationId2)];
        if (filters?.bookingId) {
          conditions.push(eq2(guestAccessSessions.bookingId, filters.bookingId));
        }
        if (filters?.credentialId) {
          conditions.push(eq2(guestAccessSessions.credentialId, filters.credentialId));
        }
        if (filters?.guestEmail) {
          conditions.push(eq2(guestAccessSessions.guestEmail, filters.guestEmail));
        }
        return await db.select().from(guestAccessSessions).where(and3(...conditions)).orderBy(desc2(guestAccessSessions.accessGrantedAt));
      }
      async createGuestAccessSession(session3) {
        const [newSession] = await db.insert(guestAccessSessions).values(session3).returning();
        return newSession;
      }
      async updateGuestAccessSession(id, session3) {
        const [updatedSession] = await db.update(guestAccessSessions).set(session3).where(eq2(guestAccessSessions.id, id)).returning();
        return updatedSession;
      }
      async revokeGuestAccessSession(id, revokedBy, reason) {
        const [revokedSession] = await db.update(guestAccessSessions).set({
          isActive: false,
          revokedAt: /* @__PURE__ */ new Date(),
          revokedBy,
          revokedReason: reason
        }).where(eq2(guestAccessSessions.id, id)).returning();
        return revokedSession;
      }
      // Smart Lock Sync Log operations
      async getSmartLockSyncLog(credentialId) {
        return await db.select().from(smartLockSyncLog).where(eq2(smartLockSyncLog.credentialId, credentialId)).orderBy(desc2(smartLockSyncLog.syncStartedAt));
      }
      async createSmartLockSyncLog(log2) {
        const [newLog] = await db.insert(smartLockSyncLog).values(log2).returning();
        return newLog;
      }
      // Code Rotation Schedule operations
      async getCodeRotationSchedules(organizationId2, filters) {
        const conditions = [
          eq2(codeRotationSchedule.organizationId, organizationId2),
          eq2(codeRotationSchedule.isActive, true)
        ];
        if (filters?.dueForRotation) {
          conditions.push(lte2(codeRotationSchedule.nextRotationDate, /* @__PURE__ */ new Date()));
        }
        return await db.select().from(codeRotationSchedule).where(and3(...conditions)).orderBy(asc(codeRotationSchedule.nextRotationDate));
      }
      async createCodeRotationSchedule(schedule) {
        const [newSchedule] = await db.insert(codeRotationSchedule).values(schedule).returning();
        return newSchedule;
      }
      async updateCodeRotationSchedule(id, schedule) {
        const [updatedSchedule] = await db.update(codeRotationSchedule).set({
          ...schedule,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(codeRotationSchedule.id, id)).returning();
        return updatedSchedule;
      }
      // Access visibility filtering based on user role
      async getFilteredAccessCredentials(organizationId2, userRole, userId, propertyId) {
        const conditions = [
          eq2(propertyAccessCredentials.organizationId, organizationId2),
          eq2(propertyAccessCredentials.isActive, true)
        ];
        if (propertyId) {
          conditions.push(eq2(propertyAccessCredentials.propertyId, propertyId));
        }
        const allCredentials = await db.select().from(propertyAccessCredentials).where(and3(...conditions)).orderBy(desc2(propertyAccessCredentials.createdAt));
        return allCredentials.filter((credential) => {
          const visibleTo = credential.visibleTo;
          return visibleTo.includes(userRole) || visibleTo.includes("all");
        });
      }
      // QR Code generation and access token management
      async generateGuestAccessToken(bookingId, credentialId) {
        const token = `guest_${bookingId}_${credentialId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        return token;
      }
      async validateGuestAccessToken(token) {
        const session3 = await db.select().from(guestAccessSessions).where(and3(
          eq2(guestAccessSessions.accessToken, token),
          eq2(guestAccessSessions.isActive, true),
          gte2(guestAccessSessions.accessExpiresAt, /* @__PURE__ */ new Date())
        )).limit(1);
        if (session3.length === 0) {
          return { valid: false };
        }
        return {
          valid: true,
          credentialId: session3[0].credentialId,
          bookingId: session3[0].bookingId
        };
      }
      // Rotation reminders and notifications
      async getDueRotationReminders(organizationId2) {
        return await db.select().from(codeRotationSchedule).where(and3(
          eq2(codeRotationSchedule.organizationId, organizationId2),
          eq2(codeRotationSchedule.isActive, true),
          lte2(codeRotationSchedule.nextRotationDate, /* @__PURE__ */ new Date()),
          eq2(codeRotationSchedule.reminderSent, false)
        )).orderBy(asc(codeRotationSchedule.nextRotationDate));
      }
      async markRotationReminderSent(scheduleId) {
        const [updatedSchedule] = await db.update(codeRotationSchedule).set({
          reminderSent: true,
          reminderSentAt: /* @__PURE__ */ new Date()
        }).where(eq2(codeRotationSchedule.id, scheduleId)).returning();
        return !!updatedSchedule;
      }
      // ===== DAILY OPERATIONS DASHBOARD METHODS =====
      // Generate daily operations summary for a specific date
      async generateDailyOperationsSummary(organizationId2, operationDate) {
        const dateStr = operationDate;
        const dayTasks = await db.select().from(tasks).where(and3(
          eq2(tasks.organizationId, organizationId2),
          sql3`DATE(${tasks.createdAt}) = ${dateStr}`
        ));
        const departmentStats = {
          cleaningTasks: 0,
          cleaningCompleted: 0,
          poolTasks: 0,
          poolCompleted: 0,
          gardenTasks: 0,
          gardenCompleted: 0,
          maintenanceTasks: 0,
          maintenanceCompleted: 0,
          generalTasks: 0,
          generalCompleted: 0
        };
        let overdueTasks = 0;
        let tasksWithoutProof = 0;
        let unassignedTasks = 0;
        for (const task of dayTasks) {
          const dept = task.department || "general";
          const isCompleted = task.status === "completed";
          switch (dept.toLowerCase()) {
            case "cleaning":
              departmentStats.cleaningTasks++;
              if (isCompleted) departmentStats.cleaningCompleted++;
              break;
            case "pool":
              departmentStats.poolTasks++;
              if (isCompleted) departmentStats.poolCompleted++;
              break;
            case "garden":
              departmentStats.gardenTasks++;
              if (isCompleted) departmentStats.gardenCompleted++;
              break;
            case "maintenance":
              departmentStats.maintenanceTasks++;
              if (isCompleted) departmentStats.maintenanceCompleted++;
              break;
            default:
              departmentStats.generalTasks++;
              if (isCompleted) departmentStats.generalCompleted++;
          }
          if (task.dueDate && new Date(task.dueDate) < /* @__PURE__ */ new Date() && !isCompleted) {
            overdueTasks++;
          }
          if (isCompleted && (!task.evidencePhotos || task.evidencePhotos.length === 0)) {
            tasksWithoutProof++;
          }
          if (!task.assignedTo) {
            unassignedTasks++;
          }
        }
        const todayBookings = await db.select().from(bookings).where(and3(
          eq2(bookings.organizationId, organizationId2),
          sql3`DATE(${bookings.checkinDate}) = ${dateStr}`
        ));
        const uncleanedCheckinProperties = todayBookings.length;
        const staffAssignments = await this.getDailyStaffAssignments(organizationId2, operationDate);
        return {
          id: 0,
          // Will be set by DB
          organizationId: organizationId2,
          operationDate,
          ...departmentStats,
          overdueTasks,
          tasksWithoutProof,
          uncleanedCheckinProperties,
          unassignedTasks,
          totalStaffScheduled: staffAssignments.length,
          totalTasksAssigned: dayTasks.length,
          lastUpdated: /* @__PURE__ */ new Date(),
          createdAt: /* @__PURE__ */ new Date()
        };
      }
      // Get or create daily operations summary
      async getDailyOperationsSummary(organizationId2, operationDate) {
        const [existing] = await db.select().from(dailyOperationsSummary).where(and3(
          eq2(dailyOperationsSummary.organizationId, organizationId2),
          eq2(dailyOperationsSummary.operationDate, operationDate)
        )).limit(1);
        if (existing) {
          return existing;
        }
        const summary = await this.generateDailyOperationsSummary(organizationId2, operationDate);
        const [created] = await db.insert(dailyOperationsSummary).values(summary).returning();
        return created;
      }
      // Get daily staff assignments
      async getDailyStaffAssignments(organizationId2, operationDate) {
        return await db.select().from(dailyStaffAssignments).where(and3(
          eq2(dailyStaffAssignments.organizationId, organizationId2),
          eq2(dailyStaffAssignments.operationDate, operationDate)
        )).orderBy(asc(dailyStaffAssignments.staffId));
      }
      // Create or update staff assignment for a day
      async upsertDailyStaffAssignment(assignment) {
        const [existing] = await db.select().from(dailyStaffAssignments).where(and3(
          eq2(dailyStaffAssignments.organizationId, assignment.organizationId),
          eq2(dailyStaffAssignments.staffId, assignment.staffId),
          eq2(dailyStaffAssignments.operationDate, assignment.operationDate)
        )).limit(1);
        if (existing) {
          const [updated] = await db.update(dailyStaffAssignments).set({
            ...assignment,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq2(dailyStaffAssignments.id, existing.id)).returning();
          return updated;
        }
        const [created] = await db.insert(dailyStaffAssignments).values(assignment).returning();
        return created;
      }
      // Get daily property operations
      async getDailyPropertyOperations(organizationId2, operationDate) {
        return await db.select().from(dailyPropertyOperations).where(and3(
          eq2(dailyPropertyOperations.organizationId, organizationId2),
          eq2(dailyPropertyOperations.operationDate, operationDate)
        )).orderBy(asc(dailyPropertyOperations.propertyId));
      }
      // Get property operations with property details
      async getDailyPropertyOperationsWithDetails(organizationId2, operationDate) {
        const propertyOps = await db.select({
          propertyOp: dailyPropertyOperations,
          property: properties
        }).from(dailyPropertyOperations).leftJoin(properties, eq2(dailyPropertyOperations.propertyId, properties.id)).where(and3(
          eq2(dailyPropertyOperations.organizationId, organizationId2),
          eq2(dailyPropertyOperations.operationDate, operationDate)
        )).orderBy(asc(properties.name));
        return propertyOps.map((row) => ({
          ...row.propertyOp,
          propertyName: row.property?.name,
          propertyAddress: row.property?.address
        }));
      }
      // Generate property operations for a date (if not exist)
      async generateDailyPropertyOperations(organizationId2, operationDate) {
        const orgProperties = await db.select().from(properties).where(eq2(properties.organizationId, organizationId2));
        for (const property of orgProperties) {
          const [existing] = await db.select().from(dailyPropertyOperations).where(and3(
            eq2(dailyPropertyOperations.organizationId, organizationId2),
            eq2(dailyPropertyOperations.propertyId, property.id),
            eq2(dailyPropertyOperations.operationDate, operationDate)
          )).limit(1);
          if (!existing) {
            const bookingsToday = await db.select().from(bookings).where(and3(
              eq2(bookings.organizationId, organizationId2),
              eq2(bookings.propertyId, property.id),
              sql3`DATE(${bookings.checkinDate}) = ${operationDate} OR DATE(${bookings.checkoutDate}) = ${operationDate}`
            ));
            const hasCheckin = bookingsToday.some(
              (b) => new Date(b.checkinDate).toISOString().split("T")[0] === operationDate
            );
            const hasCheckout = bookingsToday.some(
              (b) => new Date(b.checkoutDate).toISOString().split("T")[0] === operationDate
            );
            const propertyTasks = await db.select().from(tasks).where(and3(
              eq2(tasks.organizationId, organizationId2),
              eq2(tasks.propertyId, property.id),
              sql3`DATE(${tasks.createdAt}) = ${operationDate}`
            ));
            const maintenanceTasks = propertyTasks.filter((t) => t.department === "maintenance").length;
            const maintenanceCompleted = propertyTasks.filter((t) => t.department === "maintenance" && t.status === "completed").length;
            const maintenanceOverdue = propertyTasks.filter(
              (t) => t.department === "maintenance" && t.dueDate && new Date(t.dueDate) < /* @__PURE__ */ new Date() && t.status !== "completed"
            ).length;
            await db.insert(dailyPropertyOperations).values({
              organizationId: organizationId2,
              propertyId: property.id,
              operationDate,
              hasCheckin,
              hasCheckout,
              needsCleaning: hasCheckin || hasCheckout,
              cleaningCompleted: false,
              maintenanceTasks,
              maintenanceCompleted,
              maintenanceOverdue,
              recurringServices: 0,
              // To be calculated from recurring services
              recurringCompleted: 0,
              isUrgent: maintenanceOverdue > 0,
              urgencyReason: maintenanceOverdue > 0 ? "overdue_maintenance" : null,
              operationStatus: "scheduled"
            });
          }
        }
      }
      // Get tasks for operations dashboard with enhanced details
      async getOperationsDashboardTasks(organizationId2, operationDate) {
        const tasksForDate = await db.select({
          task: tasks,
          property: properties,
          assignedUser: users
        }).from(tasks).leftJoin(properties, eq2(tasks.propertyId, properties.id)).leftJoin(users, eq2(tasks.assignedTo, users.id)).where(and3(
          eq2(tasks.organizationId, organizationId2),
          sql3`DATE(${tasks.createdAt}) = ${operationDate}`
        )).orderBy(asc(tasks.priority), asc(tasks.createdAt));
        return tasksForDate.map((row) => ({
          ...row.task,
          propertyName: row.property?.name,
          assignedUserName: row.assignedUser ? `${row.assignedUser.firstName} ${row.assignedUser.lastName}` : null,
          isOverdue: row.task.dueDate && new Date(row.task.dueDate) < /* @__PURE__ */ new Date() && row.task.status !== "completed",
          hasProof: row.task.evidencePhotos && row.task.evidencePhotos.length > 0
        }));
      }
      // Refresh daily operations data
      async refreshDailyOperations(organizationId2, operationDate) {
        await this.generateDailyPropertyOperations(organizationId2, operationDate);
        await this.generateDailyOperationsSummary(organizationId2, operationDate);
      }
      // ==================== CHECK-IN/CHECK-OUT WORKFLOW OPERATIONS ====================
      // Guest Check-ins Operations
      async getGuestCheckIns(organizationId2, filters) {
        let query = db.select().from(guestCheckIns).where(eq2(guestCheckIns.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(guestCheckIns.propertyId, filters.propertyId));
        }
        if (filters?.bookingId) {
          query = query.where(eq2(guestCheckIns.bookingId, filters.bookingId));
        }
        if (filters?.assignedToStaff) {
          query = query.where(eq2(guestCheckIns.assignedToStaff, filters.assignedToStaff));
        }
        if (filters?.status) {
          query = query.where(eq2(guestCheckIns.status, filters.status));
        }
        if (filters?.fromDate) {
          query = query.where(gte2(guestCheckIns.scheduledDate, filters.fromDate));
        }
        if (filters?.toDate) {
          query = query.where(lte2(guestCheckIns.scheduledDate, filters.toDate));
        }
        return query.orderBy(desc2(guestCheckIns.scheduledDate));
      }
      async getGuestCheckIn(id) {
        const [checkIn] = await db.select().from(guestCheckIns).where(eq2(guestCheckIns.id, id));
        return checkIn;
      }
      async createGuestCheckIn(checkIn) {
        const [newCheckIn] = await db.insert(guestCheckIns).values(checkIn).returning();
        return newCheckIn;
      }
      async updateGuestCheckIn(id, updates) {
        const [updated] = await db.update(guestCheckIns).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(guestCheckIns.id, id)).returning();
        return updated;
      }
      async startGuestCheckIn(id, staffId) {
        const [updated] = await db.update(guestCheckIns).set({
          status: "in_progress",
          completedByStaff: staffId,
          startedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(guestCheckIns.id, id)).returning();
        return updated;
      }
      async completeGuestCheckIn(id, completionData) {
        const [updated] = await db.update(guestCheckIns).set({
          status: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          ...completionData
        }).where(eq2(guestCheckIns.id, id)).returning();
        return updated;
      }
      // Guest Check-outs Operations
      async getGuestCheckOuts(organizationId2, filters) {
        let query = db.select().from(guestCheckOuts).where(eq2(guestCheckOuts.organizationId, organizationId2));
        if (filters?.propertyId) {
          query = query.where(eq2(guestCheckOuts.propertyId, filters.propertyId));
        }
        if (filters?.bookingId) {
          query = query.where(eq2(guestCheckOuts.bookingId, filters.bookingId));
        }
        if (filters?.checkInId) {
          query = query.where(eq2(guestCheckOuts.checkInId, filters.checkInId));
        }
        if (filters?.assignedToStaff) {
          query = query.where(eq2(guestCheckOuts.assignedToStaff, filters.assignedToStaff));
        }
        if (filters?.status) {
          query = query.where(eq2(guestCheckOuts.status, filters.status));
        }
        if (filters?.fromDate) {
          query = query.where(gte2(guestCheckOuts.scheduledDate, filters.fromDate));
        }
        if (filters?.toDate) {
          query = query.where(lte2(guestCheckOuts.scheduledDate, filters.toDate));
        }
        return query.orderBy(desc2(guestCheckOuts.scheduledDate));
      }
      async getGuestCheckOut(id) {
        const [checkOut] = await db.select().from(guestCheckOuts).where(eq2(guestCheckOuts.id, id));
        return checkOut;
      }
      async createGuestCheckOut(checkOut) {
        const [newCheckOut] = await db.insert(guestCheckOuts).values(checkOut).returning();
        return newCheckOut;
      }
      async updateGuestCheckOut(id, updates) {
        const [updated] = await db.update(guestCheckOuts).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(guestCheckOuts.id, id)).returning();
        return updated;
      }
      async startGuestCheckOut(id, staffId) {
        const [updated] = await db.update(guestCheckOuts).set({
          status: "in_progress",
          completedByStaff: staffId,
          startedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(guestCheckOuts.id, id)).returning();
        return updated;
      }
      async completeGuestCheckOut(id, completionData) {
        const [updated] = await db.update(guestCheckOuts).set({
          status: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          ...completionData
        }).where(eq2(guestCheckOuts.id, id)).returning();
        return updated;
      }
      // Property Electricity Settings Operations
      async getPropertyElectricitySettings(organizationId2, propertyId) {
        let query = db.select().from(propertyElectricitySettings).where(eq2(propertyElectricitySettings.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(propertyElectricitySettings.propertyId, propertyId));
        }
        return query;
      }
      async getPropertyElectricitySetting(propertyId) {
        const [setting] = await db.select().from(propertyElectricitySettings).where(eq2(propertyElectricitySettings.propertyId, propertyId));
        return setting;
      }
      async createPropertyElectricitySetting(setting) {
        const [newSetting] = await db.insert(propertyElectricitySettings).values(setting).returning();
        return newSetting;
      }
      async updatePropertyElectricitySetting(propertyId, updates) {
        const [updated] = await db.update(propertyElectricitySettings).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyElectricitySettings.propertyId, propertyId)).returning();
        return updated;
      }
      // Demo Tasks Operations
      async getCheckInOutDemoTasks(organizationId2, filters) {
        let query = db.select().from(checkInOutDemoTasks).where(eq2(checkInOutDemoTasks.organizationId, organizationId2));
        if (filters?.taskType) {
          query = query.where(eq2(checkInOutDemoTasks.taskType, filters.taskType));
        }
        if (filters?.assignedRole) {
          query = query.where(eq2(checkInOutDemoTasks.assignedRole, filters.assignedRole));
        }
        if (filters?.assignedToUser) {
          query = query.where(eq2(checkInOutDemoTasks.assignedToUser, filters.assignedToUser));
        }
        if (filters?.propertyId) {
          query = query.where(eq2(checkInOutDemoTasks.propertyId, filters.propertyId));
        }
        if (filters?.status) {
          query = query.where(eq2(checkInOutDemoTasks.status, filters.status));
        }
        if (filters?.demoUserType) {
          query = query.where(eq2(checkInOutDemoTasks.demoUserType, filters.demoUserType));
        }
        return query.orderBy(asc(checkInOutDemoTasks.dueDate));
      }
      async getCheckInOutDemoTask(id) {
        const [task] = await db.select().from(checkInOutDemoTasks).where(eq2(checkInOutDemoTasks.id, id));
        return task;
      }
      async createCheckInOutDemoTask(task) {
        const [newTask] = await db.insert(checkInOutDemoTasks).values(task).returning();
        return newTask;
      }
      async updateCheckInOutDemoTask(id, updates) {
        const [updated] = await db.update(checkInOutDemoTasks).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(checkInOutDemoTasks.id, id)).returning();
        return updated;
      }
      async completeCheckInOutDemoTask(id, completionData) {
        const [updated] = await db.update(checkInOutDemoTasks).set({
          status: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          ...completionData
        }).where(eq2(checkInOutDemoTasks.id, id)).returning();
        return updated;
      }
      // Workflow Analytics
      async getCheckInOutAnalytics(organizationId2, filters) {
        let checkInQuery = db.select().from(guestCheckIns).where(eq2(guestCheckIns.organizationId, organizationId2));
        let checkOutQuery = db.select().from(guestCheckOuts).where(eq2(guestCheckOuts.organizationId, organizationId2));
        let demoTaskQuery = db.select().from(checkInOutDemoTasks).where(eq2(checkInOutDemoTasks.organizationId, organizationId2));
        if (filters?.fromDate) {
          checkInQuery = checkInQuery.where(gte2(guestCheckIns.scheduledDate, filters.fromDate));
          checkOutQuery = checkOutQuery.where(gte2(guestCheckOuts.scheduledDate, filters.fromDate));
          demoTaskQuery = demoTaskQuery.where(gte2(checkInOutDemoTasks.dueDate, filters.fromDate));
        }
        if (filters?.toDate) {
          checkInQuery = checkInQuery.where(lte2(guestCheckIns.scheduledDate, filters.toDate));
          checkOutQuery = checkOutQuery.where(lte2(guestCheckOuts.scheduledDate, filters.toDate));
          demoTaskQuery = demoTaskQuery.where(lte2(checkInOutDemoTasks.dueDate, filters.toDate));
        }
        const [checkIns, checkOuts, demoTasks] = await Promise.all([
          checkInQuery,
          checkOutQuery,
          demoTaskQuery
        ]);
        const totalCheckIns = checkIns.length;
        const totalCheckOuts = checkOuts.length;
        const completedCheckIns = checkIns.filter((c) => c.status === "completed").length;
        const completedCheckOuts = checkOuts.filter((c) => c.status === "completed").length;
        const completionRate = totalCheckIns + totalCheckOuts > 0 ? (completedCheckIns + completedCheckOuts) / (totalCheckIns + totalCheckOuts) * 100 : 0;
        const completedCheckOutsWithUsage = checkOuts.filter((c) => c.status === "completed" && c.electricityUsed);
        const avgElectricityUsage = completedCheckOutsWithUsage.length > 0 ? completedCheckOutsWithUsage.reduce((sum4, c) => sum4 + parseFloat(c.electricityUsed?.toString() || "0"), 0) / completedCheckOutsWithUsage.length : 0;
        const avgElectricityCharge = completedCheckOutsWithUsage.length > 0 ? completedCheckOutsWithUsage.reduce((sum4, c) => sum4 + parseFloat(c.totalElectricityCharge?.toString() || "0"), 0) / completedCheckOutsWithUsage.length : 0;
        const paymentStatusBreakdown = {};
        checkOuts.forEach((c) => {
          const status = c.paymentStatus || "unknown";
          paymentStatusBreakdown[status] = (paymentStatusBreakdown[status] || 0) + 1;
        });
        const departmentTaskBreakdown = {};
        demoTasks.forEach((t) => {
          const dept = t.department || "unknown";
          departmentTaskBreakdown[dept] = (departmentTaskBreakdown[dept] || 0) + 1;
        });
        return {
          totalCheckIns,
          totalCheckOuts,
          completionRate,
          avgElectricityUsage,
          avgElectricityCharge,
          paymentStatusBreakdown,
          departmentTaskBreakdown
        };
      }
      // ===== PROPERTY UTILITIES & MAINTENANCE ENHANCED IMPLEMENTATION =====
      // Property utility accounts enhanced operations
      async getPropertyUtilityAccountsEnhanced(organizationId2, propertyId) {
        let query = db.select().from(propertyUtilityAccountsEnhanced).where(eq2(propertyUtilityAccountsEnhanced.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(propertyUtilityAccountsEnhanced.propertyId, propertyId));
        }
        return query.orderBy(desc2(propertyUtilityAccountsEnhanced.createdAt));
      }
      async getPropertyUtilityAccountEnhanced(id) {
        const [account] = await db.select().from(propertyUtilityAccountsEnhanced).where(eq2(propertyUtilityAccountsEnhanced.id, id));
        return account;
      }
      async createPropertyUtilityAccountEnhanced(account) {
        const [newAccount] = await db.insert(propertyUtilityAccountsEnhanced).values(account).returning();
        return newAccount;
      }
      async updatePropertyUtilityAccountEnhanced(id, account) {
        const [updated] = await db.update(propertyUtilityAccountsEnhanced).set({ ...account, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyUtilityAccountsEnhanced.id, id)).returning();
        return updated;
      }
      async deletePropertyUtilityAccountEnhanced(id) {
        const result = await db.delete(propertyUtilityAccountsEnhanced).where(eq2(propertyUtilityAccountsEnhanced.id, id));
        return result.rowCount > 0;
      }
      // Utility bill logs enhanced operations
      async getUtilityBillLogsEnhanced(organizationId2, propertyId, filters) {
        let query = db.select().from(utilityBillLogsEnhanced).where(eq2(utilityBillLogsEnhanced.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(utilityBillLogsEnhanced.propertyId, propertyId));
        }
        if (filters?.billingMonth) {
          query = query.where(eq2(utilityBillLogsEnhanced.billingMonth, filters.billingMonth));
        }
        if (filters?.paymentStatus) {
          query = query.where(eq2(utilityBillLogsEnhanced.paymentStatus, filters.paymentStatus));
        }
        return query.orderBy(desc2(utilityBillLogsEnhanced.createdAt));
      }
      async getUtilityBillLogEnhanced(id) {
        const [bill] = await db.select().from(utilityBillLogsEnhanced).where(eq2(utilityBillLogsEnhanced.id, id));
        return bill;
      }
      async createUtilityBillLogEnhanced(bill) {
        const [newBill] = await db.insert(utilityBillLogsEnhanced).values(bill).returning();
        return newBill;
      }
      async updateUtilityBillLogEnhanced(id, bill) {
        const [updated] = await db.update(utilityBillLogsEnhanced).set({ ...bill, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(utilityBillLogsEnhanced.id, id)).returning();
        return updated;
      }
      async uploadBillScan(id, scanUrl, filename, uploadedBy) {
        const [updated] = await db.update(utilityBillLogsEnhanced).set({
          billScanUrl: scanUrl,
          billScanFilename: filename,
          uploadedBy,
          uploadedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(utilityBillLogsEnhanced.id, id)).returning();
        return updated;
      }
      async markBillPaid(id, paidAmount, paidDate, paymentMethod, processedBy) {
        const [updated] = await db.update(utilityBillLogsEnhanced).set({
          paymentStatus: "paid",
          paidAmount: paidAmount.toString(),
          paidDate,
          paymentMethod,
          processedBy,
          processedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(utilityBillLogsEnhanced.id, id)).returning();
        return updated;
      }
      async deleteUtilityBillLogEnhanced(id) {
        const result = await db.delete(utilityBillLogsEnhanced).where(eq2(utilityBillLogsEnhanced.id, id));
        return result.rowCount > 0;
      }
      // Utility AI reminders operations
      async getUtilityAiReminders(organizationId2, propertyId, status) {
        let query = db.select().from(utilityAiReminders).where(eq2(utilityAiReminders.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(utilityAiReminders.propertyId, propertyId));
        }
        if (status) {
          query = query.where(eq2(utilityAiReminders.status, status));
        }
        return query.orderBy(desc2(utilityAiReminders.createdAt));
      }
      async getUtilityAiReminder(id) {
        const [reminder] = await db.select().from(utilityAiReminders).where(eq2(utilityAiReminders.id, id));
        return reminder;
      }
      async createUtilityAiReminder(reminder) {
        const [newReminder] = await db.insert(utilityAiReminders).values(reminder).returning();
        return newReminder;
      }
      async acknowledgeUtilityReminder(id, acknowledgedBy) {
        const [updated] = await db.update(utilityAiReminders).set({
          status: "acknowledged",
          acknowledgedBy,
          acknowledgedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(utilityAiReminders.id, id)).returning();
        return updated;
      }
      async resolveUtilityReminder(id, resolvedBy) {
        const [updated] = await db.update(utilityAiReminders).set({
          status: "resolved",
          resolvedBy,
          resolvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(utilityAiReminders.id, id)).returning();
        return updated;
      }
      // Property maintenance history operations
      async getPropertyMaintenanceHistory(organizationId2, propertyId, filters) {
        let query = db.select().from(propertyMaintenanceHistory).where(eq2(propertyMaintenanceHistory.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(propertyMaintenanceHistory.propertyId, propertyId));
        }
        if (filters?.serviceType) {
          query = query.where(eq2(propertyMaintenanceHistory.serviceType, filters.serviceType));
        }
        if (filters?.fromDate) {
          query = query.where(gte2(propertyMaintenanceHistory.serviceDate, filters.fromDate.toISOString().split("T")[0]));
        }
        if (filters?.toDate) {
          query = query.where(lte2(propertyMaintenanceHistory.serviceDate, filters.toDate.toISOString().split("T")[0]));
        }
        return query.orderBy(desc2(propertyMaintenanceHistory.serviceDate));
      }
      async getPropertyMaintenanceHistoryRecord(id) {
        const [record] = await db.select().from(propertyMaintenanceHistory).where(eq2(propertyMaintenanceHistory.id, id));
        return record;
      }
      async createPropertyMaintenanceHistory(record) {
        const [newRecord] = await db.insert(propertyMaintenanceHistory).values(record).returning();
        return newRecord;
      }
      async updatePropertyMaintenanceHistory(id, record) {
        const [updated] = await db.update(propertyMaintenanceHistory).set({ ...record, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(propertyMaintenanceHistory.id, id)).returning();
        return updated;
      }
      async approveMaintenanceRecord(id, approvedBy) {
        const [updated] = await db.update(propertyMaintenanceHistory).set({
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(propertyMaintenanceHistory.id, id)).returning();
        return updated;
      }
      async deletePropertyMaintenanceHistory(id) {
        const result = await db.delete(propertyMaintenanceHistory).where(eq2(propertyMaintenanceHistory.id, id));
        return result.rowCount > 0;
      }
      // Maintenance service intervals operations
      async getMaintenanceServiceIntervals(organizationId2, propertyId) {
        let query = db.select().from(maintenanceServiceIntervals).where(eq2(maintenanceServiceIntervals.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(maintenanceServiceIntervals.propertyId, propertyId));
        }
        return query.where(eq2(maintenanceServiceIntervals.isActive, true)).orderBy(maintenanceServiceIntervals.serviceType);
      }
      async getMaintenanceServiceInterval(id) {
        const [interval] = await db.select().from(maintenanceServiceIntervals).where(eq2(maintenanceServiceIntervals.id, id));
        return interval;
      }
      async createMaintenanceServiceInterval(interval) {
        const [newInterval] = await db.insert(maintenanceServiceIntervals).values(interval).returning();
        return newInterval;
      }
      async updateMaintenanceServiceInterval(id, interval) {
        const [updated] = await db.update(maintenanceServiceIntervals).set({ ...interval, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(maintenanceServiceIntervals.id, id)).returning();
        return updated;
      }
      async deleteMaintenanceServiceInterval(id) {
        const result = await db.delete(maintenanceServiceIntervals).where(eq2(maintenanceServiceIntervals.id, id));
        return result.rowCount > 0;
      }
      // Maintenance AI suggestions operations
      async getMaintenanceAiSuggestions(organizationId2, propertyId, status) {
        let query = db.select().from(maintenanceAiSuggestions).where(eq2(maintenanceAiSuggestions.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(maintenanceAiSuggestions.propertyId, propertyId));
        }
        if (status) {
          query = query.where(eq2(maintenanceAiSuggestions.status, status));
        }
        return query.orderBy(desc2(maintenanceAiSuggestions.createdAt));
      }
      async getMaintenanceAiSuggestion(id) {
        const [suggestion] = await db.select().from(maintenanceAiSuggestions).where(eq2(maintenanceAiSuggestions.id, id));
        return suggestion;
      }
      async createMaintenanceAiSuggestion(suggestion) {
        const [newSuggestion] = await db.insert(maintenanceAiSuggestions).values(suggestion).returning();
        return newSuggestion;
      }
      async updateMaintenanceAiSuggestion(id, suggestion) {
        const [updated] = await db.update(maintenanceAiSuggestions).set({ ...suggestion, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(maintenanceAiSuggestions.id, id)).returning();
        return updated;
      }
      async reviewMaintenanceSuggestion(id, reviewedBy, action, notes) {
        const [updated] = await db.update(maintenanceAiSuggestions).set({
          status: action === "accept" ? "accepted" : "rejected",
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          reviewNotes: notes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(maintenanceAiSuggestions.id, id)).returning();
        return updated;
      }
      // Property alerts operations
      async getPropertyAlerts(organizationId2, propertyId, alertType, status) {
        let query = db.select().from(propertyAlerts).where(eq2(propertyAlerts.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(propertyAlerts.propertyId, propertyId));
        }
        if (alertType) {
          query = query.where(eq2(propertyAlerts.alertType, alertType));
        }
        if (status) {
          query = query.where(eq2(propertyAlerts.status, status));
        }
        return query.orderBy(desc2(propertyAlerts.createdAt));
      }
      async getPropertyAlert(id) {
        const [alert] = await db.select().from(propertyAlerts).where(eq2(propertyAlerts.id, id));
        return alert;
      }
      async createPropertyAlert(alert) {
        const [newAlert] = await db.insert(propertyAlerts).values(alert).returning();
        return newAlert;
      }
      async acknowledgePropertyAlert(id, acknowledgedBy) {
        const [updated] = await db.update(propertyAlerts).set({
          status: "acknowledged",
          acknowledgedBy,
          acknowledgedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(propertyAlerts.id, id)).returning();
        return updated;
      }
      async resolvePropertyAlert(id, resolvedBy) {
        const [updated] = await db.update(propertyAlerts).set({
          status: "resolved",
          resolvedBy,
          resolvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(propertyAlerts.id, id)).returning();
        return updated;
      }
      async dismissPropertyAlert(id, dismissedBy) {
        const [updated] = await db.update(propertyAlerts).set({
          status: "dismissed",
          dismissedBy,
          dismissedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(propertyAlerts.id, id)).returning();
        return updated;
      }
      // Analytics and automated processing methods - Mock implementations for demo
      async generateUtilityReminders(organizationId2, propertyId) {
        return [];
      }
      async generateMaintenanceSuggestions(organizationId2, propertyId) {
        return [];
      }
      async processOverdueUtilities(organizationId2) {
        return [];
      }
      async checkMaintenanceDueDates(organizationId2) {
        return [];
      }
      // ===== ENHANCED FINANCIAL CONTROLS SYSTEM IMPLEMENTATION =====
      // Owner Balance Dashboard Methods
      async getEnhancedOwnerBalances(organizationId2, ownerId, propertyId) {
        let query = db.select({
          id: ownerBalances.id,
          ownerId: ownerBalances.ownerId,
          ownerName: users.firstName,
          currentBalance: ownerBalances.currentBalance,
          totalEarnings: ownerBalances.totalEarnings,
          totalExpenses: ownerBalances.totalExpenses,
          pendingPayouts: ownerBalances.totalPayoutsRequested,
          thisMonthEarnings: ownerBalances.thisMonthEarnings,
          thisMonthExpenses: ownerBalances.thisMonthExpenses,
          lastCalculated: ownerBalances.lastCalculated
        }).from(ownerBalances).leftJoin(users, eq2(ownerBalances.ownerId, users.id)).where(eq2(ownerBalances.organizationId, organizationId2));
        if (ownerId) {
          query = query.where(eq2(ownerBalances.ownerId, ownerId));
        }
        return await query.orderBy(desc2(ownerBalances.lastCalculated));
      }
      async getOwnerFinancialSummary(organizationId2, ownerId) {
        const [ownerBalance] = await db.select().from(ownerBalances).where(and3(
          eq2(ownerBalances.organizationId, organizationId2),
          eq2(ownerBalances.ownerId, ownerId)
        ));
        const pendingPayouts = await db.select({ amount: sum(ownerPayoutRequests.requestedAmount) }).from(ownerPayoutRequests).where(and3(
          eq2(ownerPayoutRequests.organizationId, organizationId2),
          eq2(ownerPayoutRequests.ownerId, ownerId),
          eq2(ownerPayoutRequests.requestStatus, "pending")
        ));
        const [lastPayout] = await db.select({ paidAt: ownerPayoutRequests.paidAt }).from(ownerPayoutRequests).where(and3(
          eq2(ownerPayoutRequests.organizationId, organizationId2),
          eq2(ownerPayoutRequests.ownerId, ownerId),
          eq2(ownerPayoutRequests.requestStatus, "confirmed")
        )).orderBy(desc2(ownerPayoutRequests.paidAt)).limit(1);
        const propertyBalances = await db.select({
          propertyId: properties2.id,
          propertyName: properties2.name,
          earnings: sql3`COALESCE(SUM(CASE WHEN ${finances.type} = 'income' THEN ${finances.amount} ELSE 0 END), 0)`,
          expenses: sql3`COALESCE(SUM(CASE WHEN ${finances.type} = 'expense' THEN ${finances.amount} ELSE 0 END), 0)`
        }).from(properties2).leftJoin(finances, eq2(finances.propertyId, properties2.id)).where(and3(
          eq2(properties2.organizationId, organizationId2),
          eq2(properties2.ownerId, ownerId)
        )).groupBy(properties2.id, properties2.name);
        const properties2 = propertyBalances.map((p) => ({
          propertyId: p.propertyId,
          propertyName: p.propertyName,
          balance: p.earnings - p.expenses,
          earnings: p.earnings,
          expenses: p.expenses
        }));
        return {
          currentBalance: parseFloat(ownerBalance?.currentBalance || "0"),
          pendingPayouts: parseFloat(pendingPayouts[0]?.amount || "0"),
          totalEarnings: parseFloat(ownerBalance?.totalEarnings || "0"),
          totalExpenses: parseFloat(ownerBalance?.totalExpenses || "0"),
          thisMonthEarnings: parseFloat(ownerBalance?.thisMonthEarnings || "0"),
          thisMonthExpenses: parseFloat(ownerBalance?.thisMonthExpenses || "0"),
          netBalance: parseFloat(ownerBalance?.currentBalance || "0") - parseFloat(pendingPayouts[0]?.amount || "0"),
          lastPayoutDate: lastPayout?.paidAt || null,
          properties: properties2
        };
      }
      // Owner Payout Request Workflow Methods
      async getOwnerPayoutRequests(organizationId2, ownerId, filters) {
        let query = db.select().from(ownerPayoutRequests).where(eq2(ownerPayoutRequests.organizationId, organizationId2));
        if (ownerId) {
          query = query.where(eq2(ownerPayoutRequests.ownerId, ownerId));
        }
        if (filters?.status) {
          query = query.where(eq2(ownerPayoutRequests.requestStatus, filters.status));
        }
        if (filters?.startDate) {
          query = query.where(gte2(ownerPayoutRequests.requestedAt, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          query = query.where(lte2(ownerPayoutRequests.requestedAt, new Date(filters.endDate)));
        }
        return await query.orderBy(desc2(ownerPayoutRequests.requestedAt));
      }
      async createOwnerPayoutRequest(request) {
        const [newRequest] = await db.insert(ownerPayoutRequests).values(request).returning();
        return newRequest;
      }
      async approveOwnerPayoutRequest(id, approvedBy, approvalNotes) {
        const [updatedRequest] = await db.update(ownerPayoutRequests).set({
          requestStatus: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          approvalNotes
        }).where(eq2(ownerPayoutRequests.id, id)).returning();
        return updatedRequest;
      }
      async rejectOwnerPayoutRequest(id, rejectedBy, rejectionReason) {
        const [updatedRequest] = await db.update(ownerPayoutRequests).set({
          requestStatus: "rejected",
          approvedBy: rejectedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          approvalNotes: rejectionReason
        }).where(eq2(ownerPayoutRequests.id, id)).returning();
        return updatedRequest;
      }
      async uploadPaymentReceipt(id, receiptUrl, uploadedBy) {
        const [updatedRequest] = await db.update(ownerPayoutRequests).set({
          requestStatus: "payment_uploaded",
          paymentSlipUrl: receiptUrl,
          uploadedBy,
          paymentUploadedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerPayoutRequests.id, id)).returning();
        return updatedRequest;
      }
      async confirmPayoutReceived(id, confirmedBy) {
        const [updatedRequest] = await db.update(ownerPayoutRequests).set({
          requestStatus: "confirmed",
          confirmedBy,
          confirmedAt: /* @__PURE__ */ new Date(),
          completedAt: /* @__PURE__ */ new Date()
        }).where(eq2(ownerPayoutRequests.id, id)).returning();
        return updatedRequest;
      }
      // Enhanced Invoice Tool Methods
      async getInvoiceTemplates(organizationId2) {
        return await db.select().from(invoiceTemplates).where(eq2(invoiceTemplates.organizationId, organizationId2)).orderBy(desc2(invoiceTemplates.createdAt));
      }
      async createInvoiceTemplate(template) {
        const [newTemplate] = await db.insert(invoiceTemplates).values(template).returning();
        return newTemplate;
      }
      async updateInvoiceTemplate(id, template) {
        const [updatedTemplate] = await db.update(invoiceTemplates).set({ ...template, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(invoiceTemplates.id, id)).returning();
        return updatedTemplate;
      }
      async getEnhancedInvoices(organizationId2, filters) {
        return await db.select().from(invoices).where(eq2(invoices.organizationId, organizationId2)).orderBy(desc2(invoices.createdAt));
      }
      async createEnhancedInvoice(invoice) {
        const [newInvoice] = await db.insert(invoices).values(invoice).returning();
        return newInvoice;
      }
      async updateEnhancedInvoice(id, invoice) {
        const [updatedInvoice] = await db.update(invoices).set({ ...invoice, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(invoices.id, id)).returning();
        return updatedInvoice;
      }
      async generateInvoiceNumber(organizationId2) {
        const today = /* @__PURE__ */ new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, "0");
        const invoiceCount = await db.select({ count: sql3`count(*)` }).from(invoices).where(and3(
          eq2(invoices.organizationId, organizationId2),
          sql3`EXTRACT(YEAR FROM ${invoices.createdAt}) = ${year}`,
          sql3`EXTRACT(MONTH FROM ${invoices.createdAt}) = ${parseInt(month)}`
        ));
        const nextNumber = (invoiceCount[0]?.count || 0) + 1;
        return `INV-${year}${month}-${String(nextNumber).padStart(4, "0")}`;
      }
      async getInvoiceLineItems(invoiceId) {
        return await db.select().from(invoiceLineItems).where(eq2(invoiceLineItems.invoiceId, invoiceId)).orderBy(invoiceLineItems.id);
      }
      async createInvoiceLineItem(lineItem) {
        const [newLineItem] = await db.insert(invoiceLineItems).values(lineItem).returning();
        return newLineItem;
      }
      async deleteInvoiceLineItem(id) {
        const result = await db.delete(invoiceLineItems).where(eq2(invoiceLineItems.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Portfolio Manager Earnings Methods
      async getPortfolioManagerEarnings(organizationId2, pmId, filters) {
        return await db.select().from(commissionEarnings).where(eq2(commissionEarnings.organizationId, organizationId2)).orderBy(desc2(commissionEarnings.createdAt));
      }
      async createPortfolioManagerEarning(earning) {
        const [newEarning] = await db.insert(commissionEarnings).values(earning).returning();
        return newEarning;
      }
      async updatePortfolioManagerEarning(id, earning) {
        const [updatedEarning] = await db.update(commissionEarnings).set({ ...earning, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(commissionEarnings.id, id)).returning();
        return updatedEarning;
      }
      async requestPortfolioManagerPayout(id) {
        const [updatedEarning] = await db.update(commissionEarnings).set({
          payoutStatus: "requested",
          payoutRequestedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(commissionEarnings.id, id)).returning();
        return updatedEarning;
      }
      async approvePortfolioManagerPayout(id, approvedBy) {
        const [updatedEarning] = await db.update(commissionEarnings).set({
          payoutStatus: "approved",
          payoutApprovedBy: approvedBy,
          payoutApprovedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(commissionEarnings.id, id)).returning();
        return updatedEarning;
      }
      async getPortfolioManagerSummary(organizationId2, pmId) {
        const earnings = await db.select({
          totalEarnings: sql3`COALESCE(SUM(${commissionEarnings.commissionAmount}), 0)`,
          pendingPayouts: sql3`COALESCE(SUM(CASE WHEN ${commissionEarnings.payoutStatus} = 'pending' THEN ${commissionEarnings.commissionAmount} ELSE 0 END), 0)`,
          thisMonthEarnings: sql3`COALESCE(SUM(CASE WHEN EXTRACT(MONTH FROM ${commissionEarnings.createdAt}) = EXTRACT(MONTH FROM CURRENT_DATE) THEN ${commissionEarnings.commissionAmount} ELSE 0 END), 0)`
        }).from(commissionEarnings).where(and3(
          eq2(commissionEarnings.organizationId, organizationId2),
          eq2(commissionEarnings.portfolioManagerId, pmId)
        ));
        const propertiesCount = await db.select({ count: sql3`count(distinct ${properties.id})` }).from(properties).where(and3(
          eq2(properties.organizationId, organizationId2),
          eq2(properties.managedBy, pmId)
        ));
        return {
          totalEarnings: earnings[0]?.totalEarnings || 0,
          pendingPayouts: earnings[0]?.pendingPayouts || 0,
          thisMonthEarnings: earnings[0]?.thisMonthEarnings || 0,
          propertiesManaged: propertiesCount[0]?.count || 0,
          totalCommission: earnings[0]?.totalEarnings || 0,
          averageCommissionRate: 5
          // Default 5% commission rate
        };
      }
      // Staff Salary & Advance Request Methods
      async getStaffSalarySettings(organizationId2, staffId) {
        let query = db.select().from(staffSalaries).where(eq2(staffSalaries.organizationId, organizationId2));
        if (staffId) {
          query = query.where(eq2(staffSalaries.staffId, staffId));
        }
        return await query.orderBy(desc2(staffSalaries.createdAt));
      }
      async createStaffSalarySettings(settings) {
        const [newSettings] = await db.insert(staffSalaries).values(settings).returning();
        return newSettings;
      }
      async updateStaffSalarySettings(id, settings) {
        const [updatedSettings] = await db.update(staffSalaries).set({ ...settings, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffSalaries.id, id)).returning();
        return updatedSettings;
      }
      async getStaffAdvanceRequests(organizationId2, staffId, filters) {
        let query = db.select().from(staffAdvanceRequests).where(eq2(staffAdvanceRequests.organizationId, organizationId2));
        if (staffId) {
          query = query.where(eq2(staffAdvanceRequests.staffId, staffId));
        }
        if (filters?.requestStatus) {
          query = query.where(eq2(staffAdvanceRequests.requestStatus, filters.requestStatus));
        }
        if (filters?.urgencyLevel) {
          query = query.where(eq2(staffAdvanceRequests.urgencyLevel, filters.urgencyLevel));
        }
        return await query.orderBy(desc2(staffAdvanceRequests.requestedAt));
      }
      async createStaffAdvanceRequest(request) {
        const [newRequest] = await db.insert(staffAdvanceRequests).values(request).returning();
        return newRequest;
      }
      async approveStaffAdvanceRequest(id, approvedBy, approvalNotes) {
        const [updatedRequest] = await db.update(staffAdvanceRequests).set({
          requestStatus: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          approvalNotes
        }).where(eq2(staffAdvanceRequests.id, id)).returning();
        return updatedRequest;
      }
      async rejectStaffAdvanceRequest(id, rejectedBy, rejectionReason) {
        const [updatedRequest] = await db.update(staffAdvanceRequests).set({
          requestStatus: "rejected",
          approvedBy: rejectedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          rejectionReason
        }).where(eq2(staffAdvanceRequests.id, id)).returning();
        return updatedRequest;
      }
      async payStaffAdvanceRequest(id, paidBy, paymentMethod, paymentReference) {
        const [updatedRequest] = await db.update(staffAdvanceRequests).set({
          requestStatus: "paid",
          paidBy,
          paidAt: /* @__PURE__ */ new Date(),
          paymentMethod,
          paymentReference
        }).where(eq2(staffAdvanceRequests.id, id)).returning();
        return updatedRequest;
      }
      async getStaffMonthlySalary(organizationId2, staffId, month) {
        const [staffSalary] = await db.select().from(staffSalaries).where(and3(
          eq2(staffSalaries.organizationId, organizationId2),
          eq2(staffSalaries.staffId, staffId)
        ));
        const advanceDeductions = await db.select({ totalDeducted: sum(staffAdvanceRequests.monthlyDeductionAmount) }).from(staffAdvanceRequests).where(and3(
          eq2(staffAdvanceRequests.organizationId, organizationId2),
          eq2(staffAdvanceRequests.staffId, staffId),
          eq2(staffAdvanceRequests.deductionStartMonth, month)
        ));
        const baseSalary = parseFloat(staffSalary?.baseSalary || "0");
        const deductions = parseFloat(advanceDeductions[0]?.totalDeducted || "0");
        return {
          baseSalary,
          overtimeHours: 0,
          overtimePay: 0,
          advanceDeductions: deductions,
          bonuses: 0,
          netPay: baseSalary - deductions,
          paymentStatus: "pending"
        };
      }
      // Balance Reset Control Methods (Admin Only)
      async getUsersForBalanceReset(organizationId2) {
        const users3 = await db.select({
          id: users3.id,
          firstName: users3.firstName,
          lastName: users3.lastName,
          email: users3.email,
          role: users3.role
        }).from(users3).where(and3(
          eq2(users3.organizationId, organizationId2),
          inArray(users3.role, ["owner", "portfolio-manager", "retail-agent", "referral-agent"])
        ));
        const usersWithBalances = await Promise.all(
          users3.map(async (user) => {
            const balance = await this.getUserBalanceSummary(organizationId2, user.id);
            return {
              ...user,
              currentBalance: balance.currentBalance,
              pendingPayouts: balance.pendingPayouts
            };
          })
        );
        return usersWithBalances;
      }
      async getUserBalanceSummary(organizationId2, userId) {
        const [ownerBalance] = await db.select().from(ownerBalances).where(and3(
          eq2(ownerBalances.organizationId, organizationId2),
          eq2(ownerBalances.ownerId, userId)
        ));
        const pendingPayouts = await db.select({ amount: sum(ownerPayoutRequests.requestedAmount) }).from(ownerPayoutRequests).where(and3(
          eq2(ownerPayoutRequests.organizationId, organizationId2),
          eq2(ownerPayoutRequests.ownerId, userId),
          eq2(ownerPayoutRequests.requestStatus, "pending")
        ));
        const commissions = await db.select({ amount: sum(commissionEarnings.commissionAmount) }).from(commissionEarnings).where(and3(
          eq2(commissionEarnings.organizationId, organizationId2),
          eq2(commissionEarnings.portfolioManagerId, userId)
        ));
        return {
          currentBalance: parseFloat(ownerBalance?.currentBalance || "0"),
          pendingPayouts: parseFloat(pendingPayouts[0]?.amount || "0"),
          totalEarnings: parseFloat(ownerBalance?.totalEarnings || "0"),
          totalExpenses: parseFloat(ownerBalance?.totalExpenses || "0"),
          commissions: parseFloat(commissions[0]?.amount || "0")
        };
      }
      async resetUserBalance(organizationId2, userId, adminUserId, reason) {
        const balanceSummary = await this.getUserBalanceSummary(organizationId2, userId);
        const previousBalance = balanceSummary.currentBalance;
        await db.update(ownerBalances).set({
          currentBalance: "0.00",
          totalEarnings: "0.00",
          totalExpenses: "0.00",
          totalPayoutsRequested: "0.00",
          totalPayoutsPaid: "0.00",
          thisMonthEarnings: "0.00",
          thisMonthExpenses: "0.00",
          thisMonthNet: "0.00",
          lastCalculated: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and3(
          eq2(ownerBalances.organizationId, organizationId2),
          eq2(ownerBalances.ownerId, userId)
        ));
        await db.insert(balanceResetAudit).values({
          organizationId: organizationId2,
          userId,
          adminUserId,
          resetReason: reason,
          previousBalance: previousBalance.toString(),
          resetAmount: previousBalance.toString(),
          resetDate: /* @__PURE__ */ new Date()
        });
        return {
          success: true,
          previousBalance,
          resetAmount: previousBalance
        };
      }
      async getBalanceResetAuditLog(organizationId2, userId) {
        let query = db.select().from(balanceResetAudit).where(eq2(balanceResetAudit.organizationId, organizationId2));
        if (userId) {
          query = query.where(eq2(balanceResetAudit.userId, userId));
        }
        return await query.orderBy(desc2(balanceResetAudit.createdAt));
      }
      // Cross-Module Analytics & Reporting
      async getFinancialControlsDashboard(organizationId2) {
        const totalBalances = await db.select({ total: sum(ownerBalances.currentBalance) }).from(ownerBalances).where(eq2(ownerBalances.organizationId, organizationId2));
        const pendingPayouts = await db.select({ total: sum(ownerPayoutRequests.requestedAmount) }).from(ownerPayoutRequests).where(and3(
          eq2(ownerPayoutRequests.organizationId, organizationId2),
          eq2(ownerPayoutRequests.requestStatus, "pending")
        ));
        const monthlyInvoices = await db.select({ count: sql3`count(*)` }).from(invoices).where(and3(
          eq2(invoices.organizationId, organizationId2),
          sql3`EXTRACT(MONTH FROM ${invoices.createdAt}) = EXTRACT(MONTH FROM CURRENT_DATE)`
        ));
        const pmEarnings = await db.select({ total: sum(commissionEarnings.commissionAmount) }).from(commissionEarnings).where(eq2(commissionEarnings.organizationId, organizationId2));
        const staffRequests = await db.select({ count: sql3`count(*)` }).from(staffAdvanceRequests).where(and3(
          eq2(staffAdvanceRequests.organizationId, organizationId2),
          eq2(staffAdvanceRequests.requestStatus, "pending")
        ));
        return {
          totalOwnerBalances: parseFloat(totalBalances[0]?.total || "0"),
          pendingPayouts: parseFloat(pendingPayouts[0]?.total || "0"),
          monthlyInvoiceCount: monthlyInvoices[0]?.count || 0,
          portfolioManagerEarnings: parseFloat(pmEarnings[0]?.total || "0"),
          staffAdvanceRequests: staffRequests[0]?.count || 0,
          systemHealth: "operational"
        };
      }
      // ===== ENHANCED FINANCIAL CONTROLS MOCK IMPLEMENTATIONS =====
      // Owner Balance Dashboard Methods
      async getEnhancedOwnerBalances(organizationId2, ownerId, propertyId) {
        const mockOwnerBalances = [
          {
            id: 1,
            ownerId: "demo-owner",
            ownerName: "Jacky Testuser",
            currentBalance: "45750.00",
            thisMonthEarnings: "12350.00",
            pendingPayouts: "8500.00",
            propertyCount: 2,
            lastCalculated: /* @__PURE__ */ new Date(),
            lastPayoutDate: new Date(Date.now() - 15 * 24 * 60 * 60 * 1e3)
            // 15 days ago
          },
          {
            id: 2,
            ownerId: "demo-owner-2",
            ownerName: "Sarah Johnson",
            currentBalance: "32100.00",
            thisMonthEarnings: "9840.00",
            pendingPayouts: "5200.00",
            propertyCount: 1,
            lastCalculated: /* @__PURE__ */ new Date(),
            lastPayoutDate: new Date(Date.now() - 8 * 24 * 60 * 60 * 1e3)
            // 8 days ago
          },
          {
            id: 3,
            ownerId: "demo-owner-3",
            ownerName: "Michael Chen",
            currentBalance: "67890.00",
            thisMonthEarnings: "18500.00",
            pendingPayouts: "12000.00",
            propertyCount: 3,
            lastCalculated: /* @__PURE__ */ new Date(),
            lastPayoutDate: new Date(Date.now() - 22 * 24 * 60 * 60 * 1e3)
            // 22 days ago
          }
        ];
        if (ownerId) {
          return mockOwnerBalances.filter((balance) => balance.ownerId === ownerId);
        }
        return mockOwnerBalances;
      }
      async getOwnerFinancialSummary(organizationId2, ownerId) {
        return {
          totalEarnings: 125430.5,
          totalExpenses: 23650.75,
          netBalance: 101779.75,
          pendingPayouts: 8500,
          thisMonthIncome: 12350,
          thisMonthExpenses: 3200,
          propertiesOwned: 2,
          averageMonthlyIncome: 10452.54,
          lastPayoutAmount: 15e3,
          lastPayoutDate: new Date(Date.now() - 15 * 24 * 60 * 60 * 1e3)
        };
      }
      // Owner Payout Request Methods
      async getOwnerPayoutRequests(organizationId2, ownerId, filters) {
        const mockPayoutRequests = [
          {
            id: 1,
            organizationId: organizationId2,
            ownerId: "demo-owner",
            ownerName: "Jacky Testuser",
            requestedAmount: "15000.00",
            requestStatus: "pending",
            paymentMethod: "Bank Transfer",
            requestedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1e3),
            // 2 days ago
            requestedBy: "demo-owner",
            description: "Monthly payout request",
            currency: "THB"
          },
          {
            id: 2,
            organizationId: organizationId2,
            ownerId: "demo-owner",
            ownerName: "Jacky Testuser",
            requestedAmount: "8500.00",
            requestStatus: "approved",
            paymentMethod: "Bank Transfer",
            requestedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1e3),
            // 10 days ago
            approvedAt: new Date(Date.now() - 8 * 24 * 60 * 60 * 1e3),
            // 8 days ago
            requestedBy: "demo-owner",
            description: "Emergency payout request",
            currency: "THB"
          },
          {
            id: 3,
            organizationId: organizationId2,
            ownerId: "demo-owner-2",
            ownerName: "Sarah Johnson",
            requestedAmount: "12000.00",
            requestStatus: "payment_uploaded",
            paymentMethod: "Wire Transfer",
            requestedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1e3),
            // 5 days ago
            approvedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1e3),
            // 3 days ago
            requestedBy: "demo-owner-2",
            description: "Quarterly payout request",
            currency: "THB"
          }
        ];
        let filteredRequests = mockPayoutRequests;
        if (ownerId) {
          filteredRequests = filteredRequests.filter((req) => req.ownerId === ownerId);
        }
        if (filters?.status && filters.status !== "all") {
          filteredRequests = filteredRequests.filter((req) => req.requestStatus === filters.status);
        }
        return filteredRequests;
      }
      async createOwnerPayoutRequest(requestData) {
        const newRequest = {
          id: Date.now(),
          // Simple ID generation for mock
          ...requestData,
          createdAt: /* @__PURE__ */ new Date()
        };
        return newRequest;
      }
      // Enhanced Invoice Tool Methods
      async getInvoiceTemplates(organizationId2) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            templateName: "Monthly Management Fee",
            templateType: "management_fee",
            defaultTaxRate: "7.00",
            isActive: true,
            createdAt: /* @__PURE__ */ new Date()
          },
          {
            id: 2,
            organizationId: organizationId2,
            templateName: "Owner Commission Invoice",
            templateType: "owner_commission",
            defaultTaxRate: "7.00",
            isActive: true,
            createdAt: /* @__PURE__ */ new Date()
          }
        ];
      }
      async getEnhancedInvoices(organizationId2, filters) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            invoiceNumber: "INV-2024-001",
            invoiceType: "management_fee",
            totalAmount: "12500.00",
            invoiceStatus: "paid",
            createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3),
            senderType: "management",
            recipientType: "owner"
          }
        ];
      }
      // Portfolio Manager Earnings Methods
      async getPortfolioManagerEarnings(organizationId2, pmId, filters) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            portfolioManagerId: "demo-portfolio-manager",
            pmName: "Dean Testmanager",
            earningsMonth: "2024-12",
            totalEarnings: "45200.00",
            propertyCount: 5,
            commissionRate: "15.00",
            payoutStatus: "pending",
            earningsDate: /* @__PURE__ */ new Date()
          }
        ];
      }
      async getPortfolioManagerSummary(organizationId2, pmId) {
        return {
          totalEarnings: 542500,
          propertiesManaged: 5,
          pendingPayouts: 45200,
          thisMonthEarnings: 45200,
          averageMonthlyEarnings: 38750,
          totalCommissions: 542500,
          lastPayoutDate: new Date(Date.now() - 20 * 24 * 60 * 60 * 1e3)
        };
      }
      // Staff Salary & Advance Request Methods
      async getStaffAdvanceRequests(organizationId2, staffId, filters) {
        const mockAdvanceRequests = [
          {
            id: 1,
            organizationId: organizationId2,
            staffId: "demo-staff",
            staffName: "Anna Housekeeper",
            requestedAmount: "5000.00",
            requestStatus: "pending",
            urgencyLevel: "normal",
            requestReason: "Emergency medical expenses",
            requestedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1e3),
            // 1 day ago
            requestedBy: "demo-staff",
            expectedDeductionMonths: 3
          },
          {
            id: 2,
            organizationId: organizationId2,
            staffId: "demo-staff-2",
            staffName: "Tom Maintenance",
            requestedAmount: "3000.00",
            requestStatus: "approved",
            urgencyLevel: "low",
            requestReason: "Home renovation",
            requestedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1e3),
            // 5 days ago
            approvedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1e3),
            // 3 days ago
            requestedBy: "demo-staff-2",
            expectedDeductionMonths: 2
          }
        ];
        let filteredRequests = mockAdvanceRequests;
        if (staffId) {
          filteredRequests = filteredRequests.filter((req) => req.staffId === staffId);
        }
        if (filters?.requestStatus) {
          filteredRequests = filteredRequests.filter((req) => req.requestStatus === filters.requestStatus);
        }
        if (filters?.urgencyLevel) {
          filteredRequests = filteredRequests.filter((req) => req.urgencyLevel === filters.urgencyLevel);
        }
        return filteredRequests;
      }
      async createStaffAdvanceRequest(requestData) {
        const newRequest = {
          id: Date.now(),
          // Simple ID generation for mock
          ...requestData,
          createdAt: /* @__PURE__ */ new Date()
        };
        return newRequest;
      }
      // Balance Reset Control Methods (Admin Only)
      async getUsersForBalanceReset(organizationId2) {
        return [
          {
            id: "demo-owner",
            firstName: "Jacky",
            lastName: "Testuser",
            email: "jacky@example.com",
            role: "owner",
            currentBalance: 45750,
            pendingPayouts: 8500
          },
          {
            id: "demo-portfolio-manager",
            firstName: "Dean",
            lastName: "Testmanager",
            email: "dean@example.com",
            role: "portfolio-manager",
            currentBalance: 45200,
            pendingPayouts: 45200
          },
          {
            id: "demo-staff",
            firstName: "Anna",
            lastName: "Housekeeper",
            email: "anna@example.com",
            role: "staff",
            currentBalance: -2500,
            // Negative due to advance
            pendingPayouts: 0
          },
          {
            id: "demo-retail-agent",
            firstName: "Mike",
            lastName: "Booking",
            email: "mike@example.com",
            role: "retail-agent",
            currentBalance: 15200,
            pendingPayouts: 5e3
          }
        ];
      }
      async resetUserBalance(organizationId2, userId, adminId, reason) {
        return {
          success: true,
          message: `Balance reset completed for user ${userId}`,
          resetBy: adminId,
          resetReason: reason,
          resetAt: /* @__PURE__ */ new Date(),
          previousBalance: 45750,
          // Mock previous balance
          newBalance: 0
        };
      }
      // Financial Controls Dashboard Method
      async getFinancialControlsDashboard(organizationId2) {
        return {
          totalOwnerBalances: 145740,
          pendingPayouts: 25700,
          monthlyInvoiceCount: 42,
          portfolioManagerEarnings: 45200,
          staffAdvanceRequests: 2,
          systemHealth: "Operational",
          totalUsers: 15,
          activeProperties: 8,
          pendingApprovals: 5,
          lastCalculated: /* @__PURE__ */ new Date()
        };
      }
      // ===== MAINTENANCE, UTILITIES & RENOVATION TRACKER MOCK IMPLEMENTATIONS =====
      // Maintenance Issues Methods
      async getMaintenanceIssues(organizationId2, propertyId) {
        const mockIssues = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            issueTitle: "AC Unit Not Cooling Properly",
            issueDescription: "Master bedroom AC unit is not cooling effectively. Room temperature remains at 28\xB0C despite setting to 22\xB0C.",
            issueType: "AC",
            urgencyLevel: "Urgent",
            currentStatus: "open",
            reportedBy: "demo-owner",
            reportedByName: "Jacky Testuser",
            assignedTo: "demo-staff",
            assignedToName: "Anna Housekeeper",
            assignedToType: "staff",
            estimatedCost: "8500.00",
            actualCost: null,
            currency: "THB",
            dueDateEstimate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1e3),
            // 3 days from now
            startedAt: null,
            completedAt: null,
            receipts: [],
            resolutionPhotos: [],
            createdAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1e3),
            // 2 days ago
            updatedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1e3)
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            issueTitle: "Pool Pump Making Loud Noise",
            issueDescription: "Pool pump has been making unusual grinding noise for the past week. Filtration seems affected.",
            issueType: "Pool",
            urgencyLevel: "Normal",
            currentStatus: "in_progress",
            reportedBy: "demo-staff",
            reportedByName: "Anna Housekeeper",
            assignedTo: "demo-staff-2",
            assignedToName: "Tom Maintenance",
            assignedToType: "staff",
            estimatedCost: "5000.00",
            actualCost: null,
            currency: "THB",
            dueDateEstimate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1e3),
            // 5 days from now
            startedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1e3),
            // 1 day ago
            completedAt: null,
            receipts: [],
            resolutionPhotos: [],
            createdAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1e3),
            // 5 days ago
            updatedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1e3)
          },
          {
            id: 3,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            issueTitle: "Garden Irrigation System Leak",
            issueDescription: "Water leak detected in the garden irrigation system near the entrance. Water pooling observed.",
            issueType: "Garden",
            urgencyLevel: "Normal",
            currentStatus: "resolved",
            reportedBy: "demo-portfolio-manager",
            reportedByName: "Dean Testmanager",
            assignedTo: "demo-staff-2",
            assignedToName: "Tom Maintenance",
            assignedToType: "staff",
            resolvedBy: "demo-staff-2",
            resolvedByName: "Tom Maintenance",
            resolutionDate: new Date(Date.now() - 1 * 24 * 60 * 60 * 1e3),
            resolutionNotes: "Replaced damaged irrigation pipe section. Tested system thoroughly.",
            estimatedCost: "2500.00",
            actualCost: "2800.00",
            currency: "THB",
            dueDateEstimate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1e3),
            startedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1e3),
            completedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1e3),
            receipts: ["receipt_irrigation_parts_001.pdf"],
            resolutionPhotos: ["irrigation_repair_before.jpg", "irrigation_repair_after.jpg"],
            createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3),
            // 7 days ago
            updatedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1e3)
          }
        ];
        if (propertyId) {
          return mockIssues.filter((issue) => issue.propertyId === propertyId);
        }
        return mockIssues;
      }
      async createMaintenanceIssue(issueData) {
        const newIssue = {
          id: Date.now(),
          // Simple ID generation for mock
          ...issueData,
          currentStatus: "open",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newIssue;
      }
      // Property Service History Methods
      async getPropertyServiceHistory(organizationId2, propertyId) {
        const mockServiceHistory = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            serviceType: "ac_service",
            serviceName: "Annual AC Maintenance & Cleaning",
            serviceDescription: "Complete AC system maintenance including coil cleaning, filter replacement, and refrigerant check.",
            serviceDate: new Date(Date.now() - 90 * 24 * 60 * 60 * 1e3),
            // 90 days ago
            serviceProvider: "Cool Air Solutions Co., Ltd.",
            providerContact: "+66 2 123 4567",
            serviceCategory: "routine_maintenance",
            serviceNotes: "All units serviced successfully. Recommended next service in 6 months.",
            attachments: ["ac_service_report_001.pdf", "before_after_photos.zip"],
            serviceCost: "12500.00",
            currency: "THB",
            qualityRating: 5,
            followUpRequired: false,
            nextServiceDue: new Date(Date.now() + 90 * 24 * 60 * 60 * 1e3),
            // 90 days from now
            serviceWarranty: "3 months",
            createdBy: "demo-portfolio-manager",
            createdByName: "Dean Testmanager",
            createdAt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1e3)
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            serviceType: "pest_control",
            serviceName: "Quarterly Pest Control Treatment",
            serviceDescription: "Comprehensive pest control treatment covering indoor and outdoor areas.",
            serviceDate: new Date(Date.now() - 45 * 24 * 60 * 60 * 1e3),
            // 45 days ago
            serviceProvider: "Samui Pest Control Services",
            providerContact: "+66 77 987 6543",
            serviceCategory: "routine_maintenance",
            serviceNotes: "Applied eco-friendly treatment. No pest activity observed during inspection.",
            attachments: ["pest_control_certificate.pdf"],
            serviceCost: "3500.00",
            currency: "THB",
            qualityRating: 4,
            followUpRequired: false,
            nextServiceDue: new Date(Date.now() + 45 * 24 * 60 * 60 * 1e3),
            // 45 days from now
            serviceWarranty: "30 days",
            createdBy: "demo-staff",
            createdByName: "Anna Housekeeper",
            createdAt: new Date(Date.now() - 45 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 45 * 24 * 60 * 60 * 1e3)
          },
          {
            id: 3,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            serviceType: "pool_inspection",
            serviceName: "Pool System Deep Inspection & Chemical Balance",
            serviceDescription: "Complete pool system inspection including pump, filtration, and chemical balance optimization.",
            serviceDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
            // 30 days ago
            serviceProvider: "Tropical Pool Maintenance",
            providerContact: "+66 77 555 1234",
            serviceCategory: "routine_maintenance",
            serviceNotes: "Pool system functioning well. Minor pump adjustment made. Chemical levels balanced.",
            attachments: ["pool_inspection_report.pdf", "chemical_test_results.jpg"],
            serviceCost: "4500.00",
            currency: "THB",
            qualityRating: 5,
            followUpRequired: false,
            nextServiceDue: new Date(Date.now() + 60 * 24 * 60 * 60 * 1e3),
            // 60 days from now
            serviceWarranty: "14 days",
            createdBy: "demo-portfolio-manager",
            createdByName: "Dean Testmanager",
            createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)
          },
          {
            id: 4,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            serviceType: "deep_clean",
            serviceName: "Post-Guest Deep Cleaning & Steam Treatment",
            serviceDescription: "Comprehensive deep cleaning including steam cleaning of carpets, upholstery, and mattresses.",
            serviceDate: new Date(Date.now() - 15 * 24 * 60 * 60 * 1e3),
            // 15 days ago
            serviceProvider: "Samui Premium Cleaning",
            providerContact: "+66 77 333 2222",
            serviceCategory: "routine_maintenance",
            serviceNotes: "Complete deep clean performed. All fabrics steam treated. Property ready for next guests.",
            attachments: ["cleaning_checklist.pdf", "before_after_photos.zip"],
            serviceCost: "6500.00",
            currency: "THB",
            qualityRating: 5,
            followUpRequired: false,
            nextServiceDue: new Date(Date.now() + 75 * 24 * 60 * 60 * 1e3),
            // 75 days from now
            serviceWarranty: "7 days",
            createdBy: "demo-staff",
            createdByName: "Anna Housekeeper",
            createdAt: new Date(Date.now() - 15 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 15 * 24 * 60 * 60 * 1e3)
          }
        ];
        if (propertyId) {
          return mockServiceHistory.filter((service) => service.propertyId === propertyId);
        }
        return mockServiceHistory;
      }
      async createPropertyServiceHistory(serviceData) {
        const newService = {
          id: Date.now(),
          // Simple ID generation for mock
          ...serviceData,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newService;
      }
      // AI Task Suggestions Methods
      async getMaintenanceTaskSuggestions(organizationId2, propertyId) {
        const mockSuggestions = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            suggestionType: "recurring_service",
            taskType: "AC",
            suggestionTitle: "AC Service Due Soon",
            suggestionDescription: "Next AC service due in 30 days based on last service date. Regular maintenance helps maintain efficiency and prevents breakdowns.",
            aiConfidence: "92.5",
            basedOnData: "historical_pattern",
            lastServiceDate: new Date(Date.now() - 90 * 24 * 60 * 60 * 1e3),
            daysSinceLastService: 90,
            recommendedInterval: 120,
            priorityLevel: "medium",
            suggestedDueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3),
            estimatedCost: "12500.00",
            currency: "THB",
            suggestionStatus: "pending",
            createdAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1e3)
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            suggestionType: "overdue_maintenance",
            taskType: "Pest Control",
            suggestionTitle: "Pest Control Overdue",
            suggestionDescription: "No pest control service in last 120 days. Recommended quarterly treatment to prevent infestations.",
            aiConfidence: "88.0",
            basedOnData: "industry_standard",
            lastServiceDate: new Date(Date.now() - 130 * 24 * 60 * 60 * 1e3),
            daysSinceLastService: 130,
            recommendedInterval: 90,
            priorityLevel: "high",
            suggestedDueDate: new Date(Date.now() - 10 * 24 * 60 * 60 * 1e3),
            // Already overdue
            estimatedCost: "3500.00",
            currency: "THB",
            suggestionStatus: "pending",
            createdAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1e3)
          },
          {
            id: 3,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            suggestionType: "predictive_alert",
            taskType: "Pool",
            suggestionTitle: "Pool Equipment Maintenance Recommended",
            suggestionDescription: "Based on usage patterns and last inspection, pool equipment maintenance recommended within 2 weeks.",
            aiConfidence: "76.5",
            basedOnData: "historical_pattern",
            lastServiceDate: new Date(Date.now() - 60 * 24 * 60 * 60 * 1e3),
            daysSinceLastService: 60,
            recommendedInterval: 75,
            priorityLevel: "low",
            suggestedDueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1e3),
            estimatedCost: "4500.00",
            currency: "THB",
            suggestionStatus: "pending",
            createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1e3)
          }
        ];
        if (propertyId) {
          return mockSuggestions.filter((suggestion) => suggestion.propertyId === propertyId);
        }
        return mockSuggestions;
      }
      async approveSuggestion(suggestionId) {
        return {
          success: true,
          message: "Task created from suggestion",
          taskId: Date.now(),
          // Mock task ID
          approvedAt: /* @__PURE__ */ new Date()
        };
      }
      async dismissSuggestion(suggestionId, reason) {
        return {
          success: true,
          message: "Suggestion dismissed",
          dismissedAt: /* @__PURE__ */ new Date(),
          reason
        };
      }
      // Property Utilities Methods
      async getPropertyUtilities(organizationId2, propertyId) {
        const mockUtilities = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityType: "electricity",
            customUtilityName: null,
            provider: "Provincial Electricity Authority (PEA)",
            accountNumber: "1234567890123",
            billingCycle: "monthly",
            averageBillAmount: "4500.00",
            currency: "THB",
            expectedBillDate: 17,
            alertDaysAfter: 4,
            autoRemindersEnabled: true,
            providerContact: "+66 2 590 1234",
            onlinePortal: "https://www.pea.co.th",
            loginCredentials: "encrypted_login_data",
            isActive: true,
            notes: "Main electricity supply for entire property",
            createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityType: "water",
            customUtilityName: null,
            provider: "Samui Waterworks",
            accountNumber: "SW-987654321",
            billingCycle: "monthly",
            averageBillAmount: "1200.00",
            currency: "THB",
            expectedBillDate: 22,
            alertDaysAfter: 4,
            autoRemindersEnabled: true,
            providerContact: "+66 77 421 0088",
            onlinePortal: "https://www.samuiwater.co.th",
            loginCredentials: "encrypted_login_data",
            isActive: true,
            notes: "Municipal water supply",
            createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)
          },
          {
            id: 3,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityType: "internet",
            customUtilityName: null,
            provider: "True Internet",
            accountNumber: "TRUE-555888999",
            billingCycle: "monthly",
            averageBillAmount: "1990.00",
            currency: "THB",
            expectedBillDate: 5,
            alertDaysAfter: 4,
            autoRemindersEnabled: true,
            providerContact: "+66 2 888 8888",
            onlinePortal: "https://www.trueonline.com",
            loginCredentials: "encrypted_login_data",
            isActive: true,
            notes: "Fiber optic internet 1000/500 Mbps package",
            createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)
          },
          {
            id: 4,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityType: "pest_control",
            customUtilityName: null,
            provider: "Samui Pest Control Services",
            accountNumber: "SPC-2024-001",
            billingCycle: "quarterly",
            averageBillAmount: "3500.00",
            currency: "THB",
            expectedBillDate: 15,
            alertDaysAfter: 7,
            autoRemindersEnabled: true,
            providerContact: "+66 77 987 6543",
            onlinePortal: "",
            loginCredentials: null,
            isActive: true,
            notes: "Eco-friendly pest control service contract",
            createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
            updatedAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)
          }
        ];
        if (propertyId) {
          return mockUtilities.filter((utility) => utility.propertyId === propertyId);
        }
        return mockUtilities;
      }
      async createPropertyUtility(utilityData) {
        const newUtility = {
          id: Date.now(),
          // Simple ID generation for mock
          ...utilityData,
          isActive: true,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newUtility;
      }
      // Utility Bill History Methods
      async getUtilityBillHistory(organizationId2, propertyId, utilityId) {
        const mockBills = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityId: 1,
            // Electricity
            billingMonth: "2024-12",
            billAmount: "4890.50",
            currency: "THB",
            billDueDate: /* @__PURE__ */ new Date("2024-12-31"),
            billReceivedDate: /* @__PURE__ */ new Date("2024-12-17"),
            paymentStatus: "paid",
            paidDate: /* @__PURE__ */ new Date("2024-12-20"),
            paidBy: "demo-portfolio-manager",
            paidByName: "Dean Testmanager",
            receiptUrl: "electricity_bill_dec_2024.pdf",
            paymentReceiptUrl: "payment_receipt_electricity_dec.pdf",
            notes: "Higher usage due to guests during holiday season",
            alertSent: false,
            alertSentDate: null,
            alertSentTo: [],
            createdAt: /* @__PURE__ */ new Date("2024-12-17"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-20")
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityId: 1,
            // Electricity
            billingMonth: "2024-11",
            billAmount: "4125.00",
            currency: "THB",
            billDueDate: /* @__PURE__ */ new Date("2024-11-30"),
            billReceivedDate: /* @__PURE__ */ new Date("2024-11-17"),
            paymentStatus: "paid",
            paidDate: /* @__PURE__ */ new Date("2024-11-18"),
            paidBy: "demo-staff",
            paidByName: "Anna Housekeeper",
            receiptUrl: "electricity_bill_nov_2024.pdf",
            paymentReceiptUrl: "payment_receipt_electricity_nov.pdf",
            notes: "Normal usage month",
            alertSent: false,
            alertSentDate: null,
            alertSentTo: [],
            createdAt: /* @__PURE__ */ new Date("2024-11-17"),
            updatedAt: /* @__PURE__ */ new Date("2024-11-18")
          },
          {
            id: 3,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityId: 2,
            // Water
            billingMonth: "2024-12",
            billAmount: "1350.00",
            currency: "THB",
            billDueDate: /* @__PURE__ */ new Date("2025-01-15"),
            billReceivedDate: /* @__PURE__ */ new Date("2024-12-22"),
            paymentStatus: "pending",
            paidDate: null,
            paidBy: null,
            paidByName: null,
            receiptUrl: "water_bill_dec_2024.pdf",
            paymentReceiptUrl: null,
            notes: "Bill just received, payment pending",
            alertSent: false,
            alertSentDate: null,
            alertSentTo: [],
            createdAt: /* @__PURE__ */ new Date("2024-12-22"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-22")
          },
          {
            id: 4,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityId: 3,
            // Internet
            billingMonth: "2024-12",
            billAmount: "1990.00",
            currency: "THB",
            billDueDate: /* @__PURE__ */ new Date("2025-01-05"),
            billReceivedDate: /* @__PURE__ */ new Date("2024-12-05"),
            paymentStatus: "paid",
            paidDate: /* @__PURE__ */ new Date("2024-12-05"),
            paidBy: "demo-portfolio-manager",
            paidByName: "Dean Testmanager",
            receiptUrl: "internet_bill_dec_2024.pdf",
            paymentReceiptUrl: "payment_receipt_internet_dec.pdf",
            notes: "Auto-paid via bank transfer",
            alertSent: false,
            alertSentDate: null,
            alertSentTo: [],
            createdAt: /* @__PURE__ */ new Date("2024-12-05"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-05")
          }
        ];
        let filteredBills = mockBills;
        if (propertyId) {
          filteredBills = filteredBills.filter((bill) => bill.propertyId === propertyId);
        }
        if (utilityId) {
          filteredBills = filteredBills.filter((bill) => bill.utilityId === utilityId);
        }
        return filteredBills;
      }
      async createUtilityBill(billData) {
        const newBill = {
          id: Date.now(),
          // Simple ID generation for mock
          ...billData,
          alertSent: false,
          alertSentDate: null,
          alertSentTo: [],
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newBill;
      }
      // Utility Bill Alerts Methods
      async getUtilityBillAlerts(organizationId2, propertyId) {
        const mockAlerts = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityId: 2,
            // Water utility
            alertType: "missing_receipt",
            alertTitle: "Water Bill Overdue - Receipt Not Uploaded",
            alertMessage: "Water bill for December 2024 is overdue by 2 days. Expected receipt by 26th Dec, but not yet uploaded.",
            alertSeverity: "warning",
            sentTo: ["demo-portfolio-manager", "demo-admin"],
            sentToRoles: ["admin", "portfolio-manager"],
            alertStatus: "active",
            acknowledgedBy: null,
            acknowledgedAt: null,
            resolvedBy: null,
            resolvedAt: null,
            createdAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1e3)
            // 2 days ago
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityId: 1,
            // Electricity utility
            alertType: "payment_reminder",
            alertTitle: "Electricity Bill Payment Due Soon",
            alertMessage: "Electricity bill for January 2025 is due in 3 days (Jan 31st). Amount: \u0E3F4,890.50",
            alertSeverity: "info",
            sentTo: ["demo-portfolio-manager", "demo-staff"],
            sentToRoles: ["portfolio-manager", "staff"],
            alertStatus: "active",
            acknowledgedBy: null,
            acknowledgedAt: null,
            resolvedBy: null,
            resolvedAt: null,
            createdAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1e3)
            // 1 day ago
          },
          {
            id: 3,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            utilityId: 4,
            // Pest control utility
            alertType: "overdue_bill",
            alertTitle: "Pest Control Service Payment Overdue",
            alertMessage: "Quarterly pest control payment is overdue by 5 days. Please process payment immediately.",
            alertSeverity: "urgent",
            sentTo: ["demo-admin", "demo-portfolio-manager"],
            sentToRoles: ["admin", "portfolio-manager"],
            alertStatus: "acknowledged",
            acknowledgedBy: "demo-portfolio-manager",
            acknowledgedAt: new Date(Date.now() - 12 * 60 * 60 * 1e3),
            // 12 hours ago
            resolvedBy: null,
            resolvedAt: null,
            createdAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1e3)
            // 5 days ago
          }
        ];
        if (propertyId) {
          return mockAlerts.filter((alert) => alert.propertyId === propertyId);
        }
        return mockAlerts;
      }
      // Property Info Summary Methods
      async getPropertyInfoSummary(organizationId2, propertyId) {
        return {
          id: 1,
          organizationId: organizationId2,
          propertyId,
          totalUtilities: 4,
          utilitiesWithUnpaidBills: 1,
          utilitiesWithOverdueBills: 1,
          totalMonthlyUtilityCost: "9530.00",
          openMaintenanceIssues: 2,
          urgentMaintenanceIssues: 1,
          totalMaintenanceCostThisYear: "28500.00",
          lastMaintenanceDate: new Date(Date.now() - 1 * 24 * 60 * 60 * 1e3),
          lastServiceDate: new Date(Date.now() - 15 * 24 * 60 * 60 * 1e3),
          lastUtilityBillDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1e3),
          activeSuggestions: 3,
          urgentSuggestions: 1,
          lastUpdated: /* @__PURE__ */ new Date(),
          cacheVersion: 1
        };
      }
      // ===== GUEST CHECK-IN / CHECK-OUT TRACKER =====
      // Property Electricity Settings
      async getPropertyElectricitySettings(organizationId2, propertyId) {
        return {
          id: 1,
          organizationId: organizationId2,
          propertyId,
          defaultRatePerKwh: "7.00",
          currency: "THB",
          enableOcrReading: true,
          ocrProvider: "openai_vision",
          electricityBillingDefault: "included",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async createPropertyElectricitySettings(settings) {
        return { id: 1, ...settings, createdAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() };
      }
      async updatePropertyElectricitySettings(propertyId, settings) {
        return { id: 1, propertyId, ...settings, updatedAt: /* @__PURE__ */ new Date() };
      }
      // Guest Check-Ins
      async getGuestCheckIns(organizationId2, filters) {
        const now = /* @__PURE__ */ new Date();
        const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
        const mockCheckIns = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            bookingId: 1,
            guestName: "Sarah Johnson",
            guestEmail: "sarah.johnson@email.com",
            guestPhone: "+66123456789",
            numberOfGuests: 2,
            checkInDate: yesterday,
            assignedStaff: "demo-staff",
            staffName: "Demo Staff",
            passportPhotos: ["/uploads/passport1.jpg", "/uploads/passport2.jpg"],
            passportNumbers: ["A12345678", "B87654321"],
            passportNames: ["Sarah Johnson", "Mike Johnson"],
            depositType: "cash",
            depositAmount: "5000.00",
            depositCurrency: "THB",
            depositPhotoUrl: "/uploads/deposit1.jpg",
            meterPhotoUrl: "/uploads/meter_checkin1.jpg",
            meterReading: "1245.5",
            meterReadingMethod: "ocr_auto",
            ocrConfidence: "95.8",
            checkInNotes: "Guests arrived on time. All documentation verified.",
            taskStatus: "completed",
            completedAt: yesterday,
            completedBy: "demo-staff",
            createdAt: yesterday,
            updatedAt: yesterday
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            bookingId: null,
            guestName: "David Chen",
            guestEmail: "david.chen@email.com",
            guestPhone: "+66987654321",
            numberOfGuests: 1,
            checkInDate: now,
            assignedStaff: "demo-staff",
            staffName: "Demo Staff",
            passportPhotos: ["/uploads/passport3.jpg"],
            passportNumbers: ["C98765432"],
            passportNames: ["David Chen"],
            depositType: "digital",
            depositAmount: "3000.00",
            depositCurrency: "THB",
            depositPhotoUrl: null,
            meterPhotoUrl: "/uploads/meter_checkin2.jpg",
            meterReading: "1278.2",
            meterReadingMethod: "manual",
            ocrConfidence: null,
            checkInNotes: "Late arrival, but check-in completed successfully.",
            taskStatus: "in_progress",
            completedAt: null,
            completedBy: null,
            createdAt: now,
            updatedAt: now
          }
        ];
        if (filters?.status) {
          return mockCheckIns.filter((checkIn) => checkIn.taskStatus === filters.status);
        }
        if (filters?.assignedStaff) {
          return mockCheckIns.filter((checkIn) => checkIn.assignedStaff === filters.assignedStaff);
        }
        return mockCheckIns;
      }
      async getGuestCheckInById(organizationId2, checkInId) {
        const checkIns = await this.getGuestCheckIns(organizationId2);
        return checkIns.find((checkIn) => checkIn.id === checkInId);
      }
      async createGuestCheckIn(checkInData) {
        const newCheckIn = {
          id: Date.now(),
          ...checkInData,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        await this.createCheckInOutHistory({
          organizationId: checkInData.organizationId,
          propertyId: checkInData.propertyId,
          entryType: "check_in_created",
          entryTitle: `Check-in created for ${checkInData.guestName}`,
          entryDescription: `Guest check-in scheduled for ${new Date(checkInData.checkInDate).toLocaleDateString()}`,
          checkInId: newCheckIn.id,
          actionBy: checkInData.assignedStaff || "system",
          actionByName: checkInData.staffName || "System"
        });
        return newCheckIn;
      }
      async updateGuestCheckIn(checkInId, updates) {
        return { id: checkInId, ...updates, updatedAt: /* @__PURE__ */ new Date() };
      }
      async completeGuestCheckIn(checkInId, completedBy) {
        const completed = {
          id: checkInId,
          taskStatus: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          completedBy,
          updatedAt: /* @__PURE__ */ new Date()
        };
        await this.createCheckInOutHistory({
          organizationId: "default-org",
          propertyId: 1,
          entryType: "check_in_completed",
          entryTitle: `Check-in completed`,
          entryDescription: `Guest check-in process completed. Passport photos and meter reading recorded.`,
          checkInId,
          actionBy: completedBy,
          actionByName: completedBy
        });
        return completed;
      }
      // Guest Check-Outs
      async getGuestCheckOuts(organizationId2, filters) {
        const now = /* @__PURE__ */ new Date();
        const mockCheckOuts = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            checkInId: 1,
            checkOutDate: now,
            assignedStaff: "demo-staff",
            staffName: "Demo Staff",
            finalMeterPhotoUrl: "/uploads/meter_checkout1.jpg",
            finalMeterReading: "1267.8",
            finalMeterReadingMethod: "ocr_auto",
            finalOcrConfidence: "92.4",
            unitsUsed: "22.3",
            ratePerKwh: "7.00",
            totalElectricityCost: "156.10",
            electricityBilling: "guest_pays",
            companyCompensationReason: null,
            depositPaid: "5000.00",
            electricityCost: "156.10",
            discounts: "0.00",
            discountReason: null,
            damageCosts: "0.00",
            damageCostReason: null,
            finalRefundAmount: "4843.90",
            refundMethod: "cash",
            refundReceiptUrl: "/uploads/refund_receipt1.jpg",
            refundStatus: "processed",
            refundProcessedBy: "demo-admin",
            refundProcessedAt: now,
            checkOutNotes: "Clean checkout. No damages observed.",
            taskStatus: "completed",
            completedAt: now,
            completedBy: "demo-staff",
            createdAt: now,
            updatedAt: now
          }
        ];
        if (filters?.status) {
          return mockCheckOuts.filter((checkOut) => checkOut.taskStatus === filters.status);
        }
        if (filters?.assignedStaff) {
          return mockCheckOuts.filter((checkOut) => checkOut.assignedStaff === filters.assignedStaff);
        }
        return mockCheckOuts;
      }
      async getGuestCheckOutById(organizationId2, checkOutId) {
        const checkOuts = await this.getGuestCheckOuts(organizationId2);
        return checkOuts.find((checkOut) => checkOut.id === checkOutId);
      }
      async createGuestCheckOut(checkOutData) {
        const newCheckOut = {
          id: Date.now(),
          ...checkOutData,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        await this.createCheckInOutHistory({
          organizationId: checkOutData.organizationId,
          propertyId: checkOutData.propertyId,
          entryType: "check_out_created",
          entryTitle: `Check-out created`,
          entryDescription: `Guest check-out scheduled for ${new Date(checkOutData.checkOutDate).toLocaleDateString()}`,
          checkOutId: newCheckOut.id,
          actionBy: checkOutData.assignedStaff || "system",
          actionByName: checkOutData.staffName || "System"
        });
        return newCheckOut;
      }
      async updateGuestCheckOut(checkOutId, updates) {
        return { id: checkOutId, ...updates, updatedAt: /* @__PURE__ */ new Date() };
      }
      async completeGuestCheckOut(checkOutId, completedBy) {
        const completed = {
          id: checkOutId,
          taskStatus: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          completedBy,
          updatedAt: /* @__PURE__ */ new Date()
        };
        await this.createCheckInOutHistory({
          organizationId: "default-org",
          propertyId: 1,
          entryType: "check_out_completed",
          entryTitle: `Check-out completed`,
          entryDescription: `Guest check-out process completed. Final meter reading and refund calculation processed.`,
          checkOutId,
          actionBy: completedBy,
          actionByName: completedBy
        });
        return completed;
      }
      async processRefund(checkOutId, refundData) {
        const processed = {
          id: checkOutId,
          refundMethod: refundData.refundMethod,
          refundReceiptUrl: refundData.refundReceiptUrl,
          refundStatus: "processed",
          refundProcessedBy: refundData.processedBy,
          refundProcessedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        await this.createCheckInOutHistory({
          organizationId: "default-org",
          propertyId: 1,
          entryType: "refund_processed",
          entryTitle: `Refund processed`,
          entryDescription: `Deposit refund processed via ${refundData.refundMethod}`,
          checkOutId,
          actionBy: refundData.processedBy,
          actionByName: refundData.processedBy
        });
        return processed;
      }
      // Check-In/Out Tasks
      async getCheckInOutTasks(organizationId2, filters) {
        const now = /* @__PURE__ */ new Date();
        const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1e3);
        const mockTasks = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            taskType: "check_out",
            taskTitle: "Check-out for David Chen",
            taskDescription: "Process guest check-out including final meter reading and refund calculation",
            checkInId: null,
            checkOutId: null,
            assignedTo: "demo-staff",
            assignedBy: "demo-admin",
            assignedAt: now,
            dueDate: tomorrow,
            scheduledDate: tomorrow,
            status: "pending",
            priority: "normal",
            startedAt: null,
            completedAt: null,
            completionNotes: null,
            requiresApproval: true,
            approvalStatus: null,
            approvedBy: null,
            approvedAt: null,
            approvalNotes: null,
            createdAt: now,
            updatedAt: now
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            taskType: "check_in",
            taskTitle: "Check-in for Emma Wilson",
            taskDescription: "Process guest check-in including passport documentation and meter reading",
            checkInId: null,
            checkOutId: null,
            assignedTo: "demo-staff",
            assignedBy: "demo-admin",
            assignedAt: now,
            dueDate: tomorrow,
            scheduledDate: tomorrow,
            status: "in_progress",
            priority: "high",
            startedAt: now,
            completedAt: null,
            completionNotes: null,
            requiresApproval: false,
            approvalStatus: null,
            approvedBy: null,
            approvedAt: null,
            approvalNotes: null,
            createdAt: now,
            updatedAt: now
          }
        ];
        let filteredTasks = mockTasks;
        if (filters?.taskType) {
          filteredTasks = filteredTasks.filter((task) => task.taskType === filters.taskType);
        }
        if (filters?.status) {
          filteredTasks = filteredTasks.filter((task) => task.status === filters.status);
        }
        if (filters?.assignedTo) {
          filteredTasks = filteredTasks.filter((task) => task.assignedTo === filters.assignedTo);
        }
        return filteredTasks;
      }
      async createCheckInOutTask(taskData) {
        return {
          id: Date.now(),
          ...taskData,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async updateCheckInOutTask(taskId, updates) {
        return { id: taskId, ...updates, updatedAt: /* @__PURE__ */ new Date() };
      }
      // Check-In/Out History
      async getCheckInOutHistory(organizationId2, filters) {
        const now = /* @__PURE__ */ new Date();
        const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
        const mockHistory = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            entryType: "check_in_completed",
            entryTitle: "Check-in completed for Sarah Johnson",
            entryDescription: "Guest check-in process completed. Passport photos and meter reading recorded.",
            entryIcon: "luggage",
            checkInId: 1,
            checkOutId: null,
            taskId: null,
            actionBy: "demo-staff",
            actionByName: "Demo Staff",
            visibleToOwner: true,
            visibleToStaff: true,
            visibleToGuests: false,
            additionalData: { meterReading: "1245.5", depositAmount: "5000.00" },
            createdAt: yesterday
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            entryType: "check_out_completed",
            entryTitle: "Check-out completed for Sarah Johnson",
            entryDescription: "Guest check-out process completed. Final meter reading and refund calculation processed.",
            entryIcon: "luggage",
            checkInId: null,
            checkOutId: 1,
            taskId: null,
            actionBy: "demo-staff",
            actionByName: "Demo Staff",
            visibleToOwner: true,
            visibleToStaff: true,
            visibleToGuests: false,
            additionalData: { finalMeterReading: "1267.8", refundAmount: "4843.90" },
            createdAt: now
          },
          {
            id: 3,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            entryType: "refund_processed",
            entryTitle: "Refund processed for Sarah Johnson",
            entryDescription: "Deposit refund of 4843.90 THB processed via cash",
            entryIcon: "dollar-sign",
            checkInId: null,
            checkOutId: 1,
            taskId: null,
            actionBy: "demo-admin",
            actionByName: "Demo Admin",
            visibleToOwner: true,
            visibleToStaff: true,
            visibleToGuests: false,
            additionalData: { refundMethod: "cash", refundAmount: "4843.90" },
            createdAt: now
          }
        ];
        if (filters?.entryType) {
          return mockHistory.filter((entry) => entry.entryType === filters.entryType);
        }
        return mockHistory;
      }
      async createCheckInOutHistory(historyData) {
        return {
          id: Date.now(),
          ...historyData,
          createdAt: /* @__PURE__ */ new Date()
        };
      }
      // Utility Methods for Check-In/Out
      async calculateElectricityUsage(checkInReading, checkOutReading, ratePerKwh) {
        const unitsUsed = Math.max(0, checkOutReading - checkInReading);
        const totalCost = unitsUsed * ratePerKwh;
        return {
          unitsUsed: Math.round(unitsUsed * 100) / 100,
          // Round to 2 decimal places
          totalCost: Math.round(totalCost * 100) / 100
        };
      }
      async calculateRefund(depositAmount, electricityCost, discounts, damageCosts) {
        const refundAmount = depositAmount - electricityCost + discounts - damageCosts;
        return Math.max(0, Math.round(refundAmount * 100) / 100);
      }
      // ===== AUTO-SCHEDULING & RECURRING TASKS IMPLEMENTATION =====
      // Task Scheduling Rules
      async getTaskSchedulingRules(organizationId2, propertyId) {
        let query = db.select().from(taskSchedulingRules).where(eq2(taskSchedulingRules.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(taskSchedulingRules.propertyId, propertyId));
        }
        const result = await query;
        if (result.length === 0) {
          const mockRules = [
            {
              id: 1,
              organizationId: organizationId2,
              propertyId: propertyId || 1,
              ruleName: "Weekly Pool Cleaning",
              taskTitle: "Pool Maintenance & Chemical Balance",
              taskDescription: "Clean pool, check chemical levels, skim surface, vacuum if needed",
              department: "Pool",
              assignedTo: "demo-pool-staff",
              triggerType: "recurring",
              frequency: "weekly",
              recurringSettings: {
                dayOfWeek: 1,
                // Monday
                time: "09:00"
              },
              priority: "medium",
              estimatedDuration: 120,
              requirements: ["Pool chemicals", "Testing kit", "Cleaning equipment"],
              isActive: true,
              createdBy: "demo-admin",
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            },
            {
              id: 2,
              organizationId: organizationId2,
              propertyId: propertyId || 1,
              ruleName: "Daily Garden Watering",
              taskTitle: "Water Garden Plants",
              taskDescription: "Water all garden areas, check plant health, remove any dead leaves",
              department: "Garden",
              assignedTo: "demo-garden-staff",
              triggerType: "recurring",
              frequency: "daily",
              recurringSettings: {
                time: "07:00"
              },
              priority: "medium",
              estimatedDuration: 45,
              requirements: ["Garden hose", "Watering can", "Pruning shears"],
              isActive: true,
              createdBy: "demo-admin",
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            },
            {
              id: 3,
              organizationId: organizationId2,
              propertyId: propertyId || 1,
              ruleName: "Monthly Deep Clean",
              taskTitle: "Deep Cleaning - Full Property",
              taskDescription: "Comprehensive deep cleaning including windows, ceiling fans, behind furniture",
              department: "Cleaning",
              assignedTo: "demo-cleaning-supervisor",
              triggerType: "recurring",
              frequency: "monthly",
              recurringSettings: {
                dayOfMonth: 15,
                time: "10:00"
              },
              priority: "high",
              estimatedDuration: 480,
              requirements: ["Deep cleaning supplies", "Ladder", "Window cleaning kit", "Steam cleaner"],
              isActive: true,
              createdBy: "demo-admin",
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }
          ];
          return mockRules;
        }
        return result;
      }
      async getTaskSchedulingRule(organizationId2, ruleId) {
        const rules = await this.getTaskSchedulingRules(organizationId2);
        return rules.find((rule) => rule.id === ruleId);
      }
      async createTaskSchedulingRule(rule) {
        const newRule = {
          id: Date.now(),
          // Mock ID generation
          ...rule,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newRule;
      }
      async updateTaskSchedulingRule(organizationId2, ruleId, updates) {
        const existingRule = await this.getTaskSchedulingRule(organizationId2, ruleId);
        if (!existingRule) {
          throw new Error(`Task scheduling rule with ID ${ruleId} not found`);
        }
        return {
          ...existingRule,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async deleteTaskSchedulingRule(organizationId2, ruleId) {
        console.log(`Deleted task scheduling rule ${ruleId} for organization ${organizationId2}`);
      }
      async toggleTaskSchedulingRule(organizationId2, ruleId, isActive) {
        return this.updateTaskSchedulingRule(organizationId2, ruleId, { isActive });
      }
      // Recurring Tasks
      async getRecurringTasks(organizationId2, filters) {
        const mockTasks = [
          {
            id: 1,
            organizationId: organizationId2,
            ruleId: 1,
            propertyId: filters?.propertyId || 1,
            taskTitle: "Pool Maintenance & Chemical Balance",
            taskDescription: "Clean pool, check chemical levels, skim surface, vacuum if needed",
            department: "Pool",
            assignedTo: "demo-pool-staff",
            scheduledDate: "2025-01-06",
            scheduledTime: "09:00",
            priority: "medium",
            estimatedDuration: 120,
            requirements: ["Pool chemicals", "Testing kit", "Cleaning equipment"],
            status: "pending",
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          },
          {
            id: 2,
            organizationId: organizationId2,
            ruleId: 2,
            propertyId: filters?.propertyId || 1,
            taskTitle: "Water Garden Plants",
            taskDescription: "Water all garden areas, check plant health, remove any dead leaves",
            department: "Garden",
            assignedTo: "demo-garden-staff",
            scheduledDate: "2025-01-04",
            scheduledTime: "07:00",
            priority: "medium",
            estimatedDuration: 45,
            requirements: ["Garden hose", "Watering can", "Pruning shears"],
            status: "completed",
            completedAt: /* @__PURE__ */ new Date(),
            completionNotes: "All plants watered, removed some dead leaves from rose bushes",
            evidencePhotos: ["garden_watering_1.jpg", "garden_health_check.jpg"],
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          },
          {
            id: 3,
            organizationId: organizationId2,
            ruleId: 2,
            propertyId: filters?.propertyId || 1,
            taskTitle: "Water Garden Plants",
            taskDescription: "Water all garden areas, check plant health, remove any dead leaves",
            department: "Garden",
            assignedTo: "demo-garden-staff",
            scheduledDate: "2025-01-05",
            scheduledTime: "07:00",
            priority: "medium",
            estimatedDuration: 45,
            requirements: ["Garden hose", "Watering can", "Pruning shears"],
            status: "in_progress",
            startedAt: /* @__PURE__ */ new Date(),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        ];
        let filteredTasks = mockTasks;
        if (filters?.propertyId) {
          filteredTasks = filteredTasks.filter((task) => task.propertyId === filters.propertyId);
        }
        if (filters?.department) {
          filteredTasks = filteredTasks.filter((task) => task.department === filters.department);
        }
        if (filters?.assignedTo) {
          filteredTasks = filteredTasks.filter((task) => task.assignedTo === filters.assignedTo);
        }
        if (filters?.status) {
          filteredTasks = filteredTasks.filter((task) => task.status === filters.status);
        }
        return filteredTasks;
      }
      async getRecurringTask(organizationId2, taskId) {
        const tasks2 = await this.getRecurringTasks(organizationId2);
        return tasks2.find((task) => task.id === taskId);
      }
      async createRecurringTask(task) {
        const newTask = {
          id: Date.now(),
          ...task,
          status: "pending",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newTask;
      }
      async updateRecurringTask(organizationId2, taskId, updates) {
        const existingTask = await this.getRecurringTask(organizationId2, taskId);
        if (!existingTask) {
          throw new Error(`Recurring task with ID ${taskId} not found`);
        }
        return {
          ...existingTask,
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async completeRecurringTask(organizationId2, taskId, completionData) {
        return this.updateRecurringTask(organizationId2, taskId, {
          status: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          completionNotes: completionData.completionNotes,
          evidencePhotos: completionData.evidencePhotos,
          issuesFound: completionData.issuesFound
        });
      }
      async skipRecurringTask(organizationId2, taskId, skipReason) {
        return this.updateRecurringTask(organizationId2, taskId, {
          status: "skipped",
          skipReason,
          skippedAt: /* @__PURE__ */ new Date()
        });
      }
      // Task Generation
      async generateRecurringTasks(organizationId2, targetDate) {
        const rules = await this.getTaskSchedulingRules(organizationId2);
        const activeRules = rules.filter((rule) => rule.isActive);
        let tasksGenerated = 0;
        const generatedTaskIds = [];
        for (const rule of activeRules) {
          const shouldGenerate = this.shouldGenerateTaskForDate(rule, targetDate);
          if (shouldGenerate) {
            const newTask = await this.createRecurringTask({
              organizationId: organizationId2,
              ruleId: rule.id,
              propertyId: rule.propertyId,
              taskTitle: rule.taskTitle,
              taskDescription: rule.taskDescription,
              department: rule.department,
              assignedTo: rule.assignedTo,
              scheduledDate: targetDate,
              scheduledTime: rule.recurringSettings?.time || "09:00",
              priority: rule.priority,
              estimatedDuration: rule.estimatedDuration,
              requirements: rule.requirements
            });
            tasksGenerated++;
            generatedTaskIds.push(newTask.id);
          }
        }
        const log2 = {
          id: Date.now(),
          organizationId: organizationId2,
          targetDate,
          rulesProcessed: activeRules.length,
          tasksGenerated,
          generatedTaskIds,
          errors: [],
          generatedAt: /* @__PURE__ */ new Date()
        };
        return log2;
      }
      shouldGenerateTaskForDate(rule, targetDate) {
        const date3 = new Date(targetDate);
        const settings = rule.recurringSettings;
        switch (rule.frequency) {
          case "daily":
            return true;
          case "weekly":
            return settings?.dayOfWeek === date3.getDay();
          case "monthly":
            return settings?.dayOfMonth === date3.getDate();
          case "custom":
            return false;
          default:
            return false;
        }
      }
      async getTaskGenerationLogs(organizationId2, limit = 50) {
        const mockLogs = [
          {
            id: 1,
            organizationId: organizationId2,
            targetDate: "2025-01-04",
            rulesProcessed: 3,
            tasksGenerated: 1,
            generatedTaskIds: [2],
            errors: [],
            generatedAt: /* @__PURE__ */ new Date("2025-01-04T00:00:00Z")
          },
          {
            id: 2,
            organizationId: organizationId2,
            targetDate: "2025-01-05",
            rulesProcessed: 3,
            tasksGenerated: 1,
            generatedTaskIds: [3],
            errors: [],
            generatedAt: /* @__PURE__ */ new Date("2025-01-05T00:00:00Z")
          }
        ];
        return mockLogs.slice(0, limit);
      }
      // Analytics
      async getRecurringTaskAnalytics(organizationId2, propertyId, department, year, month) {
        const mockAnalytics = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            department: department || "Pool",
            year: year || 2025,
            month: month || 1,
            totalTasksScheduled: 4,
            totalTasksCompleted: 3,
            totalTasksSkipped: 0,
            totalTasksOverdue: 1,
            averageCompletionTime: 115,
            completionRate: 75,
            onTimeCompletionRate: 100,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            department: department || "Garden",
            year: year || 2025,
            month: month || 1,
            totalTasksScheduled: 31,
            totalTasksCompleted: 29,
            totalTasksSkipped: 1,
            totalTasksOverdue: 1,
            averageCompletionTime: 42,
            completionRate: 93.5,
            onTimeCompletionRate: 96.7,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          },
          {
            id: 3,
            organizationId: organizationId2,
            propertyId: propertyId || 1,
            department: department || "Cleaning",
            year: year || 2025,
            month: month || 1,
            totalTasksScheduled: 1,
            totalTasksCompleted: 0,
            totalTasksSkipped: 0,
            totalTasksOverdue: 0,
            averageCompletionTime: 0,
            completionRate: 0,
            onTimeCompletionRate: 0,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        ];
        let filteredAnalytics = mockAnalytics;
        if (propertyId) {
          filteredAnalytics = filteredAnalytics.filter((a) => a.propertyId === propertyId);
        }
        if (department) {
          filteredAnalytics = filteredAnalytics.filter((a) => a.department === department);
        }
        if (year) {
          filteredAnalytics = filteredAnalytics.filter((a) => a.year === year);
        }
        if (month) {
          filteredAnalytics = filteredAnalytics.filter((a) => a.month === month);
        }
        return filteredAnalytics;
      }
      async updateRecurringTaskAnalytics(organizationId2) {
        console.log(`Updated recurring task analytics for organization ${organizationId2}`);
      }
      // Alerts
      async getTaskSchedulingAlerts(organizationId2, filters) {
        const mockAlerts = [
          {
            id: 1,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            alertType: "overdue_task",
            severity: "medium",
            title: "Pool Cleaning Overdue",
            message: "Pool maintenance task scheduled for yesterday has not been completed.",
            relatedTaskId: 1,
            status: "active",
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          },
          {
            id: 2,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            alertType: "rule_failure",
            severity: "high",
            title: "Task Generation Failed",
            message: "Unable to generate tasks for 'Monthly Deep Clean' rule - assigned staff not available.",
            relatedRuleId: 3,
            status: "active",
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          },
          {
            id: 3,
            organizationId: organizationId2,
            propertyId: filters?.propertyId || 1,
            alertType: "completion_rate_low",
            severity: "low",
            title: "Low Completion Rate - Cleaning Department",
            message: "Cleaning department completion rate has dropped below 85% this month.",
            department: "Cleaning",
            status: "acknowledged",
            acknowledgedBy: "demo-admin",
            acknowledgedAt: /* @__PURE__ */ new Date(),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        ];
        let filteredAlerts = mockAlerts;
        if (filters?.severity) {
          filteredAlerts = filteredAlerts.filter((alert) => alert.severity === filters.severity);
        }
        if (filters?.status) {
          filteredAlerts = filteredAlerts.filter((alert) => alert.status === filters.status);
        }
        if (filters?.propertyId) {
          filteredAlerts = filteredAlerts.filter((alert) => alert.propertyId === filters.propertyId);
        }
        return filteredAlerts;
      }
      async createTaskSchedulingAlert(alert) {
        const newAlert = {
          id: Date.now(),
          ...alert,
          status: "active",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newAlert;
      }
      async acknowledgeTaskSchedulingAlert(organizationId2, alertId, acknowledgedBy) {
        const alerts = await this.getTaskSchedulingAlerts(organizationId2);
        const alert = alerts.find((a) => a.id === alertId);
        if (!alert) {
          throw new Error(`Alert with ID ${alertId} not found`);
        }
        return {
          ...alert,
          status: "acknowledged",
          acknowledgedBy,
          acknowledgedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // ===== SMART INVENTORY & SUPPLY CHAIN IMPLEMENTATIONS =====
      // Smart Inventory Items
      async getSmartInventoryItems(organizationId2) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            name: "Premium Bath Towels",
            category: "linens",
            sku: "TOWEL-PREM-001",
            brand: "Luxury Linens Co",
            description: "100% Egyptian cotton, 600 GSM",
            unitCost: 850,
            currency: "THB",
            currentStock: 24,
            minimumStock: 10,
            maximumStock: 50,
            unit: "piece",
            supplierIds: [1, 2],
            warehouseId: 1,
            category: "linens",
            isActive: true,
            lastRestocked: /* @__PURE__ */ new Date("2024-12-20"),
            expiryDate: null,
            batchNumber: null,
            tags: ["premium", "guest-room", "bathroom"],
            properties: [1, 2, 3],
            averageUsageRate: 0.5,
            seasonalDemand: { high: [11, 12, 1, 2], low: [5, 6, 7, 8] },
            createdAt: /* @__PURE__ */ new Date("2024-11-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-20")
          },
          {
            id: 2,
            organizationId: organizationId2,
            name: "Welcome Pack Snacks - Mixed Nuts",
            category: "food_beverage",
            sku: "SNACK-NUTS-001",
            brand: "Thai Premium",
            description: "Cashew and macadamia mix, 50g pack",
            unitCost: 45,
            currency: "THB",
            currentStock: 156,
            minimumStock: 50,
            maximumStock: 200,
            unit: "pack",
            supplierIds: [3],
            warehouseId: 1,
            category: "food_beverage",
            isActive: true,
            lastRestocked: /* @__PURE__ */ new Date("2024-12-28"),
            expiryDate: /* @__PURE__ */ new Date("2025-06-30"),
            batchNumber: "NUTS-2024-12-B",
            tags: ["welcome-pack", "snacks", "premium"],
            properties: [1, 2, 3, 4],
            averageUsageRate: 2.1,
            seasonalDemand: { high: [11, 12, 1, 2], low: [6, 7, 8, 9] },
            createdAt: /* @__PURE__ */ new Date("2024-10-15"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-28")
          },
          {
            id: 3,
            organizationId: organizationId2,
            name: "Cleaning Supplies - Multi-Surface Cleaner",
            category: "cleaning",
            sku: "CLEAN-MULTI-001",
            brand: "EcoClean Pro",
            description: "Biodegradable multi-surface cleaner, 1L bottle",
            unitCost: 125,
            currency: "THB",
            currentStock: 8,
            minimumStock: 12,
            maximumStock: 30,
            unit: "bottle",
            supplierIds: [4],
            warehouseId: 2,
            category: "cleaning",
            isActive: true,
            lastRestocked: /* @__PURE__ */ new Date("2024-12-15"),
            expiryDate: /* @__PURE__ */ new Date("2026-12-15"),
            batchNumber: "CLEAN-2024-12-A",
            tags: ["cleaning", "eco-friendly", "maintenance"],
            properties: [1, 2, 3, 4, 5],
            averageUsageRate: 1.2,
            seasonalDemand: { high: [3, 4, 5, 10, 11], low: [1, 6, 7] },
            createdAt: /* @__PURE__ */ new Date("2024-09-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-15")
          }
        ];
      }
      async getSmartInventoryItemsByProperty(organizationId2, propertyId) {
        const allItems = await this.getSmartInventoryItems(organizationId2);
        return allItems.filter((item) => item.properties.includes(propertyId));
      }
      async createSmartInventoryItem(item) {
        const newItem = {
          id: Date.now(),
          ...item,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newItem;
      }
      async updateSmartInventoryItem(id, item) {
        const items = await this.getSmartInventoryItems(item.organizationId);
        const existingItem = items.find((i) => i.id === id);
        if (!existingItem) {
          throw new Error(`Inventory item with ID ${id} not found`);
        }
        return {
          ...existingItem,
          ...item,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async deleteSmartInventoryItem(id) {
        return true;
      }
      // Smart Suppliers
      async getSmartSuppliers(organizationId2) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            name: "Luxury Linens Co",
            contactPerson: "Somchai Jaidee",
            email: "orders@luxurylinens.co.th",
            phone: "+66-2-555-0101",
            address: "123 Textile District, Bangkok 10110",
            supplierType: "premium",
            categories: ["linens", "bedding", "bathroom"],
            paymentTerms: "Net 30",
            deliveryTime: "3-5 business days",
            minimumOrder: 5e3,
            currency: "THB",
            rating: 4.8,
            totalOrders: 24,
            isActive: true,
            notes: "Premium supplier with excellent quality control",
            createdAt: /* @__PURE__ */ new Date("2024-08-15"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-20")
          },
          {
            id: 2,
            organizationId: organizationId2,
            name: "Island Essentials Supply",
            contactPerson: "Ploy Siriporn",
            email: "supply@islandessentials.com",
            phone: "+66-77-123-456",
            address: "45 Beach Road, Koh Samui 84320",
            supplierType: "local",
            categories: ["linens", "toiletries", "cleaning"],
            paymentTerms: "Net 15",
            deliveryTime: "1-2 business days",
            minimumOrder: 2e3,
            currency: "THB",
            rating: 4.5,
            totalOrders: 18,
            isActive: true,
            notes: "Local supplier, fast delivery to Samui properties",
            createdAt: /* @__PURE__ */ new Date("2024-09-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-18")
          },
          {
            id: 3,
            organizationId: organizationId2,
            name: "Thai Premium Foods Ltd",
            contactPerson: "Niran Apirak",
            email: "b2b@thaipremiumfoods.com",
            phone: "+66-2-666-7777",
            address: "88 Food Industrial Park, Samut Prakan 10280",
            supplierType: "manufacturer",
            categories: ["food_beverage", "welcome_packs"],
            paymentTerms: "Net 30",
            deliveryTime: "5-7 business days",
            minimumOrder: 3e3,
            currency: "THB",
            rating: 4.6,
            totalOrders: 12,
            isActive: true,
            notes: "Excellent food safety standards, custom packaging available",
            createdAt: /* @__PURE__ */ new Date("2024-10-01"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-25")
          }
        ];
      }
      async createSmartSupplier(supplier) {
        const newSupplier = {
          id: Date.now(),
          ...supplier,
          totalOrders: 0,
          rating: 0,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newSupplier;
      }
      async updateSmartSupplier(id, supplier) {
        const suppliers = await this.getSmartSuppliers(supplier.organizationId);
        const existingSupplier = suppliers.find((s) => s.id === id);
        if (!existingSupplier) {
          throw new Error(`Supplier with ID ${id} not found`);
        }
        return {
          ...existingSupplier,
          ...supplier,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Smart Purchase Orders
      async getSmartPurchaseOrders(organizationId2) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            orderNumber: "PO-2025-001",
            supplierId: 1,
            supplierName: "Luxury Linens Co",
            orderDate: /* @__PURE__ */ new Date("2025-01-02"),
            expectedDelivery: /* @__PURE__ */ new Date("2025-01-07"),
            status: "pending",
            priority: "normal",
            totalAmount: 12750,
            currency: "THB",
            paymentTerms: "Net 30",
            paymentStatus: "pending",
            deliveryAddress: "Central Samui Warehouse, 123 Warehouse St, Koh Samui",
            orderItems: [
              {
                itemId: 1,
                itemName: "Premium Bath Towels",
                quantity: 15,
                unitCost: 850,
                totalCost: 12750
              }
            ],
            createdBy: "admin-001",
            approvedBy: null,
            receivedBy: null,
            notes: "Urgent restock for Property",
            attachments: [],
            createdAt: /* @__PURE__ */ new Date("2025-01-02"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-02")
          },
          {
            id: 2,
            organizationId: organizationId2,
            orderNumber: "PO-2025-002",
            supplierId: 3,
            supplierName: "Thai Premium Foods Ltd",
            orderDate: /* @__PURE__ */ new Date("2024-12-28"),
            expectedDelivery: /* @__PURE__ */ new Date("2025-01-06"),
            status: "approved",
            priority: "high",
            totalAmount: 9e3,
            currency: "THB",
            paymentTerms: "Net 30",
            paymentStatus: "pending",
            deliveryAddress: "Central Samui Warehouse, 123 Warehouse St, Koh Samui",
            orderItems: [
              {
                itemId: 2,
                itemName: "Welcome Pack Snacks - Mixed Nuts",
                quantity: 200,
                unitCost: 45,
                totalCost: 9e3
              }
            ],
            createdBy: "pm-001",
            approvedBy: "admin-001",
            receivedBy: null,
            notes: "New Year welcome pack preparation",
            attachments: ["quote-thai-premium-foods.pdf"],
            createdAt: /* @__PURE__ */ new Date("2024-12-28"),
            updatedAt: /* @__PURE__ */ new Date("2024-12-30")
          }
        ];
      }
      async createSmartPurchaseOrder(order) {
        const orderNumber = `PO-${(/* @__PURE__ */ new Date()).getFullYear()}-${String(Date.now()).slice(-3)}`;
        const newOrder = {
          id: Date.now(),
          orderNumber,
          ...order,
          status: "pending",
          paymentStatus: "pending",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        return newOrder;
      }
      async updateSmartPurchaseOrderStatus(id, status) {
        return {
          id,
          status,
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      // Smart Stock Movements
      async getSmartStockMovements(organizationId2, filters) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            itemId: 1,
            itemName: "Premium Bath Towels",
            movementType: "stock_in",
            quantity: 15,
            unitCost: 850,
            totalValue: 12750,
            currency: "THB",
            fromLocation: "Supplier - Luxury Linens Co",
            toLocation: "Central Samui Warehouse",
            propertyId: null,
            bookingId: null,
            purchaseOrderId: 1,
            reason: "Purchase order delivery",
            performedBy: "warehouse-001",
            notes: "Quality check passed, all items in good condition",
            batchNumber: "TOWEL-2025-001",
            expiryDate: null,
            movementDate: /* @__PURE__ */ new Date("2025-01-04"),
            createdAt: /* @__PURE__ */ new Date("2025-01-04")
          },
          {
            id: 2,
            organizationId: organizationId2,
            itemId: 2,
            itemName: "Welcome Pack Snacks - Mixed Nuts",
            movementType: "stock_out",
            quantity: -4,
            unitCost: 45,
            totalValue: -180,
            currency: "THB",
            fromLocation: "Central Samui Warehouse",
            toLocation: "Property",
            propertyId: 1,
            bookingId: 101,
            purchaseOrderId: null,
            reason: "Guest welcome pack setup",
            performedBy: "staff-001",
            notes: "VIP guest arrival preparation",
            batchNumber: "NUTS-2024-12-B",
            expiryDate: /* @__PURE__ */ new Date("2025-06-30"),
            movementDate: /* @__PURE__ */ new Date("2025-01-03"),
            createdAt: /* @__PURE__ */ new Date("2025-01-03")
          },
          {
            id: 3,
            organizationId: organizationId2,
            itemId: 3,
            itemName: "Cleaning Supplies - Multi-Surface Cleaner",
            movementType: "stock_out",
            quantity: -2,
            unitCost: 125,
            totalValue: -250,
            currency: "THB",
            fromLocation: "Property Storage - Villa Aruna",
            toLocation: "Used - Deep Cleaning",
            propertyId: 2,
            bookingId: null,
            purchaseOrderId: null,
            reason: "Maintenance cleaning",
            performedBy: "staff-002",
            notes: "Post-checkout deep cleaning session",
            batchNumber: "CLEAN-2024-12-A",
            expiryDate: /* @__PURE__ */ new Date("2026-12-15"),
            movementDate: /* @__PURE__ */ new Date("2025-01-02"),
            createdAt: /* @__PURE__ */ new Date("2025-01-02")
          }
        ];
      }
      async createSmartStockMovement(movement) {
        const newMovement = {
          id: Date.now(),
          ...movement,
          movementDate: /* @__PURE__ */ new Date(),
          createdAt: /* @__PURE__ */ new Date()
        };
        return newMovement;
      }
      // Smart Analytics
      async getSmartInventoryAnalytics(organizationId2) {
        return {
          totalItems: 3,
          totalValue: 89750,
          currency: "THB",
          lowStockItems: 1,
          expiringSoon: 1,
          totalSuppliers: 3,
          pendingOrders: 2,
          monthlyUsage: {
            currentMonth: 8750,
            previousMonth: 7200,
            trend: "increasing"
          },
          topCategories: [
            { category: "linens", value: 45900, percentage: 51.2 },
            { category: "food_beverage", value: 32400, percentage: 36.1 },
            { category: "cleaning", value: 11450, percentage: 12.7 }
          ],
          stockTurnoverRate: 0.45,
          averageDeliveryTime: 4.2,
          supplierPerformance: {
            onTimeDelivery: 94.5,
            qualityRating: 4.6,
            averageResponseTime: 2.3
          },
          predictedRestockDate: {
            criticalItems: 2,
            avgDaysUntilRestock: 12
          }
        };
      }
      async getSmartLowStockAlerts(organizationId2) {
        return [
          {
            id: 1,
            organizationId: organizationId2,
            itemId: 3,
            itemName: "Cleaning Supplies - Multi-Surface Cleaner",
            currentStock: 8,
            minimumStock: 12,
            severity: "critical",
            daysUntilStockout: 7,
            estimatedReorderQuantity: 15,
            preferredSupplierId: 4,
            averageUsageRate: 1.2,
            lastRestocked: /* @__PURE__ */ new Date("2024-12-15"),
            alertCreated: /* @__PURE__ */ new Date("2025-01-02"),
            status: "active"
          }
        ];
      }
      async getSmartDemandForecast(organizationId2) {
        return [
          {
            itemId: 1,
            itemName: "Premium Bath Towels",
            currentStock: 24,
            forecastPeriod: "30_days",
            predictedUsage: 12,
            recommendedReorder: 8,
            confidence: 85,
            seasonalAdjustment: 1.2,
            bookingInfluence: 0.8,
            historicalAccuracy: 92
          },
          {
            itemId: 2,
            itemName: "Welcome Pack Snacks - Mixed Nuts",
            currentStock: 156,
            forecastPeriod: "30_days",
            predictedUsage: 68,
            recommendedReorder: 0,
            confidence: 78,
            seasonalAdjustment: 1.5,
            bookingInfluence: 1.1,
            historicalAccuracy: 87
          },
          {
            itemId: 3,
            itemName: "Cleaning Supplies - Multi-Surface Cleaner",
            currentStock: 8,
            forecastPeriod: "30_days",
            predictedUsage: 15,
            recommendedReorder: 18,
            confidence: 91,
            seasonalAdjustment: 1,
            bookingInfluence: 0.9,
            historicalAccuracy: 94
          }
        ];
      }
      // ==================== SERVICE MARKETPLACE & VENDOR BOOKING SYSTEM ====================
      // Service Vendors Operations
      async getServiceVendors(organizationId2) {
        return db.select().from(serviceVendors).where(eq2(serviceVendors.organizationId, organizationId2)).orderBy(serviceVendors.businessName);
      }
      async getServiceVendor(id) {
        const [vendor] = await db.select().from(serviceVendors).where(eq2(serviceVendors.id, id));
        return vendor;
      }
      async createServiceVendor(vendor) {
        const [newVendor] = await db.insert(serviceVendors).values(vendor).returning();
        return newVendor;
      }
      async updateServiceVendor(id, vendor) {
        const [updated] = await db.update(serviceVendors).set({ ...vendor, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(serviceVendors.id, id)).returning();
        return updated;
      }
      async deleteServiceVendor(id) {
        const result = await db.delete(serviceVendors).where(eq2(serviceVendors.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Service Categories Operations
      async getServiceCategories(organizationId2) {
        return db.select().from(serviceCategories).where(eq2(serviceCategories.organizationId, organizationId2)).orderBy(serviceCategories.categoryName);
      }
      async getServiceCategory(id) {
        const [category] = await db.select().from(serviceCategories).where(eq2(serviceCategories.id, id));
        return category;
      }
      async createServiceCategory(category) {
        const [newCategory] = await db.insert(serviceCategories).values(category).returning();
        return newCategory;
      }
      async updateServiceCategory(id, category) {
        const [updated] = await db.update(serviceCategories).set({ ...category, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(serviceCategories.id, id)).returning();
        return updated;
      }
      async deleteServiceCategory(id) {
        const result = await db.delete(serviceCategories).where(eq2(serviceCategories.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Marketplace Services Operations
      async getMarketplaceServices(organizationId2, categoryId, vendorId) {
        let query = db.select().from(marketplaceServices).where(eq2(marketplaceServices.organizationId, organizationId2));
        if (categoryId) {
          query = query.where(eq2(marketplaceServices.categoryId, categoryId));
        }
        if (vendorId) {
          query = query.where(eq2(marketplaceServices.vendorId, vendorId));
        }
        return query.orderBy(marketplaceServices.serviceName);
      }
      async getMarketplaceService(id) {
        const [service] = await db.select().from(marketplaceServices).where(eq2(marketplaceServices.id, id));
        return service;
      }
      async createMarketplaceService(service) {
        const [newService] = await db.insert(marketplaceServices).values(service).returning();
        return newService;
      }
      async updateMarketplaceService(id, service) {
        const [updated] = await db.update(marketplaceServices).set({ ...service, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(marketplaceServices.id, id)).returning();
        return updated;
      }
      async deleteMarketplaceService(id) {
        const result = await db.delete(marketplaceServices).where(eq2(marketplaceServices.id, id));
        return (result.rowCount || 0) > 0;
      }
      // Service Bookings Operations
      async getServiceBookings(organizationId2, propertyId, status) {
        let query = db.select().from(serviceBookings).where(eq2(serviceBookings.organizationId, organizationId2));
        if (propertyId) {
          query = query.where(eq2(serviceBookings.propertyId, propertyId));
        }
        if (status) {
          query = query.where(eq2(serviceBookings.status, status));
        }
        return query.orderBy(desc2(serviceBookings.createdAt));
      }
      async getServiceBooking(id) {
        const [booking] = await db.select().from(serviceBookings).where(eq2(serviceBookings.id, id));
        return booking;
      }
      async createServiceBooking(booking) {
        const [newBooking] = await db.insert(serviceBookings).values(booking).returning();
        return newBooking;
      }
      async updateServiceBooking(id, booking) {
        const [updated] = await db.update(serviceBookings).set({ ...booking, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(serviceBookings.id, id)).returning();
        return updated;
      }
      async approveServiceBooking(id, approvedBy) {
        const [updated] = await db.update(serviceBookings).set({
          status: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(serviceBookings.id, id)).returning();
        return updated;
      }
      async confirmServiceBooking(id, confirmedBy) {
        const [updated] = await db.update(serviceBookings).set({
          status: "confirmed",
          confirmedBy,
          confirmedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(serviceBookings.id, id)).returning();
        return updated;
      }
      async completeServiceBooking(id, completedBy, notes, photos) {
        const [updated] = await db.update(serviceBookings).set({
          status: "completed",
          completedBy,
          completedAt: /* @__PURE__ */ new Date(),
          completionNotes: notes,
          completionPhotos: photos,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(serviceBookings.id, id)).returning();
        return updated;
      }
      async cancelServiceBooking(id, cancelledBy, reason) {
        const [updated] = await db.update(serviceBookings).set({
          status: "cancelled",
          cancelledBy,
          cancelledAt: /* @__PURE__ */ new Date(),
          cancellationReason: reason,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(serviceBookings.id, id)).returning();
        return updated;
      }
      // Service Reviews Operations
      async getServiceReviews(organizationId2, serviceId, vendorId) {
        let query = db.select().from(serviceReviews).where(eq2(serviceReviews.organizationId, organizationId2));
        if (serviceId) {
          query = query.where(eq2(serviceReviews.serviceId, serviceId));
        }
        if (vendorId) {
          query = query.where(eq2(serviceReviews.vendorId, vendorId));
        }
        return query.orderBy(desc2(serviceReviews.createdAt));
      }
      async getServiceReview(id) {
        const [review] = await db.select().from(serviceReviews).where(eq2(serviceReviews.id, id));
        return review;
      }
      async createServiceReview(review) {
        const [newReview] = await db.insert(serviceReviews).values(review).returning();
        return newReview;
      }
      async updateServiceReview(id, review) {
        const [updated] = await db.update(serviceReviews).set({ ...review, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(serviceReviews.id, id)).returning();
        return updated;
      }
      // Service Analytics Operations
      async getServiceAnalytics(organizationId2, periodType, periodStart, periodEnd) {
        return db.select().from(serviceAnalytics).where(
          and3(
            eq2(serviceAnalytics.organizationId, organizationId2),
            eq2(serviceAnalytics.periodType, periodType),
            gte2(serviceAnalytics.periodStart, new Date(periodStart)),
            lte2(serviceAnalytics.periodEnd, new Date(periodEnd))
          )
        ).orderBy(desc2(serviceAnalytics.periodStart));
      }
      async createServiceAnalytics(analytics) {
        const [newAnalytics] = await db.insert(serviceAnalytics).values(analytics).returning();
        return newAnalytics;
      }
      async getServiceDashboardStats(organizationId2) {
        const totalBookingsResult = await db.select({ count: count() }).from(serviceBookings).where(eq2(serviceBookings.organizationId, organizationId2));
        const completedBookingsResult = await db.select({ count: count() }).from(serviceBookings).where(
          and3(
            eq2(serviceBookings.organizationId, organizationId2),
            eq2(serviceBookings.status, "completed")
          )
        );
        const totalRevenueResult = await db.select({ total: sum(serviceBookings.totalAmount) }).from(serviceBookings).where(
          and3(
            eq2(serviceBookings.organizationId, organizationId2),
            eq2(serviceBookings.status, "completed")
          )
        );
        const topServicesResult = await db.select({
          name: marketplaceServices.serviceName,
          bookings: count(serviceBookings.id),
          revenue: sum(serviceBookings.totalAmount)
        }).from(serviceBookings).leftJoin(marketplaceServices, eq2(serviceBookings.serviceId, marketplaceServices.id)).where(eq2(serviceBookings.organizationId, organizationId2)).groupBy(marketplaceServices.serviceName).orderBy(desc2(count(serviceBookings.id))).limit(5);
        const topVendorsResult = await db.select({
          name: serviceVendors.businessName,
          rating: avg(serviceReviews.rating),
          bookings: count(serviceBookings.id)
        }).from(serviceVendors).leftJoin(serviceBookings, eq2(serviceVendors.id, serviceBookings.vendorId)).leftJoin(serviceReviews, eq2(serviceVendors.id, serviceReviews.vendorId)).where(eq2(serviceVendors.organizationId, organizationId2)).groupBy(serviceVendors.businessName).orderBy(desc2(avg(serviceReviews.rating)), desc2(count(serviceBookings.id))).limit(5);
        return {
          totalBookings: totalBookingsResult[0]?.count || 0,
          completedBookings: completedBookingsResult[0]?.count || 0,
          totalRevenue: parseFloat(totalRevenueResult[0]?.total || "0"),
          topServices: topServicesResult.map((service) => ({
            name: service.name || "Unknown",
            bookings: service.bookings || 0,
            revenue: parseFloat(service.revenue || "0")
          })),
          topVendors: topVendorsResult.map((vendor) => ({
            name: vendor.name || "Unknown",
            rating: parseFloat(vendor.rating || "0"),
            bookings: vendor.bookings || 0
          }))
        };
      }
      // ===== GUEST CHECKOUT SURVEY OPERATIONS =====
      // Survey operations
      async getGuestCheckoutSurveys(organizationId2, filters) {
        const johnSarahSurvey = {
          id: 1,
          organizationId: "default",
          guestId: "john-sarah-smith",
          propertyId: 1,
          propertyName: "Property",
          guestName: "John & Sarah Smith",
          guestEmail: "john.smith@email.com",
          surveyType: "checkout",
          submittedAt: /* @__PURE__ */ new Date("2025-01-10T14:30:00Z"),
          ratingCheckIn: 5,
          ratingCleanliness: 5,
          ratingProperty: 5,
          ratingLocation: 5,
          ratingTeam: 5,
          ratingCommunication: 5,
          ratingOverall: 5,
          averageRating: 5,
          commentImprovement: "The villa was absolutely perfect! The pool area could benefit from some evening lighting for nighttime swims. Maybe some solar lights around the pool perimeter?",
          commentRecommendation: "We would definitely recommend this villa to friends! The location is perfect - close to the beach but private. The welcome basket was a wonderful touch, and the staff was incredibly helpful throughout our stay.",
          sentimentScore: 0.95,
          sentimentLabel: "very_positive",
          sentimentConfidence: 0.92,
          publicReviewRequested: true,
          publicReviewApproved: true,
          reviewedBy: "admin",
          reviewedAt: /* @__PURE__ */ new Date("2025-01-10T15:00:00Z"),
          adminNotes: "Excellent feedback! Pool lighting suggestion noted for implementation. Perfect candidates for public review.",
          isPublic: true,
          flagged: false,
          createdAt: /* @__PURE__ */ new Date("2025-01-10T14:30:00Z"),
          updatedAt: /* @__PURE__ */ new Date("2025-01-10T15:00:00Z")
        };
        const surveys = [johnSarahSurvey];
        if (filters?.guestId && !johnSarahSurvey.guestId.includes(filters.guestId)) {
          return [];
        }
        if (filters?.propertyId && johnSarahSurvey.propertyId !== filters.propertyId) {
          return [];
        }
        if (filters?.surveyType && johnSarahSurvey.surveyType !== filters.surveyType) {
          return [];
        }
        return surveys;
      }
      async getGuestCheckoutSurvey(id) {
        const [survey] = await db.select().from(guestCheckoutSurveys).where(eq2(guestCheckoutSurveys.id, id));
        return survey;
      }
      async createGuestCheckoutSurvey(survey) {
        const ratings = [
          survey.ratingCheckIn,
          survey.ratingCleanliness,
          survey.ratingProperty,
          survey.ratingLocation,
          survey.ratingTeam,
          survey.ratingCommunication,
          survey.ratingOverall
        ].filter((rating) => rating !== null && rating !== void 0);
        const averageRating = ratings.length > 0 ? ratings.reduce((sum4, rating) => sum4 + rating, 0) / ratings.length : 0;
        let sentimentScore = 0;
        let sentimentCategory = "neutral";
        let flaggedForReview = false;
        if (survey.improvementSuggestions || survey.additionalComments) {
          const textContent = `${survey.improvementSuggestions || ""} ${survey.additionalComments || ""}`.toLowerCase();
          const positiveWords = ["great", "excellent", "amazing", "wonderful", "perfect", "love", "fantastic"];
          const negativeWords = ["bad", "terrible", "awful", "horrible", "worst", "hate", "disgusting", "dirty"];
          const positiveCount = positiveWords.reduce((count3, word) => count3 + (textContent.includes(word) ? 1 : 0), 0);
          const negativeCount = negativeWords.reduce((count3, word) => count3 + (textContent.includes(word) ? 1 : 0), 0);
          sentimentScore = (positiveCount - negativeCount) / Math.max(positiveCount + negativeCount, 1);
          if (sentimentScore > 0.3) {
            sentimentCategory = "positive";
          } else if (sentimentScore < -0.3) {
            sentimentCategory = "negative";
          }
        }
        if (averageRating < 4.5 || sentimentCategory === "negative") {
          flaggedForReview = true;
        }
        const surveyWithAnalysis = {
          ...survey,
          averageRating,
          sentimentScore,
          sentimentCategory,
          flaggedForReview
        };
        const [newSurvey] = await db.insert(guestCheckoutSurveys).values(surveyWithAnalysis).returning();
        if (flaggedForReview) {
          await this.createSurveyAlert({
            organizationId: survey.organizationId,
            surveyId: newSurvey.id,
            alertType: averageRating < 3 ? "low_rating" : "negative_feedback",
            severity: averageRating < 3 ? "high" : "medium",
            recipientRoles: ["admin", "portfolio-manager"],
            alertMessage: `Guest survey flagged for review - Average rating: ${averageRating.toFixed(1)}/5, Sentiment: ${sentimentCategory}`,
            actionRequired: true
          });
        }
        return newSurvey;
      }
      async updateGuestCheckoutSurvey(id, survey) {
        const [updated] = await db.update(guestCheckoutSurveys).set({ ...survey, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(guestCheckoutSurveys.id, id)).returning();
        return updated;
      }
      async reviewGuestSurvey(id, reviewedBy, adminNotes) {
        const [updated] = await db.update(guestCheckoutSurveys).set({
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          adminNotes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(guestCheckoutSurveys.id, id)).returning();
        return updated;
      }
      // Survey settings operations
      async getSurveySettings(organizationId2, propertyId) {
        const conditions = [eq2(surveySettings.organizationId, organizationId2)];
        if (propertyId) {
          conditions.push(eq2(surveySettings.propertyId, propertyId));
        }
        const [settings] = await db.select().from(surveySettings).where(and3(...conditions)).orderBy(desc2(surveySettings.createdAt)).limit(1);
        return settings;
      }
      async createSurveySettings(settings) {
        const [newSettings] = await db.insert(surveySettings).values(settings).returning();
        return newSettings;
      }
      async updateSurveySettings(id, settings) {
        const [updated] = await db.update(surveySettings).set({ ...settings, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(surveySettings.id, id)).returning();
        return updated;
      }
      // Survey alerts operations
      async getSurveyAlerts(organizationId2, filters) {
        const conditions = [eq2(surveyAlerts.organizationId, organizationId2)];
        if (filters?.severity) {
          conditions.push(eq2(surveyAlerts.severity, filters.severity));
        }
        if (filters?.alertType) {
          conditions.push(eq2(surveyAlerts.alertType, filters.alertType));
        }
        if (filters?.resolved !== void 0) {
          if (filters.resolved) {
            conditions.push(isNotNull(surveyAlerts.resolvedAt));
          } else {
            conditions.push(isNull2(surveyAlerts.resolvedAt));
          }
        }
        return await db.select().from(surveyAlerts).where(and3(...conditions)).orderBy(desc2(surveyAlerts.createdAt));
      }
      async createSurveyAlert(alert) {
        const [newAlert] = await db.insert(surveyAlerts).values(alert).returning();
        return newAlert;
      }
      async resolveSurveyAlert(id, resolvedBy, resolutionNotes) {
        const [updated] = await db.update(surveyAlerts).set({
          resolvedBy,
          resolvedAt: /* @__PURE__ */ new Date(),
          resolutionNotes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(surveyAlerts.id, id)).returning();
        return updated;
      }
      // Survey analytics operations with John & Sarah Smith demo data
      async getSurveyAnalytics(organizationId2, propertyId, period) {
        const demoAnalytics = {
          id: 1,
          organizationId: "default",
          propertyId: 1,
          period: "monthly",
          periodStart: /* @__PURE__ */ new Date("2025-01-01"),
          periodEnd: /* @__PURE__ */ new Date("2025-01-31"),
          totalSurveys: 1,
          completedSurveys: 1,
          completionRate: 1,
          averageOverallRating: 5,
          averageCheckInRating: 5,
          averageCleanlinessRating: 5,
          averagePropertyRating: 5,
          averageLocationRating: 5,
          averageTeamRating: 5,
          averageCommunicationRating: 5,
          responseDistribution: {
            "5": 1,
            "4": 0,
            "3": 0,
            "2": 0,
            "1": 0
          },
          sentimentBreakdown: {
            "very_positive": 1,
            "positive": 0,
            "neutral": 0,
            "negative": 0,
            "very_negative": 0
          },
          publicReviewsGenerated: 1,
          improvementSuggestions: 1,
          createdAt: /* @__PURE__ */ new Date("2025-01-10T15:00:00Z"),
          updatedAt: /* @__PURE__ */ new Date("2025-01-10T15:00:00Z")
        };
        if (propertyId && demoAnalytics.propertyId !== propertyId) {
          return [];
        }
        if (period && demoAnalytics.period !== period) {
          return [];
        }
        return [demoAnalytics];
      }
      async generateSurveyAnalytics(organizationId2, propertyId) {
        const now = /* @__PURE__ */ new Date();
        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
        const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        const surveys = await this.getGuestCheckoutSurveys(organizationId2, {
          propertyId,
          dateRange: { start: startOfMonth, end: endOfMonth }
        });
        if (surveys.length === 0) return;
        const totalSurveys = surveys.length;
        const completedSurveys = surveys.filter((s) => s.averageRating !== null).length;
        const completionRate = totalSurveys > 0 ? completedSurveys / totalSurveys : 0;
        const ratings = surveys.filter((s) => s.averageRating !== null);
        const avgOverall = ratings.reduce((sum4, s) => sum4 + (s.ratingOverall || 0), 0) / ratings.length || 0;
        const avgCheckIn = ratings.reduce((sum4, s) => sum4 + (s.ratingCheckIn || 0), 0) / ratings.length || 0;
        const avgCleanliness = ratings.reduce((sum4, s) => sum4 + (s.ratingCleanliness || 0), 0) / ratings.length || 0;
        const avgProperty = ratings.reduce((sum4, s) => sum4 + (s.ratingProperty || 0), 0) / ratings.length || 0;
        const avgLocation = ratings.reduce((sum4, s) => sum4 + (s.ratingLocation || 0), 0) / ratings.length || 0;
        const avgTeam = ratings.reduce((sum4, s) => sum4 + (s.ratingTeam || 0), 0) / ratings.length || 0;
        const avgCommunication = ratings.reduce((sum4, s) => sum4 + (s.ratingCommunication || 0), 0) / ratings.length || 0;
        const positiveFeedback = surveys.filter((s) => s.sentimentCategory === "positive").length;
        const neutralFeedback = surveys.filter((s) => s.sentimentCategory === "neutral").length;
        const negativeFeedback = surveys.filter((s) => s.sentimentCategory === "negative").length;
        const analyticsData = {
          organizationId: organizationId2,
          propertyId: propertyId || null,
          period: "monthly",
          periodStart: startOfMonth.toISOString().split("T")[0],
          periodEnd: endOfMonth.toISOString().split("T")[0],
          totalSurveys,
          completedSurveys,
          completionRate,
          averageOverallRating: avgOverall,
          averageCheckInRating: avgCheckIn,
          averageCleanlinessRating: avgCleanliness,
          averagePropertyRating: avgProperty,
          averageLocationRating: avgLocation,
          averageTeamRating: avgTeam,
          averageCommunicationRating: avgCommunication,
          positiveFeedbackCount: positiveFeedback,
          neutralFeedbackCount: neutralFeedback,
          negativeFeedbackCount: negativeFeedback,
          publicReviewsGenerated: surveys.filter((s) => s.averageRating && s.averageRating >= 4.5 && s.sentimentCategory === "positive").length,
          internalFlagsCreated: surveys.filter((s) => s.flaggedForReview).length,
          incentivesOffered: surveys.filter((s) => s.incentiveOffered).length,
          incentivesRedeemed: surveys.filter((s) => s.incentiveRedeemed).length
        };
        await db.insert(surveyAnalytics).values(analyticsData);
      }
      // Demo survey data for testing
      async getGuestSurveyDemoData(organizationId2) {
        return [
          {
            id: 1,
            guestId: "guest_demo_001",
            guestName: "Sarah Johnson",
            propertyId: 1,
            propertyName: "Property",
            bookingId: 101,
            surveyType: "checkout",
            ratingCheckIn: 5,
            ratingCleanliness: 4,
            ratingProperty: 5,
            ratingLocation: 5,
            ratingTeam: 5,
            ratingCommunication: 4,
            ratingOverall: 5,
            averageRating: 4.7,
            improvementSuggestions: "The WiFi could be a bit faster, but overall everything was perfect!",
            wouldRecommend: "Absolutely! This place exceeded our expectations. The pool area is stunning and the location is perfect for exploring Koh Samui.",
            additionalComments: "Thank you for an amazing stay. We'll definitely be back!",
            sentimentScore: 0.8,
            sentimentCategory: "positive",
            flaggedForReview: false,
            submittedAt: "2025-01-02T14:30:00Z",
            incentiveOffered: "10% discount on next stay",
            incentiveRedeemed: false
          },
          {
            id: 2,
            guestId: "guest_demo_002",
            guestName: "Michael Chen",
            propertyId: 1,
            propertyName: "Property",
            bookingId: 102,
            surveyType: "checkout",
            ratingCheckIn: 3,
            ratingCleanliness: 2,
            ratingProperty: 3,
            ratingLocation: 4,
            ratingTeam: 3,
            ratingCommunication: 2,
            ratingOverall: 3,
            averageRating: 2.9,
            improvementSuggestions: "The bathroom needs better cleaning. We found hair in the shower and the towels smelled musty.",
            wouldRecommend: "The location is good but the cleanliness standards need improvement. Also, the check-in process was confusing.",
            additionalComments: "We were disappointed with the condition of the villa upon arrival.",
            sentimentScore: -0.4,
            sentimentCategory: "negative",
            flaggedForReview: true,
            submittedAt: "2025-01-03T11:00:00Z",
            incentiveOffered: null,
            incentiveRedeemed: false
          }
        ];
        for (const survey of demoSurveys) {
          await this.createGuestDepartureSurvey(survey);
        }
        console.log("Demo guest departure surveys created successfully");
      }
      // ===== STAFF MANAGEMENT METHODS =====
      async getStaffMembers(organizationId2, filters) {
        let query = db.select().from(staffMembers).where(eq2(staffMembers.organizationId, organizationId2));
        if (filters?.department) {
          query = query.where(eq2(staffMembers.department, filters.department));
        }
        if (filters?.status) {
          query = query.where(eq2(staffMembers.status, filters.status));
        }
        return await query;
      }
      async getStaffMember(id) {
        const [member] = await db.select().from(staffMembers).where(eq2(staffMembers.id, id));
        return member;
      }
      async getStaffMemberByEmployeeId(employeeId, organizationId2) {
        const [member] = await db.select().from(staffMembers).where(and3(
          eq2(staffMembers.employeeId, employeeId),
          eq2(staffMembers.organizationId, organizationId2)
        ));
        return member;
      }
      async createStaffMember(member) {
        const [created] = await db.insert(staffMembers).values(member).returning();
        return created;
      }
      async updateStaffMember(id, member) {
        const [updated] = await db.update(staffMembers).set({ ...member, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(staffMembers.id, id)).returning();
        return updated;
      }
      async deleteStaffMember(id) {
        const result = await db.delete(staffMembers).where(eq2(staffMembers.id, id));
        return true;
      }
      async getStaffDocuments(staffMemberId) {
        return await db.select().from(staffDocuments).where(eq2(staffDocuments.staffMemberId, staffMemberId));
      }
      async createStaffDocument(document) {
        const [created] = await db.insert(staffDocuments).values(document).returning();
        return created;
      }
      async getPayrollRecords(organizationId2, filters) {
        let query = db.select().from(payrollRecords).where(eq2(payrollRecords.organizationId, organizationId2));
        if (filters?.staffMemberId) {
          query = query.where(eq2(payrollRecords.staffMemberId, filters.staffMemberId));
        }
        return await query;
      }
      async createPayrollRecord(record) {
        const [created] = await db.insert(payrollRecords).values(record).returning();
        return created;
      }
      async getStaffAnalytics(organizationId2) {
        const allStaff = await this.getStaffMembers(organizationId2);
        const activeStaff = allStaff.filter((s) => s.status === "active");
        const totalSalary = allStaff.reduce((sum4, s) => sum4 + parseFloat(s.baseSalary || "0"), 0);
        const avgSalary = allStaff.length > 0 ? totalSalary / allStaff.length : 0;
        return {
          totalStaff: allStaff.length,
          activeStaff: activeStaff.length,
          totalMonthlySalary: totalSalary,
          averageSalary: avgSalary,
          departmentBreakdown: allStaff.reduce((acc, staff) => {
            acc[staff.department] = (acc[staff.department] || 0) + 1;
            return acc;
          }, {})
        };
      }
      // ===== REPORTS & ANALYTICS OPERATIONS =====
      async getReports(organizationId2) {
        return await db.select().from(reports).where(eq2(reports.organizationId, organizationId2)).orderBy(desc2(reports.createdAt));
      }
      async getReportsByType(organizationId2, type) {
        return await db.select().from(reports).where(and3(eq2(reports.organizationId, organizationId2), eq2(reports.type, type))).orderBy(desc2(reports.createdAt));
      }
      async getReport(id) {
        const [report] = await db.select().from(reports).where(eq2(reports.id, id));
        return report;
      }
      async createReport(report) {
        const [created] = await db.insert(reports).values(report).returning();
        return created;
      }
      async deleteReport(id) {
        await db.delete(reports).where(eq2(reports.id, id));
        return true;
      }
      async generateReport(organizationId2, type, userId) {
        let reportData = {};
        let title = "";
        switch (type) {
          case "bookings":
            const bookings3 = await this.getBookings(organizationId2);
            const activeBookings = bookings3.filter((b) => b.status === "confirmed" || b.status === "active");
            title = "Bookings Summary Report";
            reportData = {
              summary: {
                total: bookings3.length,
                active: activeBookings.length,
                totalRevenue: bookings3.reduce((sum4, b) => sum4 + parseFloat(b.totalAmount || "0"), 0)
              },
              details: bookings3.map((b) => ({
                id: b.id,
                guestName: b.guestName,
                checkIn: b.checkInDate,
                checkOut: b.checkOutDate,
                status: b.status,
                amount: b.totalAmount
              }))
            };
            break;
          case "finances":
            const finances3 = await this.getFinances();
            const revenue = finances3.filter((f) => f.type === "income");
            const expenses = finances3.filter((f) => f.type === "expense");
            title = "Financial Summary Report";
            reportData = {
              summary: {
                totalRevenue: revenue.reduce((sum4, f) => sum4 + parseFloat(f.amount || "0"), 0),
                totalExpenses: expenses.reduce((sum4, f) => sum4 + parseFloat(f.amount || "0"), 0),
                netProfit: revenue.reduce((sum4, f) => sum4 + parseFloat(f.amount || "0"), 0) - expenses.reduce((sum4, f) => sum4 + parseFloat(f.amount || "0"), 0)
              },
              details: finances3.map((f) => ({
                id: f.id,
                type: f.type,
                category: f.category,
                amount: f.amount,
                date: f.date
              }))
            };
            break;
          case "tasks":
            const tasks2 = await this.getTasks();
            const completedTasks = tasks2.filter((t) => t.status === "completed");
            const pendingTasks = tasks2.filter((t) => t.status === "pending");
            title = "Tasks Summary Report";
            reportData = {
              summary: {
                total: tasks2.length,
                completed: completedTasks.length,
                pending: pendingTasks.length,
                completionRate: tasks2.length > 0 ? (completedTasks.length / tasks2.length * 100).toFixed(2) : 0
              },
              details: tasks2.map((t) => ({
                id: t.id,
                title: t.title,
                status: t.status,
                priority: t.priority,
                dueDate: t.dueDate
              }))
            };
            break;
          case "properties":
            const properties2 = await this.getProperties();
            const activeProperties = properties2.filter((p) => p.status === "active");
            title = "Properties Summary Report";
            reportData = {
              summary: {
                total: properties2.length,
                active: activeProperties.length,
                totalValue: properties2.reduce((sum4, p) => sum4 + parseFloat(p.estimatedValue || "0"), 0)
              },
              details: properties2.map((p) => ({
                id: p.id,
                name: p.name,
                address: p.address,
                status: p.status,
                estimatedValue: p.estimatedValue
              }))
            };
            break;
          default:
            title = "General Report";
            reportData = { summary: {}, details: [] };
        }
        const report = {
          organizationId: organizationId2,
          title,
          type,
          data: reportData,
          generatedBy: userId
        };
        return await this.createReport(report);
      }
      // ===== AUTOMATION & ALERTS OPERATIONS =====
      async getAutomations(organizationId2) {
        return await db.select().from(automations).where(eq2(automations.organizationId, organizationId2)).orderBy(desc2(automations.createdAt));
      }
      async getActiveAutomations(organizationId2) {
        return await db.select().from(automations).where(and3(eq2(automations.organizationId, organizationId2), eq2(automations.isActive, true))).orderBy(desc2(automations.createdAt));
      }
      async getAutomation(id) {
        const [automation] = await db.select().from(automations).where(eq2(automations.id, id));
        return automation;
      }
      async createAutomation(automation) {
        const [created] = await db.insert(automations).values(automation).returning();
        return created;
      }
      async updateAutomation(id, automation) {
        const [updated] = await db.update(automations).set({ ...automation, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(automations.id, id)).returning();
        return updated;
      }
      async deleteAutomation(id) {
        await db.delete(automations).where(eq2(automations.id, id));
        return true;
      }
      async toggleAutomation(id, isActive) {
        const [updated] = await db.update(automations).set({ isActive, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(automations.id, id)).returning();
        return updated;
      }
      // ===== AUTOMATION LOGS OPERATIONS =====
      async getAutomationLogs(automationId) {
        return await db.select().from(automationLogs).where(eq2(automationLogs.automationId, automationId)).orderBy(desc2(automationLogs.executedAt));
      }
      async createAutomationLog(log2) {
        const [created] = await db.insert(automationLogs).values(log2).returning();
        return created;
      }
      // ===== INVOICE GENERATOR OPERATIONS =====
      async getBillingInvoices(organizationId2, filters) {
        const conditions = [eq2(billingInvoices.organizationId, organizationId2)];
        if (filters?.status) {
          conditions.push(eq2(billingInvoices.status, filters.status));
        }
        if (filters?.clientId) {
          conditions.push(eq2(billingInvoices.clientId, filters.clientId));
        }
        if (filters?.propertyId) {
          conditions.push(eq2(billingInvoices.propertyId, filters.propertyId));
        }
        if (filters?.search) {
          if (filters?.createdBy) {
            conditions.push(eq2(billingInvoices.createdBy, filters.createdBy));
          }
          conditions.push(
            or(
              like(billingInvoices.invoiceNumber, `%${filters.search}%`),
              like(billingInvoices.clientName, `%${filters.search}%`)
            )
          );
        }
        if (filters?.fromDate) {
          conditions.push(gte2(billingInvoices.issueDate, filters.fromDate));
        }
        if (filters?.toDate) {
          conditions.push(lte2(billingInvoices.issueDate, filters.toDate));
        }
        const [{ count: count3 }] = await db.select({ count: sql3`count(*)` }).from(billingInvoices).where(and3(...conditions));
        const page = filters?.page || 1;
        const limit = filters?.limit || 20;
        const offset = (page - 1) * limit;
        const invoicesList = await db.select().from(billingInvoices).where(and3(...conditions)).orderBy(desc2(billingInvoices.createdAt)).limit(limit).offset(offset);
        return { invoices: invoicesList, total: Number(count3) };
      }
      async getBillingInvoice(id) {
        const [invoice] = await db.select().from(billingInvoices).where(eq2(billingInvoices.id, id));
        return invoice;
      }
      async createBillingInvoice(invoice, lineItems) {
        let subtotal = 0;
        let taxTotal = 0;
        let discountTotal = 0;
        const processedLineItems = lineItems.map((item) => {
          const qty = Number(item.quantity);
          const price = Number(item.unitPrice);
          const taxRate = Number(item.taxRate || 0);
          const discount = Number(item.discount || 0);
          const lineSubtotal = qty * price;
          const lineTax = lineSubtotal * (taxRate / 100);
          const lineAmount = lineSubtotal + lineTax - discount;
          subtotal += lineSubtotal;
          taxTotal += lineTax;
          discountTotal += discount;
          return {
            ...item,
            amount: lineAmount.toFixed(2)
          };
        });
        const total = subtotal + taxTotal - discountTotal;
        const [newInvoice] = await db.insert(billingInvoices).values({
          ...invoice,
          subtotal: subtotal.toFixed(2),
          taxTotal: taxTotal.toFixed(2),
          discountTotal: discountTotal.toFixed(2),
          total: total.toFixed(2)
        }).returning();
        if (processedLineItems.length > 0) {
          await db.insert(billingInvoiceLineItems2).values(
            processedLineItems.map((item) => ({
              ...item,
              invoiceId: newInvoice.id
            }))
          );
        }
        return newInvoice;
      }
      async updateBillingInvoice(id, invoice, lineItems) {
        if (lineItems && lineItems.length > 0) {
          let subtotal = 0;
          let taxTotal = 0;
          let discountTotal = 0;
          const processedLineItems = lineItems.map((item) => {
            const qty = Number(item.quantity);
            const price = Number(item.unitPrice);
            const taxRate = Number(item.taxRate || 0);
            const discount = Number(item.discount || 0);
            const lineSubtotal = qty * price;
            const lineTax = lineSubtotal * (taxRate / 100);
            const lineAmount = lineSubtotal + lineTax - discount;
            subtotal += lineSubtotal;
            taxTotal += lineTax;
            discountTotal += discount;
            return {
              ...item,
              amount: lineAmount.toFixed(2)
            };
          });
          const total = subtotal + taxTotal - discountTotal;
          await db.delete(billingInvoiceLineItems2).where(eq2(billingInvoiceLineItems2.invoiceId, id));
          await db.insert(billingInvoiceLineItems2).values(
            processedLineItems.map((item) => ({
              ...item,
              invoiceId: id
            }))
          );
          invoice = {
            ...invoice,
            subtotal: subtotal.toFixed(2),
            taxTotal: taxTotal.toFixed(2),
            discountTotal: discountTotal.toFixed(2),
            total: total.toFixed(2)
          };
        }
        const [updatedInvoice] = await db.update(billingInvoices).set({ ...invoice, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(billingInvoices.id, id)).returning();
        return updatedInvoice;
      }
      async deleteBillingInvoice(id) {
        const result = await db.delete(billingInvoices).where(eq2(billingInvoices.id, id));
        return result.rowCount > 0;
      }
      async getNextInvoiceNumber(organizationId2) {
        const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        const prefix = `INV-${currentYear}-`;
        const [latestInvoice] = await db.select().from(billingInvoices).where(
          and3(
            eq2(billingInvoices.organizationId, organizationId2),
            like(billingInvoices.invoiceNumber, `${prefix}%`)
          )
        ).orderBy(desc2(billingInvoices.invoiceNumber)).limit(1);
        if (!latestInvoice) {
          return `${prefix}001`;
        }
        const numberPart = latestInvoice.invoiceNumber.replace(prefix, "");
        const nextNumber = parseInt(numberPart, 10) + 1;
        return `${prefix}${String(nextNumber).padStart(3, "0")}`;
      }
      async getBillingInvoiceStats(organizationId2) {
        const statusStats = await db.select({
          status: billingInvoices.status,
          count: sql3`count(*)`,
          total: sql3`sum(${billingInvoices.total})`
        }).from(billingInvoices).where(eq2(billingInvoices.organizationId, organizationId2)).groupBy(billingInvoices.status);
        const monthlyStats = await db.select({
          month: sql3`to_char(${billingInvoices.issueDate}, 'YYYY-MM')`,
          total: sql3`sum(${billingInvoices.total})`,
          count: sql3`count(*)`
        }).from(billingInvoices).where(
          and3(
            eq2(billingInvoices.organizationId, organizationId2),
            gte2(billingInvoices.issueDate, sql3`current_date - interval '12 months'`)
          )
        ).groupBy(sql3`to_char(${billingInvoices.issueDate}, 'YYYY-MM')`).orderBy(sql3`to_char(${billingInvoices.issueDate}, 'YYYY-MM')`);
        const totalInvoiced = statusStats.reduce((sum4, stat) => sum4 + Number(stat.total || 0), 0);
        const totalOutstanding = statusStats.filter((stat) => stat.status === "sent" || stat.status === "overdue").reduce((sum4, stat) => sum4 + Number(stat.total || 0), 0);
        const totalPaid = statusStats.filter((stat) => stat.status === "paid").reduce((sum4, stat) => sum4 + Number(stat.total || 0), 0);
        return {
          statusBreakdown: statusStats,
          monthlyTotals: monthlyStats,
          summary: {
            totalInvoiced,
            totalOutstanding,
            totalPaid,
            totalInvoices: statusStats.reduce((sum4, stat) => sum4 + Number(stat.count), 0)
          }
        };
      }
      async exportBillingInvoices(organizationId2, filters) {
        const conditions = [eq2(billingInvoices.organizationId, organizationId2)];
        if (filters?.status) {
          conditions.push(eq2(billingInvoices.status, filters.status));
        }
        if (filters?.fromDate) {
          conditions.push(gte2(billingInvoices.issueDate, filters.fromDate));
        }
        if (filters?.toDate) {
          conditions.push(lte2(billingInvoices.issueDate, filters.toDate));
        }
        return await db.select().from(billingInvoices).where(and3(...conditions)).orderBy(desc2(billingInvoices.issueDate));
      }
      // ===== INVOICE TEMPLATE OPERATIONS =====
      async getBillingInvoiceTemplates(organizationId2) {
        return await db.select().from(billingInvoiceTemplates).where(
          and3(
            eq2(billingInvoiceTemplates.organizationId, organizationId2),
            eq2(billingInvoiceTemplates.isActive, true)
          )
        ).orderBy(billingInvoiceTemplates.name);
      }
      async getBillingInvoiceTemplate(id) {
        const [template] = await db.select().from(billingInvoiceTemplates).where(eq2(billingInvoiceTemplates.id, id));
        return template;
      }
      async createBillingInvoiceTemplate(template, lineItems) {
        const [newTemplate] = await db.insert(billingInvoiceTemplates).values(template).returning();
        if (lineItems.length > 0) {
          await db.insert(billingTemplateLineItems2).values(
            lineItems.map((item) => ({
              ...item,
              templateId: newTemplate.id
            }))
          );
        }
        return newTemplate;
      }
      async updateBillingInvoiceTemplate(id, template, lineItems) {
        if (lineItems) {
          await db.delete(billingTemplateLineItems2).where(eq2(billingTemplateLineItems2.templateId, id));
          if (lineItems.length > 0) {
            await db.insert(billingTemplateLineItems2).values(
              lineItems.map((item) => ({
                ...item,
                templateId: id
              }))
            );
          }
        }
        const [updatedTemplate] = await db.update(billingInvoiceTemplates).set({ ...template, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(billingInvoiceTemplates.id, id)).returning();
        return updatedTemplate;
      }
      async deleteBillingInvoiceTemplate(id) {
        const result = await db.delete(billingInvoiceTemplates).where(eq2(billingInvoiceTemplates.id, id));
        return result.rowCount > 0;
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/demoAuth.ts
import session from "express-session";
import connectPg from "connect-pg-simple";
function isProductionEnvironment() {
  const isProduction = process.env.NODE_ENV === "production" || !!process.env.RENDER || // Render sets this variable when deployed
  process.env.RAILWAY_ENVIRONMENT === "production";
  return isProduction;
}
function getCookieOptions() {
  const isProduction = isProductionEnvironment();
  return {
    httpOnly: true,
    secure: isProduction,
    // true for HTTPS (Render), false for HTTP (dev)
    sameSite: "lax",
    // 'lax' works for same-origin (frontend+backend on same domain)
    path: "/"
  };
}
function getDemoSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1e3;
  const pgStore = connectPg(session);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: true,
    // Auto-create sessions table if missing
    ttl: sessionTtl,
    tableName: "sessions"
  });
  const isProduction = isProductionEnvironment();
  const cookieOptions = getCookieOptions();
  console.log(`\u{1F510} Session config: isProduction=${isProduction}, NODE_ENV=${process.env.NODE_ENV}, RENDER=${process.env.RENDER}`);
  return session({
    secret: process.env.SESSION_SECRET || "hostpilot-secure-secret-key-2024",
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    name: "hostpilot.sid",
    proxy: isProduction,
    // Trust the proxy in production (Render)
    cookie: {
      ...cookieOptions,
      maxAge: sessionTtl
    }
  });
}
async function setupDemoAuth(app2) {
  app2.set("trust proxy", 1);
  app2.use(getDemoSession());
  console.log("\u2705 Demo seeding disabled - production mode active");
  app2.post("/api/auth/demo-login", async (req, res) => {
    try {
      const { email, password } = req.body;
      const cookieOptions = getCookieOptions();
      console.log(`\u{1F511} Login attempt for: ${email}, production=${isProductionEnvironment()}, secure=${cookieOptions.secure}`);
      const demoUser = DEMO_USERS.find((u) => u.email === email && u.password === password);
      if (demoUser) {
        req.session.userId = demoUser.id;
        req.session.save((err) => {
          if (err) {
            console.error("Session save error:", err);
            return res.status(500).json({ message: "Login failed" });
          }
          console.log(`\u2705 Demo user logged in: ${demoUser.id}, sessionID: ${req.sessionID}`);
          res.json({
            message: "Login successful",
            redirectUrl: "/",
            user: {
              id: demoUser.id,
              email: demoUser.email,
              firstName: demoUser.firstName,
              lastName: demoUser.lastName,
              role: demoUser.role
            }
          });
        });
        return;
      }
      const user = await storage.getUserByEmail(email);
      if (!user || !user.password) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      const bcrypt3 = await import("bcrypt");
      const isPasswordValid = await bcrypt3.compare(password, user.password);
      if (!isPasswordValid) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      req.session.userId = user.id;
      req.session.save((err) => {
        if (err) {
          console.error("Session save error:", err);
          return res.status(500).json({ message: "Login failed" });
        }
        res.json({
          message: "Login successful",
          redirectUrl: "/",
          user: {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role
          }
        });
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });
  app2.post("/api/auth/demo-logout", (req, res) => {
    const sessionId = req.session?.userId;
    console.log(`\u{1F6AA} Logout requested for user: ${sessionId}`);
    req.session.destroy((err) => {
      if (err) {
        console.error("Logout error:", err);
        return res.status(500).json({ message: "Logout failed" });
      }
      const cookieOptions = getCookieOptions();
      res.clearCookie("hostpilot.sid", cookieOptions);
      console.log(`\u2705 Session destroyed and cookie cleared for user: ${sessionId} (secure=${cookieOptions.secure})`);
      res.json({ message: "Logout successful", redirectUrl: "/" });
    });
  });
  app2.get("/api/auth/demo-logout", (req, res) => {
    const sessionId = req.session?.userId;
    console.log(`\u{1F6AA} GET Logout requested for user: ${sessionId}`);
    req.session.destroy((err) => {
      if (err) {
        console.error("Logout error:", err);
        return res.status(500).json({ message: "Logout failed" });
      }
      const cookieOptions = getCookieOptions();
      res.clearCookie("hostpilot.sid", cookieOptions);
      console.log(`\u2705 Session destroyed and cookie cleared for user: ${sessionId} (secure=${cookieOptions.secure})`);
      res.redirect("/");
    });
  });
  app2.get("/api/auth/demo-users", (req, res) => {
    const safeUsers = DEMO_USERS.map((u) => ({
      id: u.id,
      email: u.email,
      firstName: u.firstName,
      lastName: u.lastName,
      role: u.role
    }));
    res.json(safeUsers);
  });
  app2.get("/api/auth/user", async (req, res) => {
    if (!req.session?.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    try {
      const demoUser = DEMO_USERS.find((u) => u.id === req.session.userId);
      if (demoUser) {
        return res.json({
          id: demoUser.id,
          organizationId: demoUser.organizationId,
          email: demoUser.email,
          firstName: demoUser.firstName,
          lastName: demoUser.lastName,
          role: demoUser.role,
          profileImageUrl: demoUser.profileImageUrl,
          isActive: true,
          permissions: [],
          listingsAccess: []
        });
      }
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      res.json({
        id: user.id,
        organizationId: user.organizationId,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
        profileImageUrl: user.profileImageUrl,
        isActive: user.isActive,
        permissions: [],
        listingsAccess: []
      });
    } catch (error) {
      console.error("Auth user error:", error);
      res.status(500).json({ message: "Authentication failed" });
    }
  });
  app2.post("/api/auth/auto-demo-login", async (req, res) => {
    res.status(403).json({ message: "Auto-login disabled in production mode" });
  });
}
var DEMO_USERS, isDemoAuthenticated;
var init_demoAuth = __esm({
  "server/demoAuth.ts"() {
    "use strict";
    init_storage();
    DEMO_USERS = [
      {
        id: "demo-admin",
        organizationId: "default-org",
        email: "admin@hostpilot.com",
        password: "demo123",
        firstName: "Admin",
        lastName: "Demo",
        role: "admin",
        profileImageUrl: null
      },
      {
        id: "demo-owner",
        organizationId: "default-org",
        email: "owner@hostpilot.com",
        password: "demo123",
        firstName: "Property",
        lastName: "Owner",
        role: "owner",
        profileImageUrl: null
      },
      {
        id: "demo-manager",
        organizationId: "default-org",
        email: "manager@hostpilot.com",
        password: "demo123",
        firstName: "Property",
        lastName: "Manager",
        role: "property_manager",
        profileImageUrl: null
      },
      {
        id: "demo-cleaner",
        organizationId: "default-org",
        email: "cleaner@hostpilot.com",
        password: "demo123",
        firstName: "Cleaning",
        lastName: "Staff",
        role: "cleaner",
        profileImageUrl: null
      }
    ];
    isDemoAuthenticated = async (req, res, next) => {
      if (!req.session?.userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const demoUser = DEMO_USERS.find((u) => u.id === req.session.userId);
        if (demoUser) {
          req.user = demoUser;
          return next();
        }
        const user = await storage.getUser(req.session.userId);
        if (!user) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        req.user = user;
        next();
      } catch (error) {
        console.error("Auth error:", error);
        res.status(401).json({ message: "Unauthorized" });
      }
    };
  }
});

// server/services/currencyConversionService.ts
var currencyConversionService_exports = {};
__export(currencyConversionService_exports, {
  CURRENCY_SYMBOLS: () => CURRENCY_SYMBOLS,
  SUPPORTED_CURRENCIES: () => SUPPORTED_CURRENCIES,
  clearRatesCache: () => clearRatesCache,
  convertAmount: () => convertAmount,
  formatCurrencyAmount: () => formatCurrencyAmount,
  getAllRatesForFrontend: () => getAllRatesForFrontend,
  getConversionRate: () => getConversionRate,
  getRates: () => getRates,
  isCurrencySupported: () => isCurrencySupported
});
async function tryFrankfurterAPI(baseCurrency) {
  try {
    const targetCurrencies = SUPPORTED_CURRENCIES.filter((c) => c !== baseCurrency).join(",");
    const url = `https://api.frankfurter.dev/v1/latest?from=${baseCurrency}&to=${targetCurrencies}`;
    console.log("[CURRENCY] Trying Frankfurter API (ECB data)...");
    const response = await fetch(url);
    if (!response.ok) {
      console.log(`[CURRENCY] Frankfurter API returned ${response.status}`);
      return null;
    }
    const data = await response.json();
    if (!data.rates) return null;
    const rates = { [baseCurrency]: 1 };
    for (const currency of SUPPORTED_CURRENCIES) {
      if (data.rates?.[currency] !== void 0) {
        rates[currency] = data.rates[currency];
      }
    }
    console.log(`[CURRENCY] Frankfurter API success! Date: ${data.date}, ${Object.keys(rates).length} currencies`);
    return Object.keys(rates).length > 1 ? rates : null;
  } catch (error) {
    console.log("[CURRENCY] Frankfurter API error:", error);
    return null;
  }
}
async function tryExchangeRateAPI(apiKey, baseCurrency) {
  try {
    const url = `https://v6.exchangerate-api.com/v6/${apiKey}/latest/${baseCurrency}`;
    console.log("[CURRENCY] Trying ExchangeRate-API...");
    const response = await fetch(url);
    if (!response.ok) return null;
    const data = await response.json();
    if (data.result !== "success") return null;
    const rates = {};
    for (const currency of SUPPORTED_CURRENCIES) {
      if (data.conversion_rates?.[currency] !== void 0) {
        rates[currency] = data.conversion_rates[currency];
      }
    }
    console.log("[CURRENCY] ExchangeRate-API success!");
    return Object.keys(rates).length > 0 ? rates : null;
  } catch {
    return null;
  }
}
async function tryFreeCurrencyAPI(apiKey, baseCurrency) {
  try {
    const url = `https://api.freecurrencyapi.com/v1/latest?apikey=${apiKey}&base_currency=${baseCurrency}`;
    console.log("[CURRENCY] Trying FreeCurrencyAPI...");
    const response = await fetch(url);
    if (!response.ok) return null;
    const data = await response.json();
    if (!data.data) return null;
    const rates = {};
    for (const currency of SUPPORTED_CURRENCIES) {
      if (data.data?.[currency] !== void 0) {
        rates[currency] = data.data[currency];
      }
    }
    console.log("[CURRENCY] FreeCurrencyAPI success!");
    return Object.keys(rates).length > 0 ? rates : null;
  } catch {
    return null;
  }
}
async function tryOpenExchangeRates(apiKey, baseCurrency) {
  try {
    const url = `https://openexchangerates.org/api/latest.json?app_id=${apiKey}`;
    console.log("[CURRENCY] Trying OpenExchangeRates...");
    const response = await fetch(url);
    if (!response.ok) return null;
    const data = await response.json();
    if (!data.rates) return null;
    const baseRate = baseCurrency === "USD" ? 1 : data.rates[baseCurrency];
    if (!baseRate) return null;
    const rates = {};
    for (const currency of SUPPORTED_CURRENCIES) {
      if (data.rates?.[currency] !== void 0) {
        rates[currency] = data.rates[currency] / baseRate;
      }
    }
    console.log("[CURRENCY] OpenExchangeRates success!");
    return Object.keys(rates).length > 0 ? rates : null;
  } catch {
    return null;
  }
}
async function tryCurrencyLayer(apiKey, baseCurrency) {
  try {
    const url = `http://api.currencylayer.com/live?access_key=${apiKey}&source=${baseCurrency}`;
    console.log("[CURRENCY] Trying CurrencyLayer...");
    const response = await fetch(url);
    if (!response.ok) return null;
    const data = await response.json();
    if (!data.success || !data.quotes) return null;
    const rates = {};
    for (const currency of SUPPORTED_CURRENCIES) {
      const key = `${baseCurrency}${currency}`;
      if (data.quotes?.[key] !== void 0) {
        rates[currency] = data.quotes[key];
      }
    }
    console.log("[CURRENCY] CurrencyLayer success!");
    return Object.keys(rates).length > 0 ? rates : null;
  } catch {
    return null;
  }
}
async function fetchRatesFromAPI(baseCurrency = "USD") {
  console.log("[CURRENCY] Fetching real-time exchange rates...");
  const frankfurterRates = await tryFrankfurterAPI(baseCurrency);
  if (frankfurterRates) {
    console.log(`[CURRENCY] Using Frankfurter API (ECB data) - ${Object.keys(frankfurterRates).length} currencies`);
    return frankfurterRates;
  }
  const apiKey = process.env.CURRENCY_API_KEY || process.env.EXCHANGE_RATES_API_KEY;
  if (apiKey) {
    console.log("[CURRENCY] Frankfurter failed, trying API key providers...");
    const providers = [
      () => tryExchangeRateAPI(apiKey, baseCurrency),
      () => tryFreeCurrencyAPI(apiKey, baseCurrency),
      () => tryOpenExchangeRates(apiKey, baseCurrency),
      () => tryCurrencyLayer(apiKey, baseCurrency)
    ];
    for (const tryProvider of providers) {
      const rates = await tryProvider();
      if (rates) {
        console.log(`[CURRENCY] Successfully fetched rates for ${Object.keys(rates).length} currencies`);
        return rates;
      }
    }
  }
  console.log("[CURRENCY] All API providers failed, using fallback rates");
  return convertFallbackToBase(baseCurrency);
}
function convertFallbackToBase(baseCurrency) {
  if (baseCurrency === "USD") {
    return { ...FALLBACK_RATES };
  }
  const baseRate = FALLBACK_RATES[baseCurrency];
  if (!baseRate) {
    console.warn(`[CURRENCY] Unknown base currency: ${baseCurrency}, defaulting to USD`);
    return { ...FALLBACK_RATES };
  }
  const convertedRates = {};
  for (const [currency, rate] of Object.entries(FALLBACK_RATES)) {
    convertedRates[currency] = rate / baseRate;
  }
  return convertedRates;
}
async function getRates(baseCurrency = "USD") {
  const now = Date.now();
  if (ratesCache && ratesCache.baseCurrency === baseCurrency && now - ratesCache.timestamp < CACHE_DURATION_MS) {
    console.log("[CURRENCY] Using cached rates");
    return ratesCache.rates;
  }
  const rates = await fetchRatesFromAPI(baseCurrency);
  ratesCache = {
    baseCurrency,
    rates,
    timestamp: now
  };
  return rates;
}
async function convertAmount(amount, fromCurrency, toCurrency) {
  if (fromCurrency === toCurrency) {
    return amount;
  }
  const rates = await getRates(fromCurrency);
  const rate = rates[toCurrency];
  if (rate === void 0) {
    console.warn(`[CURRENCY] No rate found for ${toCurrency}, returning original amount`);
    return amount;
  }
  return amount * rate;
}
async function getConversionRate(fromCurrency, toCurrency) {
  if (fromCurrency === toCurrency) {
    return 1;
  }
  const rates = await getRates(fromCurrency);
  return rates[toCurrency] || 1;
}
function formatCurrencyAmount(amount, currencyCode, options = {}) {
  const symbol = CURRENCY_SYMBOLS[currencyCode] || currencyCode;
  const locale = CURRENCY_LOCALES[currencyCode] || "en-US";
  const useDecimals = !["JPY", "THB"].includes(currencyCode);
  const decimals = options.decimals ?? (useDecimals ? 2 : 0);
  try {
    const formatted = new Intl.NumberFormat(locale, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals
    }).format(amount);
    return `${symbol}${formatted}`;
  } catch {
    return `${symbol}${amount.toLocaleString()}`;
  }
}
async function getAllRatesForFrontend(baseCurrency = "USD") {
  const rates = await getRates(baseCurrency);
  return {
    baseCurrency,
    rates,
    symbols: CURRENCY_SYMBOLS,
    supportedCurrencies: SUPPORTED_CURRENCIES,
    lastUpdated: ratesCache?.timestamp || Date.now()
  };
}
function clearRatesCache() {
  ratesCache = null;
  console.log("[CURRENCY] Cache cleared");
}
function isCurrencySupported(currencyCode) {
  return SUPPORTED_CURRENCIES.includes(currencyCode.toUpperCase());
}
var CACHE_DURATION_MS, ratesCache, SUPPORTED_CURRENCIES, FALLBACK_RATES, CURRENCY_SYMBOLS, CURRENCY_LOCALES;
var init_currencyConversionService = __esm({
  "server/services/currencyConversionService.ts"() {
    "use strict";
    CACHE_DURATION_MS = 12 * 60 * 60 * 1e3;
    ratesCache = null;
    SUPPORTED_CURRENCIES = ["USD", "EUR", "GBP", "THB", "JPY", "AUD", "SGD", "MYR", "INR", "CNY"];
    FALLBACK_RATES = {
      USD: 1,
      EUR: 0.92,
      GBP: 0.79,
      THB: 35.5,
      JPY: 149.5,
      AUD: 1.53,
      SGD: 1.34,
      MYR: 4.47,
      INR: 83.5,
      CNY: 7.24
    };
    CURRENCY_SYMBOLS = {
      USD: "$",
      EUR: "\u20AC",
      GBP: "\xA3",
      THB: "\u0E3F",
      JPY: "\xA5",
      AUD: "A$",
      SGD: "S$",
      MYR: "RM",
      INR: "\u20B9",
      CNY: "\xA5"
    };
    CURRENCY_LOCALES = {
      USD: "en-US",
      EUR: "de-DE",
      GBP: "en-GB",
      THB: "th-TH",
      JPY: "ja-JP",
      AUD: "en-AU",
      SGD: "en-SG",
      MYR: "ms-MY",
      INR: "en-IN",
      CNY: "zh-CN"
    };
  }
});

// server/logger.ts
var logger;
var init_logger = __esm({
  "server/logger.ts"() {
    "use strict";
    logger = {
      info: (message, ...args) => {
        console.log(`[INFO] ${message}`, ...args);
      },
      warn: (message, ...args) => {
        console.warn(`[WARN] ${message}`, ...args);
      },
      error: (message, ...args) => {
        console.error(`[ERROR] ${message}`, ...args);
      },
      debug: (message, ...args) => {
        console.debug(`[DEBUG] ${message}`, ...args);
      }
    };
  }
});

// server/performanceOptimizer.ts
var performanceOptimizer_exports = {};
__export(performanceOptimizer_exports, {
  cacheResponse: () => cacheResponse,
  clearCache: () => clearCache,
  getCachedResponse: () => getCachedResponse,
  sendCachedOrFetch: () => sendCachedOrFetch
});
function cacheResponse(key, data, minutes = 10) {
  const expiry = Date.now() + minutes * 60 * 1e3;
  memoryCache.set(key, { data, expiry });
}
function getCachedResponse(key) {
  const cached = memoryCache.get(key);
  if (cached && cached.expiry > Date.now()) {
    return cached.data;
  }
  if (cached) {
    memoryCache.delete(key);
  }
  return null;
}
function clearCache(pattern) {
  if (pattern) {
    for (const key of memoryCache.keys()) {
      if (key.includes(pattern)) {
        memoryCache.delete(key);
      }
    }
  } else {
    memoryCache.clear();
  }
}
function sendCachedOrFetch(cacheKey, fetchFn, res, cacheMinutes = 10) {
  const cached = getCachedResponse(cacheKey);
  if (cached) {
    console.log(`Cache hit: ${cacheKey}`);
    return res.json(cached);
  }
  return fetchFn().then((data) => {
    cacheResponse(cacheKey, data, cacheMinutes);
    res.json(data);
  }).catch((error) => {
    console.error(`Error in ${cacheKey}:`, error);
    res.status(500).json({ message: "Internal server error" });
  });
}
var memoryCache;
var init_performanceOptimizer = __esm({
  "server/performanceOptimizer.ts"() {
    "use strict";
    memoryCache = /* @__PURE__ */ new Map();
    setInterval(() => {
      const now = Date.now();
      for (const [key, value] of memoryCache.entries()) {
        if (value.expiry <= now) {
          memoryCache.delete(key);
        }
      }
    }, 5 * 60 * 1e3);
  }
});

// server/bulk-delete-api.ts
var bulk_delete_api_exports = {};
__export(bulk_delete_api_exports, {
  registerBulkDeleteRoutes: () => registerBulkDeleteRoutes
});
async function deleteExpiredTasks(organizationId2) {
  const thirtyDaysAgo = /* @__PURE__ */ new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  try {
    const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
    const { tasks: tasks2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const { lt: lt2, and: and22, eq: eq23 } = await import("drizzle-orm");
    const result = await db2.delete(tasks2).where(
      and22(
        eq23(tasks2.organizationId, organizationId2),
        lt2(tasks2.createdAt, thirtyDaysAgo)
      )
    ).returning({ id: tasks2.id });
    return result.length;
  } catch (error) {
    console.error("Error deleting expired tasks:", error);
    return 0;
  }
}
async function deleteCompletedTasks(organizationId2) {
  try {
    const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
    const { tasks: tasks2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const { and: and22, eq: eq23 } = await import("drizzle-orm");
    const result = await db2.delete(tasks2).where(
      and22(
        eq23(tasks2.organizationId, organizationId2),
        eq23(tasks2.status, "completed")
      )
    ).returning({ id: tasks2.id });
    return result.length;
  } catch (error) {
    console.error("Error deleting completed tasks:", error);
    return 0;
  }
}
async function deleteOldTasks(organizationId2) {
  const ninetyDaysAgo = /* @__PURE__ */ new Date();
  ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
  try {
    const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
    const { tasks: tasks2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const { lt: lt2, and: and22, eq: eq23 } = await import("drizzle-orm");
    const result = await db2.delete(tasks2).where(
      and22(
        eq23(tasks2.organizationId, organizationId2),
        lt2(tasks2.createdAt, ninetyDaysAgo)
      )
    ).returning({ id: tasks2.id });
    return result.length;
  } catch (error) {
    console.error("Error deleting old tasks:", error);
    return 0;
  }
}
function registerBulkDeleteRoutes(app2) {
  const isDemoAuthenticated3 = (req, res, next) => {
    console.log("\u{1F50D} Bulk delete auth check - req.user:", req.user ? "EXISTS" : "NULL", req.user?.id || "N/A");
    if (!req.user) {
      console.log("\u274C Bulk delete - No user found, returning 401");
      return res.status(401).json({ message: "Unauthorized" });
    }
    console.log("\u2705 Bulk delete - User authenticated:", req.user.id);
    next();
  };
  app2.delete("/api/tasks/bulk-delete/expired", isDemoAuthenticated3, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const deletedCount = await deleteExpiredTasks(organizationId2);
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      clearCache2("tasks");
      clearCache2("properties");
      console.log(`\u2705 Bulk deleted ${deletedCount} expired tasks for org: ${organizationId2}`);
      res.json({
        deletedCount,
        message: `Successfully deleted ${deletedCount} expired tasks`
      });
    } catch (error) {
      console.error("Error deleting expired tasks:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.delete("/api/tasks/bulk-delete/completed", isDemoAuthenticated3, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const deletedCount = await deleteCompletedTasks(organizationId2);
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      clearCache2("tasks");
      clearCache2("properties");
      console.log(`\u2705 Bulk deleted ${deletedCount} completed tasks for org: ${organizationId2}`);
      res.json({
        deletedCount,
        message: `Successfully deleted ${deletedCount} completed tasks`
      });
    } catch (error) {
      console.error("Error deleting completed tasks:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.delete("/api/tasks/bulk-delete/old", isDemoAuthenticated3, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const deletedCount = await deleteOldTasks(organizationId2);
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      clearCache2("tasks");
      clearCache2("properties");
      console.log(`\u2705 Bulk deleted ${deletedCount} old tasks for org: ${organizationId2}`);
      res.json({
        deletedCount,
        message: `Successfully deleted ${deletedCount} old tasks`
      });
    } catch (error) {
      console.error("Error deleting old tasks:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
}
var init_bulk_delete_api = __esm({
  "server/bulk-delete-api.ts"() {
    "use strict";
  }
});

// server/standardDemoProperties.ts
var standardDemoProperties_exports = {};
__export(standardDemoProperties_exports, {
  ensureStandardDemoProperties: () => ensureStandardDemoProperties,
  getStandardDemoPropertyIds: () => getStandardDemoPropertyIds
});
import { and as and7, eq as eq6 } from "drizzle-orm";
async function ensureStandardDemoProperties() {
  console.log(
    "[standardDemoProperties] Skipping demo seed \u2013 using dynamic properties only."
  );
}
async function getStandardDemoPropertyIds(organizationId2 = "default-org", ownerId = "demo-owner") {
  const rows = await db.select({ id: properties.id }).from(properties).where(
    and7(
      eq6(properties.organizationId, organizationId2),
      eq6(properties.ownerId, ownerId)
    )
  );
  return rows.map((r) => r.id);
}
var init_standardDemoProperties = __esm({
  "server/standardDemoProperties.ts"() {
    "use strict";
    init_db();
    init_schema();
  }
});

// server/fastRoutes.ts
var fastRoutes_exports = {};
__export(fastRoutes_exports, {
  registerFastRoutes: () => registerFastRoutes
});
function registerFastRoutes(app2) {
  app2.get("/api/properties/fast", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `properties-${organizationId2}`;
    return sendCachedOrFetch(
      cacheKey,
      () => storage.getProperties(organizationId2),
      res,
      15
      // 15 minute cache
    );
  });
  app2.get("/api/tasks/fast", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `tasks-${organizationId2}`;
    return sendCachedOrFetch(
      cacheKey,
      () => storage.getTasks(organizationId2),
      res,
      5
      // 5 minute cache
    );
  });
  app2.get("/api/bookings/fast", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `bookings-${organizationId2}`;
    return sendCachedOrFetch(
      cacheKey,
      () => storage.getBookings(organizationId2),
      res,
      10
      // 10 minute cache
    );
  });
  app2.get("/api/dashboard/stats/fast", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `dashboard-stats-${organizationId2}`;
    return sendCachedOrFetch(
      cacheKey,
      async () => {
        const [properties2, tasks2, bookings3] = await Promise.all([
          storage.getProperties(organizationId2),
          storage.getTasks(organizationId2),
          storage.getBookings(organizationId2)
        ]);
        return {
          totalProperties: properties2.length,
          activeBookings: bookings3.filter((b) => b.status === "confirmed").length,
          pendingTasks: tasks2.filter((t) => t.status === "pending").length,
          completedTasks: tasks2.filter((t) => t.status === "completed").length,
          totalRevenue: bookings3.reduce((sum4, b) => sum4 + (b.totalAmount || 0), 0)
        };
      },
      res,
      30
      // 30 minute cache for dashboard
    );
  });
  app2.get("/api/hub/dashboard/fast", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `hub-dashboard-${organizationId2}`;
    return sendCachedOrFetch(
      cacheKey,
      async () => {
        return {
          success: true,
          timestamp: Date.now(),
          hubType: "dashboard"
        };
      },
      res,
      60
      // 1 hour cache for hub navigation
    );
  });
  app2.get("/api/hub/property/fast", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `hub-property-${organizationId2}`;
    return sendCachedOrFetch(
      cacheKey,
      async () => {
        return {
          success: true,
          timestamp: Date.now(),
          hubType: "property"
        };
      },
      res,
      60
      // 1 hour cache
    );
  });
  app2.get("/api/hub/finance/fast", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `hub-finance-${organizationId2}`;
    return sendCachedOrFetch(
      cacheKey,
      async () => {
        return {
          success: true,
          timestamp: Date.now(),
          hubType: "finance"
        };
      },
      res,
      60
      // 1 hour cache
    );
  });
  app2.get("/api/hub/system/fast", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `hub-system-${organizationId2}`;
    return sendCachedOrFetch(
      cacheKey,
      async () => {
        return {
          success: true,
          timestamp: Date.now(),
          hubType: "system"
        };
      },
      res,
      60
      // 1 hour cache
    );
  });
  app2.get("/api/dashboard/live-alerts", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `live-alerts-${organizationId2}`;
    return sendCachedOrFetch(
      cacheKey,
      () => storage.getLiveAlerts(organizationId2),
      res,
      2
      // 2 minute cache for alerts
    );
  });
  app2.get("/api/dashboard/kpi-metrics", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `kpi-metrics-${organizationId2}`;
    return sendCachedOrFetch(
      cacheKey,
      () => storage.getKPIMetrics(organizationId2),
      res,
      5
      // 5 minute cache for KPIs
    );
  });
  app2.get("/api/system", async (req, res) => {
    const organizationId2 = req.user?.organizationId || "default-org";
    try {
      const [allProperties, users3, settings, finances3, tasks2, bookings3] = await Promise.all([
        storage.getProperties(),
        // No filter - get all, then filter by org
        storage.getUsers({ organizationId: organizationId2 }),
        storage.getPlatformSettings(organizationId2),
        storage.getFinances({ organizationId: organizationId2 }),
        storage.getTasks().then((t) => t.filter((task) => task.organizationId === organizationId2)),
        storage.getBookings(organizationId2)
      ]);
      const properties2 = allProperties.filter((p) => p.organizationId === organizationId2);
      const hostawayProperties = properties2.filter((p) => p.source === "HOSTAWAY");
      const hostawayBookings = bookings3.filter((b) => b.source === "HOSTAWAY");
      const systemInfo = {
        version: "2.0 Enterprise FIXED",
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
        status: "online",
        health: {
          database: "healthy",
          api: "operational",
          cache: "active"
        },
        modules: {
          properties: { active: true, count: properties2.length },
          users: { active: true, count: users3.length },
          finance: { active: true, count: finances3.length },
          tasks: { active: true, count: tasks2.length },
          bookings: { active: true, count: bookings3.length }
        },
        hostaway: {
          properties: hostawayProperties.length,
          bookings: hostawayBookings.length,
          isConnected: !!process.env.HOSTAWAY_API_KEY
        },
        apiConfigs: {
          hasStripe: settings.some((s) => s.settingKey === "api.stripe_secret_key"),
          hasHostaway: settings.some((s) => s.settingKey === "api.hostaway_api_key"),
          hasOpenAI: settings.some((s) => s.settingKey === "api.openai_api_key"),
          hasTwilio: settings.some((s) => s.settingKey === "api.twilio_account_sid")
        },
        organization: {
          id: organizationId2,
          name: organizationId2 === "default-org" ? "HostPilotPro" : organizationId2
        }
      };
      res.json(systemInfo);
    } catch (error) {
      console.error("Error fetching system info:", error);
      res.status(500).json({
        error: "Failed to fetch system information",
        version: "2.0 Enterprise",
        status: "error"
      });
    }
  });
}
var init_fastRoutes = __esm({
  "server/fastRoutes.ts"() {
    "use strict";
    init_performanceOptimizer();
    init_storage();
  }
});

// server/optimizedRoutes.ts
var optimizedRoutes_exports = {};
__export(optimizedRoutes_exports, {
  default: () => optimizedRoutes_default
});
import { Router as Router2 } from "express";
var router2, optimizedRoutes_default;
var init_optimizedRoutes = __esm({
  "server/optimizedRoutes.ts"() {
    "use strict";
    init_storage();
    init_demoAuth();
    router2 = Router2();
    router2.get("/api/finance-hub/summary", isDemoAuthenticated, async (req, res) => {
      try {
        const { page = 1, limit = 20, type } = req.query;
        const offset = (Number(page) - 1) * Number(limit);
        const [finances3, analytics] = await Promise.all([
          storage.getFinances({
            organizationId: req.user?.organizationId || "default-org",
            limit: Number(limit),
            offset,
            type
          }),
          storage.getFinanceAnalytics({ organizationId: req.user?.organizationId || "default-org" })
        ]);
        const totalCount = await storage.getFinanceCount({
          organizationId: req.user?.organizationId || "default-org",
          type
        });
        res.json({
          summary: {
            totalRevenue: analytics.totalRevenue || 0,
            totalExpenses: analytics.totalExpenses || 0,
            netProfit: (analytics.totalRevenue || 0) - (analytics.totalExpenses || 0),
            monthlyGrowth: analytics.monthlyGrowth || 0,
            transactionCount: totalCount
          },
          transactions: finances3,
          pagination: {
            page: Number(page),
            limit: Number(limit),
            total: totalCount,
            totalPages: Math.ceil(totalCount / Number(limit)),
            hasNext: offset + Number(limit) < totalCount,
            hasPrev: Number(page) > 1
          }
        });
      } catch (error) {
        console.error("Finance hub summary error:", error);
        res.status(500).json({ message: "Failed to fetch finance summary" });
      }
    });
    router2.get("/api/utilities-hub/summary", isDemoAuthenticated, async (req, res) => {
      try {
        const { page = 1, limit = 20, status, type } = req.query;
        const offset = (Number(page) - 1) * Number(limit);
        const [utilities, summary] = await Promise.all([
          storage.getUtilities({
            organizationId: req.user?.organizationId || "default-org",
            limit: Number(limit),
            offset,
            status,
            type
          }),
          storage.getUtilitySummary({ organizationId: req.user?.organizationId || "default-org" })
        ]);
        const totalCount = await storage.getUtilityCount({
          organizationId: req.user?.organizationId || "default-org",
          status,
          type
        });
        res.json({
          summary: {
            totalPaid: summary.totalPaid || 0,
            totalPending: summary.totalPending || 0,
            totalOverdue: summary.totalOverdue || 0,
            monthlyAverage: summary.monthlyAverage || 0,
            utilityCount: totalCount
          },
          utilities,
          pagination: {
            page: Number(page),
            limit: Number(limit),
            total: totalCount,
            totalPages: Math.ceil(totalCount / Number(limit)),
            hasNext: offset + Number(limit) < totalCount,
            hasPrev: Number(page) > 1
          }
        });
      } catch (error) {
        console.error("Utilities hub summary error:", error);
        res.status(500).json({ message: "Failed to fetch utilities summary" });
      }
    });
    router2.get("/api/invoices-hub/summary", isDemoAuthenticated, async (req, res) => {
      try {
        const { page = 1, limit = 20, status } = req.query;
        const offset = (Number(page) - 1) * Number(limit);
        const [invoices2, summary] = await Promise.all([
          storage.getInvoices({
            organizationId: req.user?.organizationId || "default-org",
            limit: Number(limit),
            offset,
            status
          }),
          storage.getInvoiceSummary({ organizationId: req.user?.organizationId || "default-org" })
        ]);
        const totalCount = await storage.getInvoiceCount({
          organizationId: req.user?.organizationId || "default-org",
          status
        });
        res.json({
          summary: {
            totalInvoices: totalCount,
            totalPaid: summary.totalPaid || 0,
            totalPending: summary.totalPending || 0,
            totalOverdue: summary.totalOverdue || 0,
            averageInvoiceValue: summary.averageValue || 0
          },
          invoices: invoices2,
          pagination: {
            page: Number(page),
            limit: Number(limit),
            total: totalCount,
            totalPages: Math.ceil(totalCount / Number(limit)),
            hasNext: offset + Number(limit) < totalCount,
            hasPrev: Number(page) > 1
          }
        });
      } catch (error) {
        console.error("Invoices hub summary error:", error);
        res.status(500).json({ message: "Failed to fetch invoices summary" });
      }
    });
    router2.get("/api/system-hub/summary", isDemoAuthenticated, async (req, res) => {
      try {
        const [userStats, systemStats, recentActivity] = await Promise.all([
          storage.getUserStats({ organizationId: req.user?.organizationId || "default-org" }),
          storage.getSystemStats({ organizationId: req.user?.organizationId || "default-org" }),
          storage.getRecentActivity({
            organizationId: req.user?.organizationId || "default-org",
            limit: 10
          })
        ]);
        res.json({
          userStats: {
            totalUsers: userStats.totalUsers || 0,
            activeUsers: userStats.activeUsers || 0,
            newUsersThisMonth: userStats.newUsersThisMonth || 0,
            usersByRole: userStats.usersByRole || {}
          },
          systemStats: {
            totalProperties: systemStats.totalProperties || 0,
            activeTasks: systemStats.activeTasks || 0,
            systemUptime: systemStats.uptime || "99.9%",
            apiCallsToday: systemStats.apiCallsToday || 0
          },
          recentActivity
        });
      } catch (error) {
        console.error("System hub summary error:", error);
        res.status(500).json({ message: "Failed to fetch system summary" });
      }
    });
    router2.get("/api/charts/finance-trends", isDemoAuthenticated, async (req, res) => {
      try {
        const { period = "7d" } = req.query;
        const trends = await storage.getFinanceTrends({
          organizationId: req.user?.organizationId || "default-org",
          period
        });
        res.json(trends);
      } catch (error) {
        console.error("Finance trends error:", error);
        res.status(500).json({ message: "Failed to fetch finance trends" });
      }
    });
    router2.get("/api/charts/utility-usage", isDemoAuthenticated, async (req, res) => {
      try {
        const { period = "30d" } = req.query;
        const usage = await storage.getUtilityUsageTrends({
          organizationId: req.user?.organizationId || "default-org",
          period
        });
        res.json(usage);
      } catch (error) {
        console.error("Utility usage error:", error);
        res.status(500).json({ message: "Failed to fetch utility usage" });
      }
    });
    router2.get("/api/charts/system-performance", isDemoAuthenticated, async (req, res) => {
      try {
        const { period = "24h" } = req.query;
        const performance = await storage.getSystemPerformance({
          organizationId: req.user?.organizationId || "default-org",
          period
        });
        res.json(performance);
      } catch (error) {
        console.error("System performance error:", error);
        res.status(500).json({ message: "Failed to fetch system performance" });
      }
    });
    optimizedRoutes_default = router2;
  }
});

// server/cortex/intent.ts
function detectIntent(question) {
  const normalizedQuestion = question.toLowerCase().trim();
  const scores = [];
  for (const [intentType, keywords] of Object.entries(INTENT_PATTERNS)) {
    const matchedKeywords = [];
    let score = 0;
    for (const keyword of keywords) {
      if (normalizedQuestion.includes(keyword.toLowerCase())) {
        matchedKeywords.push(keyword);
        score += keyword.split(" ").length;
      }
    }
    if (score > 0) {
      scores.push({
        type: intentType,
        score,
        keywords: matchedKeywords
      });
    }
  }
  if (scores.length === 0) {
    return {
      type: "unknown",
      confidence: 0,
      keywords: [],
      rawQuestion: question
    };
  }
  scores.sort((a, b) => b.score - a.score);
  const topIntent = scores[0];
  const totalWords = normalizedQuestion.split(/\s+/).length;
  const confidence = Math.min(topIntent.score / totalWords, 1);
  return {
    type: topIntent.type,
    confidence,
    keywords: topIntent.keywords,
    rawQuestion: question
  };
}
function isActionableIntent(intent) {
  return intent.confidence >= 0.15 && intent.type !== "unknown";
}
var INTENT_PATTERNS;
var init_intent = __esm({
  "server/cortex/intent.ts"() {
    "use strict";
    INTENT_PATTERNS = {
      property_query: [
        "property",
        "villa",
        "properties",
        "building",
        "estate",
        "unit",
        "house",
        "apartment",
        "residence"
      ],
      utility_query: [
        "utility",
        "bill",
        "electricity",
        "water",
        "internet",
        "gas",
        "electric",
        "wifi",
        "broadband",
        "power",
        "consumption",
        "meter",
        "reading",
        "usage",
        "paid",
        "unpaid",
        "due",
        "overdue",
        "payslip",
        "receipt",
        "proof of payment"
      ],
      task_query: [
        "task",
        "maintenance",
        "repair",
        "cleaning",
        "inspection",
        "work order",
        "job",
        "pending",
        "completed",
        "assigned",
        "scheduled",
        "overdue",
        "priority"
      ],
      booking_query: [
        "booking",
        "reservation",
        "guest",
        "check-in",
        "checkout",
        "occupied",
        "vacant",
        "available",
        "booked",
        "reserved",
        "arrival",
        "departure",
        "stay"
      ],
      finance_query: [
        "finance",
        "revenue",
        "expense",
        "income",
        "profit",
        "loss",
        "payment",
        "transaction",
        "commission",
        "payout",
        "invoice",
        "cost",
        "earning",
        "budget",
        "financial"
      ]
    };
  }
});

// server/cortex/extract.ts
function extractPropertyName(question) {
  const normalizedQuestion = question.toLowerCase();
  const villaMatch = normalizedQuestion.match(/villa\s+([a-z0-9\s]+?)(?:\s+|,|\.|\?|$)/i);
  if (villaMatch) {
    return `Villa ${villaMatch[1].trim().split(/\s+/).map(
      (w) => w.charAt(0).toUpperCase() + w.slice(1)
    ).join(" ")}`;
  }
  const quotedMatch = question.match(/"([^"]+)"/);
  if (quotedMatch) {
    return quotedMatch[1];
  }
  return void 0;
}
function extractUtilityType(question) {
  const normalizedQuestion = question.toLowerCase();
  for (const utilityType of UTILITY_TYPES) {
    if (normalizedQuestion.includes(utilityType)) {
      return utilityType;
    }
  }
  if (normalizedQuestion.includes("electric") || normalizedQuestion.includes("power")) {
    return "electricity";
  }
  if (normalizedQuestion.includes("wifi") || normalizedQuestion.includes("broadband")) {
    return "internet";
  }
  return void 0;
}
function extractMonthYear(question) {
  const normalizedQuestion = question.toLowerCase();
  let month;
  for (const [monthName, monthNum] of Object.entries(MONTH_PATTERNS)) {
    if (normalizedQuestion.includes(monthName)) {
      month = monthNum;
      break;
    }
  }
  if (!month) {
    const numericMonthMatch = normalizedQuestion.match(/\b(1[0-2]|[1-9])(th|st|nd|rd)?\b/);
    if (numericMonthMatch) {
      month = numericMonthMatch[1];
    }
  }
  const yearMatch = question.match(/\b(20\d{2})\b/);
  const year = yearMatch ? parseInt(yearMatch[1]) : void 0;
  if (normalizedQuestion.includes("this month") || normalizedQuestion.includes("current month")) {
    const now = /* @__PURE__ */ new Date();
    month = (now.getMonth() + 1).toString();
    return { month, year: now.getFullYear() };
  }
  return { month, year };
}
function extractDateRange(question) {
  const normalizedQuestion = question.toLowerCase();
  if (normalizedQuestion.includes("next weekend")) {
    const now = /* @__PURE__ */ new Date();
    const daysUntilSaturday = (6 - now.getDay() + 7) % 7 || 7;
    const saturday = new Date(now);
    saturday.setDate(now.getDate() + daysUntilSaturday);
    const sunday = new Date(saturday);
    sunday.setDate(saturday.getDate() + 1);
    return {
      dateFrom: saturday.toISOString().split("T")[0],
      dateTo: sunday.toISOString().split("T")[0]
    };
  }
  if (normalizedQuestion.includes("this week")) {
    const now = /* @__PURE__ */ new Date();
    const monday = new Date(now);
    monday.setDate(now.getDate() - now.getDay() + 1);
    const sunday = new Date(monday);
    sunday.setDate(monday.getDate() + 6);
    return {
      dateFrom: monday.toISOString().split("T")[0],
      dateTo: sunday.toISOString().split("T")[0]
    };
  }
  return {};
}
function extractTaskStatus(question) {
  const normalizedQuestion = question.toLowerCase();
  for (const status of TASK_STATUSES) {
    if (normalizedQuestion.includes(status)) {
      return status;
    }
  }
  return void 0;
}
function extractFinanceType(question) {
  const normalizedQuestion = question.toLowerCase();
  if (normalizedQuestion.includes("revenue") || normalizedQuestion.includes("income") || normalizedQuestion.includes("earning")) {
    return "income";
  }
  if (normalizedQuestion.includes("expense") || normalizedQuestion.includes("cost") || normalizedQuestion.includes("spending")) {
    return "expense";
  }
  return void 0;
}
function extractEntities(question) {
  const entities = {};
  entities.propertyName = extractPropertyName(question);
  entities.utilityType = extractUtilityType(question);
  const { month, year } = extractMonthYear(question);
  entities.month = month;
  entities.year = year;
  const { dateFrom, dateTo } = extractDateRange(question);
  entities.dateFrom = dateFrom;
  entities.dateTo = dateTo;
  entities.status = extractTaskStatus(question);
  entities.financeType = extractFinanceType(question);
  return entities;
}
var MONTH_PATTERNS, UTILITY_TYPES, TASK_STATUSES;
var init_extract = __esm({
  "server/cortex/extract.ts"() {
    "use strict";
    MONTH_PATTERNS = {
      january: "1",
      jan: "1",
      february: "2",
      feb: "2",
      march: "3",
      mar: "3",
      april: "4",
      apr: "4",
      may: "5",
      june: "6",
      jun: "6",
      july: "7",
      jul: "7",
      august: "8",
      aug: "8",
      september: "9",
      sep: "9",
      sept: "9",
      october: "10",
      oct: "10",
      november: "11",
      nov: "11",
      december: "12",
      dec: "12"
    };
    UTILITY_TYPES = ["electricity", "water", "internet", "gas", "waste", "security"];
    TASK_STATUSES = ["pending", "completed", "in-progress", "cancelled"];
  }
});

// server/cortex/connectors.ts
async function executeWithRetry(fn, maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT) {
  let lastError;
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Timeout")), timeout);
      });
      const result = await Promise.race([fn(), timeoutPromise]);
      return result;
    } catch (error) {
      lastError = error;
      if (attempt < maxRetries) {
        await new Promise((resolve) => setTimeout(resolve, 100 * Math.pow(2, attempt)));
      }
    }
  }
  throw lastError || new Error("Unknown error");
}
async function fetchProperties(options) {
  const startTime = Date.now();
  const route = "/api/properties";
  const params = {
    organizationId: options.organizationId,
    name: options.name,
    id: options.id
  };
  try {
    const data = await executeWithRetry(async () => {
      if (options.id) {
        return await storage.getProperty(options.id);
      } else if (options.name) {
        const allProperties = await storage.getProperties(options.organizationId);
        return allProperties.filter(
          (p) => p.name.toLowerCase().includes(options.name.toLowerCase())
        );
      } else {
        return await storage.getProperties(options.organizationId);
      }
    }, options.maxRetries, options.timeout);
    return {
      success: true,
      data,
      route,
      params,
      latency: Date.now() - startTime
    };
  } catch (error) {
    logger.error("[CORTEX] Property connector error:", error);
    return {
      success: false,
      error: error.message,
      route,
      params,
      latency: Date.now() - startTime
    };
  }
}
async function fetchUtilityBills(options) {
  const startTime = Date.now();
  const route = "/api/utility-bills";
  const params = {
    organizationId: options.organizationId,
    propertyId: options.propertyId,
    type: options.type,
    month: options.month,
    year: options.year
  };
  try {
    const data = await executeWithRetry(async () => {
      const allBills = await storage.getUtilityBills(options.organizationId);
      let filtered = allBills;
      if (options.propertyId) {
        filtered = filtered.filter((b) => b.propertyId === options.propertyId);
      }
      if (options.type) {
        filtered = filtered.filter(
          (b) => b.utilityType?.toLowerCase() === options.type?.toLowerCase()
        );
      }
      if (options.month && options.year) {
        filtered = filtered.filter((b) => {
          const billDate = new Date(b.billMonth);
          return billDate.getMonth() + 1 === parseInt(options.month) && billDate.getFullYear() === options.year;
        });
      }
      return filtered;
    }, options.maxRetries, options.timeout);
    return {
      success: true,
      data,
      route,
      params,
      latency: Date.now() - startTime
    };
  } catch (error) {
    logger.error("[CORTEX] Utility bill connector error:", error);
    return {
      success: false,
      error: error.message,
      route,
      params,
      latency: Date.now() - startTime
    };
  }
}
async function fetchTasks(options) {
  const startTime = Date.now();
  const route = "/api/tasks";
  const params = {
    organizationId: options.organizationId,
    status: options.status,
    assignedTo: options.assignedTo,
    propertyId: options.propertyId
  };
  try {
    const data = await executeWithRetry(async () => {
      const allTasks = await storage.getTasks(options.organizationId);
      let filtered = allTasks;
      if (options.status) {
        filtered = filtered.filter((t) => t.status === options.status);
      }
      if (options.assignedTo) {
        filtered = filtered.filter((t) => t.assignedTo === options.assignedTo);
      }
      if (options.propertyId) {
        filtered = filtered.filter((t) => t.propertyId === options.propertyId);
      }
      return filtered;
    }, options.maxRetries, options.timeout);
    return {
      success: true,
      data,
      route,
      params,
      latency: Date.now() - startTime
    };
  } catch (error) {
    logger.error("[CORTEX] Task connector error:", error);
    return {
      success: false,
      error: error.message,
      route,
      params,
      latency: Date.now() - startTime
    };
  }
}
async function fetchBookings(options) {
  const startTime = Date.now();
  const route = "/api/bookings";
  const params = {
    organizationId: options.organizationId,
    propertyId: options.propertyId,
    dateFrom: options.dateFrom,
    dateTo: options.dateTo
  };
  try {
    const data = await executeWithRetry(async () => {
      const allBookings = await storage.getBookings(options.organizationId);
      let filtered = allBookings;
      if (options.propertyId) {
        filtered = filtered.filter((b) => b.propertyId === options.propertyId);
      }
      if (options.dateFrom && options.dateTo) {
        const from = new Date(options.dateFrom);
        const to = new Date(options.dateTo);
        filtered = filtered.filter((b) => {
          const checkIn = new Date(b.checkInDate);
          const checkOut = new Date(b.checkOutDate);
          return checkIn <= to && checkOut >= from;
        });
      }
      return filtered;
    }, options.maxRetries, options.timeout);
    return {
      success: true,
      data,
      route,
      params,
      latency: Date.now() - startTime
    };
  } catch (error) {
    logger.error("[CORTEX] Booking connector error:", error);
    return {
      success: false,
      error: error.message,
      route,
      params,
      latency: Date.now() - startTime
    };
  }
}
async function fetchFinances(options) {
  const startTime = Date.now();
  const route = "/api/finances";
  const params = {
    organizationId: options.organizationId,
    type: options.type,
    month: options.month,
    year: options.year
  };
  try {
    const data = await executeWithRetry(async () => {
      const allFinances = await storage.getFinances(options.organizationId);
      let filtered = allFinances;
      if (options.type) {
        filtered = filtered.filter((f) => f.type === options.type);
      }
      if (options.month && options.year) {
        filtered = filtered.filter((f) => {
          const financeDate = new Date(f.date);
          return financeDate.getMonth() + 1 === parseInt(options.month) && financeDate.getFullYear() === options.year;
        });
      }
      return filtered;
    }, options.maxRetries, options.timeout);
    return {
      success: true,
      data,
      route,
      params,
      latency: Date.now() - startTime
    };
  } catch (error) {
    logger.error("[CORTEX] Finance connector error:", error);
    return {
      success: false,
      error: error.message,
      route,
      params,
      latency: Date.now() - startTime
    };
  }
}
var DEFAULT_TIMEOUT, DEFAULT_MAX_RETRIES;
var init_connectors = __esm({
  "server/cortex/connectors.ts"() {
    "use strict";
    init_storage();
    init_logger();
    DEFAULT_TIMEOUT = 3e3;
    DEFAULT_MAX_RETRIES = 2;
  }
});

// server/cortex/grounder.ts
async function groundQuestion(intent, entities, organizationId2) {
  const startTime = Date.now();
  const sources = [];
  const groundedData = {
    metadata: {
      sources: [],
      totalLatency: 0,
      cacheHit: false
    }
  };
  try {
    if (entities.propertyName || intent.type === "property_query") {
      const propertyResult = await fetchProperties({
        organizationId: organizationId2,
        name: entities.propertyName
      });
      sources.push({
        route: propertyResult.route,
        params: propertyResult.params,
        success: propertyResult.success,
        latency: propertyResult.latency
      });
      if (propertyResult.success && propertyResult.data) {
        groundedData.properties = Array.isArray(propertyResult.data) ? propertyResult.data : [propertyResult.data];
        if (groundedData.properties.length === 1) {
          entities.propertyId = groundedData.properties[0].id;
        }
      }
    }
    if (intent.type === "utility_query" || entities.utilityType) {
      const utilityResult = await fetchUtilityBills({
        organizationId: organizationId2,
        propertyId: entities.propertyId,
        type: entities.utilityType,
        month: entities.month,
        year: entities.year
      });
      sources.push({
        route: utilityResult.route,
        params: utilityResult.params,
        success: utilityResult.success,
        latency: utilityResult.latency
      });
      if (utilityResult.success) {
        groundedData.utilityBills = utilityResult.data || [];
      }
    }
    if (intent.type === "task_query") {
      const taskResult = await fetchTasks({
        organizationId: organizationId2,
        status: entities.status,
        propertyId: entities.propertyId
      });
      sources.push({
        route: taskResult.route,
        params: taskResult.params,
        success: taskResult.success,
        latency: taskResult.latency
      });
      if (taskResult.success) {
        groundedData.tasks = taskResult.data || [];
      }
    }
    if (intent.type === "booking_query") {
      const bookingResult = await fetchBookings({
        organizationId: organizationId2,
        propertyId: entities.propertyId,
        dateFrom: entities.dateFrom,
        dateTo: entities.dateTo
      });
      sources.push({
        route: bookingResult.route,
        params: bookingResult.params,
        success: bookingResult.success,
        latency: bookingResult.latency
      });
      if (bookingResult.success) {
        groundedData.bookings = bookingResult.data || [];
      }
    }
    if (intent.type === "finance_query") {
      const financeResult = await fetchFinances({
        organizationId: organizationId2,
        type: entities.financeType,
        month: entities.month,
        year: entities.year
      });
      sources.push({
        route: financeResult.route,
        params: financeResult.params,
        success: financeResult.success,
        latency: financeResult.latency
      });
      if (financeResult.success) {
        groundedData.finances = financeResult.data || [];
      }
    }
    groundedData.metadata = {
      sources,
      totalLatency: Date.now() - startTime,
      cacheHit: false
    };
    logger.info("[CORTEX]", {
      intent: intent.type,
      organizationId: organizationId2,
      routes: sources.map((s) => s.route),
      latency: groundedData.metadata.totalLatency,
      dataFetched: {
        properties: groundedData.properties?.length || 0,
        utilityBills: groundedData.utilityBills?.length || 0,
        tasks: groundedData.tasks?.length || 0,
        bookings: groundedData.bookings?.length || 0,
        finances: groundedData.finances?.length || 0
      }
    });
    return groundedData;
  } catch (error) {
    logger.error("[CORTEX] Grounding error:", error);
    throw error;
  }
}
function normalizeDataForLLM(groundedData) {
  const parts = [];
  if (groundedData.properties && groundedData.properties.length > 0) {
    parts.push("PROPERTIES DATA:");
    groundedData.properties.forEach((p) => {
      parts.push(`- ${p.name} (ID: ${p.id}, Status: ${p.status}, Owner: ${p.ownerId || "N/A"})`);
    });
  }
  if (groundedData.utilityBills && groundedData.utilityBills.length > 0) {
    parts.push("\nUTILITY BILLS DATA:");
    groundedData.utilityBills.forEach((b) => {
      const billDate = new Date(b.billMonth).toLocaleDateString("en-US", {
        month: "long",
        year: "numeric"
      });
      parts.push(`- ${b.utilityType} bill for ${billDate}: Amount \u0E3F${b.amount}, Status: ${b.paymentStatus}, ${b.proofOfPayment ? "Proof uploaded" : "No proof"}`);
    });
  }
  if (groundedData.tasks && groundedData.tasks.length > 0) {
    parts.push("\nTASKS DATA:");
    groundedData.tasks.forEach((t) => {
      parts.push(`- ${t.title} (ID: ${t.id}, Status: ${t.status}, Priority: ${t.priority}, Assigned to: ${t.assignedTo || "Unassigned"})`);
    });
  }
  if (groundedData.bookings && groundedData.bookings.length > 0) {
    parts.push("\nBOOKINGS DATA:");
    groundedData.bookings.forEach((b) => {
      parts.push(`- Guest: ${b.guestName}, Check-in: ${b.checkInDate}, Check-out: ${b.checkOutDate}, Status: ${b.status}`);
    });
  }
  if (groundedData.finances && groundedData.finances.length > 0) {
    parts.push("\nFINANCE DATA:");
    const income = groundedData.finances.filter((f) => f.type === "income");
    const expenses = groundedData.finances.filter((f) => f.type === "expense");
    if (income.length > 0) {
      const totalIncome = income.reduce((sum4, f) => sum4 + parseFloat(f.amount || "0"), 0);
      parts.push(`- Total Income: \u0E3F${totalIncome.toFixed(2)} (${income.length} transactions)`);
    }
    if (expenses.length > 0) {
      const totalExpenses = expenses.reduce((sum4, f) => sum4 + parseFloat(f.amount || "0"), 0);
      parts.push(`- Total Expenses: \u0E3F${totalExpenses.toFixed(2)} (${expenses.length} transactions)`);
    }
    if (income.length > 0 && expenses.length > 0) {
      const totalIncome = income.reduce((sum4, f) => sum4 + parseFloat(f.amount || "0"), 0);
      const totalExpenses = expenses.reduce((sum4, f) => sum4 + parseFloat(f.amount || "0"), 0);
      const netProfit2 = totalIncome - totalExpenses;
      parts.push(`- Net Profit: \u0E3F${netProfit2.toFixed(2)}`);
    }
  }
  if (parts.length === 0) {
    return "NO DATA FOUND - The system could not find any relevant data for this query.";
  }
  return parts.join("\n");
}
var init_grounder = __esm({
  "server/cortex/grounder.ts"() {
    "use strict";
    init_connectors();
    init_logger();
  }
});

// server/cortex/answer.ts
import OpenAI from "openai";
async function generateAnswer(question, intent, groundedData) {
  const startTime = Date.now();
  try {
    const dataContext = normalizeDataForLLM(groundedData);
    const hasData = dataContext !== "NO DATA FOUND - The system could not find any relevant data for this query.";
    let answer;
    if (!hasData) {
      answer = `I couldn't find any relevant information in the internal system for your question: "${question}"

This could be because:
- The property name might be spelled differently
- The data hasn't been uploaded yet
- The time period specified doesn't have any records

Please check the property name, dates, or other details and try again.`;
    } else {
      const completion = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        // Using GPT-4o mini for cost efficiency
        temperature: 0.2,
        // Low temperature for factual responses
        messages: [
          {
            role: "system",
            content: SYSTEM_PROMPT
          },
          {
            role: "user",
            content: `QUESTION: ${question}

INTERNAL DATA:
${dataContext}

Provide a concise, data-grounded answer using ONLY the information above.`
          }
        ]
      });
      answer = completion.choices[0]?.message?.content || "I apologize, but I encountered an issue generating a response. Please try again.";
    }
    const latency = Date.now() - startTime;
    logger.info("[CORTEX] Answer generated", {
      question: question.substring(0, 100),
      intent: intent.type,
      confidence: intent.confidence,
      hasData,
      latency
    });
    return {
      answer,
      sources: groundedData.metadata.sources.map((s) => ({
        route: s.route,
        params: s.params
      })),
      latency,
      cached: false,
      intent: intent.type,
      confidence: intent.confidence
    };
  } catch (error) {
    logger.error("[CORTEX] Answer generation error:", error);
    return {
      answer: `I encountered an error processing your question. This might be due to:
- A temporary system issue
- Complex query requiring manual review

Please try rephrasing your question or contact support if the issue persists.

Error: ${error.message}`,
      sources: groundedData.metadata.sources.map((s) => ({
        route: s.route,
        params: s.params
      })),
      latency: Date.now() - startTime,
      cached: false,
      intent: intent.type,
      confidence: intent.confidence
    };
  }
}
var openai, SYSTEM_PROMPT;
var init_answer = __esm({
  "server/cortex/answer.ts"() {
    "use strict";
    init_grounder();
    init_logger();
    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    SYSTEM_PROMPT = `You are Captain Cortex for HostPilotPro, an intelligent property management assistant.

CRITICAL RULES:
1. Only answer using the provided internal data (properties/tasks/utility/finance/bookings).
2. If data is missing or ambiguous, ask for the missing fields or clearly state you cannot find it.
3. Provide concise, actionable summaries. No speculation or assumptions.
4. Always mention specific data points (dates, amounts, statuses) when available.
5. Use a professional, helpful tone.

When answering:
- Be specific: Use actual property names, dates, amounts from the data
- Be helpful: Provide context and next steps when relevant
- Be honest: If data is incomplete or missing, say so clearly
- Be concise: Keep responses focused and actionable`;
  }
});

// server/cortex/cache.ts
function generateCacheKey(question, organizationId2) {
  const normalizedQuestion = question.toLowerCase().trim();
  return `cortex:${organizationId2}:${normalizedQuestion}`;
}
function getFromCache(key) {
  const entry = cache.get(key);
  if (!entry) {
    return null;
  }
  const age = Date.now() - entry.timestamp;
  if (age > CACHE_TTL) {
    cache.delete(key);
    return null;
  }
  logger.info("[CORTEX CACHE] Hit", { key, age });
  return entry.data;
}
function setToCache(key, data) {
  cache.set(key, {
    data,
    timestamp: Date.now(),
    key
  });
  logger.info("[CORTEX CACHE] Set", { key });
}
function invalidateCache(pattern) {
  if (!pattern) {
    const size = cache.size;
    cache.clear();
    logger.info("[CORTEX CACHE] Cleared all", { entriesRemoved: size });
    return;
  }
  let removed = 0;
  for (const [key] of cache) {
    if (key.includes(pattern)) {
      cache.delete(key);
      removed++;
    }
  }
  logger.info("[CORTEX CACHE] Invalidated", { pattern, entriesRemoved: removed });
}
var CACHE_TTL, cache;
var init_cache = __esm({
  "server/cortex/cache.ts"() {
    "use strict";
    init_logger();
    CACHE_TTL = 0;
    cache = /* @__PURE__ */ new Map();
  }
});

// server/cortex/index.ts
var cortex_exports = {};
__export(cortex_exports, {
  invalidateCache: () => invalidateCache,
  processQuestion: () => processQuestion
});
async function processQuestion(request) {
  const startTime = Date.now();
  const { question, organizationId: organizationId2, userId } = request;
  try {
    const cacheKey = generateCacheKey(question, organizationId2);
    const cachedResult = getFromCache(cacheKey);
    if (cachedResult) {
      logger.info("[CORTEX] Cache hit", {
        question: question.substring(0, 100),
        organizationId: organizationId2,
        userId,
        latency: Date.now() - startTime
      });
      return {
        ...cachedResult,
        cached: true,
        question,
        organizationId: organizationId2
      };
    }
    const intent = detectIntent(question);
    if (!isActionableIntent(intent)) {
      logger.warn("[CORTEX] Low confidence intent", {
        question: question.substring(0, 100),
        intent: intent.type,
        confidence: intent.confidence
      });
      return {
        answer: `I'm not entirely sure how to help with that question. Could you please rephrase it to be more specific about:
- Which property/villa you're asking about
- What information you need (bills, tasks, bookings, finances)
- The time period or dates if relevant

Example questions:
- "Is Villa Samui's October electricity bill paid?"
- "How many pending tasks does Test Villa have?"
- "What's the net profit for September 2025?"
- "Is Test Villa booked next weekend?"`,
        sources: [],
        latency: Date.now() - startTime,
        cached: false,
        intent: intent.type,
        confidence: intent.confidence,
        question,
        organizationId: organizationId2
      };
    }
    const entities = extractEntities(question);
    logger.info("[CORTEX] Processing", {
      question: question.substring(0, 100),
      intent: intent.type,
      confidence: intent.confidence,
      entities,
      organizationId: organizationId2,
      userId
    });
    const groundedData = await groundQuestion(intent, entities, organizationId2);
    const answerResult = await generateAnswer(question, intent, groundedData);
    setToCache(cacheKey, answerResult);
    const totalLatency = Date.now() - startTime;
    logger.info("[CORTEX] Complete", {
      question: question.substring(0, 100),
      organizationId: organizationId2,
      userId,
      intent: intent.type,
      routes: answerResult.sources.map((s) => s.route),
      latency: totalLatency,
      cacheHit: false
    });
    return {
      ...answerResult,
      question,
      organizationId: organizationId2,
      latency: totalLatency
    };
  } catch (error) {
    logger.error("[CORTEX] Error", {
      question: question.substring(0, 100),
      organizationId: organizationId2,
      userId,
      error: error.message,
      latency: Date.now() - startTime
    });
    throw error;
  }
}
var init_cortex = __esm({
  "server/cortex/index.ts"() {
    "use strict";
    init_intent();
    init_extract();
    init_grounder();
    init_answer();
    init_cache();
    init_logger();
    init_cache();
  }
});

// server/ai-bot-engine.ts
var ai_bot_engine_exports = {};
__export(ai_bot_engine_exports, {
  AIBotEngine: () => AIBotEngine,
  aiBotEngine: () => aiBotEngine
});
import OpenAI2 from "openai";
var AIBotEngine, aiBotEngine;
var init_ai_bot_engine = __esm({
  "server/ai-bot-engine.ts"() {
    "use strict";
    init_storage();
    AIBotEngine = class {
      // DISABLED - Always fetch real-time data from database
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
        this.CACHE_TTL = 0;
        if (!process.env.OPENAI_API_KEY) {
          throw new Error("OPENAI_API_KEY is required for AI Bot functionality");
        }
        const apiKey = process.env.OPENAI_API_KEY.trim().replace(/^-+/, "");
        if (!apiKey || !apiKey.startsWith("sk-")) {
          throw new Error('Invalid OPENAI_API_KEY format. Expected key to start with "sk-"');
        }
        this.openai = new OpenAI2({
          apiKey
        });
        this.storage = new DatabaseStorage();
      }
      /**
       * Main entry point for AI bot queries
       */
      async processQuery(question, context) {
        try {
          console.log(`\u{1F916} AI Bot processing: "${question}" for org: ${context.organizationId}`);
          const cacheKey = `${context.organizationId}:${question.toLowerCase().trim()}`;
          const cached = this.cache.get(cacheKey);
          if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
            console.log("\u{1F4A8} Cache hit - returning cached response");
            return cached.response;
          }
          const response = await this.processQueryFast(question, context);
          this.cache.set(cacheKey, { response, timestamp: Date.now() });
          this.cleanupCache();
          return response;
        } catch (error) {
          console.error("\u274C AI Bot error:", error);
          return `I apologize, but I encountered an error while processing your question: ${error?.message || "Unknown error"}. Please try rephrasing your question or contact support if the issue persists.`;
        }
      }
      /**
       * Fast single-call query processing
       */
      async processQueryFast(question, context) {
        const [
          properties2,
          tasks2,
          bookings3,
          finances3,
          financeAnalytics,
          users3,
          staffSalaries2,
          utilityBills2,
          ownerPayouts2,
          propertyDocuments2,
          expiringDocuments,
          invoices2,
          utilityAccounts
        ] = await Promise.all([
          this.storage.getProperties(),
          this.storage.getTasks(),
          this.storage.getBookings(context.organizationId),
          this.storage.getFinances(),
          this.storage.getFinanceAnalytics().catch(() => null),
          this.storage.getUsers().catch(() => []),
          this.storage.getAllStaffSalaries(context.organizationId).catch(() => []),
          this.storage.getUtilityBills().catch(() => []),
          this.storage.getOwnerPayouts().catch(() => []),
          this.storage.getPropertyDocuments(context.organizationId).catch(() => []),
          this.storage.getExpiringDocuments(context.organizationId, 30).catch(() => []),
          this.storage.getInvoices(context.organizationId).catch(() => []),
          this.storage.getPropertyUtilityAccounts().catch(() => [])
        ]);
        console.log("\u{1F4CA} Raw data counts:", {
          properties: properties2.length,
          tasks: tasks2.length,
          bookings: bookings3.length,
          finances: finances3.length,
          users: users3.length,
          staffSalaries: staffSalaries2.length,
          utilityBills: utilityBills2.length,
          ownerPayouts: ownerPayouts2.length,
          propertyDocuments: propertyDocuments2.length,
          expiringDocuments: expiringDocuments.length,
          invoices: invoices2.length,
          utilityAccounts: utilityAccounts.length,
          hasFinanceAnalytics: !!financeAnalytics
        });
        const bookingPropertyIds = [...new Set(bookings3.map((b) => b.propertyId))].filter((id) => id);
        const financePropertyIds = [...new Set(finances3.map((f) => f.propertyId))].filter((id) => id);
        console.log("\u{1F50D} Unique booking propertyIds:", bookingPropertyIds);
        console.log("\u{1F50D} Unique finance propertyIds:", financePropertyIds.slice(0, 10));
        if (financeAnalytics) {
          console.log("\u{1F4B0} Finance Analytics:", {
            totalRevenue: financeAnalytics.totalRevenue,
            totalExpenses: financeAnalytics.totalExpenses,
            netProfit: financeAnalytics.netProfit,
            transactionCount: financeAnalytics.transactionCount
          });
        }
        const filteredProperties = properties2.filter((p) => p.organizationId === context.organizationId).map((p) => ({
          id: p.id,
          name: p.name,
          bedrooms: p.bedrooms,
          bathrooms: p.bathrooms,
          maxGuests: p.maxGuests,
          pricePerNight: p.pricePerNight,
          currency: p.currency,
          status: p.status,
          location: p.location,
          propertyType: p.propertyType,
          externalId: p.externalId,
          listingUrl: p.listingUrl
        }));
        const allOrgTasks = tasks2.filter((t) => t.organizationId === context.organizationId);
        const allOrgBookings = bookings3.filter((b) => b.organizationId === context.organizationId);
        const allOrgFinances = finances3.filter((f) => f.organizationId === context.organizationId);
        const taskStats = {
          total: allOrgTasks.length,
          completed: allOrgTasks.filter((t) => t.status === "completed").length,
          pending: allOrgTasks.filter((t) => t.status === "pending").length,
          inProgress: allOrgTasks.filter((t) => t.status === "in-progress").length,
          approved: allOrgTasks.filter((t) => t.status === "approved").length,
          highPriority: allOrgTasks.filter((t) => t.priority === "high").length,
          overdue: allOrgTasks.filter((t) => t.dueDate && new Date(t.dueDate) < /* @__PURE__ */ new Date() && t.status !== "completed").length
        };
        const bookingStats = {
          total: allOrgBookings.length,
          confirmed: allOrgBookings.filter((b) => b.status === "confirmed").length,
          pending: allOrgBookings.filter((b) => b.status === "pending").length,
          completed: allOrgBookings.filter((b) => b.status === "completed").length,
          cancelled: allOrgBookings.filter((b) => b.status === "cancelled").length
        };
        const activeBookings = allOrgBookings.filter((b) => b.status !== "cancelled");
        const totalBookingRevenue = activeBookings.reduce((sum4, b) => {
          const revenue = b.platformPayout || b.totalAmount || 0;
          return sum4 + parseFloat(revenue.toString());
        }, 0);
        const today = /* @__PURE__ */ new Date();
        const startOfToday = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        const pendingPayments = allOrgBookings.filter((b) => {
          if (b.status !== "confirmed") return false;
          const checkInDate = new Date(b.checkIn);
          const checkInDay = new Date(checkInDate.getFullYear(), checkInDate.getMonth(), checkInDate.getDate());
          return checkInDay > startOfToday;
        });
        const totalPendingAmount = pendingPayments.reduce((sum4, b) => {
          const amount = b.platformPayout || b.totalAmount || 0;
          return sum4 + parseFloat(amount.toString());
        }, 0);
        const currentMonthStart = new Date(today.getFullYear(), today.getMonth(), 1);
        const currentMonthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0);
        const monthEndExclusive = new Date(today.getFullYear(), today.getMonth() + 1, 1);
        const daysInMonth = currentMonthEnd.getDate();
        const currentMonthBookings = activeBookings.filter((b) => {
          const checkIn = new Date(b.checkIn);
          const checkInDay = new Date(checkIn.getFullYear(), checkIn.getMonth(), checkIn.getDate());
          const checkOut = new Date(b.checkOut);
          const checkOutDay = new Date(checkOut.getFullYear(), checkOut.getMonth(), checkOut.getDate());
          return checkInDay < monthEndExclusive && checkOutDay > currentMonthStart;
        });
        const currentMonthRevenue = currentMonthBookings.reduce((sum4, b) => {
          const revenue = b.platformPayout || b.totalAmount || 0;
          return sum4 + parseFloat(revenue.toString());
        }, 0);
        const totalBookingDays = currentMonthBookings.reduce((sum4, b) => {
          const checkIn = new Date(b.checkIn);
          const checkInDay = new Date(checkIn.getFullYear(), checkIn.getMonth(), checkIn.getDate());
          const checkOut = new Date(b.checkOut);
          const checkOutDay = new Date(checkOut.getFullYear(), checkOut.getMonth(), checkOut.getDate());
          const overlapStart = checkInDay > currentMonthStart ? checkInDay : currentMonthStart;
          const overlapEnd = checkOutDay < monthEndExclusive ? checkOutDay : monthEndExclusive;
          if (overlapStart < overlapEnd) {
            const days = Math.ceil((overlapEnd.getTime() - overlapStart.getTime()) / (1e3 * 60 * 60 * 24));
            return sum4 + days;
          }
          return sum4;
        }, 0);
        const propertyCount = filteredProperties.length;
        const totalAvailableDays = propertyCount * daysInMonth;
        const occupancyRate = totalAvailableDays > 0 ? Math.round(totalBookingDays / totalAvailableDays * 100) : 0;
        const financeStats = {
          total: allOrgFinances.length,
          income: allOrgFinances.filter((f) => f.type === "income").length,
          expense: allOrgFinances.filter((f) => f.type === "expense").length,
          totalIncome: allOrgFinances.filter((f) => f.type === "income").reduce((sum4, f) => sum4 + parseFloat(f.amount || 0), 0),
          totalExpense: allOrgFinances.filter((f) => f.type === "expense").reduce((sum4, f) => sum4 + parseFloat(f.amount || 0), 0),
          // Booking revenue (synchronized with dashboards)
          totalBookingRevenue,
          currentMonthRevenue,
          pendingPaymentsCount: pendingPayments.length,
          totalPendingAmount,
          occupancyRate
        };
        const allOrgUtilityBills = utilityBills2.filter((u) => u.organizationId === context.organizationId);
        const utilityStats = {
          total: allOrgUtilityBills.length,
          electricity: allOrgUtilityBills.filter((u) => u.utilityType === "electricity").length,
          water: allOrgUtilityBills.filter((u) => u.utilityType === "water").length,
          internet: allOrgUtilityBills.filter((u) => u.utilityType === "internet").length,
          gas: allOrgUtilityBills.filter((u) => u.utilityType === "gas").length,
          paid: allOrgUtilityBills.filter((u) => u.paymentStatus === "paid").length,
          pending: allOrgUtilityBills.filter((u) => u.paymentStatus === "pending").length,
          overdue: allOrgUtilityBills.filter((u) => u.paymentStatus === "overdue").length
        };
        const allOrgDocuments = propertyDocuments2.filter((d) => d.organizationId === context.organizationId);
        const now = /* @__PURE__ */ new Date();
        const documentStats = {
          total: allOrgDocuments.length,
          expiring: expiringDocuments.length,
          expired: expiringDocuments.filter((d) => d.expirationDate && new Date(d.expirationDate) < now).length,
          expiringNames: expiringDocuments.map((d) => d.title || d.originalFilename).join(", ")
        };
        console.log("\u{1F4CA} LIVE DATABASE STATS:", { taskStats, bookingStats, financeStats, utilityStats, documentStats });
        const recentTasks = allOrgTasks.slice(0, 20).map((t) => ({
          id: t.id,
          title: t.title,
          status: t.status,
          priority: t.priority,
          propertyName: t.propertyName,
          dueDate: t.dueDate
        }));
        const recentBookings = allOrgBookings.slice(0, 15).map((b) => ({
          id: b.id,
          guestName: b.guestName,
          propertyName: b.propertyName,
          checkIn: b.checkIn,
          checkOut: b.checkOut,
          totalAmount: b.totalAmount,
          status: b.status
        }));
        const recentFinances = allOrgFinances.slice(0, 20).map((f) => ({
          id: f.id,
          type: f.type,
          category: f.category,
          amount: f.amount,
          currency: f.currency,
          date: f.date,
          propertyId: f.propertyId
        }));
        const filteredSalaries = staffSalaries2.slice(0, 15);
        const filteredUtilityBills = utilityBills2.filter((u) => u.organizationId === context.organizationId).slice(0, 15);
        const filteredOwnerPayouts = ownerPayouts2.filter((p) => p.organizationId === context.organizationId).slice(0, 15);
        const filteredDocuments = propertyDocuments2.slice(0, 10);
        const filteredInvoices = invoices2.slice(0, 15);
        const filteredUtilityAccounts = utilityAccounts.filter((a) => a.organizationId === context.organizationId).slice(0, 10);
        const propertyMetrics = filteredProperties.map((property, index2) => {
          const propertyBookings = bookings3.filter(
            (b) => b.propertyId === property.id
          );
          const propertyFinances = finances3.filter(
            (f) => f.propertyId === property.id
          );
          if (index2 === 0) {
            console.log(`\u{1F50D} Matching for property ${property.id} (${property.name}):`, {
              bookingsFound: propertyBookings.length,
              financesFound: propertyFinances.length,
              sampleBooking: propertyBookings[0] ? { id: propertyBookings[0].id, propertyId: propertyBookings[0].propertyId } : "none",
              sampleFinance: propertyFinances[0] ? { id: propertyFinances[0].id, propertyId: propertyFinances[0].propertyId, amount: propertyFinances[0].amount } : "none"
            });
          }
          const activePropertyBookings = propertyBookings.filter((b) => b.status !== "cancelled");
          const bookingRevenue2 = activePropertyBookings.reduce((sum4, b) => {
            const revenue = b.platformPayout || b.totalAmount || 0;
            return sum4 + parseFloat(revenue.toString());
          }, 0);
          const totalRevenue = propertyFinances.filter((f) => f.type === "income").reduce((sum4, f) => sum4 + parseFloat(f.amount || 0), 0);
          const now2 = /* @__PURE__ */ new Date();
          const thirtyDaysAgo = new Date(now2.getTime() - 30 * 24 * 60 * 60 * 1e3);
          const monthlyRevenue = propertyFinances.filter((f) => f.type === "income" && new Date(f.date) >= thirtyDaysAgo).reduce((sum4, f) => sum4 + parseFloat(f.amount || 0), 0);
          const lastBooking = propertyBookings.length > 0 ? propertyBookings.sort(
            (a, b) => new Date(b.checkIn).getTime() - new Date(a.checkIn).getTime()
          )[0] : null;
          const recentBookings2 = propertyBookings.filter(
            (b) => new Date(b.checkIn) >= thirtyDaysAgo
          );
          const bookedDays = recentBookings2.reduce((sum4, b) => {
            const checkIn = new Date(b.checkIn);
            const checkOut = new Date(b.checkOut);
            const nights = Math.ceil((checkOut.getTime() - checkIn.getTime()) / (1e3 * 60 * 60 * 24));
            return sum4 + nights;
          }, 0);
          const occupancyRate2 = Math.min(100, Math.round(bookedDays / 30 * 100));
          const totalExpenses = propertyFinances.filter((f) => f.type === "expense").reduce((sum4, f) => sum4 + parseFloat(f.amount || 0), 0);
          const roi = totalRevenue > 0 ? (totalRevenue - totalExpenses) / totalRevenue * 100 : 0;
          return {
            ...property,
            occupancyRate: occupancyRate2,
            monthlyRevenue,
            totalRevenue,
            bookingRevenue: bookingRevenue2,
            // Total booking revenue (synchronized with dashboards)
            lastBookingDate: lastBooking ? lastBooking.checkIn : null,
            roi: Math.round(roi * 10) / 10,
            bookingCount: propertyBookings.length,
            recentBookingCount: recentBookings2.length
          };
        });
        const organizationData = {
          properties: propertyMetrics,
          tasks: recentTasks,
          bookings: recentBookings,
          finances: recentFinances,
          financeAnalytics,
          taskStats,
          bookingStats,
          financeStats,
          utilityStats,
          documentStats,
          staffSalaries: filteredSalaries,
          utilityBills: filteredUtilityBills,
          ownerPayouts: filteredOwnerPayouts,
          propertyDocuments: filteredDocuments,
          expiringDocuments,
          invoices: filteredInvoices,
          utilityAccounts: filteredUtilityAccounts
        };
        console.log("\u{1F4CB} Data fetched:", Object.keys(organizationData));
        const ASSISTANT_ID = "asst_OATIDMTgutnkdOJpTrQ9Mf7u";
        const systemPrompt = `You are Captain Cortex, the Smart Co-Pilot for Property Management by HostPilotPro, an AI assistant for a comprehensive hospitality management platform. Analyze the user's question and provide helpful responses using ALL available data from multiple modules.

Guidelines:
1. Be conversational and helpful with real-time data
2. Use specific numbers and metrics from the provided context
3. Format money in Thai Baht (\u0E3F) with proper formatting
4. Provide property-level breakdowns when relevant (occupancy rate, ROI, monthly revenue, last booking date)
5. For date-related queries, be specific about time periods
6. Always mention property names when relevant
7. Keep responses concise but data-rich
8. Use ALL real property data including comprehensive metrics (occupancy, ROI, revenue, bookings)
9. Cross-reference data between modules (e.g., property revenue + utility costs + staff salaries)
10. For revenue questions, ALWAYS use Booking Revenue (Real-Time) data - it's synchronized with the financial dashboards
11. For pending payments, use the Pending Payments count and total amount
12. For occupancy questions, use the Current Occupancy Rate stat

Current date: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}

Available data across ALL modules (LIVE DATABASE COUNTS):
- Properties: ${organizationData.properties.length} total properties (${organizationData.properties.filter((p) => p.status === "active").length} active, ${organizationData.properties.filter((p) => p.status === "inactive").length} inactive)
- Tasks: ${taskStats.total} TOTAL tasks (${taskStats.completed} completed, ${taskStats.pending} pending, ${taskStats.inProgress} in-progress, ${taskStats.approved} approved, ${taskStats.highPriority} high priority, ${taskStats.overdue} overdue)
- Bookings: ${bookingStats.total} TOTAL bookings (${bookingStats.confirmed} confirmed, ${bookingStats.pending} pending, ${bookingStats.completed} completed, ${bookingStats.cancelled} cancelled)
- Finance: ${financeStats.total} TOTAL transactions (${financeStats.income} income: \u0E3F${financeStats.totalIncome.toLocaleString()}, ${financeStats.expense} expense: \u0E3F${financeStats.totalExpense.toLocaleString()}, Net: \u0E3F${(financeStats.totalIncome - financeStats.totalExpense).toLocaleString()})
- Booking Revenue (Real-Time): Total All-Time: \u0E3F${financeStats.totalBookingRevenue.toLocaleString()}, Current Month: \u0E3F${financeStats.currentMonthRevenue.toLocaleString()}
- Pending Payments: ${financeStats.pendingPaymentsCount} bookings awaiting payment (Total: \u0E3F${financeStats.totalPendingAmount.toLocaleString()})
- Current Occupancy Rate: ${financeStats.occupancyRate}% across all properties
- Finance Analytics: ${financeAnalytics ? `Revenue: \u0E3F${financeAnalytics.totalRevenue?.toLocaleString()}, Expenses: \u0E3F${financeAnalytics.totalExpenses?.toLocaleString()}, Net Profit: \u0E3F${financeAnalytics.netProfit?.toLocaleString()}` : "Not available"}
- Utility Bills: ${utilityStats.total} TOTAL utility bills (${utilityStats.electricity} electricity, ${utilityStats.water} water, ${utilityStats.internet} internet, ${utilityStats.gas} gas | Payment: ${utilityStats.paid} paid, ${utilityStats.pending} pending, ${utilityStats.overdue} overdue)
- Utility Accounts: ${organizationData.utilityAccounts.length} utility accounts
- Staff Members: ${organizationData.staffSalaries.length} staff members (from salary & staff management)
- Owner Payouts: ${organizationData.ownerPayouts.length} payout records
- Property Documents: ${documentStats.total} TOTAL documents (${documentStats.expiring} expiring within 30 days, ${documentStats.expired} already expired)
- Expiring Documents: ${documentStats.expiringNames || "None"}
- Invoices: ${organizationData.invoices.length} invoices

IMPORTANT: When answering questions about TOTALS or COUNTS, use the statistics above (e.g., ${taskStats.total} total tasks, ${taskStats.completed} completed tasks). The detailed task/booking/finance lists below are LIMITED SAMPLES for context only.`;
        console.log("\u{1F3E0} Property Metrics Sample:", organizationData.properties.slice(0, 3).map((p) => ({
          name: p.name,
          occupancy: p.occupancyRate,
          roi: p.roi,
          monthlyRevenue: p.monthlyRevenue,
          totalRevenue: p.totalRevenue,
          bookingRevenue: p.bookingRevenue,
          bookings: p.bookingCount
        })));
        const dataSummary = `Properties (${organizationData.properties.length}):
${organizationData.properties.map((p) => `- ${p.name}: ${p.bedrooms}BR/${p.bathrooms}BA, \u0E3F${p.pricePerNight?.toLocaleString()}/night, Status: ${p.status}, Occupancy: ${p.occupancyRate}%, ROI: ${p.roi}%, Monthly Revenue: \u0E3F${p.monthlyRevenue?.toLocaleString()}, Total Revenue: \u0E3F${p.totalRevenue?.toLocaleString()}, Booking Revenue: \u0E3F${p.bookingRevenue?.toLocaleString()}, Last Booking: ${p.lastBookingDate || "None"}, Total Bookings: ${p.bookingCount}, Recent Bookings (30d): ${p.recentBookingCount}`).join("\n")}

Recent Tasks (${organizationData.tasks.length}):
${organizationData.tasks.map((t) => `- ${t.title} (${t.status}, ${t.priority}, ${t.propertyName}, due: ${t.dueDate})`).join("\n")}

Recent Bookings (${organizationData.bookings.length}):
${organizationData.bookings.map((b) => `- ${b.guestName} at ${b.propertyName} (${b.checkIn} to ${b.checkOut}), \u0E3F${b.totalAmount}, ${b.status}`).join("\n")}

Recent Finance Records (${organizationData.finances.length}):
${organizationData.finances.map((f) => `- ${f.type}: ${f.category} \u0E3F${f.amount} (${f.date})`).join("\n")}

Finance Analytics Summary:
${financeAnalytics ? `- Total Revenue: \u0E3F${financeAnalytics.totalRevenue?.toLocaleString() || 0}
- Total Expenses: \u0E3F${financeAnalytics.totalExpenses?.toLocaleString() || 0}
- Net Profit: \u0E3F${financeAnalytics.netProfit?.toLocaleString() || 0}
- Profit Margin: ${financeAnalytics.netProfit && financeAnalytics.totalRevenue ? (financeAnalytics.netProfit / financeAnalytics.totalRevenue * 100).toFixed(1) : 0}%
- Total Transactions: ${financeAnalytics.transactionCount || 0}` : "Finance analytics not available"}

Staff Members (${organizationData.staffSalaries.length}):
${organizationData.staffSalaries.length > 0 ? organizationData.staffSalaries.map((s) => `- ${s.firstName} ${s.lastName} (${s.employeeId}): ${s.position} in ${s.department}, Salary: \u0E3F${s.monthlySalary || s.hourlyRate || 0}/month, Email: ${s.email || "N/A"}, Status: ${s.status || "active"}, Started: ${s.startDate || "N/A"}`).join("\n") : "No staff members found"}

Utility Bills (${organizationData.utilityBills.length}):
${organizationData.utilityBills.length > 0 ? organizationData.utilityBills.map((u) => `- ${u.utilityType}: \u0E3F${u.amount}, Property: ${u.propertyName || u.propertyId}, Status: ${u.status}, Due: ${u.dueDate}`).join("\n") : "No utility bills found"}

Utility Accounts (${organizationData.utilityAccounts.length}):
${organizationData.utilityAccounts.length > 0 ? organizationData.utilityAccounts.map((a) => `- ${a.utilityType}: ${a.accountNumber}, Property: ${a.propertyName || a.propertyId}, Provider: ${a.providerName}`).join("\n") : "No utility accounts found"}

Owner Payouts (${organizationData.ownerPayouts.length}):
${organizationData.ownerPayouts.length > 0 ? organizationData.ownerPayouts.map((p) => `- Owner: ${p.ownerName || p.ownerId}, \u0E3F${p.amount}, Period: ${p.period}, Status: ${p.status}`).join("\n") : "No owner payouts found"}

Property Documents (${organizationData.propertyDocuments.length}):
${organizationData.propertyDocuments.length > 0 ? organizationData.propertyDocuments.map((d) => `- ${d.documentType}: ${d.documentName}, Property: ${d.propertyName || d.propertyId}, Expires: ${d.expiryDate || "N/A"}`).join("\n") : "No documents found"}

Expiring Documents within 30 days (${organizationData.expiringDocuments.length}):
${organizationData.expiringDocuments.length > 0 ? organizationData.expiringDocuments.map((d) => `- ${d.title || d.originalFilename} (Category: ${d.category}, Expires: ${d.expirationDate}, Property: ${d.propertyId})`).join("\n") : "No expiring documents"}

Invoices (${organizationData.invoices.length}):
${organizationData.invoices.length > 0 ? organizationData.invoices.map((i) => `- #${i.invoiceNumber}: \u0E3F${i.totalAmount}, Type: ${i.type}, Status: ${i.status}, Due: ${i.dueDate}`).join("\n") : "No invoices found"}`;
        const userPrompt = `Question: "${question}"

Available data:
${dataSummary}

Please provide a helpful response based on this data.`;
        let response;
        try {
          const thread = await this.openai.beta.threads.create();
          await this.openai.beta.threads.messages.create(thread.id, {
            role: "user",
            content: `${systemPrompt}

${userPrompt}`
          });
          const run = await this.openai.beta.threads.runs.create(thread.id, {
            assistant_id: ASSISTANT_ID
          });
          let runStatus = run;
          for (let i = 0; i < 30; i++) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
            runStatus = await this.openai.beta.threads.runs.retrieve(thread.id, run.id);
            if (runStatus.status === "completed") break;
            if (runStatus.status === "failed") throw new Error("Assistant run failed");
          }
          if (runStatus.status === "completed") {
            const messages = await this.openai.beta.threads.messages.list(thread.id);
            const lastMessage = messages.data[0];
            if (lastMessage.content[0].type === "text") {
              response = lastMessage.content[0].text.value;
            }
          }
        } catch (assistantError) {
          console.log("Assistant failed, falling back to direct completion");
        }
        if (!response) {
          const completion = await this.openai.chat.completions.create({
            model: "gpt-4o-mini",
            messages: [
              { role: "system", content: systemPrompt },
              { role: "user", content: userPrompt }
            ],
            temperature: 0.3,
            max_tokens: 600
          });
          response = completion.choices[0].message.content;
        }
        return response || "I apologize, but I couldn't generate a response to your question.";
      }
      /**
       * Clear cache (for maintenance)
       */
      clearCache() {
        this.cache.clear();
        console.log("\u{1F9F9} AI Bot cache cleared");
      }
      /**
       * Cleanup expired cache entries
       */
      cleanupCache() {
        const now = Date.now();
        for (const [key, value] of this.cache.entries()) {
          if (now - value.timestamp > this.CACHE_TTL) {
            this.cache.delete(key);
          }
        }
      }
      /**
       * Analyze the user question to determine what data to fetch
       */
      async analyzeQuestion(question) {
        const systemPrompt = `You are a data analyst for a property management system. Analyze the user's question and return a JSON object with the query structure.

Available data types: tasks, revenue, expenses, bookings, properties, general
Available filters: property (property name), dateRange (start/end dates), status, category

Examples:
- "What tasks do we have for tomorrow?" \u2192 {"type": "tasks", "filters": {"dateRange": {"start": "tomorrow", "end": "tomorrow"}}}
- "Revenue from [property name] in March 2025" \u2192 {"type": "revenue", "filters": {"property": "[property name]", "dateRange": {"start": "2025-03-01", "end": "2025-03-31"}}}
- "Electric charges for [property name] in May" \u2192 {"type": "expenses", "filters": {"property": "[property name]", "category": "electric", "dateRange": {"start": "2025-05-01", "end": "2025-05-31"}}}

Return only valid JSON.`;
        const completion = await this.openai.chat.completions.create({
          model: "gpt-4o-mini",
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: question }
          ],
          temperature: 0.1,
          max_tokens: 500
        });
        try {
          const analysis = JSON.parse(completion.choices[0].message.content || "{}");
          analysis.question = question;
          return analysis;
        } catch (error) {
          return {
            type: "general",
            filters: {},
            question
          };
        }
      }
      /**
       * Fetch relevant data based on query analysis
       */
      async fetchRelevantData(query, context) {
        const data = {};
        try {
          data.properties = await this.storage.getProperties();
          switch (query.type) {
            case "tasks":
              const allTasks = await this.storage.getTasks();
              data.tasks = allTasks.filter((task) => task.organizationId === context.organizationId);
              if (query.filters.dateRange) {
                data.tasks = this.filterByDateRange(data.tasks, query.filters.dateRange, "dueDate");
              }
              break;
            case "revenue":
            case "expenses":
              const allFinances = await this.storage.getFinances();
              data.finance = allFinances.filter((finance) => finance.organizationId === context.organizationId);
              if (query.filters.property) {
                const property = this.findPropertyByName(data.properties, query.filters.property);
                if (property) {
                  data.finance = data.finance.filter((f) => f.propertyId === property.id);
                }
              }
              if (query.filters.dateRange) {
                data.finance = this.filterByDateRange(data.finance, query.filters.dateRange, "date");
              }
              if (query.type === "revenue") {
                data.finance = data.finance.filter((f) => f.type === "income");
              } else if (query.type === "expenses") {
                data.finance = data.finance.filter((f) => f.type === "expense");
                if (query.filters.category) {
                  data.finance = data.finance.filter(
                    (f) => f.category?.toLowerCase().includes(query.filters.category?.toLowerCase())
                  );
                }
              }
              break;
            case "bookings":
              const allBookings = await this.storage.getBookings();
              data.bookings = allBookings.filter((booking) => booking.organizationId === context.organizationId);
              if (query.filters.property) {
                const property = this.findPropertyByName(data.properties, query.filters.property);
                if (property) {
                  data.bookings = data.bookings.filter((b) => b.propertyId === property.id);
                }
              }
              if (query.filters.dateRange) {
                data.bookings = this.filterByDateRange(data.bookings, query.filters.dateRange, "checkInDate");
              }
              break;
            case "general":
              const allTasksGeneral = await this.storage.getTasks();
              data.tasks = allTasksGeneral.filter((task) => task.organizationId === context.organizationId);
              const allFinancesGeneral = await this.storage.getFinances();
              data.finance = allFinancesGeneral.filter((finance) => finance.organizationId === context.organizationId);
              const allBookingsGeneral = await this.storage.getBookings();
              data.bookings = allBookingsGeneral.filter((booking) => booking.organizationId === context.organizationId);
              break;
          }
          return data;
        } catch (error) {
          console.error("Error fetching data:", error);
          return { error: "Failed to fetch data", properties: data.properties || [] };
        }
      }
      /**
       * Generate intelligent response using OpenAI
       */
      async generateResponse(question, data, query) {
        const systemPrompt = `You are MR Pilot, an AI assistant for a property management company. You have access to real property management data and should provide helpful, accurate answers.

Key guidelines:
1. Be conversational and helpful
2. Use specific data from the provided context
3. Format numbers clearly (use Thai Baht \u0E3F for money)
4. If no data is found, explain why and suggest alternatives
5. For date-related queries, be specific about the time period
6. Always mention property names when relevant
7. Keep responses concise but informative

Data available: ${JSON.stringify(Object.keys(data))}

Current date context: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`;
        const userPrompt = `Question: "${question}"

Available data:
${JSON.stringify(data, null, 2)}

Please provide a helpful response based on this data.`;
        const completion = await this.openai.chat.completions.create({
          model: "gpt-4o-mini",
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userPrompt }
          ],
          temperature: 0.3,
          max_tokens: 800
        });
        return completion.choices[0].message.content || "I apologize, but I couldn't generate a response to your question.";
      }
      /**
       * Helper: Find property by name (fuzzy matching)
       */
      findPropertyByName(properties2, propertyName) {
        const name = propertyName.toLowerCase();
        return properties2.find(
          (p) => p.name.toLowerCase().includes(name) || name.includes(p.name.toLowerCase())
        );
      }
      /**
       * Helper: Filter data by date range
       */
      filterByDateRange(data, dateRange, dateField) {
        if (!dateRange.start && !dateRange.end) return data;
        const start = this.parseDate(dateRange.start);
        const end = this.parseDate(dateRange.end);
        return data.filter((item) => {
          const itemDate = new Date(item[dateField]);
          if (isNaN(itemDate.getTime())) return false;
          if (start && itemDate < start) return false;
          if (end && itemDate > end) return false;
          return true;
        });
      }
      /**
       * Helper: Parse various date formats including "tomorrow", "today", etc.
       */
      parseDate(dateStr) {
        if (!dateStr) return null;
        const today = /* @__PURE__ */ new Date();
        const tomorrow = new Date(today);
        tomorrow.setDate(today.getDate() + 1);
        switch (dateStr.toLowerCase()) {
          case "today":
            return today;
          case "tomorrow":
            return tomorrow;
          case "yesterday":
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            return yesterday;
          default:
            const parsed = new Date(dateStr);
            return isNaN(parsed.getTime()) ? null : parsed;
        }
      }
      /**
       * Get suggested questions based on available data
       */
      async getSuggestedQuestions(context) {
        return [
          "What tasks do we have for tomorrow?",
          "Show me revenue for this month",
          "What are the pending bookings?",
          "What were our total expenses last month?",
          "How many properties are currently active?",
          "What tasks are overdue?",
          "Show me electric charges for this year",
          "What's our total revenue for this year?",
          "Which properties have bookings this week?",
          "What maintenance tasks are scheduled?"
        ];
      }
    };
    aiBotEngine = new AIBotEngine();
  }
});

// server/ultraFastMiddleware.ts
var ultraFastMiddleware_exports = {};
__export(ultraFastMiddleware_exports, {
  clearUltraFastCache: () => clearUltraFastCache,
  ultraFastCache: () => ultraFastCache
});
function ultraFastCache(ttlMinutes = 10) {
  return (req, res, next) => {
    const cacheKey = `${req.method}:${req.url}:${req.user?.id || "anonymous"}`;
    const cached = responseCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < cached.ttl) {
      console.log(`Ultra-fast cache hit: ${cacheKey}`);
      return res.json(cached.data);
    }
    const originalJson = res.json;
    res.json = function(data) {
      responseCache.set(cacheKey, {
        data,
        timestamp: Date.now(),
        ttl: ttlMinutes * 60 * 1e3
      });
      return originalJson.call(this, data);
    };
    next();
  };
}
function clearUltraFastCache(pattern) {
  if (pattern) {
    for (const key of responseCache.keys()) {
      if (key.includes(pattern)) {
        responseCache.delete(key);
      }
    }
  } else {
    responseCache.clear();
  }
}
var responseCache;
var init_ultraFastMiddleware = __esm({
  "server/ultraFastMiddleware.ts"() {
    "use strict";
    responseCache = /* @__PURE__ */ new Map();
    setInterval(() => {
      const now = Date.now();
      for (const [key, value] of responseCache.entries()) {
        if (now - value.timestamp > value.ttl) {
          responseCache.delete(key);
        }
      }
    }, 10 * 60 * 1e3);
  }
});

// server/propertyVisibilityStorage.ts
var propertyVisibilityStorage_exports = {};
__export(propertyVisibilityStorage_exports, {
  PropertyVisibilityStorage: () => PropertyVisibilityStorage
});
import { eq as eq7, and as and8, desc as desc3, sql as sql5 } from "drizzle-orm";
var PropertyVisibilityStorage;
var init_propertyVisibilityStorage = __esm({
  "server/propertyVisibilityStorage.ts"() {
    "use strict";
    init_db();
    init_schema();
    PropertyVisibilityStorage = class {
      constructor(organizationId2) {
        this.organizationId = organizationId2;
      }
      // ===== PROPERTY ACCESS CONTROL =====
      async getPropertyAccessControl(filters) {
        let query = db.select({
          ...propertyAccessControl,
          userName: sql5`${userManagement.firstName} || ' ' || ${userManagement.lastName}`,
          propertyName: properties.name
        }).from(propertyAccessControl).leftJoin(userManagement, eq7(propertyAccessControl.userId, userManagement.id)).leftJoin(properties, eq7(propertyAccessControl.propertyId, properties.id)).where(eq7(propertyAccessControl.organizationId, this.organizationId));
        if (filters?.userId) {
          query = query.where(and8(
            eq7(propertyAccessControl.organizationId, this.organizationId),
            eq7(propertyAccessControl.userId, filters.userId)
          ));
        }
        if (filters?.propertyId) {
          query = query.where(and8(
            eq7(propertyAccessControl.organizationId, this.organizationId),
            eq7(propertyAccessControl.propertyId, filters.propertyId)
          ));
        }
        if (filters?.canView !== void 0) {
          query = query.where(and8(
            eq7(propertyAccessControl.organizationId, this.organizationId),
            eq7(propertyAccessControl.canView, filters.canView)
          ));
        }
        if (filters?.canManage !== void 0) {
          query = query.where(and8(
            eq7(propertyAccessControl.organizationId, this.organizationId),
            eq7(propertyAccessControl.canManage, filters.canManage)
          ));
        }
        return await query.orderBy(desc3(propertyAccessControl.updatedAt));
      }
      async getPropertyAccessById(id) {
        const [result] = await db.select().from(propertyAccessControl).where(and8(
          eq7(propertyAccessControl.id, id),
          eq7(propertyAccessControl.organizationId, this.organizationId)
        ));
        return result;
      }
      async createPropertyAccess(data) {
        const [result] = await db.insert(propertyAccessControl).values({
          ...data,
          organizationId: this.organizationId
        }).returning();
        await this.updateVisibilityMatrix(data.userId);
        return result;
      }
      async updatePropertyAccess(id, data) {
        const [result] = await db.update(propertyAccessControl).set({
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and8(
          eq7(propertyAccessControl.id, id),
          eq7(propertyAccessControl.organizationId, this.organizationId)
        )).returning();
        if (result) {
          await this.updateVisibilityMatrix(result.userId);
        }
        return result;
      }
      async deletePropertyAccess(id) {
        const accessRecord = await this.getPropertyAccessById(id);
        const result = await db.delete(propertyAccessControl).where(and8(
          eq7(propertyAccessControl.id, id),
          eq7(propertyAccessControl.organizationId, this.organizationId)
        ));
        if (accessRecord && result.rowCount && result.rowCount > 0) {
          await this.updateVisibilityMatrix(accessRecord.userId);
          return true;
        }
        return false;
      }
      async bulkUpdatePropertyAccess(userId, propertyIds, accessData) {
        const results = [];
        for (const propertyId of propertyIds) {
          const [existing] = await db.select().from(propertyAccessControl).where(and8(
            eq7(propertyAccessControl.userId, userId),
            eq7(propertyAccessControl.propertyId, propertyId),
            eq7(propertyAccessControl.organizationId, this.organizationId)
          ));
          if (existing) {
            const [updated] = await db.update(propertyAccessControl).set({
              ...accessData,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq7(propertyAccessControl.id, existing.id)).returning();
            results.push(updated);
          } else {
            const [created] = await db.insert(propertyAccessControl).values({
              userId,
              propertyId,
              organizationId: this.organizationId,
              ...accessData
            }).returning();
            results.push(created);
          }
        }
        await this.updateVisibilityMatrix(userId);
        return results;
      }
      // ===== PROPERTY ACCESS TEMPLATES =====
      async getAccessTemplates(targetRole) {
        let query = db.select().from(propertyAccessTemplates).where(eq7(propertyAccessTemplates.organizationId, this.organizationId));
        if (targetRole) {
          query = query.where(and8(
            eq7(propertyAccessTemplates.organizationId, this.organizationId),
            eq7(propertyAccessTemplates.targetRole, targetRole)
          ));
        }
        return await query.orderBy(desc3(propertyAccessTemplates.createdAt));
      }
      async createAccessTemplate(data) {
        const [result] = await db.insert(propertyAccessTemplates).values({
          ...data,
          organizationId: this.organizationId
        }).returning();
        return result;
      }
      async applyTemplateToUser(templateId, userId, propertyIds) {
        const template = await db.select().from(propertyAccessTemplates).where(and8(
          eq7(propertyAccessTemplates.id, templateId),
          eq7(propertyAccessTemplates.organizationId, this.organizationId)
        ));
        if (!template[0]) {
          throw new Error("Template not found");
        }
        const templateData = template[0];
        const accessData = {
          canView: templateData.defaultCanView,
          canManage: templateData.defaultCanManage,
          canReceiveTasks: templateData.defaultCanReceiveTasks,
          hasFinancialAccess: templateData.defaultFinancialAccess,
          hasMaintenanceAccess: templateData.defaultMaintenanceAccess,
          hasGuestBookingAccess: templateData.defaultGuestBookingAccess,
          hasUtilitiesAccess: templateData.defaultUtilitiesAccess,
          hasPropertyInfoAccess: templateData.defaultPropertyInfoAccess,
          hasServiceOrderAccess: templateData.defaultServiceOrderAccess,
          assignedBy: templateData.createdBy
        };
        return await this.bulkUpdatePropertyAccess(userId, propertyIds, accessData);
      }
      // ===== PROPERTY VISIBILITY MATRIX =====
      async getVisibilityMatrix(filters) {
        let query = db.select({
          ...propertyVisibilityMatrix,
          userName: sql5`${userManagement.firstName} || ' ' || ${userManagement.lastName}`,
          userRole: userManagement.primaryRole,
          userEmail: userManagement.email,
          lastLoginAt: userManagement.lastLoginAt
        }).from(propertyVisibilityMatrix).leftJoin(userManagement, eq7(propertyVisibilityMatrix.userId, userManagement.id)).where(eq7(propertyVisibilityMatrix.organizationId, this.organizationId));
        if (filters?.userId) {
          query = query.where(and8(
            eq7(propertyVisibilityMatrix.organizationId, this.organizationId),
            eq7(propertyVisibilityMatrix.userId, filters.userId)
          ));
        }
        if (filters?.accessLevel) {
          query = query.where(and8(
            eq7(propertyVisibilityMatrix.organizationId, this.organizationId),
            eq7(propertyVisibilityMatrix.accessLevel, filters.accessLevel)
          ));
        }
        if (filters?.hasFullAccess !== void 0) {
          query = query.where(and8(
            eq7(propertyVisibilityMatrix.organizationId, this.organizationId),
            eq7(propertyVisibilityMatrix.hasFullAccess, filters.hasFullAccess)
          ));
        }
        return await query.orderBy(desc3(propertyVisibilityMatrix.lastUpdated));
      }
      async updateVisibilityMatrix(userId) {
        const accessRecords = await this.getPropertyAccessControl({ userId });
        const propertiesLinked = accessRecords.map((record) => record.propertyId);
        const hasFullAccess = accessRecords.every(
          (record) => record.canView && record.canManage && record.canReceiveTasks
        );
        const hasRestrictedAccess = accessRecords.some(
          (record) => !record.hasFinancialAccess || !record.hasMaintenanceAccess || !record.hasGuestBookingAccess || !record.hasUtilitiesAccess || !record.hasPropertyInfoAccess || !record.hasServiceOrderAccess
        );
        let accessLevel = "read-only";
        if (hasFullAccess && !hasRestrictedAccess) {
          accessLevel = "full";
        } else if (accessRecords.some((record) => record.canManage)) {
          accessLevel = "partial";
        }
        const [existing] = await db.select().from(propertyVisibilityMatrix).where(and8(
          eq7(propertyVisibilityMatrix.userId, userId),
          eq7(propertyVisibilityMatrix.organizationId, this.organizationId)
        ));
        if (existing) {
          const [updated] = await db.update(propertyVisibilityMatrix).set({
            propertiesLinked: JSON.stringify(propertiesLinked),
            accessLevel,
            hasFullAccess,
            hasRestrictedAccess,
            lastUpdated: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq7(propertyVisibilityMatrix.id, existing.id)).returning();
          return updated;
        } else {
          const [created] = await db.insert(propertyVisibilityMatrix).values({
            userId,
            organizationId: this.organizationId,
            propertiesLinked: JSON.stringify(propertiesLinked),
            accessLevel,
            hasFullAccess,
            hasRestrictedAccess,
            lastUpdated: /* @__PURE__ */ new Date()
          }).returning();
          return created;
        }
      }
      // ===== USER SESSION PERMISSIONS =====
      async getUserSessionPermissions(userId, sessionId) {
        let query = db.select().from(userSessionPermissions).where(and8(
          eq7(userSessionPermissions.userId, userId),
          eq7(userSessionPermissions.organizationId, this.organizationId),
          eq7(userSessionPermissions.isActive, true)
        ));
        if (sessionId) {
          query = query.where(and8(
            eq7(userSessionPermissions.userId, userId),
            eq7(userSessionPermissions.organizationId, this.organizationId),
            eq7(userSessionPermissions.sessionId, sessionId),
            eq7(userSessionPermissions.isActive, true)
          ));
        }
        const [result] = await query.orderBy(desc3(userSessionPermissions.lastSyncAt));
        return result;
      }
      async syncUserSessionPermissions(userId, sessionId) {
        const accessRecords = await this.getPropertyAccessControl({ userId });
        const permissionsCache = {
          properties: accessRecords.reduce((acc, record) => {
            acc[record.propertyId] = {
              canView: record.canView,
              canManage: record.canManage,
              canReceiveTasks: record.canReceiveTasks,
              hasFinancialAccess: record.hasFinancialAccess,
              hasMaintenanceAccess: record.hasMaintenanceAccess,
              hasGuestBookingAccess: record.hasGuestBookingAccess,
              hasUtilitiesAccess: record.hasUtilitiesAccess,
              hasPropertyInfoAccess: record.hasPropertyInfoAccess,
              hasServiceOrderAccess: record.hasServiceOrderAccess
            };
            return acc;
          }, {}),
          lastSyncAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        const propertyAccessCache = accessRecords.reduce((acc, record) => {
          acc[record.propertyId] = record;
          return acc;
        }, {});
        const [existing] = await db.select().from(userSessionPermissions).where(and8(
          eq7(userSessionPermissions.userId, userId),
          eq7(userSessionPermissions.sessionId, sessionId),
          eq7(userSessionPermissions.organizationId, this.organizationId)
        ));
        if (existing) {
          const [updated] = await db.update(userSessionPermissions).set({
            permissionsCache: JSON.stringify(permissionsCache),
            propertyAccessCache: JSON.stringify(propertyAccessCache),
            lastSyncAt: /* @__PURE__ */ new Date(),
            syncVersion: existing.syncVersion + 1,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq7(userSessionPermissions.id, existing.id)).returning();
          return updated;
        } else {
          const [created] = await db.insert(userSessionPermissions).values({
            userId,
            sessionId,
            organizationId: this.organizationId,
            permissionsCache: JSON.stringify(permissionsCache),
            propertyAccessCache: JSON.stringify(propertyAccessCache),
            expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1e3)
            // 24 hours
          }).returning();
          return created;
        }
      }
      // ===== DEMO DATA METHODS =====
      async getDemoVisibilityMatrix() {
        return [
          {
            id: 1,
            organizationId: this.organizationId,
            userId: "demo-owner",
            propertiesLinked: JSON.stringify([3, 4]),
            accessLevel: "partial",
            lastUpdated: /* @__PURE__ */ new Date("2025-01-05T10:00:00Z"),
            lastUpdatedBy: "demo-admin",
            hasFullAccess: false,
            hasRestrictedAccess: true,
            requiresReview: false,
            createdAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-05T10:00:00Z"),
            userName: "John Owner",
            userRole: "owner",
            userEmail: "demo-owner@demo.com",
            lastLoginAt: /* @__PURE__ */ new Date("2025-01-05T09:30:00Z")
          },
          {
            id: 2,
            organizationId: this.organizationId,
            userId: "demo-staff",
            propertiesLinked: JSON.stringify([3, 4, 5]),
            accessLevel: "read-only",
            lastUpdated: /* @__PURE__ */ new Date("2025-01-05T11:00:00Z"),
            lastUpdatedBy: "demo-admin",
            hasFullAccess: false,
            hasRestrictedAccess: false,
            requiresReview: false,
            createdAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-05T11:00:00Z"),
            userName: "Jane Staff",
            userRole: "staff",
            userEmail: "demo-staff@demo.com",
            lastLoginAt: /* @__PURE__ */ new Date("2025-01-05T08:15:00Z")
          },
          {
            id: 3,
            organizationId: this.organizationId,
            userId: "demo-agent-retail",
            propertiesLinked: JSON.stringify([3, 4, 5, 6]),
            accessLevel: "full",
            lastUpdated: /* @__PURE__ */ new Date("2025-01-05T12:00:00Z"),
            lastUpdatedBy: "demo-admin",
            hasFullAccess: true,
            hasRestrictedAccess: false,
            requiresReview: false,
            createdAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-05T12:00:00Z"),
            userName: "Mike Agent",
            userRole: "retail-agent",
            userEmail: "demo-agent-retail@demo.com",
            lastLoginAt: /* @__PURE__ */ new Date("2025-01-05T07:45:00Z")
          }
        ];
      }
      async getDemoPropertyAccess() {
        return [
          {
            id: 1,
            organizationId: this.organizationId,
            userId: "demo-owner",
            propertyId: 3,
            canView: true,
            canManage: true,
            canReceiveTasks: false,
            hasFinancialAccess: true,
            hasMaintenanceAccess: false,
            // Restricted
            hasGuestBookingAccess: true,
            hasUtilitiesAccess: true,
            hasPropertyInfoAccess: true,
            hasServiceOrderAccess: false,
            // Restricted
            assignedBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-05T10:00:00Z"),
            userName: "John Owner",
            propertyName: "Property"
          },
          {
            id: 2,
            organizationId: this.organizationId,
            userId: "demo-staff",
            propertyId: 3,
            canView: true,
            canManage: false,
            canReceiveTasks: true,
            hasFinancialAccess: false,
            hasMaintenanceAccess: true,
            hasGuestBookingAccess: true,
            hasUtilitiesAccess: false,
            hasPropertyInfoAccess: true,
            hasServiceOrderAccess: true,
            assignedBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-05T11:00:00Z"),
            userName: "Jane Staff",
            propertyName: "Property"
          },
          {
            id: 3,
            organizationId: this.organizationId,
            userId: "demo-agent-retail",
            propertyId: 3,
            canView: true,
            canManage: true,
            canReceiveTasks: false,
            hasFinancialAccess: true,
            hasMaintenanceAccess: true,
            hasGuestBookingAccess: true,
            hasUtilitiesAccess: true,
            hasPropertyInfoAccess: true,
            hasServiceOrderAccess: true,
            assignedBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-05T12:00:00Z"),
            userName: "Mike Agent",
            propertyName: "Property"
          }
        ];
      }
      async getDemoAccessTemplates() {
        return [
          {
            id: 1,
            organizationId: this.organizationId,
            templateName: "Owner Default",
            targetRole: "owner",
            description: "Default permissions for property owners",
            defaultCanView: true,
            defaultCanManage: true,
            defaultCanReceiveTasks: false,
            defaultFinancialAccess: true,
            defaultMaintenanceAccess: true,
            defaultGuestBookingAccess: true,
            defaultUtilitiesAccess: true,
            defaultPropertyInfoAccess: true,
            defaultServiceOrderAccess: true,
            createdBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z")
          },
          {
            id: 2,
            organizationId: this.organizationId,
            templateName: "Staff Standard",
            targetRole: "staff",
            description: "Standard permissions for staff members",
            defaultCanView: true,
            defaultCanManage: false,
            defaultCanReceiveTasks: true,
            defaultFinancialAccess: false,
            defaultMaintenanceAccess: true,
            defaultGuestBookingAccess: true,
            defaultUtilitiesAccess: false,
            defaultPropertyInfoAccess: true,
            defaultServiceOrderAccess: true,
            createdBy: "demo-admin",
            createdAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z"),
            updatedAt: /* @__PURE__ */ new Date("2025-01-01T00:00:00Z")
          }
        ];
      }
    };
  }
});

// server/services/taskService.ts
import { eq as eq8, and as and9, gte as gte3, lte as lte3, ne as ne2 } from "drizzle-orm";
async function getUpcomingTasks() {
  const today = /* @__PURE__ */ new Date();
  const in7Days = /* @__PURE__ */ new Date();
  in7Days.setDate(today.getDate() + 7);
  try {
    const allTasks = await db.select().from(tasks).limit(5);
    console.log("Sample tasks in database:", allTasks.length);
    if (allTasks.length === 0) {
      console.log("No tasks found in database");
      return [];
    }
    const upcomingTasks = await db.select().from(tasks).where(
      and9(
        gte3(tasks.dueDate, today),
        lte3(tasks.dueDate, in7Days),
        ne2(tasks.status, "completed")
      )
    ).limit(10);
    return upcomingTasks;
  } catch (error) {
    console.error("Error fetching upcoming tasks:", error);
    return [
      {
        title: "Pool Cleaning",
        dueDate: /* @__PURE__ */ new Date(),
        priority: "high",
        status: "pending",
        property: "Property"
      },
      {
        title: "Guest Check-in Preparation",
        dueDate: /* @__PURE__ */ new Date(),
        priority: "medium",
        status: "pending",
        property: "Property"
      }
    ];
  }
}
var init_taskService = __esm({
  "server/services/taskService.ts"() {
    "use strict";
    init_db();
    init_schema();
  }
});

// server/aiHelper.ts
var aiHelper_exports = {};
__export(aiHelper_exports, {
  analyzeGuestReview: () => analyzeGuestReview,
  askAssistant: () => askAssistant,
  generateMaintenanceTaskSuggestion: () => generateMaintenanceTaskSuggestion,
  generatePropertyDescription: () => generatePropertyDescription,
  generateSmartGuestResponse: () => generateSmartGuestResponse
});
import OpenAI3 from "openai";
async function askAssistant(prompt, organizationId2 = "default-org") {
  try {
    console.log("Making OpenAI API call with prompt:", prompt.substring(0, 100) + "...");
    if (!process.env.OPENAI_API_KEY) {
      throw new Error("OpenAI API key not configured");
    }
    const properties2 = await storage.getProperties(organizationId2);
    const propertyList = properties2.length > 0 ? properties2.map((p) => `\u2022 ${p.name} (${p.bedrooms}BR/${p.bathrooms}BA, ${p.status})`).join("\n") : "No properties found.";
    const tasks2 = await getUpcomingTasks();
    const taskSummary = tasks2.length > 0 ? tasks2.map((t) => `\u2022 ${t.title} at ${t.property || "Unknown Property"} (due: ${t.dueDate?.toDateString() || "No date"}) - ${t.priority} priority`).join("\n") : "No upcoming tasks in the next 7 days.";
    const systemContext = `You are Mr. Pilot, the AI assistant for HostPilotPro property management platform.

Here are the user's properties:
${propertyList}

Here are current active tasks:
${taskSummary}

You help with property management, task scheduling, guest services, and financial tracking. Use the property and task context above to provide relevant, personalized assistance.

Now answer this user query:
${prompt}`;
    const response = await openai2.chat.completions.create({
      model: "gpt-4o",
      // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
      messages: [
        {
          role: "system",
          content: systemContext
        },
        {
          role: "user",
          content: prompt
        }
      ]
    });
    console.log("OpenAI response received:", {
      choices: response.choices?.length,
      content: response.choices?.[0]?.message?.content?.substring(0, 100) + "..."
    });
    if (!response.choices || response.choices.length === 0) {
      throw new Error("No response from OpenAI API");
    }
    const content = response.choices[0].message.content;
    if (!content) {
      throw new Error("Empty response from OpenAI API");
    }
    return content;
  } catch (error) {
    console.error("OpenAI API Error details:", {
      message: error.message,
      name: error.name,
      stack: error.stack,
      status: error.status,
      type: error.type
    });
    throw new Error(`Failed to get AI response: ${error.message}`);
  }
}
async function generatePropertyDescription(propertyDetails) {
  const prompt = `Generate a compelling property description for a vacation rental with the following details:
- Name: ${propertyDetails.name}
- Bedrooms: ${propertyDetails.bedrooms}
- Bathrooms: ${propertyDetails.bathrooms}
- Location: ${propertyDetails.location}
- Amenities: ${propertyDetails.amenities.join(", ")}

Please write a professional, engaging description that would attract guests.`;
  return await askAssistant(prompt);
}
async function analyzeGuestReview(reviewText) {
  const prompt = `Analyze this guest review and provide:
1. Sentiment (positive/negative/neutral)
2. Key issues mentioned (if any)
3. Suggested improvements
4. Overall rating prediction (1-5 stars)

Review: "${reviewText}"

Please respond in JSON format.`;
  try {
    const response = await openai2.chat.completions.create({
      model: "gpt-4o",
      messages: [{ role: "user", content: prompt }],
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || "{}");
  } catch (error) {
    console.error("OpenAI API Error:", error);
    throw new Error("Failed to analyze review");
  }
}
async function generateMaintenanceTaskSuggestion(propertyType, lastMaintenanceDate) {
  const prompt = `Based on a ${propertyType} property with last maintenance done on ${lastMaintenanceDate}, suggest upcoming maintenance tasks that should be scheduled. Include:
1. Task name
2. Priority level (Low/Medium/High)
3. Estimated timeframe
4. Brief description

Respond in JSON format with an array of tasks.`;
  try {
    const response = await openai2.chat.completions.create({
      model: "gpt-4o",
      messages: [{ role: "user", content: prompt }],
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || "{}");
  } catch (error) {
    console.error("OpenAI API Error:", error);
    throw new Error("Failed to generate maintenance suggestions");
  }
}
async function generateSmartGuestResponse(guestMessage, propertyInfo) {
  const prompt = `You are a helpful property manager assistant. A guest has sent this message: "${guestMessage}"

Property context: ${JSON.stringify(propertyInfo)}

Generate a friendly, helpful response that addresses their query. Keep it professional but warm.`;
  return await askAssistant(prompt);
}
var openai2;
var init_aiHelper = __esm({
  "server/aiHelper.ts"() {
    "use strict";
    init_taskService();
    init_storage();
    openai2 = new OpenAI3({
      apiKey: process.env.OPENAI_API_KEY
    });
  }
});

// server/ownerTargetUpgradeStorage.ts
var ownerTargetUpgradeStorage_exports = {};
__export(ownerTargetUpgradeStorage_exports, {
  OwnerTargetUpgradeStorage: () => OwnerTargetUpgradeStorage
});
import { eq as eq9, and as and10, desc as desc4, sql as sql6 } from "drizzle-orm";
var OwnerTargetUpgradeStorage;
var init_ownerTargetUpgradeStorage = __esm({
  "server/ownerTargetUpgradeStorage.ts"() {
    "use strict";
    init_db();
    init_schema();
    OwnerTargetUpgradeStorage = class {
      constructor(organizationId2) {
        this.organizationId = organizationId2;
      }
      // ===== REVENUE TARGETS =====
      async getRevenueTargets(filters) {
        const conditions = [eq9(propertyRevenueTargets.organizationId, this.organizationId)];
        if (filters?.propertyId) {
          conditions.push(eq9(propertyRevenueTargets.propertyId, filters.propertyId));
        }
        if (filters?.targetYear) {
          conditions.push(eq9(propertyRevenueTargets.targetYear, filters.targetYear));
        }
        if (filters?.targetQuarter) {
          conditions.push(eq9(propertyRevenueTargets.targetQuarter, filters.targetQuarter));
        }
        if (filters?.isActive !== void 0) {
          conditions.push(eq9(propertyRevenueTargets.isActive, filters.isActive));
        }
        const targets = await db.select({
          ...propertyRevenueTargets,
          propertyName: properties.name
        }).from(propertyRevenueTargets).leftJoin(properties, eq9(propertyRevenueTargets.propertyId, properties.id)).where(and10(...conditions)).orderBy(desc4(propertyRevenueTargets.targetYear), desc4(propertyRevenueTargets.targetQuarter));
        return targets.map((target) => ({
          ...target,
          propertyName: target.propertyName || void 0
        }));
      }
      async getRevenueTarget(id) {
        const [target] = await db.select().from(propertyRevenueTargets).where(and10(
          eq9(propertyRevenueTargets.id, id),
          eq9(propertyRevenueTargets.organizationId, this.organizationId)
        ));
        return target;
      }
      async createRevenueTarget(data) {
        const [target] = await db.insert(propertyRevenueTargets).values({
          ...data,
          organizationId: this.organizationId
        }).returning();
        return target;
      }
      async updateRevenueTarget(id, data) {
        const [target] = await db.update(propertyRevenueTargets).set({
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and10(
          eq9(propertyRevenueTargets.id, id),
          eq9(propertyRevenueTargets.organizationId, this.organizationId)
        )).returning();
        return target;
      }
      async deleteRevenueTarget(id) {
        const result = await db.delete(propertyRevenueTargets).where(and10(
          eq9(propertyRevenueTargets.id, id),
          eq9(propertyRevenueTargets.organizationId, this.organizationId)
        ));
        return result.rowCount > 0;
      }
      // ===== UPGRADE WISHLIST =====
      async getUpgradeWishlist(filters) {
        const conditions = [eq9(propertyUpgradeWishlist.organizationId, this.organizationId)];
        if (filters?.propertyId) {
          conditions.push(eq9(propertyUpgradeWishlist.propertyId, filters.propertyId));
        }
        if (filters?.targetId) {
          conditions.push(eq9(propertyUpgradeWishlist.targetId, filters.targetId));
        }
        if (filters?.status) {
          conditions.push(eq9(propertyUpgradeWishlist.status, filters.status));
        }
        if (filters?.priority) {
          conditions.push(eq9(propertyUpgradeWishlist.priority, filters.priority));
        }
        if (filters?.category) {
          conditions.push(eq9(propertyUpgradeWishlist.category, filters.category));
        }
        const upgrades = await db.select({
          ...propertyUpgradeWishlist,
          propertyName: properties.name,
          targetDescription: propertyRevenueTargets.description
        }).from(propertyUpgradeWishlist).leftJoin(properties, eq9(propertyUpgradeWishlist.propertyId, properties.id)).leftJoin(propertyRevenueTargets, eq9(propertyUpgradeWishlist.targetId, propertyRevenueTargets.id)).where(and10(...conditions)).orderBy(
          sql6`CASE WHEN ${propertyUpgradeWishlist.priority} = 'high' THEN 1 
                 WHEN ${propertyUpgradeWishlist.priority} = 'medium' THEN 2 
                 ELSE 3 END`,
          propertyUpgradeWishlist.deadline
        );
        return upgrades.map((upgrade) => ({
          ...upgrade,
          propertyName: upgrade.propertyName || void 0,
          targetDescription: upgrade.targetDescription || void 0
        }));
      }
      async getUpgradeItem(id) {
        const [upgrade] = await db.select().from(propertyUpgradeWishlist).where(and10(
          eq9(propertyUpgradeWishlist.id, id),
          eq9(propertyUpgradeWishlist.organizationId, this.organizationId)
        ));
        return upgrade;
      }
      async createUpgradeItem(data) {
        const [upgrade] = await db.insert(propertyUpgradeWishlist).values({
          ...data,
          organizationId: this.organizationId
        }).returning();
        return upgrade;
      }
      async updateUpgradeItem(id, data) {
        const [upgrade] = await db.update(propertyUpgradeWishlist).set({
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and10(
          eq9(propertyUpgradeWishlist.id, id),
          eq9(propertyUpgradeWishlist.organizationId, this.organizationId)
        )).returning();
        return upgrade;
      }
      async deleteUpgradeItem(id) {
        const result = await db.delete(propertyUpgradeWishlist).where(and10(
          eq9(propertyUpgradeWishlist.id, id),
          eq9(propertyUpgradeWishlist.organizationId, this.organizationId)
        ));
        return result.rowCount > 0;
      }
      async approveUpgradeItem(id, approvedBy) {
        return this.updateUpgradeItem(id, {
          status: "confirmed",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date()
        });
      }
      async completeUpgradeItem(id) {
        return this.updateUpgradeItem(id, {
          status: "completed",
          completedAt: /* @__PURE__ */ new Date()
        });
      }
      // ===== AI SUGGESTIONS =====
      async getSuggestions(filters) {
        const conditions = [eq9(targetUpgradeSuggestions.organizationId, this.organizationId)];
        if (filters?.propertyId) {
          conditions.push(eq9(targetUpgradeSuggestions.propertyId, filters.propertyId));
        }
        if (filters?.suggestionType) {
          conditions.push(eq9(targetUpgradeSuggestions.suggestionType, filters.suggestionType));
        }
        if (filters?.isRead !== void 0) {
          conditions.push(eq9(targetUpgradeSuggestions.isRead, filters.isRead));
        }
        if (filters?.isDismissed !== void 0) {
          conditions.push(eq9(targetUpgradeSuggestions.isDismissed, filters.isDismissed));
        }
        return await db.select().from(targetUpgradeSuggestions).where(and10(...conditions)).orderBy(desc4(targetUpgradeSuggestions.createdAt));
      }
      async createSuggestion(data) {
        const [suggestion] = await db.insert(targetUpgradeSuggestions).values({
          ...data,
          organizationId: this.organizationId
        }).returning();
        return suggestion;
      }
      async markSuggestionAsRead(id) {
        const [suggestion] = await db.update(targetUpgradeSuggestions).set({ isRead: true }).where(and10(
          eq9(targetUpgradeSuggestions.id, id),
          eq9(targetUpgradeSuggestions.organizationId, this.organizationId)
        )).returning();
        return suggestion;
      }
      async dismissSuggestion(id) {
        const [suggestion] = await db.update(targetUpgradeSuggestions).set({ isDismissed: true }).where(and10(
          eq9(targetUpgradeSuggestions.id, id),
          eq9(targetUpgradeSuggestions.organizationId, this.organizationId)
        )).returning();
        return suggestion;
      }
      // ===== PROGRESS TRACKING =====
      async getProgressTracking(targetId) {
        return await db.select().from(targetProgressTracking).where(and10(
          eq9(targetProgressTracking.targetId, targetId),
          eq9(targetProgressTracking.organizationId, this.organizationId)
        )).orderBy(desc4(targetProgressTracking.recordDate));
      }
      async createProgressRecord(data) {
        const [record] = await db.insert(targetProgressTracking).values({
          ...data,
          organizationId: this.organizationId
        }).returning();
        return record;
      }
      // ===== ANALYTICS & DASHBOARD =====
      async getTargetDashboard(propertyId) {
        const propertyCondition = propertyId ? eq9(propertyRevenueTargets.propertyId, propertyId) : sql6`1=1`;
        const [stats] = await db.select({
          totalTargets: sql6`COUNT(DISTINCT ${propertyRevenueTargets.id})`,
          activeTargets: sql6`COUNT(DISTINCT CASE WHEN ${propertyRevenueTargets.isActive} = true THEN ${propertyRevenueTargets.id} END)`,
          targetsOnTrack: sql6`COUNT(DISTINCT CASE WHEN ${propertyRevenueTargets.currentRevenue}::numeric >= ${propertyRevenueTargets.targetAmount}::numeric * 0.8 THEN ${propertyRevenueTargets.id} END)`,
          totalUpgrades: sql6`COUNT(DISTINCT ${propertyUpgradeWishlist.id})`,
          pendingUpgrades: sql6`COUNT(DISTINCT CASE WHEN ${propertyUpgradeWishlist.status} IN ('planned', 'confirmed') THEN ${propertyUpgradeWishlist.id} END)`,
          completedUpgrades: sql6`COUNT(DISTINCT CASE WHEN ${propertyUpgradeWishlist.status} = 'completed' THEN ${propertyUpgradeWishlist.id} END)`,
          unreadSuggestions: sql6`COUNT(DISTINCT CASE WHEN ${targetUpgradeSuggestions.isRead} = false AND ${targetUpgradeSuggestions.isDismissed} = false THEN ${targetUpgradeSuggestions.id} END)`
        }).from(propertyRevenueTargets).leftJoin(propertyUpgradeWishlist, eq9(propertyRevenueTargets.id, propertyUpgradeWishlist.targetId)).leftJoin(targetUpgradeSuggestions, eq9(propertyRevenueTargets.propertyId, targetUpgradeSuggestions.propertyId)).where(and10(
          eq9(propertyRevenueTargets.organizationId, this.organizationId),
          propertyCondition
        ));
        return {
          totalTargets: stats.totalTargets || 0,
          activeTargets: stats.activeTargets || 0,
          targetsOnTrack: stats.targetsOnTrack || 0,
          totalUpgrades: stats.totalUpgrades || 0,
          pendingUpgrades: stats.pendingUpgrades || 0,
          completedUpgrades: stats.completedUpgrades || 0,
          unreadSuggestions: stats.unreadSuggestions || 0
        };
      }
      // ===== DEMO DATA =====
      async getDemoRevenueTargets() {
        const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        return [
          {
            id: 1,
            organizationId: this.organizationId,
            propertyId: 1,
            targetYear: currentYear,
            targetQuarter: null,
            targetAmount: "3000000.00",
            currency: "THB",
            currentRevenue: "2400000.00",
            description: "3M THB annual revenue target",
            isActive: true,
            createdBy: "demo-pm",
            createdAt: /* @__PURE__ */ new Date("2024-01-01"),
            updatedAt: /* @__PURE__ */ new Date(),
            propertyName: "Property"
          },
          {
            id: 2,
            organizationId: this.organizationId,
            propertyId: 2,
            targetYear: currentYear,
            targetQuarter: 2,
            targetAmount: "750000.00",
            currency: "THB",
            currentRevenue: "620000.00",
            description: "Q2 target with pool upgrade milestone",
            isActive: true,
            createdBy: "demo-owner",
            createdAt: /* @__PURE__ */ new Date("2024-04-01"),
            updatedAt: /* @__PURE__ */ new Date(),
            propertyName: "Property"
          }
        ];
      }
      async getDemoUpgradeWishlist() {
        return [
          {
            id: 1,
            organizationId: this.organizationId,
            propertyId: 1,
            targetId: 1,
            upgradeName: "Premium Sunbeds",
            description: "Replace old pool loungers with luxury teak sunbeds",
            triggerAmount: "2500000.00",
            estimatedCost: "180000.00",
            currency: "THB",
            priority: "high",
            status: "confirmed",
            deadline: "2024-12-31",
            category: "outdoor",
            notes: "Triggered! Revenue target 83% achieved",
            createdBy: "demo-pm",
            approvedBy: "demo-owner",
            approvedAt: /* @__PURE__ */ new Date("2024-06-15"),
            completedAt: null,
            createdAt: /* @__PURE__ */ new Date("2024-06-01"),
            updatedAt: /* @__PURE__ */ new Date(),
            propertyName: "Property",
            targetDescription: "3M THB annual revenue target"
          },
          {
            id: 2,
            organizationId: this.organizationId,
            propertyId: 1,
            targetId: 1,
            upgradeName: "Smart TV Upgrade",
            description: 'Install 65" 4K Smart TVs in all bedrooms',
            triggerAmount: "2800000.00",
            estimatedCost: "250000.00",
            currency: "THB",
            priority: "medium",
            status: "planned",
            deadline: "2025-01-31",
            category: "technology",
            notes: "Pending revenue milestone - need 400K more",
            createdBy: "demo-owner",
            approvedBy: null,
            approvedAt: null,
            completedAt: null,
            createdAt: /* @__PURE__ */ new Date("2024-06-10"),
            updatedAt: /* @__PURE__ */ new Date(),
            propertyName: "Property",
            targetDescription: "3M THB annual revenue target"
          },
          {
            id: 3,
            organizationId: this.organizationId,
            propertyId: 2,
            targetId: 2,
            upgradeName: "Outdoor Dining Set",
            description: "Teak dining table with 8 chairs for terrace",
            triggerAmount: "600000.00",
            estimatedCost: "120000.00",
            currency: "THB",
            priority: "high",
            status: "completed",
            deadline: "2024-06-30",
            category: "furniture",
            notes: "Completed ahead of schedule!",
            createdBy: "demo-pm",
            approvedBy: "demo-pm",
            approvedAt: /* @__PURE__ */ new Date("2024-05-20"),
            completedAt: /* @__PURE__ */ new Date("2024-06-25"),
            createdAt: /* @__PURE__ */ new Date("2024-05-15"),
            updatedAt: /* @__PURE__ */ new Date(),
            propertyName: "Property",
            targetDescription: "Q2 target with pool upgrade milestone"
          }
        ];
      }
      async getDemoSuggestions() {
        return [
          {
            id: 1,
            organizationId: this.organizationId,
            propertyId: 1,
            suggestionType: "price_increase",
            title: "Consider Rate Increase",
            message: "Your occupancy rate is 92% this month. Consider increasing nightly rates by 10-15% for peak season.",
            suggestedAction: "Update base rates from \u0E3F12,000 to \u0E3F13,500 for December-February",
            confidence: "0.87",
            isRead: false,
            isDismissed: false,
            metadata: {
              currentRate: 12e3,
              suggestedRate: 13500,
              occupancyRate: 0.92,
              seasonality: "peak"
            },
            createdAt: /* @__PURE__ */ new Date("2024-07-01")
          },
          {
            id: 2,
            organizationId: this.organizationId,
            propertyId: 1,
            suggestionType: "upgrade_timing",
            title: "Optimal Upgrade Window",
            message: "Low season (September-October) identified as ideal time for TV upgrades. Minimal booking disruption expected.",
            suggestedAction: "Schedule Smart TV installation for September 15-30 when occupancy drops to 45%",
            confidence: "0.91",
            isRead: true,
            isDismissed: false,
            metadata: {
              lowSeasonMonths: ["September", "October"],
              expectedOccupancy: 0.45,
              upgradeCategory: "technology"
            },
            createdAt: /* @__PURE__ */ new Date("2024-06-28")
          },
          {
            id: 3,
            organizationId: this.organizationId,
            propertyId: 2,
            suggestionType: "performance_alert",
            title: "Q2 Target Exceeded!",
            message: "Congratulations! You've exceeded your Q2 target by 12%. Consider setting a stretch goal for Q3.",
            suggestedAction: "Set Q3 target at \u0E3F800,000 (20% increase) and plan kitchen appliance upgrades",
            confidence: "0.95",
            isRead: false,
            isDismissed: false,
            metadata: {
              targetAmount: 75e4,
              actualAmount: 84e4,
              exceededBy: 0.12,
              quarter: 2
            },
            createdAt: /* @__PURE__ */ new Date("2024-07-02")
          }
        ];
      }
    };
  }
});

// server/portfolioManagerDemo.ts
var portfolioManagerDemo_exports = {};
__export(portfolioManagerDemo_exports, {
  DEMO_PM_DATA: () => DEMO_PM_DATA,
  getDemoPortfolioData: () => getDemoPortfolioData,
  getDemoPropertyAccess: () => getDemoPropertyAccess
});
function getDemoPortfolioData(managerId) {
  if (managerId === "manager@test.com") {
    return DEMO_PM_DATA;
  }
  return null;
}
function getDemoPropertyAccess(managerId, propertyId) {
  const demoData = getDemoPortfolioData(managerId);
  if (!demoData) return [];
  if (propertyId && propertyId !== 999) return [];
  return [{
    ...demoData.demoProperty,
    ownerName: "Sarah Wilson",
    ownerEmail: "sarah.wilson@email.com",
    ownerPhone: "+1 555 123 4567",
    currentGuest: "John Smith",
    guestEmail: "john.smith@email.com",
    guestPhone: "+1 555 987 6543",
    checkInDate: "2024-07-05",
    checkOutDate: "2024-07-10",
    accessCodes: {
      wifi: "Demo1234Wifi",
      safe: "4567",
      gate: "1234",
      parking: "5678"
    }
  }];
}
var DEMO_PM_DATA;
var init_portfolioManagerDemo = __esm({
  "server/portfolioManagerDemo.ts"() {
    "use strict";
    DEMO_PM_DATA = {
      // Demo Portfolio Manager User
      portfolioManager: {
        id: "manager@test.com",
        email: "manager@test.com",
        role: "portfolio-manager",
        firstName: "Portfolio",
        lastName: "Manager",
        organizationId: "default-org"
      },
      // Demo Property assigned to Portfolio Manager
      demoProperty: {
        id: 999,
        name: "Villa Demo1234",
        address: "123 Demo Street, Samui, Thailand",
        bedrooms: 4,
        bathrooms: 3,
        maxGuests: 8,
        pricePerNight: 250,
        currency: "USD",
        isActive: true,
        organizationId: "default-org",
        ownerId: "owner@demo.com",
        description: "Luxury 4-bedroom villa with private pool and ocean views",
        amenities: ["Pool", "WiFi", "Air Conditioning", "Kitchen", "Parking"],
        checkInTime: "15:00",
        checkOutTime: "11:00",
        coordinates: "9.5012, 100.0074",
        houseRules: "No smoking, No pets, Quiet hours 10PM-8AM",
        wifiPassword: "Demo1234Wifi",
        safeCode: "4567",
        emergencyContact: "+66 123 456 789"
      },
      // Portfolio Manager Assignment
      assignment: {
        id: 1,
        organizationId: "default-org",
        managerId: "manager@test.com",
        propertyId: 999,
        assignedBy: "admin@test.com",
        assignedAt: "2024-01-01",
        isActive: true
      },
      // Demo Financial Overview
      financialOverview: {
        totalCommissionEarnings: 15750,
        propertyBreakdown: [
          {
            propertyId: 999,
            propertyName: "Villa Demo1234",
            commissionEarned: 15750,
            bookingCount: 12,
            totalRevenue: 52500,
            commissionRate: 30
          }
        ],
        monthlyTrend: [
          { month: "Jan 2024", earnings: 2500, bookings: 2 },
          { month: "Feb 2024", earnings: 3250, bookings: 3 },
          { month: "Mar 2024", earnings: 2750, bookings: 2 },
          { month: "Apr 2024", earnings: 3500, bookings: 3 },
          { month: "May 2024", earnings: 1875, bookings: 1 },
          { month: "Jun 2024", earnings: 1875, bookings: 1 }
        ]
      },
      // Demo Task Logs
      taskLogs: [
        {
          id: 1,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          taskType: "cleaning",
          title: "Post-checkout cleaning",
          description: "Deep clean villa after guest departure",
          assignedTo: "Cleaning Team",
          status: "completed",
          priority: "normal",
          scheduledDate: "2024-07-01",
          completedDate: "2024-07-01",
          completedBy: "pm@demo.com",
          notes: "Cleaned thoroughly, ready for next guest"
        },
        {
          id: 2,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          taskType: "maintenance",
          title: "Pool maintenance",
          description: "Weekly pool cleaning and chemical balance",
          assignedTo: "Pool Service",
          status: "completed",
          priority: "normal",
          scheduledDate: "2024-07-02",
          completedDate: "2024-07-02",
          completedBy: "pool@service.com",
          notes: "Pool cleaned and balanced"
        },
        {
          id: 3,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          taskType: "inspection",
          title: "Pre-arrival inspection",
          description: "Check villa before guest check-in",
          assignedTo: "pm@demo.com",
          status: "pending",
          priority: "high",
          scheduledDate: "2024-07-05",
          completedDate: null,
          completedBy: null,
          notes: "Scheduled for tomorrow"
        }
      ],
      // Demo Notifications
      notifications: [
        {
          id: 1,
          title: "New Booking Confirmed",
          message: "Villa Demo1234 has a new booking for July 10-15",
          type: "booking",
          priority: "normal",
          isRead: false,
          createdAt: "2024-07-04T10:30:00Z",
          propertyId: 999
        },
        {
          id: 2,
          title: "Maintenance Required",
          message: "Air conditioning service due for Villa Demo1234",
          type: "maintenance",
          priority: "high",
          isRead: false,
          createdAt: "2024-07-03T14:15:00Z",
          propertyId: 999
        },
        {
          id: 3,
          title: "Commission Payment Processed",
          message: "Your June commission of $1,875 has been processed",
          type: "financial",
          priority: "normal",
          isRead: true,
          createdAt: "2024-07-01T09:00:00Z",
          propertyId: null
        }
      ],
      // Demo Invoices
      invoices: [
        {
          id: 1,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          invoiceNumber: "INV-2024-001",
          ownerName: "Sarah Wilson",
          totalAmount: 2500,
          commissionAmount: 750,
          commissionRate: 30,
          period: "June 2024",
          status: "paid",
          dueDate: "2024-07-15",
          paidDate: "2024-07-10",
          currency: "USD"
        },
        {
          id: 2,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          invoiceNumber: "INV-2024-002",
          ownerName: "Sarah Wilson",
          totalAmount: 3500,
          commissionAmount: 1050,
          commissionRate: 30,
          period: "July 2024",
          status: "pending",
          dueDate: "2024-08-15",
          paidDate: null,
          currency: "USD"
        }
      ],
      // Demo Balance
      balance: {
        currentBalance: 4250,
        pendingCommissions: 1050,
        totalEarned: 15750,
        lastPayoutAmount: 3500,
        lastPayoutDate: "2024-06-30",
        currency: "USD"
      },
      // Demo Documents
      documents: [
        {
          id: 1,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          fileName: "Villa_Demo1234_Management_Contract.pdf",
          fileType: "contract",
          category: "Contracts",
          uploadedBy: "admin@test.com",
          uploadedAt: "2024-01-15",
          fileSize: "2.4 MB",
          accessLevel: "view",
          url: "/documents/villa-demo1234-contract.pdf"
        },
        {
          id: 2,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          fileName: "House_Rules_Villa_Demo1234.pdf",
          fileType: "rules",
          category: "House Rules",
          uploadedBy: "pm@demo.com",
          uploadedAt: "2024-02-01",
          fileSize: "1.2 MB",
          accessLevel: "edit",
          url: "/documents/villa-demo1234-rules.pdf"
        },
        {
          id: 3,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          fileName: "Appliance_Manual_AC_System.pdf",
          fileType: "manual",
          category: "Manuals",
          uploadedBy: "maintenance@demo.com",
          uploadedAt: "2024-03-10",
          fileSize: "5.8 MB",
          accessLevel: "view",
          url: "/documents/villa-demo1234-ac-manual.pdf"
        }
      ],
      // Demo Maintenance Tasks
      maintenanceTasks: [
        {
          id: 1,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          type: "AC",
          title: "AC System Service",
          description: "Annual AC system service and filter replacement",
          status: "scheduled",
          priority: "normal",
          scheduledDate: "2024-07-15",
          estimatedCost: 250,
          assignedTo: "AC Repair Co.",
          contactInfo: "+66 123 456 789",
          notes: "Schedule during vacancy period"
        },
        {
          id: 2,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          type: "Pool",
          title: "Pool Equipment Check",
          description: "Monthly pool pump and filtration system inspection",
          status: "completed",
          priority: "normal",
          scheduledDate: "2024-07-01",
          completedDate: "2024-07-01",
          actualCost: 150,
          assignedTo: "Pool Service Pro",
          contactInfo: "+66 987 654 321",
          notes: "All equipment working properly"
        },
        {
          id: 3,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          type: "Garden",
          title: "Garden Maintenance",
          description: "Weekly garden maintenance and landscaping",
          status: "recurring",
          priority: "low",
          nextScheduledDate: "2024-07-08",
          estimatedCost: 100,
          assignedTo: "Green Thumb Gardens",
          contactInfo: "+66 555 777 888",
          notes: "Weekly service every Monday"
        }
      ],
      // Demo Service Timeline
      serviceTimeline: [
        {
          id: 1,
          propertyId: 999,
          serviceType: "Pest Control",
          lastServiceDate: "2024-06-15",
          nextDueDate: "2024-09-15",
          status: "current",
          provider: "Pest Away Co.",
          cost: 200,
          notes: "Quarterly pest control service"
        },
        {
          id: 2,
          propertyId: 999,
          serviceType: "AC Service",
          lastServiceDate: "2024-05-01",
          nextDueDate: "2024-07-15",
          status: "due_soon",
          provider: "AC Repair Co.",
          cost: 250,
          notes: "Overdue by 5 days - contact for appointment"
        },
        {
          id: 3,
          propertyId: 999,
          serviceType: "Pool Service",
          lastServiceDate: "2024-07-01",
          nextDueDate: "2024-08-01",
          status: "current",
          provider: "Pool Service Pro",
          cost: 150,
          notes: "Monthly pool maintenance"
        }
      ],
      // Demo property access data
      propertyAccess: {
        properties: [
          {
            id: 999,
            name: "Villa Demo1234",
            address: "123 Ocean View Drive, Samui, Thailand",
            assignedManager: "manager@test.com",
            lastUpdated: "2024-06-15",
            accessCodes: {
              wifi: {
                network: "Villa_Demo_5G",
                password: "OceanView2024!",
                lastUpdated: "2024-06-01"
              },
              safe: {
                code: "8851",
                location: "Master bedroom closet",
                lastUpdated: "2024-05-15"
              },
              gate: {
                code: "1234#",
                type: "Keypad entry",
                lastUpdated: "2024-06-10"
              },
              parking: {
                code: "9876*",
                spaces: "2 covered spaces",
                lastUpdated: "2024-06-10"
              }
            },
            contacts: {
              owner: {
                name: "John & Sarah Smith",
                email: "owners@villademo.com",
                phone: "+66 81 234 5678",
                emergencyContact: true
              },
              cleaner: {
                name: "Mai Cleaning Services",
                phone: "+66 89 876 5432",
                schedule: "Check-out days, 2PM"
              },
              maintenance: {
                name: "Villa Maintenance Co.",
                phone: "+66 82 345 6789",
                emergency: "+66 91 234 5678"
              },
              security: {
                name: "Island Security",
                phone: "+66 85 567 8901",
                available: "24/7"
              }
            },
            emergencyInfo: {
              police: "191",
              fire: "199",
              medical: "1669",
              hospital: "Bangkok Hospital Samui: +66 77 429 500",
              electricity: "PEA Samui: +66 77 421 114"
            }
          }
        ]
      },
      // Demo documents data
      documents: [
        {
          id: 1,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          name: "Villa Ownership Certificate",
          type: "Ownership Proof",
          description: "Official ownership documentation for Villa Demo1234",
          status: "approved",
          uploadedAt: "2024-06-15",
          fileSize: "2.4 MB",
          uploadedBy: "admin@test.com",
          approvedBy: "admin@test.com",
          url: "/documents/ownership_999.pdf"
        },
        {
          id: 2,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          name: "Property Insurance Policy",
          type: "Insurance",
          description: "Current insurance policy covering property damage and liability",
          status: "approved",
          uploadedAt: "2024-06-10",
          fileSize: "1.8 MB",
          uploadedBy: "manager@test.com",
          approvedBy: "admin@test.com",
          url: "/documents/insurance_999.pdf"
        },
        {
          id: 3,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          name: "Rental License",
          type: "Rental License",
          description: "Government issued short-term rental license",
          status: "pending",
          uploadedAt: "2024-07-01",
          fileSize: "1.2 MB",
          uploadedBy: "manager@test.com",
          approvedBy: null,
          url: "/documents/license_999.pdf"
        },
        {
          id: 4,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          name: "Villa Floor Plan",
          type: "Floor Plan",
          description: "Detailed architectural floor plan with room layouts",
          status: "approved",
          uploadedAt: "2024-05-20",
          fileSize: "3.1 MB",
          uploadedBy: "admin@test.com",
          approvedBy: "admin@test.com",
          url: "/documents/floorplan_999.pdf"
        },
        {
          id: 5,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          name: "Safety Certificate",
          type: "Safety Certificate",
          description: "Fire safety and electrical safety certification",
          status: "approved",
          uploadedAt: "2024-06-25",
          fileSize: "890 KB",
          uploadedBy: "manager@test.com",
          approvedBy: "admin@test.com",
          url: "/documents/safety_999.pdf"
        }
      ],
      // Demo maintenance tasks
      maintenanceTasks: [
        {
          id: 1,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          title: "AC System Check",
          description: "Regular maintenance check for main AC unit",
          category: "HVAC",
          priority: "normal",
          status: "pending",
          createdAt: "2024-07-01",
          dueDate: "2024-07-15",
          assignedTo: "maintenance@demo.com",
          estimatedCost: 150,
          actualCost: null,
          notes: "Annual maintenance check due"
        },
        {
          id: 2,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          title: "Pool Pump Repair",
          description: "Pool pump making unusual noise, needs inspection",
          category: "Pool",
          priority: "high",
          status: "in_progress",
          createdAt: "2024-06-25",
          dueDate: "2024-07-10",
          assignedTo: "maintenance@demo.com",
          estimatedCost: 300,
          actualCost: 275,
          notes: "Technician scheduled for July 8th"
        },
        {
          id: 3,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          title: "Garden Maintenance",
          description: "Quarterly garden maintenance and landscaping",
          category: "Landscaping",
          priority: "low",
          status: "completed",
          createdAt: "2024-06-01",
          dueDate: "2024-06-30",
          assignedTo: "garden@demo.com",
          estimatedCost: 200,
          actualCost: 180,
          notes: "Completed ahead of schedule"
        }
      ],
      // Demo invoices
      invoices: [
        {
          id: 1,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          invoiceNumber: "INV-2024-001",
          type: "Commission",
          amount: 1250,
          currency: "USD",
          status: "paid",
          dueDate: "2024-06-15",
          paidDate: "2024-06-10",
          description: "Commission for June 2024 bookings",
          items: [
            { description: "Booking commission (5 nights \xD7 $250)", amount: 1250 }
          ]
        },
        {
          id: 2,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          invoiceNumber: "INV-2024-002",
          type: "Maintenance",
          amount: 450,
          currency: "USD",
          status: "pending",
          dueDate: "2024-07-15",
          paidDate: null,
          description: "Property maintenance expenses",
          items: [
            { description: "Pool pump repair", amount: 275 },
            { description: "Garden maintenance", amount: 175 }
          ]
        },
        {
          id: 3,
          propertyId: 999,
          propertyName: "Villa Demo1234",
          invoiceNumber: "INV-2024-003",
          type: "Utilities",
          amount: 320,
          currency: "USD",
          status: "overdue",
          dueDate: "2024-06-30",
          paidDate: null,
          description: "Monthly utility bills",
          items: [
            { description: "Electricity", amount: 180 },
            { description: "Water", amount: 85 },
            { description: "Internet", amount: 55 }
          ]
        }
      ]
    };
  }
});

// server/hostawayService.ts
var hostawayService_exports = {};
__export(hostawayService_exports, {
  HostawayService: () => HostawayService,
  hostawayService: () => hostawayService
});
import fetch2 from "node-fetch";
var HostawayService, hostawayService;
var init_hostawayService = __esm({
  "server/hostawayService.ts"() {
    "use strict";
    HostawayService = class {
      constructor() {
        this.baseUrl = "https://api.hostaway.com/v1";
        this.accessToken = null;
        this.tokenExpiry = 0;
        this.isConfigured = false;
        this.accountId = process.env.HOSTAWAY_ACCOUNT_ID || "";
        this.apiKey = process.env.HOSTAWAY_API_KEY || "";
        if (this.accountId && this.apiKey) {
          this.isConfigured = true;
        } else {
          console.warn(
            "\u26A0\uFE0F Hostaway credentials not configured. Please set HOSTAWAY_ACCOUNT_ID and HOSTAWAY_API_KEY environment variables."
          );
        }
      }
      checkConfiguration() {
        if (!this.isConfigured) {
          throw new Error(
            "Hostaway is not configured. Please provide HOSTAWAY_ACCOUNT_ID and HOSTAWAY_API_KEY in environment variables."
          );
        }
      }
      /**
       * Authenticate with Hostaway API using OAuth 2.0 Client Credentials flow
       */
      async authenticate() {
        this.checkConfiguration();
        if (this.accessToken && Date.now() < this.tokenExpiry) {
          return this.accessToken;
        }
        console.log("\u{1F510} Authenticating with Hostaway API...");
        console.log("\u{1F4CD} Using credentials:", {
          client_id: this.accountId ? `${this.accountId.substring(0, 4)}****` : "missing",
          client_secret: this.apiKey ? "****" : "missing",
          baseUrl: this.baseUrl
        });
        const response = await fetch2(`${this.baseUrl}/accessTokens`, {
          method: "POST",
          headers: {
            "Cache-control": "no-cache",
            "Content-type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams({
            grant_type: "client_credentials",
            client_id: this.accountId,
            client_secret: this.apiKey,
            scope: "general"
          }).toString()
        });
        console.log(
          "\u{1F4E1} Hostaway auth response status:",
          response.status,
          response.statusText
        );
        if (!response.ok) {
          const errorText = await response.text();
          console.error("\u274C Hostaway authentication failed:", {
            status: response.status,
            statusText: response.statusText,
            error: errorText.substring(0, 500)
            // Log first 500 chars
          });
          throw new Error(
            `Hostaway authentication failed: ${response.status} - ${errorText.substring(0, 200)}`
          );
        }
        const data = await response.json();
        this.accessToken = data.access_token;
        this.tokenExpiry = Date.now() + data.expires_in * 1e3 * 0.9;
        console.log("\u2705 Hostaway authentication successful");
        return this.accessToken;
      }
      /**
       * Fetch all listings/properties from Hostaway
       */
      async getListings(params) {
        const token = await this.authenticate();
        const queryParams = new URLSearchParams();
        if (params?.limit) queryParams.append("limit", params.limit.toString());
        if (params?.offset) queryParams.append("offset", params.offset.toString());
        if (params?.city) queryParams.append("city", params.city);
        if (params?.country) queryParams.append("country", params.country);
        const url = `${this.baseUrl}/listings${queryParams.toString() ? `?${queryParams.toString()}` : ""}`;
        console.log(`\u{1F4E1} Fetching Hostaway listings from: ${url}`);
        const response = await fetch2(url, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Cache-control": "no-cache"
          }
        });
        console.log(
          "\u{1F4E1} Hostaway listings response status:",
          response.status,
          response.statusText
        );
        console.log(
          "\u{1F4CB} Response content-type:",
          response.headers.get("content-type")
        );
        if (!response.ok) {
          const errorText = await response.text();
          console.error("\u274C Failed to fetch listings:", {
            status: response.status,
            error: errorText.substring(0, 500)
          });
          throw new Error(
            `Failed to fetch Hostaway listings: ${response.status} - ${errorText.substring(0, 200)}`
          );
        }
        const responseText = await response.text();
        console.log(
          "\u{1F4C4} Response type:",
          typeof responseText,
          "First 200 chars:",
          responseText.substring(0, 200)
        );
        let data;
        try {
          data = JSON.parse(responseText);
        } catch (parseError) {
          console.error(
            "\u274C JSON parse error. Response was:",
            responseText.substring(0, 1e3)
          );
          throw new Error(
            `Invalid JSON response from Hostaway: ${responseText.substring(0, 200)}`
          );
        }
        console.log(`\u2705 Retrieved ${data.result.length} listings from Hostaway`);
        return data.result;
      }
      /**
       * Get a single listing by ID
       */
      async getListing(listingId) {
        const token = await this.authenticate();
        const response = await fetch2(`${this.baseUrl}/listings/${listingId}`, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Cache-control": "no-cache"
          }
        });
        if (!response.ok) {
          if (response.status === 404) {
            return null;
          }
          const errorText = await response.text();
          throw new Error(
            `Failed to fetch Hostaway listing ${listingId}: ${response.status} ${errorText}`
          );
        }
        const data = await response.json();
        return data.result;
      }
      /**
       * Test the connection to Hostaway
       */
      async testConnection() {
        try {
          this.checkConfiguration();
          await this.authenticate();
          const listings = await this.getListings({ limit: 1 });
          return {
            success: true,
            message: "Successfully connected to Hostaway",
            listingCount: listings.length
          };
        } catch (error) {
          console.error("\u274C Hostaway connection test failed:", error);
          return {
            success: false,
            message: error.message || "Unknown error connecting to Hostaway"
          };
        }
      }
      /**
       * Map Hostaway listing to our Property model
       */
      mapHostawayListingToProperty(listing, organizationId2) {
        const address = [
          listing.street || listing.address,
          listing.city,
          listing.state,
          listing.country
        ].filter(Boolean).join(", ") || "No address provided";
        const images = [];
        console.log(`\u{1F5BC}\uFE0F [IMAGE DEBUG] Processing images for listing ${listing.id} (${listing.name})`);
        console.log(`  thumbnailUrl:`, listing.thumbnailUrl ? "EXISTS" : "MISSING");
        console.log(`  imageUrls:`, listing.imageUrls ? `ARRAY[${listing.imageUrls.length}]` : "MISSING");
        console.log(`  listingImages:`, listing.listingImages ? `ARRAY[${listing.listingImages.length}]` : "MISSING");
        const isHighQualityImage = (url) => {
          if (!url || !url.startsWith("http")) return false;
          if (url.includes("aki_policy=x_small") || url.includes("aki_policy=small")) {
            console.log(`  \u{1F6AB} Skipping low-quality thumbnail: ${url.substring(0, 80)}...`);
            return false;
          }
          return true;
        };
        const upgradeImageQuality = (url) => {
          if (url.includes("muscache.com") && url.includes("aki_policy=")) {
            return url.replace(/aki_policy=(x_small|small|medium)/, "aki_policy=large");
          }
          return url;
        };
        if (listing.listingImages && Array.isArray(listing.listingImages)) {
          const listingImgUrls = listing.listingImages.map((img) => img.url || img.large || img.original).filter(isHighQualityImage).map(upgradeImageQuality);
          images.push(...listingImgUrls);
        }
        if (listing.imageUrls && listing.imageUrls.length > 0) {
          const filteredUrls = listing.imageUrls.filter(isHighQualityImage).map(upgradeImageQuality);
          images.push(...filteredUrls);
        }
        if (listing.thumbnailUrl && isHighQualityImage(listing.thumbnailUrl)) {
          images.push(upgradeImageQuality(listing.thumbnailUrl));
        }
        const uniqueImages = Array.from(new Set(images));
        console.log(`  \u2705 Final unique images count: ${uniqueImages.length}`);
        return {
          organizationId: organizationId2,
          source: "HOSTAWAY",
          // generic identifiers
          externalId: listing.id.toString(),
          hostawayId: listing.id.toString(),
          //  NEW: explicit Hostaway mapping fields for our properties schema
          hostawayListingMapId: listing.listingMapId ?? listing.id ?? null,
          hostawayPropertyId: listing.propertyId ?? listing.id ?? null,
          hostawayAccountId: Number(this.accountId) || null,
          name: listing.name || listing.externalListingName || listing.internalListingName || "Unnamed Property",
          address,
          description: listing.description || "",
          bedrooms: listing.bedroomsNumber || listing.bedrooms || 0,
          bathrooms: listing.bathroomsNumber || listing.guestBathroomsNumber || 0,
          maxGuests: listing.guestsIncluded || listing.maxGuests || 0,
          rating: listing.starRating?.toString() || null,
          pricePerNight: listing.price?.toString() || "0",
          currency: "USD",
          // or match your properties.currency default
          status: "active",
          amenities: listing.amenities || [],
          images: uniqueImages,
          googleMapsLink: listing.latitude && listing.longitude ? `https://www.google.com/maps/search/?api=1&query=${listing.latitude},${listing.longitude}` : null,
          ownerId: null
          // Will be set to organization owner if needed
        };
      }
      /**
       * Sync Hostaway properties to database
       * Upserts properties by matching source=HOSTAWAY and externalId
       */
      /**
       * Fetch photos for a listing from Hostaway API
       */
      /**
       * Deprecated: Photos endpoint returns 404 (requires special API scope)
       * Images are now extracted directly from the listing response
       */
      async getListingPhotos(listingId) {
        console.warn(`\u26A0\uFE0F getListingPhotos() is deprecated - images are in listing response`);
        return [];
      }
      async syncPropertiesToDatabase(organizationId2) {
        try {
          this.checkConfiguration();
          console.log("\u{1F504} Starting Hostaway properties sync...");
          const listings = await this.getListings();
          console.log(`\u{1F4E6} Found ${listings.length} Hostaway listings to sync`);
          const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
          const { properties: properties2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const { eq: eq23, and: and22 } = await import("drizzle-orm");
          const syncedProperties = [];
          const errors = [];
          for (const listing of listings) {
            try {
              const propertyData = this.mapHostawayListingToProperty(
                listing,
                organizationId2
              );
              const existing = await db2.select().from(properties2).where(
                and22(
                  eq23(properties2.organizationId, organizationId2),
                  eq23(properties2.source, "HOSTAWAY"),
                  eq23(properties2.externalId, listing.id.toString())
                )
              ).limit(1);
              if (existing.length > 0) {
                const [updated] = await db2.update(properties2).set({
                  ...propertyData,
                  updatedAt: /* @__PURE__ */ new Date()
                }).where(eq23(properties2.id, existing[0].id)).returning();
                syncedProperties.push(updated);
                console.log(
                  `\u2705 Updated Hostaway property: ${propertyData.name} (ID: ${listing.id})`
                );
              } else {
                const [inserted] = await db2.insert(properties2).values(propertyData).returning();
                syncedProperties.push(inserted);
                console.log(
                  `\u2705 Created new Hostaway property: ${propertyData.name} (ID: ${listing.id})`
                );
              }
            } catch (error) {
              const errorMsg = `Failed to sync listing ${listing.id}: ${error.message}`;
              console.error("\u274C", errorMsg);
              errors.push(errorMsg);
            }
          }
          console.log(
            `\u2705 Sync complete: ${syncedProperties.length} properties synced, ${errors.length} errors`
          );
          return {
            success: errors.length === 0,
            synced: syncedProperties.length,
            errors,
            properties: syncedProperties
          };
        } catch (error) {
          console.error("\u274C Hostaway sync failed:", error);
          return {
            success: false,
            synced: 0,
            errors: [error.message]
          };
        }
      }
      /**
       * Get all reservations from Hostaway
       */
      async getReservations(params) {
        this.checkConfiguration();
        const token = await this.authenticate();
        const queryParams = new URLSearchParams();
        if (params?.listingId)
          queryParams.append("listingMapId", params.listingId.toString());
        if (params?.status) queryParams.append("status", params.status);
        if (params?.arrivalStartDate)
          queryParams.append("arrivalStartDate", params.arrivalStartDate);
        if (params?.arrivalEndDate)
          queryParams.append("arrivalEndDate", params.arrivalEndDate);
        if (params?.limit) queryParams.append("limit", params.limit.toString());
        if (params?.offset) queryParams.append("offset", params.offset.toString());
        queryParams.append("includeResources", "1");
        const url = `${this.baseUrl}/reservations?${queryParams.toString()}`;
        console.log("\u{1F4C5} Fetching reservations from Hostaway:", url);
        const response = await fetch2(url, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json"
          }
        });
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(
            `Failed to fetch reservations: ${response.status} - ${errorText}`
          );
        }
        const data = await response.json();
        console.log(`\u2705 Fetched ${data.result.length} reservations from Hostaway`);
        return data.result;
      }
      /**
       * Map Hostaway reservation to our Booking model
       */
      mapHostawayReservationToBooking(reservation, organizationId2, propertyId) {
        const statusMap = {
          new: "pending",
          confirmed: "confirmed",
          modified: "confirmed",
          cancelled: "cancelled",
          declined: "cancelled",
          expired: "cancelled",
          awaiting_payment: "pending"
        };
        const bookingStatus = statusMap[reservation.status.toLowerCase()] || "confirmed";
        const paymentStatus = reservation.isPaid ? "paid" : "pending";
        const totalAmount = reservation.totalPrice || reservation.guestTotalPrice || 0;
        const amountPaid = reservation.isPaid ? totalAmount : 0;
        const amountDue = totalAmount - amountPaid;
        return {
          organizationId: organizationId2,
          source: "HOSTAWAY",
          externalId: reservation.id.toString(),
          hostawayId: reservation.id.toString(),
          propertyId,
          guestName: reservation.guestName || `${reservation.guestFirstName || ""} ${reservation.guestLastName || ""}`.trim() || "Guest",
          guestEmail: reservation.guestEmail || null,
          guestPhone: reservation.guestPhone || null,
          checkIn: reservation.arrivalDate,
          checkOut: reservation.departureDate,
          guests: reservation.numberOfGuests || (reservation.adults || 0) + (reservation.children || 0),
          totalAmount: totalAmount.toString(),
          guestTotalPrice: reservation.guestTotalPrice?.toString() || totalAmount.toString(),
          platformPayout: reservation.totalPrice?.toString() || totalAmount.toString(),
          otaCommissionAmount: reservation.channelCommissionAmount?.toString() || null,
          otaCommissionPercentage: reservation.channelCommissionPercent?.toString() || null,
          currency: reservation.guestCurrency || "USD",
          status: bookingStatus,
          paymentStatus,
          amountPaid: amountPaid.toString(),
          amountDue: amountDue.toString(),
          specialRequests: reservation.specialRequests || null,
          bookingPlatform: "hostaway"
        };
      }
      /**
       * Sync Hostaway reservations to database
       * Must be called after properties are synced to ensure property mapping works
       */
      async syncBookingsToDatabase(organizationId2) {
        try {
          this.checkConfiguration();
          console.log("\u{1F504} Starting Hostaway bookings sync...");
          const reservations = await this.getReservations();
          console.log(
            `\u{1F4E6} Found ${reservations.length} Hostaway reservations to sync`
          );
          const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
          const { bookings: bookings3, properties: properties2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const { eq: eq23, and: and22 } = await import("drizzle-orm");
          const syncedBookings = [];
          const errors = [];
          for (const reservation of reservations) {
            try {
              const property = await db2.select().from(properties2).where(
                and22(
                  eq23(properties2.organizationId, organizationId2),
                  eq23(properties2.source, "HOSTAWAY"),
                  //  use the dedicated hostawayListingMapId column
                  eq23(properties2.hostawayListingMapId, reservation.listingMapId)
                )
              ).limit(1);
              if (property.length === 0) {
                const errorMsg = `Property not found for Hostaway listing ${reservation.listingMapId} (reservation ${reservation.id}). Please sync properties first.`;
                console.warn("\u26A0\uFE0F", errorMsg);
                errors.push(errorMsg);
                continue;
              }
              const bookingData = this.mapHostawayReservationToBooking(
                reservation,
                organizationId2,
                property[0].id
              );
              const existing = await db2.select().from(bookings3).where(
                and22(
                  eq23(bookings3.organizationId, organizationId2),
                  eq23(bookings3.source, "HOSTAWAY"),
                  eq23(bookings3.externalId, reservation.id.toString())
                )
              ).limit(1);
              if (existing.length > 0) {
                const [updated] = await db2.update(bookings3).set({
                  ...bookingData,
                  updatedAt: /* @__PURE__ */ new Date()
                }).where(eq23(bookings3.id, existing[0].id)).returning();
                syncedBookings.push(updated);
                console.log(
                  `\u2705 Updated Hostaway booking: ${bookingData.guestName} (ID: ${reservation.id})`
                );
              } else {
                const [inserted] = await db2.insert(bookings3).values(bookingData).returning();
                syncedBookings.push(inserted);
                console.log(
                  `\u2705 Created new Hostaway booking: ${bookingData.guestName} (ID: ${reservation.id})`
                );
              }
            } catch (error) {
              const errorMsg = `Failed to sync reservation ${reservation.id}: ${error.message}`;
              console.error("\u274C", errorMsg);
              errors.push(errorMsg);
            }
          }
          console.log(
            `\u2705 Bookings sync complete: ${syncedBookings.length} bookings synced, ${errors.length} errors`
          );
          return {
            success: errors.length === 0,
            synced: syncedBookings.length,
            errors,
            bookings: syncedBookings
          };
        } catch (error) {
          console.error("\u274C Hostaway bookings sync failed:", error);
          return {
            success: false,
            synced: 0,
            errors: [error.message]
          };
        }
      }
      /**
       * Create a reservation in Hostaway
       * Used by our /api/booking-revenue route when property.source = "HOSTAWAY"
       */
      async createReservation(params) {
        this.checkConfiguration();
        const token = await this.authenticate();
        const payload = {
          listingMapId: params.listingMapId,
          arrivalDate: params.arrivalDate,
          departureDate: params.departureDate,
          guestName: params.guestName,
          guestEmail: params.guestEmail,
          phone: params.guestPhone,
          numberOfGuests: params.numberOfGuests,
          specialRequests: params.specialRequests,
          //  channelId: adjust if you use a specific "Direct / Manual" channel in Hostaway
          channelId: 2e3
        };
        console.log("[HOSTAWAY] Creating reservation with payload:", payload);
        const response = await fetch2(`${this.baseUrl}/reservations`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });
        if (!response.ok) {
          const errorText = await response.text();
          console.error(
            "[HOSTAWAY] Reservation create failed:",
            response.status,
            errorText.substring(0, 500)
          );
          throw new Error(
            `Failed to create reservation in Hostaway: ${response.status} - ${errorText.substring(0, 200)}`
          );
        }
        const data = await response.json();
        const reservation = data.result ?? data;
        console.log("[HOSTAWAY] Reservation created:", reservation.id);
        return {
          id: reservation.id,
          reservationCode: reservation.reservationCode || reservation.code || null
        };
      }
    };
    hostawayService = new HostawayService();
  }
});

// server/utility-bills-routes.ts
var utility_bills_routes_exports = {};
__export(utility_bills_routes_exports, {
  default: () => utility_bills_routes_default
});
import { Router as Router3 } from "express";
import { eq as eq12, and as and12, desc as desc5 } from "drizzle-orm";
import multer from "multer";
import path3 from "path";
import fs3 from "fs";
import { fileURLToPath } from "url";
var __filename, __dirname, router3, uploadsDir, storage2, upload, utility_bills_routes_default;
var init_utility_bills_routes = __esm({
  "server/utility-bills-routes.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_demoAuth();
    __filename = fileURLToPath(import.meta.url);
    __dirname = path3.dirname(__filename);
    router3 = Router3();
    uploadsDir = path3.join(__dirname, "uploads/utility_bills");
    if (!fs3.existsSync(uploadsDir)) {
      fs3.mkdirSync(uploadsDir, { recursive: true });
    }
    storage2 = multer.diskStorage({
      destination: (req, file, cb) => {
        cb(null, uploadsDir);
      },
      filename: (req, file, cb) => {
        const unique = Date.now() + "-" + Math.round(Math.random() * 1e9);
        cb(null, unique + path3.extname(file.originalname));
      }
    });
    upload = multer({
      storage: storage2,
      limits: { fileSize: 10 * 1024 * 1024 },
      // 10 MB
      fileFilter: (req, file, cb) => {
        const allowed = ["application/pdf", "image/jpeg", "image/png", "image/jpg"];
        if (allowed.includes(file.mimetype)) {
          cb(null, true);
        } else {
          cb(new Error("Invalid file type. Only PDF, JPG, and PNG files are allowed."));
        }
      }
    });
    router3.get("/", isDemoAuthenticated, async (req, res) => {
      console.log("[UTILITY-BILLS] GET /api/utility-bills hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const order = req.query.order === "asc" ? "asc" : "desc";
        const limit = Math.min(100, Number(req.query.limit) || 50);
        const rawBills = await db.select().from(utilityBills).leftJoin(properties, eq12(utilityBills.propertyId, properties.id)).where(eq12(utilityBills.organizationId, orgId)).orderBy(order === "asc" ? utilityBills.dueDate : desc5(utilityBills.dueDate)).limit(limit);
        const bills = rawBills.map((row) => ({
          id: row.utility_bills.id,
          organizationId: row.utility_bills.organizationId,
          propertyId: row.utility_bills.propertyId,
          propertyName: row.properties?.name || null,
          type: row.utility_bills.type,
          provider: row.utility_bills.provider,
          accountNumber: row.utility_bills.accountNumber,
          amount: row.utility_bills.amount,
          currency: row.utility_bills.currency,
          dueDate: row.utility_bills.dueDate,
          billPeriodStart: row.utility_bills.billPeriodStart,
          billPeriodEnd: row.utility_bills.billPeriodEnd,
          billingMonth: row.utility_bills.billingMonth,
          status: row.utility_bills.status,
          receiptUrl: row.utility_bills.receiptUrl,
          receiptFilename: row.utility_bills.receiptFilename,
          responsibleParty: row.utility_bills.responsibleParty,
          createdAt: row.utility_bills.createdAt
        }));
        console.log("[UTILITY-BILLS] Found", bills.length, "bills");
        res.json(bills);
      } catch (err) {
        console.error("[UTILITY-BILLS] ERROR fetching bills:", err);
        res.status(500).json({ error: err.message || "Server error fetching bills" });
      }
    });
    router3.post("/", isDemoAuthenticated, upload.single("receipt"), async (req, res) => {
      console.log("[UTILITY-BILLS] POST /api/utility-bills hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const { property_id, bill_type, amount, due_date, provider, account_number, billing_month, responsible_party } = req.body;
        const file = req.file;
        if (!file) {
          return res.status(400).json({ error: "Receipt file is required" });
        }
        if (!property_id) {
          return res.status(400).json({ error: "Property ID is required" });
        }
        if (!bill_type) {
          return res.status(400).json({ error: "Bill type is required" });
        }
        if (!due_date) {
          return res.status(400).json({ error: "Due date is required" });
        }
        if (!billing_month) {
          return res.status(400).json({ error: "Billing month is required" });
        }
        const newBill = await db.insert(utilityBills).values({
          organizationId: orgId,
          propertyId: parseInt(property_id, 10),
          type: bill_type,
          provider: provider || null,
          accountNumber: account_number || null,
          amount: amount ? amount : null,
          currency: "AUD",
          dueDate: new Date(due_date),
          billingMonth: billing_month,
          status: "uploaded",
          receiptUrl: `/uploads/utility_bills/${file.filename}`,
          receiptFilename: file.originalname,
          responsibleParty: responsible_party || "owner",
          reminderSent: false,
          isRecurring: true,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        console.log("[UTILITY-BILLS] Created bill:", newBill[0]);
        const rawCreatedBill = await db.select().from(utilityBills).leftJoin(properties, eq12(utilityBills.propertyId, properties.id)).where(eq12(utilityBills.id, newBill[0].id)).limit(1);
        const createdBill = {
          ...rawCreatedBill[0].utility_bills,
          propertyName: rawCreatedBill[0].properties?.name || null
        };
        res.status(201).json({ bill: createdBill });
      } catch (err) {
        console.error("[UTILITY-BILLS] ERROR creating bill:", err);
        res.status(500).json({ error: err.message || "Server error creating bill" });
      }
    });
    router3.patch("/:id", isDemoAuthenticated, async (req, res) => {
      console.log("[UTILITY-BILLS] PATCH /api/utility-bills/:id hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const billId = parseInt(req.params.id, 10);
        const { status } = req.body;
        if (!status) {
          return res.status(400).json({ error: "Status is required" });
        }
        const validStatuses = ["pending", "uploaded", "paid", "overdue"];
        if (!validStatuses.includes(status)) {
          return res.status(400).json({ error: "Invalid status value" });
        }
        const updated = await db.update(utilityBills).set({ status }).where(and12(
          eq12(utilityBills.id, billId),
          eq12(utilityBills.organizationId, orgId)
        )).returning();
        if (!updated.length) {
          return res.status(404).json({ error: "Bill not found" });
        }
        console.log("[UTILITY-BILLS] Updated bill status:", updated[0]);
        res.json({ bill: updated[0] });
      } catch (err) {
        console.error("[UTILITY-BILLS] ERROR updating bill:", err);
        res.status(500).json({ error: err.message || "Server error updating bill" });
      }
    });
    router3.delete("/:id", isDemoAuthenticated, async (req, res) => {
      console.log("[UTILITY-BILLS] DELETE /api/utility-bills/:id hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const billId = parseInt(req.params.id, 10);
        const bill = await db.select().from(utilityBills).where(and12(
          eq12(utilityBills.id, billId),
          eq12(utilityBills.organizationId, orgId)
        )).limit(1);
        if (!bill.length) {
          return res.status(404).json({ error: "Bill not found" });
        }
        if (bill[0].receiptFilename) {
          const filePath = path3.join(uploadsDir, path3.basename(bill[0].receiptUrl || ""));
          if (fs3.existsSync(filePath)) {
            fs3.unlinkSync(filePath);
            console.log("[UTILITY-BILLS] Deleted file:", filePath);
          }
        }
        const deleted = await db.delete(utilityBills).where(and12(
          eq12(utilityBills.id, billId),
          eq12(utilityBills.organizationId, orgId)
        )).returning();
        console.log("[UTILITY-BILLS] Deleted bill:", deleted[0]);
        res.json({ message: "Bill deleted successfully", bill: deleted[0] });
      } catch (err) {
        console.error("[UTILITY-BILLS] ERROR deleting bill:", err);
        res.status(500).json({ error: err.message || "Server error deleting bill" });
      }
    });
    router3.use("/uploads", (req, res, next) => {
      console.log("[UTILITY-BILLS] Serving file:", req.path);
      next();
    });
    utility_bills_routes_default = router3;
  }
});

// server/utility-routes.ts
var utility_routes_exports = {};
__export(utility_routes_exports, {
  default: () => utility_routes_default
});
import { Router as Router4 } from "express";
import { eq as eq13, and as and13, desc as desc6 } from "drizzle-orm";
import multer2 from "multer";
import path4 from "path";
import fs4 from "fs";
import { fileURLToPath as fileURLToPath2 } from "url";
var __filename2, __dirname2, router4, uploadsDir2, storage3, upload2, utility_routes_default;
var init_utility_routes = __esm({
  "server/utility-routes.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_demoAuth();
    __filename2 = fileURLToPath2(import.meta.url);
    __dirname2 = path4.dirname(__filename2);
    router4 = Router4();
    uploadsDir2 = path4.join(__dirname2, "uploads/utility_bills");
    if (!fs4.existsSync(uploadsDir2)) {
      fs4.mkdirSync(uploadsDir2, { recursive: true });
    }
    storage3 = multer2.diskStorage({
      destination: (req, file, cb) => {
        cb(null, uploadsDir2);
      },
      filename: (req, file, cb) => {
        const unique = Date.now() + "-" + Math.round(Math.random() * 1e9);
        cb(null, unique + path4.extname(file.originalname));
      }
    });
    upload2 = multer2({
      storage: storage3,
      limits: { fileSize: 10 * 1024 * 1024 },
      // 10 MB
      fileFilter: (req, file, cb) => {
        const allowed = ["application/pdf", "image/jpeg", "image/png", "image/jpg"];
        if (allowed.includes(file.mimetype)) {
          cb(null, true);
        } else {
          cb(new Error("Invalid file type. Only PDF, JPG, and PNG files are allowed."));
        }
      }
    });
    router4.get("/accounts", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : null;
        let query = db.select().from(propertyUtilityAccounts).leftJoin(properties, eq13(propertyUtilityAccounts.propertyId, properties.id)).where(eq13(propertyUtilityAccounts.organizationId, orgId));
        if (propertyId) {
          query = query.where(and13(
            eq13(propertyUtilityAccounts.organizationId, orgId),
            eq13(propertyUtilityAccounts.propertyId, propertyId)
          ));
        }
        const rawAccounts = await query;
        const accounts = rawAccounts.map((row) => ({
          ...row.property_utility_accounts,
          propertyName: row.properties?.name || null
        }));
        res.json(accounts);
      } catch (err) {
        console.error("[UTILITY] ERROR fetching accounts:", err);
        res.status(500).json({ error: err.message || "Server error fetching accounts" });
      }
    });
    router4.post("/accounts", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const { propertyId, utilityType, provider, accountNumber, packageInfo, expectedBillDay } = req.body;
        if (!propertyId || !utilityType || !provider || !accountNumber || !expectedBillDay) {
          return res.status(400).json({ error: "Missing required fields" });
        }
        const newAccount = await db.insert(propertyUtilityAccounts).values({
          organizationId: orgId,
          propertyId: parseInt(propertyId),
          utilityType,
          provider,
          accountNumber,
          packageInfo: packageInfo || null,
          expectedBillDay: parseInt(expectedBillDay),
          isActive: true,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        res.status(201).json(newAccount[0]);
      } catch (err) {
        console.error("[UTILITY] ERROR creating account:", err);
        res.status(500).json({ error: err.message || "Server error creating account" });
      }
    });
    router4.patch("/accounts/:id", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const accountId = parseInt(req.params.id);
        const { provider, accountNumber, packageInfo, expectedBillDay, isActive } = req.body;
        const updateData = { updatedAt: /* @__PURE__ */ new Date() };
        if (provider !== void 0) updateData.provider = provider;
        if (accountNumber !== void 0) updateData.accountNumber = accountNumber;
        if (packageInfo !== void 0) updateData.packageInfo = packageInfo;
        if (expectedBillDay !== void 0) updateData.expectedBillDay = parseInt(expectedBillDay);
        if (isActive !== void 0) updateData.isActive = isActive;
        const updated = await db.update(propertyUtilityAccounts).set(updateData).where(and13(
          eq13(propertyUtilityAccounts.id, accountId),
          eq13(propertyUtilityAccounts.organizationId, orgId)
        )).returning();
        if (!updated.length) {
          return res.status(404).json({ error: "Account not found" });
        }
        res.json(updated[0]);
      } catch (err) {
        console.error("[UTILITY] ERROR updating account:", err);
        res.status(500).json({ error: err.message || "Server error updating account" });
      }
    });
    router4.delete("/accounts/:id", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const accountId = parseInt(req.params.id);
        const deleted = await db.delete(propertyUtilityAccounts).where(and13(
          eq13(propertyUtilityAccounts.id, accountId),
          eq13(propertyUtilityAccounts.organizationId, orgId)
        )).returning();
        if (!deleted.length) {
          return res.status(404).json({ error: "Account not found" });
        }
        res.json({ message: "Account deleted successfully", account: deleted[0] });
      } catch (err) {
        console.error("[UTILITY] ERROR deleting account:", err);
        res.status(500).json({ error: err.message || "Server error deleting account" });
      }
    });
    router4.get("/bills", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : null;
        const status = req.query.status;
        const utilityType = req.query.utilityType;
        const limit = Math.min(100, Number(req.query.limit) || 50);
        let conditions = [eq13(utilityBills.organizationId, orgId)];
        if (propertyId) {
          conditions.push(eq13(utilityBills.propertyId, propertyId));
        }
        if (status) {
          conditions.push(eq13(utilityBills.status, status));
        }
        if (utilityType) {
          conditions.push(eq13(utilityBills.type, utilityType));
        }
        const rawBills = await db.select().from(utilityBills).leftJoin(properties, eq13(utilityBills.propertyId, properties.id)).where(and13(...conditions)).orderBy(desc6(utilityBills.dueDate)).limit(limit);
        const bills = rawBills.map((row) => ({
          id: row.utility_bills.id,
          organizationId: row.utility_bills.organizationId,
          propertyId: row.utility_bills.propertyId,
          propertyName: row.properties?.name || null,
          type: row.utility_bills.type,
          provider: row.utility_bills.provider,
          accountNumber: row.utility_bills.accountNumber,
          amount: row.utility_bills.amount,
          currency: row.utility_bills.currency,
          dueDate: row.utility_bills.dueDate,
          billPeriodStart: row.utility_bills.billPeriodStart,
          billPeriodEnd: row.utility_bills.billPeriodEnd,
          billingMonth: row.utility_bills.billingMonth,
          status: row.utility_bills.status,
          receiptUrl: row.utility_bills.receiptUrl,
          receiptFilename: row.utility_bills.receiptFilename,
          responsibleParty: row.utility_bills.responsibleParty,
          notes: row.utility_bills.notes,
          createdAt: row.utility_bills.createdAt
        }));
        res.json(bills);
      } catch (err) {
        console.error("[UTILITY] ERROR fetching bills:", err);
        res.status(500).json({ error: err.message || "Server error fetching bills" });
      }
    });
    router4.post("/bills", isDemoAuthenticated, upload2.single("receipt"), async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const { propertyId, utilityType, provider, accountNumber, amount, currency, dueDate, billingMonth, status, notes } = req.body;
        const file = req.file;
        if (!propertyId || !utilityType || !dueDate || !billingMonth) {
          return res.status(400).json({ error: "Missing required fields: propertyId, utilityType, dueDate, billingMonth" });
        }
        const billData = {
          organizationId: orgId,
          propertyId: parseInt(propertyId),
          type: utilityType,
          provider: provider || null,
          accountNumber: accountNumber || null,
          amount: amount ? amount : null,
          currency: currency || "AUD",
          dueDate: new Date(dueDate),
          billingMonth,
          status: status || "pending",
          notes: notes || null,
          uploadedBy: req.user?.id,
          uploadedAt: /* @__PURE__ */ new Date(),
          createdAt: /* @__PURE__ */ new Date()
        };
        if (file) {
          billData.receiptUrl = `/uploads/utility_bills/${file.filename}`;
          billData.receiptFilename = file.originalname;
        }
        const newBill = await db.insert(utilityBills).values(billData).returning();
        const rawCreatedBill = await db.select().from(utilityBills).leftJoin(properties, eq13(utilityBills.propertyId, properties.id)).where(eq13(utilityBills.id, newBill[0].id)).limit(1);
        const createdBill = {
          ...rawCreatedBill[0].utility_bills,
          propertyName: rawCreatedBill[0].properties?.name || null
        };
        res.status(201).json(createdBill);
      } catch (err) {
        console.error("[UTILITY] ERROR creating bill:", err);
        res.status(500).json({ error: err.message || "Server error creating bill" });
      }
    });
    router4.patch("/bills/:id", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const billId = parseInt(req.params.id);
        const { status, amount, notes, provider, accountNumber } = req.body;
        const updateData = { updatedAt: /* @__PURE__ */ new Date() };
        if (status !== void 0) updateData.status = status;
        if (amount !== void 0) updateData.amount = amount;
        if (notes !== void 0) updateData.notes = notes;
        if (provider !== void 0) updateData.provider = provider;
        if (accountNumber !== void 0) updateData.accountNumber = accountNumber;
        const updated = await db.update(utilityBills).set(updateData).where(and13(
          eq13(utilityBills.id, billId),
          eq13(utilityBills.organizationId, orgId)
        )).returning();
        if (!updated.length) {
          return res.status(404).json({ error: "Bill not found" });
        }
        res.json(updated[0]);
      } catch (err) {
        console.error("[UTILITY] ERROR updating bill:", err);
        res.status(500).json({ error: err.message || "Server error updating bill" });
      }
    });
    router4.delete("/bills/:id", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const billId = parseInt(req.params.id);
        const bill = await db.select().from(utilityBills).where(and13(
          eq13(utilityBills.id, billId),
          eq13(utilityBills.organizationId, orgId)
        )).limit(1);
        if (!bill.length) {
          return res.status(404).json({ error: "Bill not found" });
        }
        if (bill[0].receiptFilename) {
          const filePath = path4.join(uploadsDir2, path4.basename(bill[0].receiptUrl || ""));
          if (fs4.existsSync(filePath)) {
            fs4.unlinkSync(filePath);
          }
        }
        const deleted = await db.delete(utilityBills).where(and13(
          eq13(utilityBills.id, billId),
          eq13(utilityBills.organizationId, orgId)
        )).returning();
        res.json({ message: "Bill deleted successfully", bill: deleted[0] });
      } catch (err) {
        console.error("[UTILITY] ERROR deleting bill:", err);
        res.status(500).json({ error: err.message || "Server error deleting bill" });
      }
    });
    router4.get("/alert-rules", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const rules = await db.select().from(utilityAlertRules).where(eq13(utilityAlertRules.organizationId, orgId)).orderBy(desc6(utilityAlertRules.createdAt));
        res.json(rules);
      } catch (err) {
        console.error("[UTILITY] ERROR fetching alert rules:", err);
        if (err.code === "42P01") {
          return res.json([]);
        }
        res.status(500).json({ error: err.message || "Server error fetching alert rules" });
      }
    });
    router4.post("/alert-rules", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const { propertyId, utilityType, alertType, threshold, daysBeforeDue, notifyUsers, notifyRoles } = req.body;
        if (!alertType) {
          return res.status(400).json({ error: "Alert type is required" });
        }
        const newRule = await db.insert(utilityAlertRules).values({
          organizationId: orgId,
          propertyId: propertyId && propertyId !== "all" ? parseInt(propertyId) : null,
          utilityType: utilityType && utilityType !== "all" ? utilityType : null,
          alertType,
          threshold: threshold || null,
          daysBeforeDue: daysBeforeDue ? parseInt(daysBeforeDue) : null,
          isEnabled: true,
          notifyUsers: notifyUsers || [],
          notifyRoles: notifyRoles || [],
          createdBy: req.user?.id,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        res.status(201).json(newRule[0]);
      } catch (err) {
        console.error("[UTILITY] ERROR creating alert rule:", err);
        res.status(500).json({ error: err.message || "Server error creating alert rule" });
      }
    });
    router4.patch("/alert-rules/:id", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const ruleId = parseInt(req.params.id);
        const { isEnabled, threshold, daysBeforeDue, notifyUsers, notifyRoles } = req.body;
        const updateData = { updatedAt: /* @__PURE__ */ new Date() };
        if (isEnabled !== void 0) updateData.isEnabled = isEnabled;
        if (threshold !== void 0) updateData.threshold = threshold;
        if (daysBeforeDue !== void 0) updateData.daysBeforeDue = daysBeforeDue;
        if (notifyUsers !== void 0) updateData.notifyUsers = notifyUsers;
        if (notifyRoles !== void 0) updateData.notifyRoles = notifyRoles;
        const updated = await db.update(utilityAlertRules).set(updateData).where(and13(
          eq13(utilityAlertRules.id, ruleId),
          eq13(utilityAlertRules.organizationId, orgId)
        )).returning();
        if (!updated.length) {
          return res.status(404).json({ error: "Alert rule not found" });
        }
        res.json(updated[0]);
      } catch (err) {
        console.error("[UTILITY] ERROR updating alert rule:", err);
        res.status(500).json({ error: err.message || "Server error updating alert rule" });
      }
    });
    router4.delete("/alert-rules/:id", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const ruleId = parseInt(req.params.id);
        const deleted = await db.delete(utilityAlertRules).where(and13(
          eq13(utilityAlertRules.id, ruleId),
          eq13(utilityAlertRules.organizationId, orgId)
        )).returning();
        if (!deleted.length) {
          return res.status(404).json({ error: "Alert rule not found" });
        }
        res.json({ message: "Alert rule deleted successfully", rule: deleted[0] });
      } catch (err) {
        console.error("[UTILITY] ERROR deleting alert rule:", err);
        res.status(500).json({ error: err.message || "Server error deleting alert rule" });
      }
    });
    router4.get("/alerts", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const status = req.query.status;
        let conditions = [eq13(utilityBillAlerts.organizationId, orgId)];
        if (status) {
          conditions.push(eq13(utilityBillAlerts.alertStatus, status));
        }
        const alerts = await db.select().from(utilityBillAlerts).leftJoin(properties, eq13(utilityBillAlerts.propertyId, properties.id)).where(and13(...conditions)).orderBy(desc6(utilityBillAlerts.createdAt)).limit(50);
        const formattedAlerts = alerts.map((row) => ({
          ...row.utility_bill_alerts,
          propertyName: row.properties?.name || null
        }));
        res.json(formattedAlerts);
      } catch (err) {
        console.error("[UTILITY] ERROR fetching alerts:", err);
        if (err.code === "42P01") {
          return res.json([]);
        }
        res.status(500).json({ error: err.message || "Server error fetching alerts" });
      }
    });
    router4.patch("/alerts/:id", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const alertId = parseInt(req.params.id);
        const { alertStatus } = req.body;
        const updateData = {};
        if (alertStatus === "acknowledged") {
          updateData.alertStatus = "acknowledged";
          updateData.acknowledgedBy = req.user?.id;
          updateData.acknowledgedAt = /* @__PURE__ */ new Date();
        } else if (alertStatus === "resolved") {
          updateData.alertStatus = "resolved";
          updateData.resolvedBy = req.user?.id;
          updateData.resolvedAt = /* @__PURE__ */ new Date();
        } else if (alertStatus) {
          updateData.alertStatus = alertStatus;
        }
        const updated = await db.update(utilityBillAlerts).set(updateData).where(and13(
          eq13(utilityBillAlerts.id, alertId),
          eq13(utilityBillAlerts.organizationId, orgId)
        )).returning();
        if (!updated.length) {
          return res.status(404).json({ error: "Alert not found" });
        }
        res.json(updated[0]);
      } catch (err) {
        console.error("[UTILITY] ERROR updating alert:", err);
        res.status(500).json({ error: err.message || "Server error updating alert" });
      }
    });
    router4.get("/analytics", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : null;
        let conditions = [eq13(utilityBills.organizationId, orgId)];
        if (propertyId) {
          conditions.push(eq13(utilityBills.propertyId, propertyId));
        }
        const bills = await db.select().from(utilityBills).where(and13(...conditions));
        const totalAmount = bills.reduce((sum4, bill) => sum4 + (parseFloat(bill.amount) || 0), 0);
        const paidAmount = bills.filter((b) => b.status === "paid").reduce((sum4, bill) => sum4 + (parseFloat(bill.amount) || 0), 0);
        const pendingAmount = bills.filter((b) => b.status === "pending").reduce((sum4, bill) => sum4 + (parseFloat(bill.amount) || 0), 0);
        const overdueAmount = bills.filter((b) => b.status === "overdue").reduce((sum4, bill) => sum4 + (parseFloat(bill.amount) || 0), 0);
        const byType = bills.reduce((acc, bill) => {
          if (!acc[bill.type]) {
            acc[bill.type] = { count: 0, total: 0 };
          }
          acc[bill.type].count++;
          acc[bill.type].total += parseFloat(bill.amount) || 0;
          return acc;
        }, {});
        const byProperty = bills.reduce((acc, bill) => {
          const propId = bill.propertyId;
          if (!acc[propId]) {
            acc[propId] = { count: 0, total: 0 };
          }
          acc[propId].count++;
          acc[propId].total += parseFloat(bill.amount) || 0;
          return acc;
        }, {});
        const byMonth = bills.reduce((acc, bill) => {
          const month = bill.billingMonth;
          if (!acc[month]) {
            acc[month] = { count: 0, total: 0 };
          }
          acc[month].count++;
          acc[month].total += parseFloat(bill.amount) || 0;
          return acc;
        }, {});
        res.json({
          summary: {
            totalAmount,
            paidAmount,
            pendingAmount,
            overdueAmount,
            billCount: bills.length
          },
          byType,
          byProperty,
          byMonth
        });
      } catch (err) {
        console.error("[UTILITY] ERROR fetching analytics:", err);
        res.status(500).json({ error: err.message || "Server error fetching analytics" });
      }
    });
    utility_routes_default = router4;
  }
});

// server/fast-dashboard-api.ts
var fast_dashboard_api_exports = {};
__export(fast_dashboard_api_exports, {
  registerFastDashboardRoutes: () => registerFastDashboardRoutes
});
function registerFastDashboardRoutes(app2) {
  app2.get("/api/dashboard/recent-tasks", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const { storage: storage5 } = await Promise.resolve().then(() => (init_storage(), storage_exports));
      const allTasks = await storage5.getTasks();
      const filteredTasks = allTasks.filter((task) => task.organizationId === organizationId2).sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, 10);
      res.json(filteredTasks);
    } catch (error) {
      console.error("Error fetching recent tasks:", error);
      res.status(500).json({ message: "Failed to fetch recent tasks" });
    }
  });
  app2.get("/api/dashboard/task-stats", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const { storage: storage5 } = await Promise.resolve().then(() => (init_storage(), storage_exports));
      const allTasks = await storage5.getTasks();
      const orgTasks = allTasks.filter((task) => task.organizationId === organizationId2);
      const stats = {
        total: orgTasks.length,
        pending: orgTasks.filter((t) => t.status === "pending").length,
        inProgress: orgTasks.filter((t) => t.status === "in-progress").length,
        completed: orgTasks.filter((t) => t.status === "completed").length,
        highPriority: orgTasks.filter((t) => t.priority === "high").length,
        overdue: orgTasks.filter((t) => {
          if (!t.dueDate) return false;
          return new Date(t.dueDate) < /* @__PURE__ */ new Date();
        }).length
      };
      res.json(stats);
    } catch (error) {
      console.error("Error fetching task stats:", error);
      res.status(500).json({ message: "Failed to fetch task stats" });
    }
  });
}
var init_fast_dashboard_api = __esm({
  "server/fast-dashboard-api.ts"() {
    "use strict";
    init_demoAuth();
  }
});

// server/achievement-routes.ts
var achievement_routes_exports = {};
__export(achievement_routes_exports, {
  setupAchievementRoutes: () => setupAchievementRoutes
});
import { eq as eq14, and as and14, sql as sql8 } from "drizzle-orm";
function setupAchievementRoutes(app2) {
  app2.get("/api/achievements/user/:userId", isDemoAuthenticated2, async (req, res) => {
    try {
      const { userId } = req.params;
      const organizationId2 = req.user?.organizationId || "default-org";
      let [userStats] = await db.select().from(userGameStats).where(and14(
        eq14(userGameStats.userId, userId),
        eq14(userGameStats.organizationId, organizationId2)
      ));
      if (!userStats) {
        [userStats] = await db.insert(userGameStats).values({
          userId,
          organizationId: organizationId2,
          totalPoints: 0,
          level: 1,
          currentStreak: 0,
          longestStreak: 0,
          tasksCompleted: 0,
          bookingsProcessed: 0,
          propertiesManaged: 0
        }).returning();
      }
      const [taskStats] = await db.select({ count: sql8`COUNT(*)` }).from(tasks).where(and14(
        eq14(tasks.organizationId, organizationId2),
        eq14(tasks.status, "completed")
      ));
      console.log("\u{1F3AE} Achievement Debug - Task Stats:", taskStats);
      console.log("\u{1F3AE} Achievement Debug - Organization:", organizationId2, "User:", userId);
      const [propertyStats] = await db.select({ count: sql8`COUNT(*)` }).from(properties).where(and14(
        eq14(properties.organizationId, organizationId2),
        eq14(properties.ownerId, userId)
      ));
      const [bookingStats] = await db.select({ count: sql8`COUNT(DISTINCT ${bookings.id})` }).from(bookings).innerJoin(properties, eq14(bookings.propertyId, properties.id)).where(and14(
        eq14(bookings.organizationId, organizationId2),
        eq14(properties.ownerId, userId)
      ));
      const tasksCompleted = Number(taskStats?.count || 0);
      const bookingsProcessed = Number(bookingStats?.count || 0);
      const propertiesManaged = Number(propertyStats?.count || 0);
      console.log("\u{1F3AE} Achievement Counts - Tasks:", tasksCompleted, "Bookings:", bookingsProcessed, "Properties:", propertiesManaged);
      const totalPoints = tasksCompleted * 10 + bookingsProcessed * 25 + propertiesManaged * 50;
      const level = calculateLevel(totalPoints);
      await db.update(userGameStats).set({
        tasksCompleted,
        bookingsProcessed,
        propertiesManaged,
        totalPoints,
        level,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq14(userGameStats.id, userStats.id));
      res.json({
        ...userStats,
        tasksCompleted,
        bookingsProcessed,
        propertiesManaged,
        totalPoints,
        level
      });
    } catch (error) {
      console.error("Error fetching user achievements:", error);
      res.status(500).json({ error: "Failed to fetch user achievements" });
    }
  });
  app2.get("/api/achievements/definitions", isDemoAuthenticated2, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const userId = req.user?.id;
      const allAchievements = await db.select().from(achievements).where(and14(
        eq14(achievements.organizationId, organizationId2),
        eq14(achievements.isActive, true)
      )).orderBy(achievements.category, achievements.points);
      const earnedAchievements = await db.select().from(userAchievements).where(and14(
        eq14(userAchievements.userId, userId),
        eq14(userAchievements.organizationId, organizationId2)
      ));
      const earnedIds = new Set(earnedAchievements.map((a) => a.achievementId));
      const [userStats] = await db.select().from(userGameStats).where(and14(
        eq14(userGameStats.userId, userId),
        eq14(userGameStats.organizationId, organizationId2)
      ));
      const achievementsWithStatus = allAchievements.map((achievement) => {
        const isEarned = earnedIds.has(achievement.id);
        const earned = earnedAchievements.find((e) => e.achievementId === achievement.id);
        let progress = 0;
        if (!isEarned && userStats) {
          progress = calculateProgress(achievement, userStats);
        }
        return {
          ...achievement,
          isEarned,
          earnedAt: earned?.earnedAt,
          progress
        };
      });
      res.json(achievementsWithStatus);
    } catch (error) {
      console.error("Error fetching achievements:", error);
      res.status(500).json({ error: "Failed to fetch achievements" });
    }
  });
  app2.post("/api/achievements/check", isDemoAuthenticated2, async (req, res) => {
    try {
      const userId = req.user?.id;
      const organizationId2 = req.user?.organizationId || "default-org";
      const [userStats] = await db.select().from(userGameStats).where(and14(
        eq14(userGameStats.userId, userId),
        eq14(userGameStats.organizationId, organizationId2)
      ));
      if (!userStats) {
        return res.json({ newAchievements: [] });
      }
      const allAchievements = await db.select().from(achievements).where(and14(
        eq14(achievements.organizationId, organizationId2),
        eq14(achievements.isActive, true)
      ));
      const earnedAchievements = await db.select().from(userAchievements).where(and14(
        eq14(userAchievements.userId, userId),
        eq14(userAchievements.organizationId, organizationId2)
      ));
      const earnedIds = new Set(earnedAchievements.map((a) => a.achievementId));
      const newAchievements = [];
      for (const achievement of allAchievements) {
        if (earnedIds.has(achievement.id)) continue;
        if (checkAchievementCriteria(achievement, userStats)) {
          await db.insert(userAchievements).values({
            userId,
            organizationId: organizationId2,
            achievementId: achievement.id,
            progress: 100
          });
          newAchievements.push(achievement);
        }
      }
      res.json({ newAchievements });
    } catch (error) {
      console.error("Error checking achievements:", error);
      res.status(500).json({ error: "Failed to check achievements" });
    }
  });
}
function calculateLevel(points) {
  const thresholds = [0, 100, 250, 500, 1e3, 2e3, 4e3, 8e3, 15e3, 3e4, 5e4];
  for (let i = thresholds.length - 1; i >= 0; i--) {
    if (points >= thresholds[i]) {
      return i + 1;
    }
  }
  return 1;
}
function calculateProgress(achievement, userStats) {
  const criteria = achievement.criteria;
  switch (achievement.category) {
    case "task":
      if (criteria.target) {
        return Math.min(100, userStats.tasksCompleted / criteria.target * 100);
      }
      break;
    case "booking":
      if (criteria.target) {
        return Math.min(100, userStats.bookingsProcessed / criteria.target * 100);
      }
      break;
    case "property":
      if (criteria.target) {
        return Math.min(100, userStats.propertiesManaged / criteria.target * 100);
      }
      break;
    case "system":
      if (criteria.action === "streak" && criteria.target) {
        return Math.min(100, userStats.currentStreak / criteria.target * 100);
      }
      break;
  }
  return 0;
}
function checkAchievementCriteria(achievement, userStats) {
  const criteria = achievement.criteria;
  switch (achievement.category) {
    case "task":
      return userStats.tasksCompleted >= (criteria.target || 0);
    case "booking":
      return userStats.bookingsProcessed >= (criteria.target || 0);
    case "property":
      return userStats.propertiesManaged >= (criteria.target || 0);
    case "system":
      if (criteria.action === "streak") {
        return userStats.currentStreak >= (criteria.target || 0);
      }
      break;
  }
  return false;
}
var isDemoAuthenticated2;
var init_achievement_routes = __esm({
  "server/achievement-routes.ts"() {
    "use strict";
    init_db();
    init_schema();
    isDemoAuthenticated2 = (req, res, next) => {
      if (req.user) {
        return next();
      }
      res.status(401).json({ error: "Unauthorized" });
    };
  }
});

// server/property-document-routes.ts
var property_document_routes_exports = {};
__export(property_document_routes_exports, {
  propertyDocRouter: () => propertyDocRouter
});
import express3 from "express";
import multer3 from "multer";
import path5 from "path";
import { eq as eq15, and as and15, desc as desc8, lte as lte6 } from "drizzle-orm";
import fs5 from "fs";
var propertyDocRouter, uploadStorage, fileFilter, upload3, requireDocumentAccess;
var init_property_document_routes = __esm({
  "server/property-document-routes.ts"() {
    "use strict";
    init_storage();
    init_demoAuth();
    init_db();
    init_schema();
    propertyDocRouter = express3.Router();
    uploadStorage = multer3.diskStorage({
      destination: (req, file, cb) => {
        const uploadDir = path5.join(process.cwd(), "server/uploads/documents");
        if (!fs5.existsSync(uploadDir)) {
          fs5.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
      },
      filename: (req, file, cb) => {
        const sanitizedFilename = file.originalname.replace(/[^a-zA-Z0-9.-]/g, "_");
        const uniqueName = `${Date.now()}_${sanitizedFilename}`;
        cb(null, uniqueName);
      }
    });
    fileFilter = (req, file, cb) => {
      const allowedMimes = [
        "application/pdf",
        "image/jpeg",
        "image/png",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/vnd.ms-excel"
      ];
      if (allowedMimes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error("Unsupported file type. Allowed: PDF, JPG, PNG, XLSX, XLS"));
      }
    };
    upload3 = multer3({
      storage: uploadStorage,
      fileFilter,
      limits: {
        fileSize: 10 * 1024 * 1024
        // 10 MB
      }
    });
    requireDocumentAccess = (req, res, next) => {
      const ALLOWED = /* @__PURE__ */ new Set(["admin", "Administrator", "portfolio-manager", "Portfolio Manager", "owner", "Owner"]);
      const roles = req.user?.roles || (req.user?.role ? [req.user.role] : []);
      const hasAccess = Array.isArray(roles) ? roles.some((r) => ALLOWED.has(r)) : ALLOWED.has(req.user?.role);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied. Admin, Portfolio Manager, or Owner role required." });
      }
      next();
    };
    propertyDocRouter.post("/upload", isDemoAuthenticated, requireDocumentAccess, upload3.single("file"), async (req, res) => {
      console.log("[ALT-ROUTE] POST /api/property-documents/upload hit");
      try {
        if (!req.file) {
          return res.status(400).json({ error: "No file uploaded" });
        }
        const {
          fileName,
          category,
          fileType,
          tags,
          description,
          propertyId
        } = req.body;
        if (!fileName || !category || !propertyId) {
          fs5.unlinkSync(req.file.path);
          return res.status(400).json({ error: "Missing required fields: fileName, category, or propertyId" });
        }
        const orgId = req.user?.organizationId || "default-org";
        const filePath = `/uploads/documents/${req.file.filename}`;
        const parsedTags = tags ? tags.split(",").map((t) => t.trim()) : [];
        const documentData = {
          organizationId: orgId,
          propertyId: parseInt(propertyId),
          docType: category,
          fileName,
          fileUrl: filePath,
          fileSize: req.file.size,
          mimeType: req.file.mimetype,
          category,
          tags: parsedTags,
          description: description || null,
          uploadedBy: req.user?.id || "unknown",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        const created = await storage.createPropertyDocument(orgId, documentData);
        console.log("[ALT-ROUTE] File uploaded successfully:", created);
        res.json(created);
      } catch (err) {
        console.error("[ALT-ROUTE] ERROR uploading file:", err);
        if (req.file && fs5.existsSync(req.file.path)) {
          fs5.unlinkSync(req.file.path);
        }
        if (err.code === "LIMIT_FILE_SIZE") {
          return res.status(413).json({ error: "File too large. Maximum size is 10 MB." });
        }
        res.status(500).json({ error: err.message || "Server error uploading file" });
      }
    });
    propertyDocRouter.post("/", isDemoAuthenticated, async (req, res) => {
      console.log("[ALT-ROUTE] POST /api/property-documents hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const data = req.body;
        console.log("[ALT-ROUTE] POST data:", JSON.stringify(data));
        if (!data.docType || !data.fileUrl || !data.uploadedBy) {
          console.log("[ALT-ROUTE] POST validation failed");
          return res.status(400).json({ message: "Missing required fields" });
        }
        if (data.fileUrl && (data.fileUrl.startsWith("file:///") || data.fileUrl.startsWith("file://") || data.fileUrl.startsWith("C:") || data.fileUrl.startsWith("D:") || data.fileUrl.match(/^[A-Z]:\\/i))) {
          console.log("[ALT-ROUTE] POST rejected: local file path detected");
          return res.status(400).json({
            message: "Invalid file URL. Please use the /upload endpoint to upload files."
          });
        }
        const documentData = {
          ...data,
          fileName: data.fileName || null,
          fileSize: data.fileSize || null,
          mimeType: data.mimeType || null,
          category: data.category || data.docType,
          tags: data.tags || [],
          description: data.description || null,
          updatedAt: /* @__PURE__ */ new Date()
        };
        const created = await storage.createPropertyDocument(orgId, documentData);
        console.log("[ALT-ROUTE] POST created document:", JSON.stringify(created));
        res.json(created);
      } catch (err) {
        console.error("[ALT-ROUTE] ERROR creating document:", err);
        res.status(500).json({ message: "Server error creating document" });
      }
    });
    propertyDocRouter.get("/expiring", isDemoAuthenticated, async (req, res) => {
      console.log("[ALT-ROUTE] GET /api/property-documents/expiring hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const days = parseInt(req.query.days) || 30;
        const futureDate = /* @__PURE__ */ new Date();
        futureDate.setDate(futureDate.getDate() + days);
        const futureDateStr = futureDate.toISOString().split("T")[0];
        console.log(`[ALT-ROUTE] Checking for documents expiring before ${futureDateStr} for org ${orgId}`);
        const expiringDocs = await db.select().from(propertyDocuments).where(and15(
          eq15(propertyDocuments.organizationId, orgId),
          lte6(propertyDocuments.expiryDate, futureDateStr)
        )).orderBy(propertyDocuments.expiryDate);
        console.log(`[ALT-ROUTE] Found ${expiringDocs.length} expiring/expired documents:`, JSON.stringify(expiringDocs));
        res.json(expiringDocs);
      } catch (err) {
        console.error("[ALT-ROUTE] ERROR fetching expiring documents:", err);
        res.status(500).json({ message: "Server error fetching expiring documents" });
      }
    });
    propertyDocRouter.get("/property/:propertyId", isDemoAuthenticated, async (req, res) => {
      console.log("[ALT-ROUTE] GET /api/property-documents/property/:propertyId hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const { propertyId } = req.params;
        console.log(`[ALT-ROUTE] GET - Fetching docs for property ${propertyId}, org ${orgId}`);
        const docs = await db.select().from(propertyDocuments).where(and15(
          eq15(propertyDocuments.organizationId, orgId),
          eq15(propertyDocuments.propertyId, Number(propertyId))
        )).orderBy(desc8(propertyDocuments.createdAt));
        console.log(`[ALT-ROUTE] GET - Found ${docs?.length || 0} documents:`, JSON.stringify(docs));
        res.json(docs);
      } catch (err) {
        console.error("[ALT-ROUTE] ERROR fetching documents:", err);
        res.status(500).json({ message: "Server error fetching documents" });
      }
    });
    propertyDocRouter.get("/", isDemoAuthenticated, async (req, res) => {
      console.log("[ALT-ROUTE] GET /api/property-documents/ hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        console.log(`[ALT-ROUTE] GET - Fetching all docs for org ${orgId}`);
        const docs = await db.select().from(propertyDocuments).where(eq15(propertyDocuments.organizationId, orgId)).orderBy(desc8(propertyDocuments.createdAt));
        console.log(`[ALT-ROUTE] GET - Found ${docs?.length || 0} documents`);
        res.json(docs);
      } catch (err) {
        console.error("[ALT-ROUTE] ERROR fetching all documents:", err);
        res.status(500).json({ message: "Server error fetching documents" });
      }
    });
    propertyDocRouter.get("/:id/download", isDemoAuthenticated, async (req, res) => {
      console.log("[ALT-ROUTE] GET /api/property-documents/:id/download hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const docId = parseInt(req.params.id);
        const doc = await db.select().from(propertyDocuments).where(and15(
          eq15(propertyDocuments.id, docId),
          eq15(propertyDocuments.organizationId, orgId)
        )).limit(1);
        if (!doc || doc.length === 0) {
          return res.status(404).json({ message: "Document not found or access denied" });
        }
        const document = doc[0];
        if (!document.fileUrl) {
          return res.status(404).json({ message: "File URL not found" });
        }
        const normalizedPath = document.fileUrl.replace(/^\//, "");
        const filePath = path5.join(process.cwd(), "server", normalizedPath);
        if (!fs5.existsSync(filePath)) {
          console.log(`[ALT-ROUTE] DOWNLOAD - File not found at: ${filePath}`);
          return res.status(404).json({ message: "File not found on server" });
        }
        const filename = document.fileName || path5.basename(filePath);
        res.setHeader("Content-Type", document.mimeType || "application/octet-stream");
        res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
        const fileStream = fs5.createReadStream(filePath);
        fileStream.pipe(res);
        console.log(`[ALT-ROUTE] DOWNLOAD - Serving file: ${filePath}`);
      } catch (err) {
        console.error("[ALT-ROUTE] ERROR downloading file:", err);
        res.status(500).json({ message: "Server error downloading file" });
      }
    });
    propertyDocRouter.delete("/:id", isDemoAuthenticated, requireDocumentAccess, async (req, res) => {
      console.log("[ALT-ROUTE] DELETE /api/property-documents/:id hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const docId = parseInt(req.params.id);
        console.log(`[ALT-ROUTE] DELETE - Deleting document ${docId} for org ${orgId}`);
        const existingDoc = await db.select().from(propertyDocuments).where(and15(
          eq15(propertyDocuments.id, docId),
          eq15(propertyDocuments.organizationId, orgId)
        )).limit(1);
        if (!existingDoc || existingDoc.length === 0) {
          return res.status(404).json({ message: "Document not found or access denied" });
        }
        const doc = existingDoc[0];
        if (doc.fileUrl) {
          const normalizedPath = doc.fileUrl.replace(/^\//, "");
          const filePath = path5.join(process.cwd(), "server", normalizedPath);
          if (fs5.existsSync(filePath)) {
            fs5.unlinkSync(filePath);
            console.log(`[ALT-ROUTE] DELETE - File deleted: ${filePath}`);
          } else {
            console.log(`[ALT-ROUTE] DELETE - File not found at: ${filePath}`);
          }
        }
        await db.delete(propertyDocuments).where(and15(
          eq15(propertyDocuments.id, docId),
          eq15(propertyDocuments.organizationId, orgId)
        ));
        console.log(`[ALT-ROUTE] DELETE - Document ${docId} deleted successfully`);
        res.json({ message: "Document deleted successfully" });
      } catch (err) {
        console.error("[ALT-ROUTE] ERROR deleting document:", err);
        res.status(500).json({ message: "Server error deleting document" });
      }
    });
  }
});

// server/property-image-routes.ts
var property_image_routes_exports = {};
__export(property_image_routes_exports, {
  default: () => property_image_routes_default
});
import { Router as Router5 } from "express";
import { eq as eq16 } from "drizzle-orm";
import multer4 from "multer";
import path6 from "path";
import fs6 from "fs";
import { fileURLToPath as fileURLToPath3 } from "url";
var __filename3, __dirname3, router5, uploadsDir3, storage4, upload4, property_image_routes_default;
var init_property_image_routes = __esm({
  "server/property-image-routes.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_demoAuth();
    __filename3 = fileURLToPath3(import.meta.url);
    __dirname3 = path6.dirname(__filename3);
    router5 = Router5();
    uploadsDir3 = path6.join(__dirname3, "uploads/property_images");
    if (!fs6.existsSync(uploadsDir3)) {
      fs6.mkdirSync(uploadsDir3, { recursive: true });
      console.log("[PROPERTY-IMAGES] Created uploads directory:", uploadsDir3);
    }
    storage4 = multer4.diskStorage({
      destination: (req, file, cb) => {
        console.log("[PROPERTY-IMAGES] Multer destination called for:", file.originalname);
        cb(null, uploadsDir3);
      },
      filename: (req, file, cb) => {
        const unique = Date.now() + "-" + Math.round(Math.random() * 1e9);
        const ext = path6.extname(file.originalname).toLowerCase();
        console.log("[PROPERTY-IMAGES] Multer filename generated:", unique + ext);
        cb(null, unique + ext);
      }
    });
    upload4 = multer4({
      storage: storage4,
      limits: {
        fileSize: 10 * 1024 * 1024
      },
      fileFilter: (req, file, cb) => {
        console.log("[PROPERTY-IMAGES] FileFilter called:", file.originalname, file.mimetype);
        const allowedMimes = [
          "image/jpeg",
          "image/jpg",
          "image/png",
          "image/webp",
          "image/tiff"
        ];
        const allowedExts = [".jpg", ".jpeg", ".png", ".webp", ".tiff", ".tif"];
        const ext = path6.extname(file.originalname).toLowerCase();
        const mimeOk = allowedMimes.includes(file.mimetype);
        const extOk = allowedExts.includes(ext);
        if (mimeOk || extOk) {
          cb(null, true);
        } else {
          cb(new Error(`Invalid file type: ${file.originalname}. Allowed: JPG, PNG, WebP, TIFF`));
        }
      }
    });
    router5.post("/:propertyId/upload", isDemoAuthenticated, (req, res, next) => {
      console.log("[PROPERTY-IMAGES] Starting upload middleware...");
      console.log("[PROPERTY-IMAGES] Content-Type header:", req.headers["content-type"]);
      console.log("[PROPERTY-IMAGES] Content-Length header:", req.headers["content-length"]);
      const uploadMiddleware = upload4.array("images", 50);
      uploadMiddleware(req, res, (err) => {
        if (err) {
          console.error("[PROPERTY-IMAGES] Multer error:", err.message, err.code);
          if (err instanceof multer4.MulterError) {
            if (err.code === "LIMIT_FILE_SIZE") {
              return res.status(400).json({ error: "File too large. Maximum size is 10MB per image." });
            }
            if (err.code === "LIMIT_FILE_COUNT") {
              return res.status(400).json({ error: "Too many files. Maximum 50 images allowed." });
            }
            return res.status(400).json({ error: `Upload error: ${err.message}` });
          }
          return res.status(400).json({ error: err.message || "Upload failed" });
        }
        console.log("[PROPERTY-IMAGES] Multer completed, files:", req.files?.length || 0);
        next();
      });
    }, async (req, res) => {
      try {
        const propertyId = parseInt(req.params.propertyId, 10);
        const files = req.files;
        console.log("[PROPERTY-IMAGES] Handler - Files received:", files?.length || 0);
        if (!files || files.length === 0) {
          return res.status(400).json({
            error: "At least one image file is required. Supported formats: JPG, PNG, WebP, TIFF (max 10MB each)"
          });
        }
        const existingProperty = await db.select().from(properties).where(eq16(properties.id, propertyId)).limit(1);
        if (existingProperty.length === 0) {
          files.forEach((file) => {
            if (fs6.existsSync(file.path)) fs6.unlinkSync(file.path);
          });
          return res.status(404).json({ error: "Property not found" });
        }
        if (existingProperty[0].source !== "LOCAL") {
          files.forEach((file) => {
            if (fs6.existsSync(file.path)) fs6.unlinkSync(file.path);
          });
          return res.status(400).json({ error: "Cannot upload images for external properties. Only local properties support image uploads." });
        }
        const existingImages = existingProperty[0].images || [];
        if (existingImages.length + files.length > 50) {
          files.forEach((file) => {
            if (fs6.existsSync(file.path)) fs6.unlinkSync(file.path);
          });
          return res.status(400).json({
            error: `Cannot upload ${files.length} images. Property already has ${existingImages.length} images. Maximum 50 images allowed per property.`
          });
        }
        const newImageUrls = files.map((file) => `/uploads/property_images/${file.filename}`);
        const allImages = [...existingImages, ...newImageUrls];
        await db.update(properties).set({
          images: allImages,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq16(properties.id, propertyId));
        console.log(`[PROPERTY-IMAGES] SUCCESS: Added ${files.length} images to property ${propertyId}. Total: ${allImages.length}`);
        res.json({
          success: true,
          message: `${files.length} image(s) uploaded successfully`,
          images: allImages,
          newImages: newImageUrls,
          totalImages: allImages.length
        });
      } catch (err) {
        console.error("[PROPERTY-IMAGES] ERROR:", err);
        res.status(500).json({ error: err.message || "Server error uploading images" });
      }
    });
    router5.delete("/:propertyId/image", isDemoAuthenticated, async (req, res) => {
      try {
        const propertyId = parseInt(req.params.propertyId, 10);
        const { imageUrl } = req.body;
        if (!imageUrl) {
          return res.status(400).json({ error: "Image URL is required" });
        }
        const existingProperty = await db.select().from(properties).where(eq16(properties.id, propertyId)).limit(1);
        if (existingProperty.length === 0) {
          return res.status(404).json({ error: "Property not found" });
        }
        if (existingProperty[0].source !== "LOCAL") {
          return res.status(400).json({ error: "Cannot delete images from external properties" });
        }
        const existingImages = existingProperty[0].images || [];
        const updatedImages = existingImages.filter((img) => img !== imageUrl);
        await db.update(properties).set({
          images: updatedImages,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq16(properties.id, propertyId));
        if (imageUrl.startsWith("/uploads/property_images/")) {
          const filename = path6.basename(imageUrl);
          const filePath = path6.join(uploadsDir3, filename);
          if (fs6.existsSync(filePath)) {
            fs6.unlinkSync(filePath);
            console.log(`[PROPERTY-IMAGES] Deleted file: ${filePath}`);
          }
        }
        res.json({
          success: true,
          message: "Image removed successfully",
          images: updatedImages,
          totalImages: updatedImages.length
        });
      } catch (err) {
        console.error("[PROPERTY-IMAGES] ERROR deleting image:", err);
        res.status(500).json({ error: err.message || "Server error deleting image" });
      }
    });
    router5.get("/:propertyId", isDemoAuthenticated, async (req, res) => {
      try {
        const propertyId = parseInt(req.params.propertyId, 10);
        const existingProperty = await db.select().from(properties).where(eq16(properties.id, propertyId)).limit(1);
        if (existingProperty.length === 0) {
          return res.status(404).json({ error: "Property not found" });
        }
        const images = existingProperty[0].images || [];
        res.json({
          propertyId,
          images,
          count: images.length,
          maxImages: 50,
          maxSizePerImage: "10MB",
          maxTotalSize: "200MB",
          allowedFormats: ["JPG", "PNG", "WebP", "TIFF"]
        });
      } catch (err) {
        console.error("[PROPERTY-IMAGES] ERROR getting images:", err);
        res.status(500).json({ error: err.message || "Server error getting images" });
      }
    });
    property_image_routes_default = router5;
  }
});

// server/service-booking-routes.ts
var service_booking_routes_exports = {};
__export(service_booking_routes_exports, {
  serviceBookingRouter: () => serviceBookingRouter
});
import express4 from "express";
import { eq as eq17, and as and16, desc as desc9 } from "drizzle-orm";
function generateBookingId() {
  const now = /* @__PURE__ */ new Date();
  const datePart = now.toISOString().slice(0, 10).replace(/-/g, "");
  const rand = Math.floor(1e3 + Math.random() * 9e3);
  return `BK-${datePart}-${rand}`;
}
var serviceBookingRouter;
var init_service_booking_routes = __esm({
  "server/service-booking-routes.ts"() {
    "use strict";
    init_demoAuth();
    init_db();
    init_schema();
    serviceBookingRouter = express4.Router();
    serviceBookingRouter.post("/", isDemoAuthenticated, async (req, res) => {
      console.log("[SERVICE-BOOKING] POST /api/service-bookings hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const userId = req.user?.id || "unknown";
        const {
          service_id,
          guest_name,
          guest_email,
          guest_phone,
          property_id,
          billing_type,
          price,
          date_due,
          scheduled_date
        } = req.body;
        if (!service_id || !guest_name || !billing_type) {
          return res.status(400).json({
            error: "service_id, guest_name and billing_type are required"
          });
        }
        const validBillingTypes = ["auto_guest", "auto_owner", "owner_gift", "company_gift"];
        if (!validBillingTypes.includes(billing_type)) {
          return res.status(400).json({
            error: `Invalid billing_type. Must be one of: ${validBillingTypes.join(", ")}`
          });
        }
        let price_cents = null;
        if (!(billing_type === "owner_gift" || billing_type === "company_gift")) {
          if (price == null || isNaN(Number(price))) {
            return res.status(400).json({
              error: "price is required for this billing type"
            });
          }
          price_cents = Math.round(Number(price) * 100);
          if (price_cents < 0) {
            return res.status(400).json({ error: "price must be >= 0" });
          }
        } else {
          price_cents = null;
        }
        if (date_due) {
          const d = new Date(date_due);
          const today = /* @__PURE__ */ new Date();
          today.setHours(0, 0, 0, 0);
          d.setHours(0, 0, 0, 0);
          if (d < today) {
            return res.status(400).json({ error: "date_due cannot be in the past" });
          }
        }
        let bookingIdRef = generateBookingId();
        let attempts = 0;
        while (attempts < 5) {
          const existing = await db.select().from(addonBookings).where(eq17(addonBookings.bookingIdRef, bookingIdRef)).limit(1);
          if (existing.length === 0) break;
          bookingIdRef = generateBookingId();
          attempts++;
        }
        if (attempts >= 5) {
          return res.status(500).json({ error: "Failed to generate unique booking ID" });
        }
        const service = await db.select().from(addonServices).where(eq17(addonServices.id, service_id)).limit(1);
        if (!service || service.length === 0) {
          return res.status(404).json({ error: "Service not found" });
        }
        const serviceData = service[0];
        let totalPrice = price_cents ? (price_cents / 100).toFixed(2) : "0.00";
        const newBooking = await db.insert(addonBookings).values({
          organizationId: orgId,
          bookingIdRef,
          serviceId: service_id,
          propertyId: property_id || null,
          guestName: guest_name,
          guestEmail: guest_email || null,
          guestPhone: guest_phone || null,
          billingType: billing_type,
          priceCents: price_cents,
          dateDue: date_due || null,
          scheduledDate: scheduled_date ? new Date(scheduled_date) : /* @__PURE__ */ new Date(),
          duration: serviceData.duration || null,
          basePrice: serviceData.basePrice || null,
          totalPrice,
          status: "pending",
          bookedBy: userId,
          bookedByRole: req.user?.role || "guest",
          approvalStatus: "auto-approved",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        console.log("[SERVICE-BOOKING] Created booking:", newBooking[0]);
        try {
          let orgCurrency = "USD";
          const displayCurrencySetting = await db.select().from(platformSettings).where(and16(
            eq17(platformSettings.settingKey, "displayCurrency"),
            eq17(platformSettings.organizationId, orgId)
          )).limit(1);
          if (displayCurrencySetting[0]?.settingValue) {
            orgCurrency = displayCurrencySetting[0].settingValue;
          } else {
            const baseCurrencySetting = await db.select().from(platformSettings).where(and16(
              eq17(platformSettings.settingKey, "baseCurrency"),
              eq17(platformSettings.organizationId, orgId)
            )).limit(1);
            if (baseCurrencySetting[0]?.settingValue) {
              orgCurrency = baseCurrencySetting[0].settingValue;
            }
          }
          console.log("[SERVICE-BOOKING] Using currency:", orgCurrency, "for org:", orgId);
          if (price_cents && price_cents > 0) {
            const financeSource = billing_type === "auto_guest" ? "guest_payment" : billing_type === "auto_owner" ? "owner_charge" : "guest_payment";
            let propertyName = "Unknown Property";
            if (property_id) {
              const prop = await db.select().from(properties).where(eq17(properties.id, property_id)).limit(1);
              if (prop.length > 0) propertyName = prop[0].name || "Unknown Property";
            }
            const financeRecord = await db.insert(finances).values({
              organizationId: orgId,
              propertyId: property_id || null,
              type: "income",
              source: financeSource,
              category: "add-on-service",
              subcategory: serviceData.name || "addon-service",
              department: "guest-services",
              amount: price_cents / 100,
              currency: orgCurrency,
              date: /* @__PURE__ */ new Date(),
              description: `Add-on Service: ${serviceData.name || "Service"} - ${guest_name} at ${propertyName} (Ref: ${bookingIdRef})`,
              referenceNumber: bookingIdRef,
              processedBy: userId
            }).returning();
            console.log("[SERVICE-BOOKING] Created finance record:", financeRecord[0]?.id, "with currency:", orgCurrency);
          } else if (billing_type === "owner_gift" || billing_type === "company_gift") {
            let propertyName = "Unknown Property";
            if (property_id) {
              const prop = await db.select().from(properties).where(eq17(properties.id, property_id)).limit(1);
              if (prop.length > 0) propertyName = prop[0].name || "Unknown Property";
            }
            const giftValue = serviceData.defaultPriceCents ? serviceData.defaultPriceCents / 100 : 0;
            await db.insert(finances).values({
              organizationId: orgId,
              propertyId: property_id || null,
              type: "expense",
              source: "complimentary",
              sourceType: billing_type,
              category: "add-on-service",
              subcategory: serviceData.name || "addon-service",
              department: "guest-services",
              amount: giftValue,
              currency: orgCurrency,
              date: /* @__PURE__ */ new Date(),
              description: `Complimentary Service: ${serviceData.name || "Service"} - ${guest_name} at ${propertyName} (${billing_type === "owner_gift" ? "Owner Gift" : "Company Gift"})`,
              referenceNumber: bookingIdRef,
              processedBy: userId
            });
            console.log("[SERVICE-BOOKING] Created complimentary finance record for", billing_type, "with currency:", orgCurrency);
          }
        } catch (financeErr) {
          console.error("[SERVICE-BOOKING] Warning: Failed to create finance record:", financeErr.message);
        }
        res.status(201).json({ booking: newBooking[0] });
      } catch (err) {
        console.error("[SERVICE-BOOKING] ERROR creating booking:", err);
        res.status(500).json({ error: err.message || "Server error creating booking" });
      }
    });
    serviceBookingRouter.get("/", isDemoAuthenticated, async (req, res) => {
      console.log("[SERVICE-BOOKING] GET /api/service-bookings hit");
      try {
        const orgId = req.user?.organizationId || "default-org";
        const order = req.query.order === "asc" ? "asc" : "desc";
        const limit = Math.min(100, Number(req.query.limit) || 50);
        const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : null;
        const whereConditions = [eq17(addonBookings.organizationId, orgId)];
        if (propertyId) {
          whereConditions.push(eq17(addonBookings.propertyId, propertyId));
        }
        const rawBookings = await db.select().from(addonBookings).leftJoin(addonServices, eq17(addonBookings.serviceId, addonServices.id)).leftJoin(properties, eq17(addonBookings.propertyId, properties.id)).where(and16(...whereConditions)).orderBy(order === "asc" ? addonBookings.createdAt : desc9(addonBookings.createdAt)).limit(limit);
        const bookings3 = rawBookings.filter((row) => row.addon_bookings || row.addonBookings).map((row) => {
          const booking = row.addon_bookings || row.addonBookings;
          const service = row.addon_services || row.addonServices;
          const property = row.properties;
          return {
            id: booking?.id,
            bookingIdRef: booking?.bookingIdRef || booking?.booking_id_ref,
            serviceId: booking?.serviceId || booking?.service_id,
            serviceName: service?.name || null,
            guestName: booking?.guestName || booking?.guest_name,
            guestEmail: booking?.guestEmail || booking?.guest_email,
            guestPhone: booking?.guestPhone || booking?.guest_phone,
            propertyId: booking?.propertyId || booking?.property_id,
            propertyName: property?.name || null,
            billingType: booking?.billingType || booking?.billing_type,
            priceCents: booking?.priceCents || booking?.price_cents,
            dateDue: booking?.dateDue || booking?.date_due,
            scheduledDate: booking?.scheduledDate || booking?.scheduled_date,
            status: booking?.status,
            totalPrice: booking?.totalPrice || booking?.total_price,
            createdAt: booking?.createdAt || booking?.created_at
          };
        });
        console.log("[SERVICE-BOOKING] Found", bookings3.length, "bookings");
        res.json({ bookings: bookings3 });
      } catch (err) {
        console.error("[SERVICE-BOOKING] ERROR fetching bookings:", err);
        res.status(500).json({ error: err.message || "Server error fetching bookings" });
      }
    });
    serviceBookingRouter.get("/:id", isDemoAuthenticated, async (req, res) => {
      try {
        const orgId = req.user?.organizationId || "default-org";
        const bookingId = parseInt(req.params.id);
        const booking = await db.select().from(addonBookings).where(and16(
          eq17(addonBookings.id, bookingId),
          eq17(addonBookings.organizationId, orgId)
        )).limit(1);
        if (!booking || booking.length === 0) {
          return res.status(404).json({ error: "Booking not found" });
        }
        res.json({ booking: booking[0] });
      } catch (err) {
        console.error("[SERVICE-BOOKING] ERROR fetching booking:", err);
        res.status(500).json({ error: err.message || "Server error" });
      }
    });
  }
});

// server/lodgify-service.ts
import axios from "axios";
function getLodgifyService(apiKey, organizationId2 = "default-org") {
  const cacheKey = `org:${organizationId2}:key:${apiKey.substring(0, 10)}`;
  if (!lodgifyInstances.has(cacheKey)) {
    lodgifyInstances.set(cacheKey, new LodgifyService(apiKey, organizationId2));
  }
  return lodgifyInstances.get(cacheKey);
}
var LodgifyService, lodgifyInstances;
var init_lodgify_service = __esm({
  "server/lodgify-service.ts"() {
    "use strict";
    LodgifyService = class {
      constructor(apiKey, organizationId2 = "default-org") {
        if (!apiKey) {
          throw new Error("Lodgify API key is required");
        }
        this.apiKey = apiKey;
        this.organizationId = organizationId2;
        this.client = axios.create({
          baseURL: "https://api.lodgify.com",
          headers: {
            "X-ApiKey": this.apiKey,
            "Content-Type": "application/json"
          },
          timeout: 3e4
        });
      }
      /**
       * Test the API connection
       */
      async testConnection() {
        try {
          const response = await this.client.get("/v1/properties");
          return {
            success: true,
            message: `Connected successfully. Found ${response.data.length || 0} properties.`
          };
        } catch (error) {
          console.error("[Lodgify] Connection test failed:", error.message);
          return {
            success: false,
            message: error.response?.data?.message || error.message || "Connection failed"
          };
        }
      }
      /**
       * Fetch all properties from Lodgify
       */
      async getProperties() {
        try {
          const response = await this.client.get("/v1/properties");
          console.log(`[Lodgify] Fetched ${response.data.length} properties`);
          return response.data;
        } catch (error) {
          console.error("[Lodgify] Error fetching properties:", error.message);
          throw new Error(`Failed to fetch properties: ${error.message}`);
        }
      }
      /**
       * Fetch a single property by ID
       */
      async getProperty(propertyId) {
        try {
          const response = await this.client.get(`/v1/properties/${propertyId}`);
          return response.data;
        } catch (error) {
          console.error(
            `[Lodgify] Error fetching property ${propertyId}:`,
            error.message
          );
          throw new Error(`Failed to fetch property: ${error.message}`);
        }
      }
      /**
       * Fetch all bookings from Lodgify
       * @param includeTransactions - Include payment transaction details
       * @param page - Page number (default: 1)
       * @param size - Page size (default: 100)
       */
      async getBookings(includeTransactions = true, page = 1, size = 100) {
        try {
          const params = new URLSearchParams({
            page: page.toString(),
            size: size.toString(),
            includeTransactions: includeTransactions.toString(),
            includeExternal: "false",
            includeQuoteDetails: "true"
          });
          const response = await this.client.get(
            `/v2/reservations/bookings?${params.toString()}`
          );
          console.log(`[Lodgify] Fetched ${response.data.length} bookings`);
          return response.data;
        } catch (error) {
          console.error("[Lodgify] Error fetching bookings:", error.message);
          throw new Error(`Failed to fetch bookings: ${error.message}`);
        }
      }
      /**
       * Fetch a single booking by ID
       */
      async getBooking(bookingId) {
        try {
          const response = await this.client.get(
            `/v2/reservations/bookings/${bookingId}`
          );
          return response.data;
        } catch (error) {
          console.error(
            `[Lodgify] Error fetching booking ${bookingId}:`,
            error.message
          );
          throw new Error(`Failed to fetch booking: ${error.message}`);
        }
      }
      /**
       * Create a new booking in Lodgify
       */
      async createBooking(bookingData) {
        try {
          const response = await this.client.post(
            "/v1/reservation/booking",
            bookingData
          );
          console.log(`[Lodgify] Created booking ID: ${response.data.id}`);
          return response.data;
        } catch (error) {
          console.error("[Lodgify] Error creating booking:", error.message);
          throw new Error(`Failed to create booking: ${error.message}`);
        }
      }
      /**
       * Get payment link for a booking
       */
      async getPaymentLink(bookingId) {
        try {
          const response = await this.client.get(
            `/v2/reservations/bookings/${bookingId}/quote/paymentLink`
          );
          return response.data.paymentLink || response.data;
        } catch (error) {
          console.error(
            `[Lodgify] Error getting payment link for booking ${bookingId}:`,
            error.message
          );
          throw new Error(`Failed to get payment link: ${error.message}`);
        }
      }
      /**
       * Fetch availability calendar for a property
       */
      async getCalendar(propertyId, startDate, endDate) {
        try {
          const response = await this.client.get(
            `/v1/calendar?propertyId=${propertyId}&start=${startDate}&end=${endDate}`
          );
          return response.data;
        } catch (error) {
          console.error(
            `[Lodgify] Error fetching calendar for property ${propertyId}:`,
            error.message
          );
          throw new Error(`Failed to fetch calendar: ${error.message}`);
        }
      }
    };
    lodgifyInstances = /* @__PURE__ */ new Map();
  }
});

// server/lodgify-routes.ts
var lodgify_routes_exports = {};
__export(lodgify_routes_exports, {
  default: () => lodgify_routes_default
});
import { Router as Router6 } from "express";
import { eq as eq18, and as and17 } from "drizzle-orm";
function getOrgId(req) {
  return req.user?.organizationId || "default-org";
}
async function getLodgifyApiKey(organizationId2) {
  const apiKeyRecord = await db.select().from(organizationApiKeys).where(
    and17(
      eq18(organizationApiKeys.organizationId, organizationId2),
      eq18(organizationApiKeys.provider, "lodgify"),
      eq18(organizationApiKeys.isActive, true)
    )
  ).limit(1);
  if (apiKeyRecord.length > 0 && apiKeyRecord[0].encryptedValue) {
    console.log(
      `[Lodgify] Using database API key for organization: ${organizationId2}`
    );
    return apiKeyRecord[0].encryptedValue;
  }
  const envKey = process.env.LODGIFY_API_KEY;
  if (envKey) {
    console.log(
      `[Lodgify] WARNING: Using fallback environment variable for org ${organizationId2}. Configure org-specific key in production.`
    );
    return envKey;
  }
  throw new Error(
    "Lodgify API key not configured. Please add it in API Connections settings."
  );
}
var router6, lodgify_routes_default;
var init_lodgify_routes = __esm({
  "server/lodgify-routes.ts"() {
    "use strict";
    init_lodgify_service();
    init_db();
    init_schema();
    router6 = Router6();
    router6.get("/lodgify/test-connection", async (req, res) => {
      try {
        const orgId = getOrgId(req);
        const apiKey = await getLodgifyApiKey(orgId);
        const lodgify = getLodgifyService(apiKey, orgId);
        const result = await lodgify.testConnection();
        console.log("[Lodgify API] Connection test:", result);
        res.json(result);
      } catch (error) {
        console.error("[Lodgify API] Test connection error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Connection test failed"
        });
      }
    });
    router6.get("/lodgify/fetch-properties", async (req, res) => {
      try {
        const orgId = getOrgId(req);
        const apiKey = await getLodgifyApiKey(orgId);
        const lodgify = getLodgifyService(apiKey, orgId);
        const lodgifyProperties = await lodgify.getProperties();
        console.log(`[Lodgify API] Fetched ${lodgifyProperties.length} properties`);
        res.json({
          success: true,
          count: lodgifyProperties.length,
          properties: lodgifyProperties
        });
      } catch (error) {
        console.error("[Lodgify API] Fetch properties error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to fetch properties"
        });
      }
    });
    router6.post("/lodgify/sync-properties", async (req, res) => {
      try {
        const orgId = getOrgId(req);
        const apiKey = await getLodgifyApiKey(orgId);
        const lodgify = getLodgifyService(apiKey, orgId);
        const lodgifyProperties = await lodgify.getProperties();
        let synced = 0;
        let updated = 0;
        let created = 0;
        const errors = [];
        for (const lodgifyProp of lodgifyProperties) {
          try {
            const existing = await db.select().from(properties).where(
              and17(
                eq18(properties.organizationId, orgId),
                eq18(properties.externalId, lodgifyProp.id.toString())
              )
            ).limit(1);
            const propertyData = {
              organizationId: orgId,
              externalId: lodgifyProp.id.toString(),
              name: lodgifyProp.name,
              address: lodgifyProp.address?.street || "",
              city: lodgifyProp.address?.city || "",
              state: lodgifyProp.address?.state || "",
              zipCode: lodgifyProp.address?.zipCode || "",
              country: lodgifyProp.address?.country || "",
              bedrooms: lodgifyProp.bedrooms || 0,
              bathrooms: lodgifyProp.bathrooms || 0,
              maxGuests: lodgifyProp.maxGuests || 0,
              propertyType: lodgifyProp.type || "apartment",
              description: lodgifyProp.description || "",
              currency: lodgifyProp.currency || "USD",
              status: "active",
              pricePerNight: 0
              // Will be updated from calendar/rates
            };
            if (existing.length > 0) {
              await db.update(properties).set({
                ...propertyData,
                updatedAt: /* @__PURE__ */ new Date()
              }).where(eq18(properties.id, existing[0].id));
              updated++;
            } else {
              await db.insert(properties).values(propertyData);
              created++;
            }
            synced++;
          } catch (error) {
            errors.push(`Property ${lodgifyProp.name}: ${error.message}`);
          }
        }
        console.log(
          `[Lodgify Sync] Properties: ${synced} synced (${created} created, ${updated} updated)`
        );
        res.json({
          success: true,
          synced,
          created,
          updated,
          total: lodgifyProperties.length,
          errors: errors.length > 0 ? errors : void 0
        });
      } catch (error) {
        console.error("[Lodgify API] Sync properties error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to sync properties"
        });
      }
    });
    router6.get("/lodgify/fetch-bookings", async (req, res) => {
      try {
        const orgId = getOrgId(req);
        const apiKey = await getLodgifyApiKey(orgId);
        const lodgify = getLodgifyService(apiKey, orgId);
        const lodgifyBookings = await lodgify.getBookings(true, 1, 100);
        console.log(`[Lodgify API] Fetched ${lodgifyBookings.length} bookings`);
        res.json({
          success: true,
          count: lodgifyBookings.length,
          bookings: lodgifyBookings
        });
      } catch (error) {
        console.error("[Lodgify API] Fetch bookings error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to fetch bookings"
        });
      }
    });
    router6.post("/lodgify/sync-bookings", async (req, res) => {
      try {
        const orgId = getOrgId(req);
        const apiKey = await getLodgifyApiKey(orgId);
        const lodgify = getLodgifyService(apiKey, orgId);
        const lodgifyBookings = await lodgify.getBookings(true, 1, 100);
        let synced = 0;
        let updated = 0;
        let created = 0;
        const errors = [];
        for (const lodgifyBooking of lodgifyBookings) {
          try {
            const matchedProperty = await db.select().from(properties).where(
              and17(
                eq18(properties.organizationId, orgId),
                eq18(properties.externalId, lodgifyBooking.property_id.toString())
              )
            ).limit(1);
            if (matchedProperty.length === 0) {
              errors.push(
                `Booking ${lodgifyBooking.id}: Property not found (external ID: ${lodgifyBooking.property_id})`
              );
              continue;
            }
            const existing = await db.select().from(bookings).where(
              and17(
                eq18(bookings.organizationId, orgId),
                eq18(bookings.externalId, lodgifyBooking.id.toString())
              )
            ).limit(1);
            const totalAmount = lodgifyBooking.total || 0;
            const transactions = lodgifyBooking.transactions || [];
            const amountPaid = transactions.filter((t) => t.status === "completed" || t.status === "paid").reduce((sum4, t) => sum4 + (t.amount || 0), 0);
            const amountDue = totalAmount - amountPaid;
            let paymentStatus = "unpaid";
            if (amountPaid >= totalAmount && totalAmount > 0) {
              paymentStatus = "paid";
            } else if (amountPaid > 0) {
              paymentStatus = "partial";
            }
            let bookingStatus = "confirmed";
            const lodgifyStatus = lodgifyBooking.status?.toLowerCase();
            if (lodgifyStatus === "cancelled") bookingStatus = "cancelled";
            else if (lodgifyStatus === "booked" || lodgifyStatus === "confirmed")
              bookingStatus = "confirmed";
            else if (lodgifyStatus === "tentative") bookingStatus = "pending";
            const bookingData = {
              organizationId: orgId,
              externalId: lodgifyBooking.id.toString(),
              propertyId: matchedProperty[0].id,
              guestName: lodgifyBooking.guest?.name || "Unknown Guest",
              guestEmail: lodgifyBooking.guest?.email || "",
              guestPhone: lodgifyBooking.guest?.phone || "",
              checkIn: lodgifyBooking.arrival,
              checkOut: lodgifyBooking.departure,
              guests: lodgifyBooking.people || 1,
              totalAmount: totalAmount.toFixed(2),
              currency: lodgifyBooking.currency_code || "USD",
              paymentStatus,
              amountPaid: amountPaid.toFixed(2),
              amountDue: amountDue.toFixed(2),
              status: bookingStatus,
              bookingPlatform: lodgifyBooking.source || "lodgify"
            };
            if (existing.length > 0) {
              await db.update(bookings).set({
                ...bookingData,
                updatedAt: /* @__PURE__ */ new Date()
              }).where(eq18(bookings.id, existing[0].id));
              updated++;
            } else {
              await db.insert(bookings).values(bookingData);
              created++;
            }
            synced++;
          } catch (error) {
            errors.push(`Booking ${lodgifyBooking.id}: ${error.message}`);
          }
        }
        console.log(
          `[Lodgify Sync] Bookings: ${synced} synced (${created} created, ${updated} updated)`
        );
        res.json({
          success: true,
          synced,
          created,
          updated,
          total: lodgifyBookings.length,
          errors: errors.length > 0 ? errors : void 0
        });
      } catch (error) {
        console.error("[Lodgify API] Sync bookings error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to sync bookings"
        });
      }
    });
    router6.get("/lodgify/sync-status", async (req, res) => {
      try {
        const orgId = getOrgId(req);
        const syncedProperties = await db.select().from(properties).where(eq18(properties.organizationId, orgId));
        const syncedBookings = await db.select().from(bookings).where(eq18(bookings.organizationId, orgId));
        const lodgifyBookings = syncedBookings.filter(
          (b) => b.externalId && b.bookingPlatform === "lodgify"
        );
        res.json({
          success: true,
          properties: {
            total: syncedProperties.length,
            synced: syncedProperties.filter((p) => p.externalId).length
          },
          bookings: {
            total: syncedBookings.length,
            synced: lodgifyBookings.length
          },
          lastSync: (/* @__PURE__ */ new Date()).toISOString()
        });
      } catch (error) {
        console.error("[Lodgify API] Sync status error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to get sync status"
        });
      }
    });
    lodgify_routes_default = router6;
  }
});

// server/makcorps-service.ts
import axios2 from "axios";
function getMakcorpsService(apiKey, organizationId2 = "default-org") {
  const cacheKey = `org:${organizationId2}:key:${apiKey.substring(0, 10)}`;
  if (!makcorpsInstances.has(cacheKey)) {
    makcorpsInstances.set(cacheKey, new MakcorpsService(apiKey, organizationId2));
  }
  return makcorpsInstances.get(cacheKey);
}
var MakcorpsService, makcorpsInstances;
var init_makcorps_service = __esm({
  "server/makcorps-service.ts"() {
    "use strict";
    MakcorpsService = class {
      constructor(apiKey, organizationId2 = "default-org") {
        if (!apiKey) {
          throw new Error("Makcorps API key is required");
        }
        this.apiKey = apiKey;
        this.organizationId = organizationId2;
        this.client = axios2.create({
          baseURL: "https://api.makcorps.com",
          timeout: 3e4,
          params: {
            api_key: this.apiKey
          }
        });
      }
      /**
       * Test the API connection by making a simple mapping request
       */
      async testConnection() {
        try {
          const response = await this.client.get("/mapping", {
            params: {
              name: "New York"
            }
          });
          if (response.data && Array.isArray(response.data)) {
            return {
              success: true,
              message: `Connected successfully. Found ${response.data.length} results for test query.`
            };
          }
          return {
            success: false,
            message: "Unexpected response format"
          };
        } catch (error) {
          console.error("[Makcorps API] Connection test error:", error.response?.data || error.message);
          throw new Error(error.response?.data?.message || "Connection test failed");
        }
      }
      /**
       * Search for hotel or city IDs using the Mapping API
       * @param name - Hotel or city name to search for
       */
      async searchMapping(name) {
        try {
          const response = await this.client.get("/mapping", {
            params: { name }
          });
          return response.data || [];
        } catch (error) {
          console.error("[Makcorps API] Mapping search error:", error.response?.data || error.message);
          throw new Error(error.response?.data?.message || "Failed to search mapping");
        }
      }
      /**
       * Search hotels by city ID with pricing comparison
       * @param cityId - City ID from mapping API
       * @param checkin - Check-in date (YYYY-MM-DD)
       * @param checkout - Check-out date (YYYY-MM-DD)
       * @param adults - Number of adults
       * @param rooms - Number of rooms
       * @param currency - Currency code (USD, EUR, etc.)
       * @param pagination - Page number (starts at 0, ~30 hotels per page)
       * @param kids - Number of children (optional, 0-10)
       */
      async searchByCity(params) {
        try {
          const response = await this.client.get("/city", {
            params: {
              cityid: params.cityId,
              checkin: params.checkin,
              checkout: params.checkout,
              adults: params.adults,
              rooms: params.rooms,
              cur: params.currency,
              pagination: params.pagination || 0,
              kids: params.kids || 0
            }
          });
          return response.data || [];
        } catch (error) {
          console.error("[Makcorps API] City search error:", error.response?.data || error.message);
          throw new Error(error.response?.data?.message || "Failed to search by city");
        }
      }
      /**
       * Get pricing for a specific hotel from 15+ vendors
       * @param hotelId - Hotel ID from mapping API
       * @param checkin - Check-in date (YYYY-MM-DD)
       * @param checkout - Check-out date (YYYY-MM-DD)
       * @param adults - Number of adults
       * @param rooms - Number of rooms
       * @param currency - Currency code (USD, EUR, etc.)
       */
      async searchByHotel(params) {
        try {
          const response = await this.client.get("/hotel", {
            params: {
              hotelid: params.hotelId,
              checkin: params.checkin,
              checkout: params.checkout,
              adults: params.adults,
              rooms: params.rooms,
              cur: params.currency
            }
          });
          return response.data || { comparison: [] };
        } catch (error) {
          console.error("[Makcorps API] Hotel search error:", error.response?.data || error.message);
          throw new Error(error.response?.data?.message || "Failed to search by hotel");
        }
      }
      /**
       * Get Booking.com specific pricing data
       * @param country - ISO country code (e.g., "us")
       * @param hotelId - Booking.com hotel ID
       * @param checkin - Check-in date (YYYY-MM-DD)
       * @param checkout - Check-out date (YYYY-MM-DD)
       * @param adults - Number of adults
       * @param rooms - Number of rooms
       * @param currency - Currency code (USD, EUR, etc.)
       * @param kids - Number of children
       */
      async getBookingPrices(params) {
        try {
          const response = await this.client.get("/booking", {
            params: {
              country: params.country,
              hotelid: params.hotelId,
              checkin: params.checkin,
              checkout: params.checkout,
              adults: params.adults,
              rooms: params.rooms,
              currency: params.currency,
              kids: params.kids || 0
            }
          });
          return response.data || [];
        } catch (error) {
          console.error("[Makcorps API] Booking.com search error:", error.response?.data || error.message);
          throw new Error(error.response?.data?.message || "Failed to get Booking.com prices");
        }
      }
      /**
       * Get Expedia specific pricing data
       * @param hotelId - Expedia hotel ID
       * @param checkin - Check-in date (YYYY-MM-DD)
       * @param checkout - Check-out date (YYYY-MM-DD)
       * @param adults - Number of adults
       * @param rooms - Number of rooms
       * @param currency - Currency code (USD, EUR, etc.)
       * @param kids - Number of children (optional)
       */
      async getExpediaPrices(params) {
        try {
          const response = await this.client.get("/expedia", {
            params: {
              hotelid: params.hotelId,
              checkin: params.checkin,
              checkout: params.checkout,
              adults: params.adults,
              rooms: params.rooms,
              currency: params.currency,
              kids: params.kids || 0
            }
          });
          return response.data || [];
        } catch (error) {
          console.error("[Makcorps API] Expedia search error:", error.response?.data || error.message);
          throw new Error(error.response?.data?.message || "Failed to get Expedia prices");
        }
      }
    };
    makcorpsInstances = /* @__PURE__ */ new Map();
  }
});

// server/makcorps-routes.ts
var makcorps_routes_exports = {};
__export(makcorps_routes_exports, {
  default: () => makcorps_routes_default
});
import { Router as Router7 } from "express";
import { eq as eq19, and as and18 } from "drizzle-orm";
function getOrgId2(req) {
  return req.user?.organizationId || "default-org";
}
async function getMakcorpsApiKey(organizationId2) {
  const apiKeyRecord = await db.select().from(organizationApiKeys).where(
    and18(
      eq19(organizationApiKeys.organizationId, organizationId2),
      eq19(organizationApiKeys.provider, "makcorps"),
      eq19(organizationApiKeys.isActive, true)
    )
  ).limit(1);
  if (apiKeyRecord.length > 0 && apiKeyRecord[0].encryptedValue) {
    console.log(`[Makcorps] Using database API key for organization: ${organizationId2}`);
    return apiKeyRecord[0].encryptedValue;
  }
  const envKey = process.env.MAKCORPS_API_KEY;
  if (envKey) {
    console.log(`[Makcorps] WARNING: Using fallback environment variable for org ${organizationId2}. Configure org-specific key in production.`);
    return envKey;
  }
  throw new Error("Makcorps API key not configured. Please add it in API Connections settings.");
}
var router7, makcorps_routes_default;
var init_makcorps_routes = __esm({
  "server/makcorps-routes.ts"() {
    "use strict";
    init_makcorps_service();
    init_db();
    init_schema();
    router7 = Router7();
    router7.get("/makcorps/test-connection", async (req, res) => {
      try {
        const orgId = getOrgId2(req);
        const apiKey = await getMakcorpsApiKey(orgId);
        const makcorps = getMakcorpsService(apiKey, orgId);
        const result = await makcorps.testConnection();
        console.log("[Makcorps API] Connection test:", result);
        res.json(result);
      } catch (error) {
        console.error("[Makcorps API] Test connection error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Connection test failed"
        });
      }
    });
    router7.get("/makcorps/mapping", async (req, res) => {
      try {
        const { name } = req.query;
        if (!name || typeof name !== "string") {
          return res.status(400).json({
            success: false,
            message: "Missing required parameter: name"
          });
        }
        const orgId = getOrgId2(req);
        const apiKey = await getMakcorpsApiKey(orgId);
        const makcorps = getMakcorpsService(apiKey, orgId);
        const results = await makcorps.searchMapping(name);
        console.log(`[Makcorps API] Mapping search for "${name}": Found ${results.length} results`);
        res.json({
          success: true,
          count: results.length,
          results
        });
      } catch (error) {
        console.error("[Makcorps API] Mapping search error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to search mapping"
        });
      }
    });
    router7.get("/makcorps/search-by-city", async (req, res) => {
      try {
        const { cityId, checkin, checkout, adults, rooms, currency, pagination, kids } = req.query;
        if (!cityId || !checkin || !checkout || !adults || !rooms || !currency) {
          return res.status(400).json({
            success: false,
            message: "Missing required parameters: cityId, checkin, checkout, adults, rooms, currency"
          });
        }
        const orgId = getOrgId2(req);
        const apiKey = await getMakcorpsApiKey(orgId);
        const makcorps = getMakcorpsService(apiKey, orgId);
        const results = await makcorps.searchByCity({
          cityId,
          checkin,
          checkout,
          adults: parseInt(adults),
          rooms: parseInt(rooms),
          currency,
          pagination: pagination ? parseInt(pagination) : 0,
          kids: kids ? parseInt(kids) : 0
        });
        console.log(`[Makcorps API] City search: Found ${results.length} hotels`);
        res.json({
          success: true,
          count: results.length,
          results
        });
      } catch (error) {
        console.error("[Makcorps API] City search error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to search by city"
        });
      }
    });
    router7.get("/makcorps/search-by-hotel", async (req, res) => {
      try {
        const { hotelId, checkin, checkout, adults, rooms, currency } = req.query;
        if (!hotelId || !checkin || !checkout || !adults || !rooms || !currency) {
          return res.status(400).json({
            success: false,
            message: "Missing required parameters: hotelId, checkin, checkout, adults, rooms, currency"
          });
        }
        const orgId = getOrgId2(req);
        const apiKey = await getMakcorpsApiKey(orgId);
        const makcorps = getMakcorpsService(apiKey, orgId);
        const result = await makcorps.searchByHotel({
          hotelId,
          checkin,
          checkout,
          adults: parseInt(adults),
          rooms: parseInt(rooms),
          currency
        });
        console.log(`[Makcorps API] Hotel search: Found pricing data`);
        res.json({
          success: true,
          ...result
        });
      } catch (error) {
        console.error("[Makcorps API] Hotel search error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to search by hotel"
        });
      }
    });
    router7.get("/makcorps/booking-prices", async (req, res) => {
      try {
        const { country, hotelId, checkin, checkout, adults, rooms, currency, kids } = req.query;
        if (!country || !hotelId || !checkin || !checkout || !adults || !rooms || !currency) {
          return res.status(400).json({
            success: false,
            message: "Missing required parameters: country, hotelId, checkin, checkout, adults, rooms, currency"
          });
        }
        const orgId = getOrgId2(req);
        const apiKey = await getMakcorpsApiKey(orgId);
        const makcorps = getMakcorpsService(apiKey, orgId);
        const results = await makcorps.getBookingPrices({
          country,
          hotelId,
          checkin,
          checkout,
          adults: parseInt(adults),
          rooms: parseInt(rooms),
          currency,
          kids: kids ? parseInt(kids) : 0
        });
        console.log(`[Makcorps API] Booking.com search: Found ${results.length} room options`);
        res.json({
          success: true,
          count: results.length,
          results
        });
      } catch (error) {
        console.error("[Makcorps API] Booking.com search error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to get Booking.com prices"
        });
      }
    });
    router7.get("/makcorps/expedia-prices", async (req, res) => {
      try {
        const { hotelId, checkin, checkout, adults, rooms, currency, kids } = req.query;
        if (!hotelId || !checkin || !checkout || !adults || !rooms || !currency) {
          return res.status(400).json({
            success: false,
            message: "Missing required parameters: hotelId, checkin, checkout, adults, rooms, currency"
          });
        }
        const orgId = getOrgId2(req);
        const apiKey = await getMakcorpsApiKey(orgId);
        const makcorps = getMakcorpsService(apiKey, orgId);
        const results = await makcorps.getExpediaPrices({
          hotelId,
          checkin,
          checkout,
          adults: parseInt(adults),
          rooms: parseInt(rooms),
          currency,
          kids: kids ? parseInt(kids) : 0
        });
        console.log(`[Makcorps API] Expedia search: Found pricing data`);
        res.json({
          success: true,
          results
        });
      } catch (error) {
        console.error("[Makcorps API] Expedia search error:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to get Expedia prices"
        });
      }
    });
    makcorps_routes_default = router7;
  }
});

// server/hostaway-routes.ts
var hostaway_routes_exports = {};
__export(hostaway_routes_exports, {
  default: () => hostaway_routes_default
});
import { Router as Router8 } from "express";
var router8, hostaway_routes_default;
var init_hostaway_routes = __esm({
  "server/hostaway-routes.ts"() {
    "use strict";
    init_demoAuth();
    router8 = Router8();
    router8.get("/test-connection", isDemoAuthenticated, async (req, res) => {
      try {
        const { hostawayService: hostawayService2 } = await Promise.resolve().then(() => (init_hostawayService(), hostawayService_exports));
        const result = await hostawayService2.testConnection();
        res.json(result);
      } catch (error) {
        console.error("Error testing Hostaway connection:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to test Hostaway connection"
        });
      }
    });
    router8.get("/listings", isDemoAuthenticated, async (req, res) => {
      console.log(
        "\u{1F680} [HOSTAWAY] Route handler executing for /listings (DB-backed)"
      );
      try {
        const organizationId2 = req.user?.organizationId || "default-org";
        const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
        const { properties: properties2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const { eq: eq23, and: and22 } = await import("drizzle-orm");
        console.log("\u{1F680} [HOSTAWAY] Looking for DB-backed Hostaway properties...");
        const dbProps = await db2.select().from(properties2).where(
          and22(
            eq23(properties2.organizationId, organizationId2),
            eq23(properties2.source, "HOSTAWAY")
          )
        ).orderBy(properties2.id);
        if (dbProps && dbProps.length > 0) {
          console.log(
            `\u{1F680} [HOSTAWAY] Returning ${dbProps.length} Hostaway properties from DB`
          );
          const listings2 = dbProps.map((row) => {
            const imagesArray = Array.isArray(row.images) ? row.images : [];
            const listingImages = imagesArray.length > 0 ? imagesArray.map((url) => ({ url })) : [];
            const price = row.price ?? row.pricePerNight ?? (typeof row.pricePerNight === "string" ? parseFloat(row.pricePerNight) : void 0);
            return {
              // core fields used in Hostaway cards
              id: row.id,
              name: row.name,
              description: row.description,
              price,
              bedroomsNumber: row.bedrooms,
              bathroomsNumber: row.bathrooms,
              personCapacity: row.maxGuests,
              averageReviewRating: row.averageReviewRating,
              airbnbListingUrl: row.airbnbListingUrl,
              //  the image fields that the UI expects
              thumbnailUrl: row.thumbnailUrl ?? (imagesArray.length > 0 ? imagesArray[0] : null),
              listingImages,
              // mapping/meta fields (kept for future use)
              organizationId: row.organizationId,
              source: row.source,
              externalId: row.externalId,
              hostawayId: row.hostawayId,
              hostawayListingMapId: row.hostawayListingMapId,
              hostawayPropertyId: row.hostawayPropertyId,
              hostawayAccountId: row.hostawayAccountId
            };
          });
          return res.json({
            success: true,
            listings: listings2,
            count: listings2.length,
            backend: "db"
          });
        }
        console.log(
          "\u{1F680} [HOSTAWAY] No DB-backed properties found, falling back to Hostaway API"
        );
        const { hostawayService: hostawayService2 } = await Promise.resolve().then(() => (init_hostawayService(), hostawayService_exports));
        const { limit, offset, city, country } = req.query;
        const listings = await hostawayService2.getListings({
          limit: limit ? parseInt(limit) : void 0,
          offset: offset ? parseInt(offset) : void 0,
          city,
          country
        });
        console.log(
          "\u{1F680} [HOSTAWAY] Got",
          listings.length,
          "listings from Hostaway API - sending JSON response"
        );
        return res.json({
          success: true,
          listings,
          count: listings.length,
          backend: "hostaway-api"
        });
      } catch (error) {
        console.error("Error fetching Hostaway listings:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to fetch Hostaway listings"
        });
      }
    });
    router8.get("/listings/:id", isDemoAuthenticated, async (req, res) => {
      try {
        const { hostawayService: hostawayService2 } = await Promise.resolve().then(() => (init_hostawayService(), hostawayService_exports));
        const listingId = parseInt(req.params.id);
        const listing = await hostawayService2.getListing(listingId);
        if (!listing) {
          return res.status(404).json({
            success: false,
            message: "Listing not found"
          });
        }
        res.json({
          success: true,
          listing
        });
      } catch (error) {
        console.error("Error fetching Hostaway listing:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to fetch Hostaway listing"
        });
      }
    });
    router8.post("/sync-properties", isDemoAuthenticated, async (req, res) => {
      try {
        const { hostawayService: hostawayService2 } = await Promise.resolve().then(() => (init_hostawayService(), hostawayService_exports));
        const organizationId2 = req.user?.organizationId || "default-org";
        console.log(
          `\u{1F504} Starting Hostaway properties sync for organization: ${organizationId2}`
        );
        const result = await hostawayService2.syncPropertiesToDatabase(organizationId2);
        if (result.success) {
          res.json({
            success: true,
            message: `Successfully synced ${result.synced} properties from Hostaway`,
            synced: result.synced,
            properties: result.properties
          });
        } else {
          res.status(500).json({
            success: false,
            message: `Sync completed with errors: ${result.errors.join(", ")}`,
            synced: result.synced,
            errors: result.errors
          });
        }
      } catch (error) {
        console.error("Error syncing Hostaway properties:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to sync Hostaway properties"
        });
      }
    });
    router8.post("/sync-bookings", isDemoAuthenticated, async (req, res) => {
      try {
        const { hostawayService: hostawayService2 } = await Promise.resolve().then(() => (init_hostawayService(), hostawayService_exports));
        const organizationId2 = req.user?.organizationId || "default-org";
        console.log(
          `\u{1F504} Starting Hostaway bookings sync for organization: ${organizationId2}`
        );
        const result = await hostawayService2.syncBookingsToDatabase(organizationId2);
        if (result.success) {
          res.json({
            success: true,
            message: `Successfully synced ${result.synced} bookings from Hostaway`,
            synced: result.synced,
            bookings: result.bookings
          });
        } else {
          res.status(500).json({
            success: false,
            message: `Sync completed with errors: ${result.errors.join(", ")}`,
            synced: result.synced,
            errors: result.errors
          });
        }
      } catch (error) {
        console.error("Error syncing Hostaway bookings:", error);
        res.status(500).json({
          success: false,
          message: error.message || "Failed to sync Hostaway bookings"
        });
      }
    });
    hostaway_routes_default = router8;
  }
});

// server/daily-operations-routes.ts
var daily_operations_routes_exports = {};
__export(daily_operations_routes_exports, {
  default: () => daily_operations_routes_default
});
import { Router as Router9 } from "express";
import { and as and19, eq as eq20, gte as gte7, lte as lte7, sql as sql10, or as or3 } from "drizzle-orm";
function getDateRange(dateString) {
  const date3 = new Date(dateString);
  const startOfDay = new Date(date3.setHours(0, 0, 0, 0));
  const endOfDay = new Date(date3.setHours(23, 59, 59, 999));
  return { startOfDay, endOfDay };
}
var router9, daily_operations_routes_default;
var init_daily_operations_routes = __esm({
  "server/daily-operations-routes.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_demoAuth();
    router9 = Router9();
    router9.get("/summary/:date", isDemoAuthenticated, async (req, res) => {
      try {
        const { date: date3 } = req.params;
        const { organizationId: organizationId2 } = req.user;
        const { startOfDay, endOfDay } = getDateRange(date3);
        const dateTasks = await db.select().from(tasks).where(
          and19(
            eq20(tasks.organizationId, organizationId2),
            gte7(tasks.dueDate, startOfDay),
            lte7(tasks.dueDate, endOfDay)
          )
        );
        const cleaningTasks = dateTasks.filter(
          (t) => t.department?.toLowerCase() === "cleaning" || t.department?.toLowerCase() === "housekeeping" || t.type?.toLowerCase() === "cleaning"
        );
        const poolTasks = dateTasks.filter(
          (t) => t.department?.toLowerCase() === "pool" || t.type?.toLowerCase() === "pool-service"
        );
        const gardenTasks = dateTasks.filter(
          (t) => t.department?.toLowerCase() === "garden" || t.department?.toLowerCase() === "landscaping" || t.type?.toLowerCase() === "garden"
        );
        const maintenanceTasks = dateTasks.filter(
          (t) => t.department?.toLowerCase() === "maintenance" || t.type?.toLowerCase() === "maintenance"
        );
        const generalTasks = dateTasks.filter(
          (t) => !["cleaning", "housekeeping", "pool", "garden", "landscaping", "maintenance"].includes(t.department?.toLowerCase() || "") && !["cleaning", "pool-service", "garden", "maintenance"].includes(t.type?.toLowerCase() || "")
        );
        const cleaningCompleted = cleaningTasks.filter((t) => t.status?.toLowerCase() === "completed").length;
        const poolCompleted = poolTasks.filter((t) => t.status?.toLowerCase() === "completed").length;
        const gardenCompleted = gardenTasks.filter((t) => t.status?.toLowerCase() === "completed").length;
        const maintenanceCompleted = maintenanceTasks.filter((t) => t.status?.toLowerCase() === "completed").length;
        const generalCompleted = generalTasks.filter((t) => t.status?.toLowerCase() === "completed").length;
        const now = /* @__PURE__ */ new Date();
        const overdueTasks = dateTasks.filter(
          (t) => t.status?.toLowerCase() !== "completed" && t.status?.toLowerCase() !== "cancelled" && t.dueDate && new Date(t.dueDate) < now
        ).length;
        const tasksWithoutProof = dateTasks.filter(
          (t) => t.status?.toLowerCase() === "completed" && (!t.evidencePhotos || t.evidencePhotos.length === 0)
        ).length;
        const unassignedTasks = dateTasks.filter((t) => !t.assignedTo).length;
        const checkInsToday = await db.select().from(bookings).where(
          and19(
            eq20(bookings.organizationId, organizationId2),
            gte7(bookings.checkIn, startOfDay),
            lte7(bookings.checkIn, endOfDay)
          )
        );
        let uncleanedCheckinProperties = 0;
        if (checkInsToday.length > 0) {
          for (const booking of checkInsToday) {
            const cleaningTask = dateTasks.find(
              (t) => t.propertyId === booking.propertyId && (t.type?.toLowerCase() === "cleaning" || t.department?.toLowerCase() === "cleaning") && t.status?.toLowerCase() === "completed"
            );
            if (!cleaningTask) {
              uncleanedCheckinProperties++;
            }
          }
        }
        const uniqueStaff = new Set(dateTasks.map((t) => t.assignedTo).filter(Boolean));
        const totalStaffScheduled = uniqueStaff.size;
        const summary = {
          id: 1,
          // Dummy ID for consistency
          organizationId: organizationId2,
          operationDate: date3,
          cleaningTasks: cleaningTasks.length,
          cleaningCompleted,
          poolTasks: poolTasks.length,
          poolCompleted,
          gardenTasks: gardenTasks.length,
          gardenCompleted,
          maintenanceTasks: maintenanceTasks.length,
          maintenanceCompleted,
          generalTasks: generalTasks.length,
          generalCompleted,
          overdueTasks,
          tasksWithoutProof,
          uncleanedCheckinProperties,
          unassignedTasks,
          totalStaffScheduled,
          totalTasksAssigned: dateTasks.length,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        res.json(summary);
      } catch (error) {
        console.error("Error fetching daily operations summary:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router9.get("/staff/:date", isDemoAuthenticated, async (req, res) => {
      try {
        const { date: date3 } = req.params;
        const { organizationId: organizationId2 } = req.user;
        const { startOfDay, endOfDay } = getDateRange(date3);
        const dateTasks = await db.select().from(tasks).where(
          and19(
            eq20(tasks.organizationId, organizationId2),
            gte7(tasks.dueDate, startOfDay),
            lte7(tasks.dueDate, endOfDay)
          )
        );
        const staffIds = [...new Set(dateTasks.map((t) => t.assignedTo).filter(Boolean))];
        const staffDetails = await db.select().from(users).where(
          and19(
            eq20(users.organizationId, organizationId2),
            sql10`${users.id} = ANY(${staffIds})`
          )
        );
        const staffAssignments = staffIds.map((staffId, index2) => {
          const staffTasks = dateTasks.filter((t) => t.assignedTo === staffId);
          const completedTasks = staffTasks.filter((t) => t.status?.toLowerCase() === "completed");
          const staff = staffDetails.find((s) => s.id === staffId);
          const deptCounts = {};
          staffTasks.forEach((t) => {
            const dept = t.department || "general";
            deptCounts[dept] = (deptCounts[dept] || 0) + 1;
          });
          const departmentFocus = Object.keys(deptCounts).length > 0 ? Object.entries(deptCounts).sort((a, b) => b[1] - a[1])[0][0] : null;
          const completedWithTimes = completedTasks.filter((t) => t.completedAt);
          let avgCompletionTime = null;
          if (completedWithTimes.length > 0) {
            const totalTime = completedWithTimes.reduce((sum4, t) => {
              const created = new Date(t.createdAt).getTime();
              const completed = new Date(t.completedAt).getTime();
              return sum4 + (completed - created);
            }, 0);
            avgCompletionTime = Math.round(totalTime / completedWithTimes.length / (1e3 * 60));
          }
          const completionRate = staffTasks.length > 0 ? (completedTasks.length / staffTasks.length * 100).toFixed(1) + "%" : "0%";
          return {
            id: index2 + 1,
            organizationId: organizationId2,
            staffId,
            staffName: staff ? `${staff.firstName || ""} ${staff.lastName || ""}`.trim() || staff.email : `Staff ${staffId}`,
            operationDate: date3,
            shiftStart: null,
            // Could be enhanced with actual shift data
            shiftEnd: null,
            isAvailable: true,
            unavailableReason: null,
            totalTasksAssigned: staffTasks.length,
            totalTasksCompleted: completedTasks.length,
            departmentFocus,
            avgTaskCompletionTime: avgCompletionTime,
            taskCompletionRate: completionRate,
            notes: null,
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
        });
        res.json(staffAssignments);
      } catch (error) {
        console.error("Error fetching staff assignments:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router9.get("/properties/:date", isDemoAuthenticated, async (req, res) => {
      try {
        const { date: date3 } = req.params;
        const { organizationId: organizationId2 } = req.user;
        const { startOfDay, endOfDay } = getDateRange(date3);
        const dateTasks = await db.select().from(tasks).where(
          and19(
            eq20(tasks.organizationId, organizationId2),
            gte7(tasks.dueDate, startOfDay),
            lte7(tasks.dueDate, endOfDay)
          )
        );
        const propertyIds = [...new Set(dateTasks.map((t) => t.propertyId).filter(Boolean))];
        const propertiesData = await db.select().from(properties).where(
          and19(
            eq20(properties.organizationId, organizationId2),
            sql10`${properties.id} = ANY(${propertyIds})`
          )
        );
        const propertyBookings = await db.select().from(bookings).where(
          and19(
            eq20(bookings.organizationId, organizationId2),
            or3(
              and19(
                gte7(bookings.checkIn, startOfDay),
                lte7(bookings.checkIn, endOfDay)
              ),
              and19(
                gte7(bookings.checkOut, startOfDay),
                lte7(bookings.checkOut, endOfDay)
              )
            )
          )
        );
        const propertyOps = propertyIds.map((propId, index2) => {
          const property = propertiesData.find((p) => p.id === propId);
          const propTasks = dateTasks.filter((t) => t.propertyId === propId);
          const propBookings = propertyBookings.filter((b) => b.propertyId === propId);
          const hasCheckin = propBookings.some((b) => {
            const checkIn = new Date(b.checkIn);
            return checkIn >= startOfDay && checkIn <= endOfDay;
          });
          const hasCheckout = propBookings.some((b) => {
            const checkOut = new Date(b.checkOut);
            return checkOut >= startOfDay && checkOut <= endOfDay;
          });
          const checkinTime = hasCheckin ? propBookings.find((b) => new Date(b.checkIn) >= startOfDay && new Date(b.checkIn) <= endOfDay)?.checkIn : null;
          const checkoutTime = hasCheckout ? propBookings.find((b) => new Date(b.checkOut) >= startOfDay && new Date(b.checkOut) <= endOfDay)?.checkOut : null;
          const cleaningTasks = propTasks.filter(
            (t) => t.type?.toLowerCase() === "cleaning" || t.department?.toLowerCase() === "cleaning" || t.department?.toLowerCase() === "housekeeping"
          );
          const needsCleaning = hasCheckin || hasCheckout || cleaningTasks.length > 0;
          const cleaningCompleted = cleaningTasks.some((t) => t.status?.toLowerCase() === "completed");
          const cleaningCompletedAt = cleaningTasks.find((t) => t.status?.toLowerCase() === "completed")?.completedAt;
          const cleaningStaffId = cleaningTasks.find((t) => t.status?.toLowerCase() === "completed")?.assignedTo;
          const maintenanceTasks = propTasks.filter(
            (t) => t.type?.toLowerCase() === "maintenance" || t.department?.toLowerCase() === "maintenance"
          );
          const maintenanceCompleted = maintenanceTasks.filter((t) => t.status?.toLowerCase() === "completed").length;
          const now = /* @__PURE__ */ new Date();
          const maintenanceOverdue = maintenanceTasks.filter(
            (t) => t.status?.toLowerCase() !== "completed" && t.dueDate && new Date(t.dueDate) < now
          ).length;
          const recurringTasks3 = propTasks.filter((t) => t.isRecurring);
          const recurringCompleted = recurringTasks3.filter((t) => t.status?.toLowerCase() === "completed").length;
          const isUrgent = hasCheckin && !cleaningCompleted || maintenanceOverdue > 0;
          const urgencyReason = isUrgent ? hasCheckin && !cleaningCompleted ? "Check-in today but cleaning not completed" : "Overdue maintenance tasks" : null;
          let operationStatus = "on-track";
          if (isUrgent) operationStatus = "urgent";
          else if (propTasks.length > 0 && propTasks.every((t) => t.status?.toLowerCase() === "completed")) {
            operationStatus = "completed";
          } else if (propTasks.some((t) => t.status?.toLowerCase() === "in-progress")) {
            operationStatus = "in-progress";
          }
          return {
            id: index2 + 1,
            organizationId: organizationId2,
            propertyId: propId,
            propertyName: property?.name || `Property ${propId}`,
            propertyAddress: property?.address || "",
            operationDate: date3,
            hasCheckin,
            checkinTime: checkinTime ? new Date(checkinTime).toISOString() : null,
            hasCheckout,
            checkoutTime: checkoutTime ? new Date(checkoutTime).toISOString() : null,
            needsCleaning,
            cleaningCompleted,
            cleaningCompletedAt: cleaningCompletedAt ? new Date(cleaningCompletedAt).toISOString() : null,
            cleaningStaffId,
            maintenanceTasks: maintenanceTasks.length,
            maintenanceCompleted,
            maintenanceOverdue,
            recurringServices: recurringTasks3.length,
            recurringCompleted,
            isUrgent,
            urgencyReason,
            operationStatus,
            statusNotes: null,
            lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          };
        });
        res.json(propertyOps);
      } catch (error) {
        console.error("Error fetching property operations:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router9.get("/tasks/:date", isDemoAuthenticated, async (req, res) => {
      try {
        const { date: date3 } = req.params;
        const { organizationId: organizationId2 } = req.user;
        const { startOfDay, endOfDay } = getDateRange(date3);
        const dateTasks = await db.select({
          task: tasks,
          property: properties,
          assignee: users
        }).from(tasks).leftJoin(properties, eq20(tasks.propertyId, properties.id)).leftJoin(users, eq20(tasks.assignedTo, users.id)).where(
          and19(
            eq20(tasks.organizationId, organizationId2),
            gte7(tasks.dueDate, startOfDay),
            lte7(tasks.dueDate, endOfDay)
          )
        );
        const now = /* @__PURE__ */ new Date();
        const formattedTasks = dateTasks.map(({ task, property, assignee }) => ({
          id: task.id,
          title: task.title,
          description: task.description,
          status: task.status || "pending",
          priority: task.priority || "medium",
          department: task.department,
          propertyId: task.propertyId,
          propertyName: property?.name || null,
          assignedTo: task.assignedTo,
          assignedUserName: assignee ? `${assignee.firstName || ""} ${assignee.lastName || ""}`.trim() || assignee.email : null,
          dueDate: task.dueDate ? new Date(task.dueDate).toISOString() : null,
          evidencePhotos: task.evidencePhotos || [],
          createdAt: new Date(task.createdAt).toISOString(),
          isOverdue: task.status?.toLowerCase() !== "completed" && task.status?.toLowerCase() !== "cancelled" && task.dueDate ? new Date(task.dueDate) < now : false,
          hasProof: task.evidencePhotos && task.evidencePhotos.length > 0
        }));
        res.json(formattedTasks);
      } catch (error) {
        console.error("Error fetching daily tasks:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router9.post("/refresh/:date", isDemoAuthenticated, async (req, res) => {
      try {
        const { date: date3 } = req.params;
        res.json({
          success: true,
          message: "Data refresh triggered",
          date: date3
        });
      } catch (error) {
        console.error("Error refreshing daily operations:", error);
        res.status(500).json({ error: error.message });
      }
    });
    daily_operations_routes_default = router9;
  }
});

// server/portfolio/commission-service.ts
import { eq as eq21, and as and20, gte as gte8, lte as lte8, sql as sql11 } from "drizzle-orm";
async function calculateManagerCommissionForPeriod(params) {
  const { organizationId: organizationId2, managerId, startDate, endDate, propertyId } = params;
  const conditions = [
    eq21(commissionPayouts.organizationId, organizationId2),
    eq21(commissionPayouts.userId, managerId),
    eq21(commissionPayouts.userRole, "portfolio-manager")
  ];
  if (propertyId) {
    conditions.push(eq21(commissionPayouts.propertyId, parseInt(propertyId)));
  }
  const startMonth = startDate.substring(0, 7);
  const endMonth = endDate.substring(0, 7);
  conditions.push(gte8(commissionPayouts.period, startMonth));
  conditions.push(lte8(commissionPayouts.period, endMonth));
  const commissionRecords = await db.select({
    id: commissionPayouts.id,
    propertyId: commissionPayouts.propertyId,
    commissionAmount: commissionPayouts.finalPayoutAmount,
    status: commissionPayouts.status,
    period: commissionPayouts.period
  }).from(commissionPayouts).where(and20(...conditions));
  const propertyIds = [...new Set(commissionRecords.map((r) => r.propertyId).filter(Boolean))];
  let propertyData = [];
  if (propertyIds.length > 0) {
    propertyData = await db.select({
      id: properties.id,
      name: properties.name
    }).from(properties).where(
      and20(
        eq21(properties.organizationId, organizationId2),
        sql11`${properties.id} = ANY(${propertyIds})`
      )
    );
  }
  const propertyMap = new Map(propertyData.map((p) => [p.id, p.name || `Property #${p.id}`]));
  const breakdownMap = /* @__PURE__ */ new Map();
  for (const record of commissionRecords) {
    const { propertyId: propertyId2, commissionAmount } = record;
    if (!propertyId2) continue;
    if (!breakdownMap.has(propertyId2)) {
      breakdownMap.set(propertyId2, {
        propertyId: propertyId2,
        propertyName: propertyMap.get(propertyId2) || `Property #${propertyId2}`,
        commission: 0,
        bookingCount: 0,
        totalRevenue: 0
      });
    }
    const breakdown = breakdownMap.get(propertyId2);
    breakdown.commission += parseFloat(commissionAmount || "0");
    breakdown.bookingCount += 1;
  }
  const breakdownByProperty = Array.from(breakdownMap.values());
  const totalCommission = breakdownByProperty.reduce((sum4, b) => sum4 + b.commission, 0);
  return {
    totalCommission,
    currency: "USD",
    breakdownByProperty,
    rawItems: commissionRecords.map((r) => ({
      bookingId: null,
      propertyId: r.propertyId || 0,
      commissionAmount: parseFloat(r.commissionAmount || "0"),
      status: r.status || "pending",
      commissionType: "monthly"
    }))
  };
}
async function getPortfolioManagerProperties(organizationId2, managerId) {
  const assignments = await db.select({
    id: portfolioAssignments.id,
    propertyId: portfolioAssignments.propertyId,
    isActive: portfolioAssignments.isActive,
    propertyName: properties.name,
    propertyAddress: properties.address,
    propertyStatus: properties.status
  }).from(portfolioAssignments).leftJoin(properties, eq21(portfolioAssignments.propertyId, properties.id)).where(
    and20(
      eq21(portfolioAssignments.organizationId, organizationId2),
      eq21(portfolioAssignments.managerId, managerId),
      eq21(portfolioAssignments.isActive, true)
    )
  );
  return assignments;
}
async function calculateMonthlyTrend(organizationId2, managerId, months = 6) {
  const endDate = /* @__PURE__ */ new Date();
  const startDate = /* @__PURE__ */ new Date();
  startDate.setMonth(startDate.getMonth() - months);
  const trends = [];
  for (let i = 0; i < months; i++) {
    const periodDate = new Date(startDate);
    periodDate.setMonth(periodDate.getMonth() + i);
    const period = `${periodDate.getFullYear()}-${String(periodDate.getMonth() + 1).padStart(2, "0")}`;
    const commissions = await db.select({
      total: sql11`SUM(CAST(${commissionPayouts.finalPayoutAmount} AS NUMERIC))`
    }).from(commissionPayouts).where(
      and20(
        eq21(commissionPayouts.organizationId, organizationId2),
        eq21(commissionPayouts.userId, managerId),
        eq21(commissionPayouts.userRole, "portfolio-manager"),
        eq21(commissionPayouts.period, period)
      )
    );
    trends.push({
      period,
      earnings: parseFloat(commissions[0]?.total?.toString() || "0")
    });
  }
  return trends;
}
async function getCommissionBalance(organizationId2, managerId) {
  const [balanceRecord] = await db.select().from(pmCommissionBalance2).where(
    and20(
      eq21(pmCommissionBalance2.organizationId, organizationId2),
      eq21(pmCommissionBalance2.managerId, managerId)
    )
  );
  if (balanceRecord) {
    return {
      totalEarned: parseFloat(balanceRecord.totalEarned || "0"),
      totalPaid: parseFloat(balanceRecord.totalPaid || "0"),
      currentBalance: parseFloat(balanceRecord.currentBalance || "0"),
      lastPayoutDate: balanceRecord.lastPayoutDate?.toISOString()
    };
  }
  const earned = await db.select({
    total: sql11`SUM(CAST(${commissionPayouts.finalPayoutAmount} AS NUMERIC))`
  }).from(commissionPayouts).where(
    and20(
      eq21(commissionPayouts.organizationId, organizationId2),
      eq21(commissionPayouts.userId, managerId),
      eq21(commissionPayouts.userRole, "portfolio-manager")
    )
  );
  const totalEarned = parseFloat(earned[0]?.total?.toString() || "0");
  const paid = await db.select({
    total: sql11`SUM(CAST(${pmPayoutRequests.amount} AS NUMERIC))`
  }).from(pmPayoutRequests).where(
    and20(
      eq21(pmPayoutRequests.organizationId, organizationId2),
      eq21(pmPayoutRequests.managerId, managerId),
      eq21(pmPayoutRequests.status, "paid")
    )
  );
  const totalPaid = parseFloat(paid[0]?.total?.toString() || "0");
  return {
    totalEarned,
    totalPaid,
    currentBalance: totalEarned - totalPaid,
    lastPayoutDate: void 0
  };
}
var init_commission_service = __esm({
  "server/portfolio/commission-service.ts"() {
    "use strict";
    init_db();
    init_schema();
  }
});

// server/portfolio/pm-dashboard-routes.ts
var pm_dashboard_routes_exports = {};
__export(pm_dashboard_routes_exports, {
  registerPMDashboardRoutes: () => registerPMDashboardRoutes
});
import { eq as eq22, and as and21, gte as gte9, lte as lte9, sql as sql12, desc as desc11, count as count2 } from "drizzle-orm";
function registerPMDashboardRoutes(app2) {
  app2.get("/api/pm/dashboard/financial-overview", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      if (!organizationId2) {
        return res.status(400).send("Organization ID required");
      }
      const { startDate, endDate, propertyId, portfolioManagerId } = req.query;
      const managerId = portfolioManagerId || req.user?.id;
      if (!managerId) {
        return res.status(400).send("Portfolio Manager ID required");
      }
      const commissionData = await calculateManagerCommissionForPeriod({
        organizationId: organizationId2,
        managerId,
        startDate: startDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        endDate: endDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        propertyId
      });
      const monthlyTrend = await calculateMonthlyTrend(organizationId2, managerId);
      res.json({
        totalCommissionEarnings: commissionData.totalCommission,
        propertyBreakdown: commissionData.breakdownByProperty.map((b) => ({
          propertyId: b.propertyId,
          propertyName: b.propertyName,
          totalRevenue: b.totalRevenue,
          commissionEarned: b.commission,
          bookingCount: b.bookingCount
        })),
        monthlyTrend,
        pendingBalance: commissionData.totalCommission
        // Will be refined with payout tracking
      });
    } catch (error) {
      console.error("Error fetching financial overview:", error);
      res.status(500).send(error.message);
    }
  });
  app2.get("/api/pm/dashboard/balance", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      if (!organizationId2) {
        return res.status(400).send("Organization ID required");
      }
      const { portfolioManagerId } = req.query;
      const managerId = portfolioManagerId || req.user?.id;
      if (!managerId) {
        return res.status(400).send("Portfolio Manager ID required");
      }
      const balance = await getCommissionBalance(organizationId2, managerId);
      const lastPayout = await db.select({
        paidAt: pmPayoutRequests.paidAt
      }).from(pmPayoutRequests).where(
        and21(
          eq22(pmPayoutRequests.organizationId, organizationId2),
          eq22(pmPayoutRequests.managerId, managerId),
          eq22(pmPayoutRequests.status, "paid")
        )
      ).orderBy(desc11(pmPayoutRequests.paidAt)).limit(1);
      res.json({
        totalEarned: balance.totalEarned,
        totalPaid: balance.totalPaid,
        currentBalance: balance.currentBalance,
        lastPayoutDate: lastPayout[0]?.paidAt?.toISOString()
      });
    } catch (error) {
      console.error("Error fetching balance:", error);
      res.status(500).send(error.message);
    }
  });
  app2.get("/api/pm/dashboard/payouts", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      if (!organizationId2) {
        return res.status(400).send("Organization ID required");
      }
      const { portfolioManagerId } = req.query;
      const managerId = portfolioManagerId || req.user?.id;
      if (!managerId) {
        return res.status(400).send("Portfolio Manager ID required");
      }
      const payouts = await db.select().from(pmPayoutRequests).where(
        and21(
          eq22(pmPayoutRequests.organizationId, organizationId2),
          eq22(pmPayoutRequests.managerId, managerId)
        )
      ).orderBy(desc11(pmPayoutRequests.requestedAt));
      res.json(payouts.map((p) => ({
        id: p.id,
        amount: parseFloat(p.amount),
        currency: p.currency,
        requestNotes: p.requestNotes,
        adminNotes: p.adminNotes,
        status: p.status,
        receiptUrl: p.receiptUrl,
        requestedAt: p.requestedAt?.toISOString(),
        approvedAt: p.approvedAt?.toISOString(),
        paidAt: p.paidAt?.toISOString()
      })));
    } catch (error) {
      console.error("Error fetching payouts:", error);
      res.status(500).send(error.message);
    }
  });
  app2.post("/api/pm/dashboard/payouts", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      const managerId = req.user?.id;
      if (!organizationId2 || !managerId) {
        return res.status(400).send("Organization ID and Manager ID required");
      }
      const { amount, requestNotes } = req.body;
      const requestAmount = parseFloat(amount);
      if (isNaN(requestAmount) || requestAmount <= 0) {
        return res.status(400).send("Invalid amount");
      }
      const balance = await getCommissionBalance(organizationId2, managerId);
      if (requestAmount > balance.currentBalance) {
        return res.status(400).send("Insufficient balance");
      }
      const [newPayout] = await db.insert(pmPayoutRequests).values({
        organizationId: organizationId2,
        managerId,
        amount: requestAmount.toString(),
        currency: "USD",
        requestNotes: requestNotes || null,
        status: "pending"
      }).returning();
      res.json(newPayout);
    } catch (error) {
      console.error("Error creating payout request:", error);
      res.status(500).send(error.message);
    }
  });
  app2.patch("/api/pm/dashboard/payouts/:id/received", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      const managerId = req.user?.id;
      const payoutId = parseInt(req.params.id);
      if (!organizationId2 || !managerId) {
        return res.status(400).send("Organization ID and Manager ID required");
      }
      const [payout] = await db.select().from(pmPayoutRequests).where(
        and21(
          eq22(pmPayoutRequests.id, payoutId),
          eq22(pmPayoutRequests.organizationId, organizationId2),
          eq22(pmPayoutRequests.managerId, managerId)
        )
      );
      if (!payout) {
        return res.status(404).send("Payout not found");
      }
      if (payout.status !== "approved" && payout.status !== "paid") {
        return res.status(400).send("Payout must be approved first");
      }
      const [updated] = await db.update(pmPayoutRequests).set({
        status: "paid",
        paidAt: /* @__PURE__ */ new Date()
      }).where(eq22(pmPayoutRequests.id, payoutId)).returning();
      res.json(updated);
    } catch (error) {
      console.error("Error confirming payout:", error);
      res.status(500).send(error.message);
    }
  });
  app2.patch("/api/pm/dashboard/payouts/:id/approve", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const userRole = req.user?.role;
      if (userRole !== "admin") {
        return res.status(403).send("Admin access required");
      }
      const organizationId2 = req.user?.organizationId;
      const adminId = req.user?.id;
      const payoutId = parseInt(req.params.id);
      const { adminNotes } = req.body;
      const [payout] = await db.select().from(pmPayoutRequests).where(
        and21(
          eq22(pmPayoutRequests.id, payoutId),
          eq22(pmPayoutRequests.organizationId, organizationId2)
        )
      );
      if (!payout) {
        return res.status(404).send("Payout not found");
      }
      if (payout.status !== "pending") {
        return res.status(400).send("Payout has already been processed");
      }
      const [updated] = await db.update(pmPayoutRequests).set({
        status: "approved",
        adminNotes: adminNotes || null,
        approvedAt: /* @__PURE__ */ new Date(),
        processedBy: adminId
      }).where(eq22(pmPayoutRequests.id, payoutId)).returning();
      res.json(updated);
    } catch (error) {
      console.error("Error approving payout:", error);
      res.status(500).send(error.message);
    }
  });
  app2.patch("/api/pm/dashboard/payouts/:id/reject", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const userRole = req.user?.role;
      if (userRole !== "admin") {
        return res.status(403).send("Admin access required");
      }
      const organizationId2 = req.user?.organizationId;
      const adminId = req.user?.id;
      const payoutId = parseInt(req.params.id);
      const { adminNotes } = req.body;
      const [payout] = await db.select().from(pmPayoutRequests).where(
        and21(
          eq22(pmPayoutRequests.id, payoutId),
          eq22(pmPayoutRequests.organizationId, organizationId2)
        )
      );
      if (!payout) {
        return res.status(404).send("Payout not found");
      }
      if (payout.status !== "pending") {
        return res.status(400).send("Payout has already been processed");
      }
      const [updated] = await db.update(pmPayoutRequests).set({
        status: "rejected",
        adminNotes: adminNotes || null,
        processedBy: adminId
      }).where(eq22(pmPayoutRequests.id, payoutId)).returning();
      res.json(updated);
    } catch (error) {
      console.error("Error rejecting payout:", error);
      res.status(500).send(error.message);
    }
  });
  app2.patch("/api/pm/dashboard/payouts/:id/pay", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const userRole = req.user?.role;
      if (userRole !== "admin") {
        return res.status(403).send("Admin access required");
      }
      const organizationId2 = req.user?.organizationId;
      const adminId = req.user?.id;
      const payoutId = parseInt(req.params.id);
      const { receiptUrl, adminNotes } = req.body;
      const [payout] = await db.select().from(pmPayoutRequests).where(
        and21(
          eq22(pmPayoutRequests.id, payoutId),
          eq22(pmPayoutRequests.organizationId, organizationId2)
        )
      );
      if (!payout) {
        return res.status(404).send("Payout not found");
      }
      if (payout.status !== "approved") {
        return res.status(400).send("Payout must be approved first");
      }
      const [updated] = await db.update(pmPayoutRequests).set({
        status: "paid",
        receiptUrl: receiptUrl || null,
        adminNotes: adminNotes || payout.adminNotes,
        paidAt: /* @__PURE__ */ new Date(),
        processedBy: adminId
      }).where(eq22(pmPayoutRequests.id, payoutId)).returning();
      const payoutAmount = parseFloat(payout.amount || "0");
      const [balanceRecord] = await db.select().from(pmCommissionBalance2).where(
        and21(
          eq22(pmCommissionBalance2.organizationId, organizationId2),
          eq22(pmCommissionBalance2.managerId, payout.managerId)
        )
      );
      if (balanceRecord) {
        const currentPaid = parseFloat(balanceRecord.totalPaid || "0");
        const currentBalance = parseFloat(balanceRecord.currentBalance || "0");
        await db.update(pmCommissionBalance2).set({
          totalPaid: (currentPaid + payoutAmount).toFixed(2),
          currentBalance: Math.max(0, currentBalance - payoutAmount).toFixed(2),
          lastPayoutDate: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq22(pmCommissionBalance2.id, balanceRecord.id));
      }
      res.json(updated);
    } catch (error) {
      console.error("Error marking payout as paid:", error);
      res.status(500).send(error.message);
    }
  });
  app2.get("/api/pm/dashboard/all-payouts", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const userRole = req.user?.role;
      if (userRole !== "admin") {
        return res.status(403).send("Admin access required");
      }
      const organizationId2 = req.user?.organizationId;
      const { status, managerId } = req.query;
      const conditions = [eq22(pmPayoutRequests.organizationId, organizationId2)];
      if (status && status !== "all") {
        conditions.push(eq22(pmPayoutRequests.status, status));
      }
      if (managerId) {
        conditions.push(eq22(pmPayoutRequests.managerId, managerId));
      }
      const payouts = await db.select({
        id: pmPayoutRequests.id,
        managerId: pmPayoutRequests.managerId,
        amount: pmPayoutRequests.amount,
        currency: pmPayoutRequests.currency,
        requestNotes: pmPayoutRequests.requestNotes,
        adminNotes: pmPayoutRequests.adminNotes,
        status: pmPayoutRequests.status,
        receiptUrl: pmPayoutRequests.receiptUrl,
        requestedAt: pmPayoutRequests.requestedAt,
        approvedAt: pmPayoutRequests.approvedAt,
        paidAt: pmPayoutRequests.paidAt,
        processedBy: pmPayoutRequests.processedBy,
        managerFirstName: users.firstName,
        managerLastName: users.lastName,
        managerEmail: users.email
      }).from(pmPayoutRequests).leftJoin(users, eq22(pmPayoutRequests.managerId, users.id)).where(and21(...conditions)).orderBy(desc11(pmPayoutRequests.requestedAt));
      res.json(payouts.map((p) => ({
        ...p,
        amount: parseFloat(p.amount || "0"),
        managerName: `${p.managerFirstName || ""} ${p.managerLastName || ""}`.trim() || p.managerEmail
      })));
    } catch (error) {
      console.error("Error fetching all payouts:", error);
      res.status(500).send(error.message);
    }
  });
  app2.post("/api/pm/dashboard/add-commission", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const userRole = req.user?.role;
      if (userRole !== "admin") {
        return res.status(403).send("Admin access required");
      }
      const organizationId2 = req.user?.organizationId;
      const { managerId, amount, description, propertyId, bookingId } = req.body;
      const commissionAmount = parseFloat(amount);
      if (isNaN(commissionAmount) || commissionAmount <= 0) {
        return res.status(400).send("Invalid amount");
      }
      let [balanceRecord] = await db.select().from(pmCommissionBalance2).where(
        and21(
          eq22(pmCommissionBalance2.organizationId, organizationId2),
          eq22(pmCommissionBalance2.managerId, managerId)
        )
      );
      if (!balanceRecord) {
        [balanceRecord] = await db.insert(pmCommissionBalance2).values({
          organizationId: organizationId2,
          managerId,
          totalEarned: "0",
          totalPaid: "0",
          currentBalance: "0"
        }).returning();
      }
      const currentEarned = parseFloat(balanceRecord.totalEarned || "0");
      const currentBalance = parseFloat(balanceRecord.currentBalance || "0");
      await db.update(pmCommissionBalance2).set({
        totalEarned: (currentEarned + commissionAmount).toFixed(2),
        currentBalance: (currentBalance + commissionAmount).toFixed(2),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq22(pmCommissionBalance2.id, balanceRecord.id));
      const currentPeriod = (/* @__PURE__ */ new Date()).toISOString().slice(0, 7);
      const [payout] = await db.insert(commissionPayouts).values({
        organizationId: organizationId2,
        propertyId: propertyId ? parseInt(propertyId) : null,
        userId: managerId,
        userRole: "portfolio-manager",
        period: currentPeriod,
        baseCommissionAmount: commissionAmount.toFixed(2),
        commissionPercentage: "100.00",
        finalPayoutAmount: commissionAmount.toFixed(2),
        status: "approved",
        notes: description || "Manual commission added by admin"
      }).returning();
      res.json({
        success: true,
        newBalance: currentBalance + commissionAmount,
        payoutRecord: payout
      });
    } catch (error) {
      console.error("Error adding commission:", error);
      res.status(500).send(error.message);
    }
  });
  app2.get("/api/pm/dashboard/task-logs", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      if (!organizationId2) {
        return res.status(400).send("Organization ID required");
      }
      const { portfolioManagerId, startDate, endDate, department, status, limit } = req.query;
      const managerId = portfolioManagerId || req.user?.id;
      if (!managerId) {
        return res.status(400).send("Portfolio Manager ID required");
      }
      const managerProperties = await db.select({
        propertyId: portfolioAssignments.propertyId
      }).from(portfolioAssignments).where(
        and21(
          eq22(portfolioAssignments.organizationId, organizationId2),
          eq22(portfolioAssignments.managerId, managerId),
          eq22(portfolioAssignments.isActive, true)
        )
      );
      const propertyIds = managerProperties.map((p) => p.propertyId);
      if (propertyIds.length === 0) {
        return res.json([]);
      }
      const conditions = [
        eq22(tasks.organizationId, organizationId2),
        sql12`${tasks.propertyId} = ANY(${propertyIds})`
      ];
      if (department && department !== "all") {
        conditions.push(eq22(tasks.department, department));
      }
      if (status && status !== "all") {
        conditions.push(eq22(tasks.status, status));
      }
      if (startDate) {
        conditions.push(gte9(tasks.createdAt, new Date(startDate)));
      }
      if (endDate) {
        conditions.push(lte9(tasks.createdAt, new Date(endDate)));
      }
      const taskLogs = await db.select({
        id: tasks.id,
        taskTitle: tasks.title,
        department: tasks.department,
        status: tasks.status,
        completedAt: tasks.completedAt,
        result: tasks.result,
        notes: tasks.notes,
        propertyId: tasks.propertyId,
        propertyName: properties.name,
        staffFirstName: users.firstName,
        staffLastName: users.lastName,
        createdAt: tasks.createdAt
      }).from(tasks).leftJoin(properties, eq22(tasks.propertyId, properties.id)).leftJoin(users, eq22(tasks.assignedTo, users.id)).where(and21(...conditions)).orderBy(desc11(tasks.createdAt)).limit(parseInt(limit) || 100);
      res.json(taskLogs.map((t) => ({
        ...t,
        staffAssigned: t.staffFirstName && t.staffLastName ? `${t.staffFirstName} ${t.staffLastName}`.trim() : t.staffFirstName || t.staffLastName || null
      })));
    } catch (error) {
      console.error("Error fetching task logs:", error);
      res.status(500).send(error.message);
    }
  });
  app2.get("/api/pm/dashboard/portfolio", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      if (!organizationId2) {
        return res.status(400).send("Organization ID required");
      }
      const { portfolioManagerId } = req.query;
      const managerId = portfolioManagerId || req.user?.id;
      if (!managerId) {
        return res.status(400).send("Portfolio Manager ID required");
      }
      console.log(`[PM Dashboard] Fetching portfolio for managerId: ${managerId}, orgId: ${organizationId2}`);
      const portfolioProperties = await getPortfolioManagerProperties(organizationId2, managerId);
      console.log(`[PM Dashboard] Found ${portfolioProperties.length} properties`);
      res.json(portfolioProperties.map((p) => ({
        id: p.propertyId,
        name: p.propertyName || `Property #${p.propertyId}`,
        address: p.propertyAddress,
        status: p.propertyStatus,
        isActive: p.isActive
      })));
    } catch (error) {
      console.error("Error fetching portfolio:", error);
      res.status(500).send(error.message);
    }
  });
  app2.get("/api/pm/dashboard/notifications", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      if (!organizationId2) {
        return res.status(400).send("Organization ID required");
      }
      const { portfolioManagerId, limit } = req.query;
      const managerId = portfolioManagerId || req.user?.id;
      if (!managerId) {
        return res.status(400).send("Portfolio Manager ID required");
      }
      const notifications2 = await db.select().from(pmNotifications2).where(
        and21(
          eq22(pmNotifications2.organizationId, organizationId2),
          eq22(pmNotifications2.managerId, managerId)
        )
      ).orderBy(desc11(pmNotifications2.createdAt)).limit(parseInt(limit) || 20);
      res.json(notifications2.map((n) => ({
        id: n.id,
        type: n.type,
        title: n.title,
        message: n.message,
        severity: n.severity,
        actionRequired: n.actionRequired,
        isRead: n.isRead ?? false,
        createdAt: n.createdAt?.toISOString(),
        relatedType: n.relatedType,
        relatedId: n.relatedId
      })));
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).send(error.message);
    }
  });
  app2.patch("/api/pm/dashboard/notifications/:id/read", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      const managerId = req.user?.id;
      const notificationId = parseInt(req.params.id);
      if (!organizationId2 || !managerId) {
        return res.status(400).send("Organization ID and Manager ID required");
      }
      const [updated] = await db.update(pmNotifications2).set({
        isRead: true
      }).where(
        and21(
          eq22(pmNotifications2.id, notificationId),
          eq22(pmNotifications2.organizationId, organizationId2),
          eq22(pmNotifications2.managerId, managerId)
        )
      ).returning();
      res.json(updated);
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).send(error.message);
    }
  });
  app2.patch("/api/pm/dashboard/notifications/mark-all-read", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      const managerId = req.user?.id;
      if (!organizationId2 || !managerId) {
        return res.status(400).send("Organization ID and Manager ID required");
      }
      const updated = await db.update(pmNotifications2).set({
        isRead: true
      }).where(
        and21(
          eq22(pmNotifications2.organizationId, organizationId2),
          eq22(pmNotifications2.managerId, managerId),
          eq22(pmNotifications2.isRead, false)
        )
      ).returning();
      res.json({ message: `Marked ${updated.length} notifications as read`, count: updated.length });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).send(error.message);
    }
  });
  app2.post("/api/pm/dashboard/notifications", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      const managerId = req.user?.id;
      if (!organizationId2 || !managerId) {
        return res.status(400).send("Organization ID and Manager ID required");
      }
      const { type, title, message, severity, relatedType, relatedId, actionRequired } = req.body;
      if (!type || !title || !message) {
        return res.status(400).send("Type, title, and message are required");
      }
      const [newNotification] = await db.insert(pmNotifications2).values({
        organizationId: organizationId2,
        managerId,
        type,
        title,
        message,
        severity: severity || "info",
        relatedType: relatedType || null,
        relatedId: relatedId || null,
        actionRequired: actionRequired || false,
        isRead: false
      }).returning();
      res.json(newNotification);
    } catch (error) {
      console.error("Error creating notification:", error);
      res.status(500).send(error.message);
    }
  });
  app2.delete("/api/pm/dashboard/notifications/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      const managerId = req.user?.id;
      const notificationId = parseInt(req.params.id);
      if (!organizationId2 || !managerId) {
        return res.status(400).send("Organization ID and Manager ID required");
      }
      const [deleted] = await db.delete(pmNotifications2).where(
        and21(
          eq22(pmNotifications2.id, notificationId),
          eq22(pmNotifications2.organizationId, organizationId2),
          eq22(pmNotifications2.managerId, managerId)
        )
      ).returning();
      if (!deleted) {
        return res.status(404).send("Notification not found");
      }
      res.json({ message: "Notification deleted", id: notificationId });
    } catch (error) {
      console.error("Error deleting notification:", error);
      res.status(500).send(error.message);
    }
  });
  app2.post("/api/pm/dashboard/notifications/generate-sample", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      const managerId = req.user?.id;
      if (!organizationId2 || !managerId) {
        return res.status(400).send("Organization ID and Manager ID required");
      }
      const sampleNotifications = [
        {
          organizationId: organizationId2,
          managerId,
          type: "guest_issue",
          title: "Guest Complaint - Property #1",
          message: "Guest reported AC not working properly. Requires immediate attention.",
          severity: "urgent",
          relatedType: "property",
          relatedId: "1",
          actionRequired: true,
          isRead: false
        },
        {
          organizationId: organizationId2,
          managerId,
          type: "owner_approval",
          title: "Expense Approval Pending",
          message: "Owner approval needed for plumbing repair ($450). Waiting for response.",
          severity: "warning",
          relatedType: "task",
          relatedId: "1",
          actionRequired: true,
          isRead: false
        },
        {
          organizationId: organizationId2,
          managerId,
          type: "system_suggestion",
          title: "Revenue Optimization Tip",
          message: "Consider raising rates by 10% for upcoming peak season (Dec-Jan). Market analysis shows demand increase.",
          severity: "info",
          relatedType: null,
          relatedId: null,
          actionRequired: false,
          isRead: false
        },
        {
          organizationId: organizationId2,
          managerId,
          type: "bill_upload",
          title: "New Utility Bill Uploaded",
          message: "Electric bill for Property #2 has been uploaded. Amount: $187.50. Due: Dec 15.",
          severity: "info",
          relatedType: "property",
          relatedId: "2",
          actionRequired: false,
          isRead: false
        },
        {
          organizationId: organizationId2,
          managerId,
          type: "guest_issue",
          title: "Early Check-in Request",
          message: "Guest arriving tomorrow requests early check-in at 10 AM instead of 3 PM.",
          severity: "warning",
          relatedType: "booking",
          relatedId: "1",
          actionRequired: true,
          isRead: false
        }
      ];
      const inserted = await db.insert(pmNotifications2).values(sampleNotifications).returning();
      res.json({ message: `Created ${inserted.length} sample notifications`, notifications: inserted });
    } catch (error) {
      console.error("Error generating sample notifications:", error);
      res.status(500).send(error.message);
    }
  });
  app2.get("/api/pm/dashboard/invoices", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      const managerId = req.user?.id;
      if (!organizationId2 || !managerId) {
        return res.status(400).send("Organization ID and Manager ID required");
      }
      const pmInvoices = await db.select().from(billingInvoices).where(
        and21(
          eq22(billingInvoices.organizationId, organizationId2),
          eq22(billingInvoices.createdBy, managerId)
        )
      ).orderBy(desc11(billingInvoices.createdAt)).limit(50);
      res.json(pmInvoices.map((inv) => ({
        id: inv.id,
        invoiceNumber: inv.invoiceNumber,
        receiverName: inv.clientName,
        invoiceType: inv.clientType,
        description: inv.description || "",
        totalAmount: parseFloat(inv.total || "0"),
        status: inv.status,
        dueDate: inv.dueDate,
        createdAt: inv.createdAt?.toISOString()
      })));
    } catch (error) {
      console.error("Error fetching invoices:", error);
      res.status(500).send(error.message);
    }
  });
  app2.post("/api/pm/dashboard/invoices", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      const managerId = req.user?.id;
      if (!organizationId2 || !managerId) {
        return res.status(400).send("Organization ID and Manager ID required");
      }
      const {
        receiverType,
        receiverId,
        receiverName,
        receiverAddress,
        invoiceType,
        description,
        lineItems,
        taxRate,
        notes,
        dueDate,
        referenceNumber
      } = req.body;
      const subtotal = lineItems.reduce((sum4, item) => {
        const qty = parseFloat(item.quantity || "0");
        const price = parseFloat(item.unitPrice || "0");
        return sum4 + qty * price;
      }, 0);
      const taxAmount = subtotal * (parseFloat(taxRate || "0") / 100);
      const totalAmount = subtotal + taxAmount;
      const invoiceNumber = `INV-${Date.now()}-${Math.random().toString(36).substring(7).toUpperCase()}`;
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const [newInvoice] = await db.insert(billingInvoices).values({
        organizationId: organizationId2,
        invoiceNumber,
        clientType: receiverType || "owner",
        clientId: receiverId || null,
        clientName: receiverName || "Unknown",
        clientEmail: null,
        propertyId: null,
        issueDate: today,
        dueDate: dueDate || today,
        description: description || null,
        status: "draft",
        subtotal: subtotal.toString(),
        taxTotal: taxAmount.toString(),
        discountTotal: "0",
        total: totalAmount.toString(),
        createdBy: managerId
      }).returning();
      res.json(newInvoice);
    } catch (error) {
      console.error("Error creating invoice:", error);
      res.status(500).send(error.message);
    }
  });
  app2.get("/api/pm/dashboard/analytics", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).send("Not authenticated");
      }
      const organizationId2 = req.user?.organizationId;
      if (!organizationId2) {
        return res.status(400).send("Organization ID required");
      }
      const { portfolioManagerId, startDate, endDate } = req.query;
      const managerId = portfolioManagerId || req.user?.id;
      if (!managerId) {
        return res.status(400).send("Portfolio Manager ID required");
      }
      const managerProperties = await db.select({
        propertyId: portfolioAssignments.propertyId
      }).from(portfolioAssignments).where(
        and21(
          eq22(portfolioAssignments.organizationId, organizationId2),
          eq22(portfolioAssignments.managerId, managerId),
          eq22(portfolioAssignments.isActive, true)
        )
      );
      const propertyIds = managerProperties.map((p) => p.propertyId).filter((id) => id !== null);
      const endDateObj = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
      const startDateObj = startDate ? new Date(startDate) : new Date(endDateObj.getFullYear(), endDateObj.getMonth() - 6, 1);
      let totalRevenue = 0;
      let totalBookings = 0;
      let averageBookingValue = 0;
      let occupancyRate = 0;
      let completedTasks = 0;
      let pendingTasks = 0;
      let revenueByMonth = [];
      let propertyPerformance = [];
      if (propertyIds.length > 0) {
        const startDateStr = startDateObj.toISOString().split("T")[0];
        const endDateStr = endDateObj.toISOString().split("T")[0];
        const bookingsData = await db.select({
          id: bookings.id,
          propertyId: bookings.propertyId,
          totalAmount: bookings.totalAmount,
          checkIn: bookings.checkIn,
          checkOut: bookings.checkOut,
          status: bookings.status
        }).from(bookings).where(
          and21(
            eq22(bookings.organizationId, organizationId2),
            sql12`${bookings.propertyId} = ANY(${propertyIds})`,
            sql12`${bookings.checkIn} >= ${startDateStr}`,
            sql12`${bookings.checkIn} <= ${endDateStr}`
          )
        );
        totalBookings = bookingsData.length;
        totalRevenue = bookingsData.reduce((sum4, b) => sum4 + parseFloat(b.totalAmount || "0"), 0);
        averageBookingValue = totalBookings > 0 ? totalRevenue / totalBookings : 0;
        const totalDays = Math.ceil((endDateObj.getTime() - startDateObj.getTime()) / (1e3 * 60 * 60 * 24));
        const totalAvailableNights = totalDays * propertyIds.length;
        const bookedNights = bookingsData.reduce((sum4, b) => {
          const checkIn = new Date(b.checkIn);
          const checkOut = new Date(b.checkOut);
          const nights = Math.ceil((checkOut.getTime() - checkIn.getTime()) / (1e3 * 60 * 60 * 24));
          return sum4 + nights;
        }, 0);
        occupancyRate = totalAvailableNights > 0 ? bookedNights / totalAvailableNights * 100 : 0;
        const monthlyData = {};
        bookingsData.forEach((b) => {
          const date3 = new Date(b.checkIn);
          const monthKey = `${date3.getFullYear()}-${String(date3.getMonth() + 1).padStart(2, "0")}`;
          if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = { revenue: 0, bookings: 0 };
          }
          monthlyData[monthKey].revenue += parseFloat(b.totalAmount || "0");
          monthlyData[monthKey].bookings += 1;
        });
        revenueByMonth = Object.entries(monthlyData).sort(([a], [b]) => a.localeCompare(b)).map(([month, data]) => {
          const [year, monthNum] = month.split("-");
          const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          return {
            month: `${monthNames[parseInt(monthNum) - 1]} ${year}`,
            revenue: data.revenue,
            bookings: data.bookings
          };
        });
        const propertiesInfo = await db.select({
          id: properties.id,
          name: properties.name
        }).from(properties).where(sql12`${properties.id} = ANY(${propertyIds})`);
        const propertyMap = new Map(propertiesInfo.map((p) => [p.id, p.name]));
        const propertyBookings = {};
        bookingsData.forEach((b) => {
          const propId = b.propertyId;
          if (!propertyBookings[propId]) {
            propertyBookings[propId] = { revenue: 0, bookings: 0, nights: 0 };
          }
          propertyBookings[propId].revenue += parseFloat(b.totalAmount || "0");
          propertyBookings[propId].bookings += 1;
          const checkIn = new Date(b.checkIn);
          const checkOut = new Date(b.checkOut);
          propertyBookings[propId].nights += Math.ceil((checkOut.getTime() - checkIn.getTime()) / (1e3 * 60 * 60 * 24));
        });
        propertyPerformance = propertyIds.map((propId) => {
          const data = propertyBookings[propId] || { revenue: 0, bookings: 0, nights: 0 };
          const propOccupancy = totalDays > 0 ? data.nights / totalDays * 100 : 0;
          return {
            propertyId: propId,
            propertyName: propertyMap.get(propId) || `Property #${propId}`,
            revenue: data.revenue,
            bookings: data.bookings,
            occupancyRate: Math.min(propOccupancy, 100),
            rating: 4 + Math.random() * 1
            // Placeholder rating
          };
        }).sort((a, b) => b.revenue - a.revenue);
        const taskStats = await db.select({
          status: tasks.status,
          count: count2()
        }).from(tasks).where(
          and21(
            eq22(tasks.organizationId, organizationId2),
            sql12`${tasks.propertyId} = ANY(${propertyIds})`
          )
        ).groupBy(tasks.status);
        taskStats.forEach((stat) => {
          if (stat.status === "completed") {
            completedTasks = Number(stat.count);
          } else if (stat.status === "pending" || stat.status === "in_progress") {
            pendingTasks += Number(stat.count);
          }
        });
      }
      const suggestions = [];
      if (occupancyRate < 50 && propertyIds.length > 0) {
        suggestions.push({
          id: 1,
          type: "occupancy",
          priority: "high",
          title: "Improve Occupancy Rate",
          description: `Current occupancy is ${occupancyRate.toFixed(1)}%. Consider adjusting pricing, running promotions, or improving property listings to attract more bookings.`,
          actionable: true
        });
      }
      if (averageBookingValue < 500 && totalBookings > 0) {
        suggestions.push({
          id: 2,
          type: "revenue",
          priority: "medium",
          title: "Increase Average Booking Value",
          description: `Average booking is $${averageBookingValue.toFixed(0)}. Consider offering premium add-ons, longer stay discounts, or seasonal pricing to increase revenue per booking.`,
          actionable: true
        });
      }
      if (pendingTasks > 5) {
        suggestions.push({
          id: 3,
          type: "tasks",
          priority: "medium",
          title: "Address Pending Tasks",
          description: `You have ${pendingTasks} pending tasks. Prioritize completing maintenance and cleaning tasks to maintain property quality.`,
          actionable: true
        });
      }
      if (occupancyRate > 70) {
        suggestions.push({
          id: 4,
          type: "performance",
          priority: "low",
          title: "Excellent Occupancy Performance",
          description: `Your portfolio is performing well with ${occupancyRate.toFixed(1)}% occupancy. Consider expanding your portfolio or optimizing pricing for even better results.`,
          actionable: false
        });
      }
      const underperformingProps = propertyPerformance.filter((p) => p.occupancyRate < 30);
      if (underperformingProps.length > 0) {
        suggestions.push({
          id: 5,
          type: "property",
          priority: "high",
          title: "Underperforming Properties Detected",
          description: `${underperformingProps.length} properties have less than 30% occupancy. Review listings, photos, and pricing for: ${underperformingProps.slice(0, 3).map((p) => p.propertyName).join(", ")}.`,
          actionable: true
        });
      }
      const topPerformer = propertyPerformance[0];
      if (topPerformer && topPerformer.revenue > 0) {
        suggestions.push({
          id: 6,
          type: "insight",
          priority: "low",
          title: "Top Performing Property",
          description: `${topPerformer.propertyName} is your best performer with $${topPerformer.revenue.toLocaleString()} in revenue. Analyze what makes it successful and apply those strategies to other properties.`,
          actionable: false
        });
      }
      if (suggestions.length === 0) {
        suggestions.push({
          id: 7,
          type: "info",
          priority: "low",
          title: "Build Your Portfolio",
          description: "Add properties to your portfolio and track bookings to receive personalized performance insights and AI-powered recommendations.",
          actionable: false
        });
      }
      res.json({
        summary: {
          totalRevenue,
          totalBookings,
          averageBookingValue,
          occupancyRate: Math.min(occupancyRate, 100),
          propertyCount: propertyIds.length,
          completedTasks,
          pendingTasks
        },
        revenueByMonth,
        propertyPerformance,
        suggestions,
        period: {
          startDate: startDateObj.toISOString().split("T")[0],
          endDate: endDateObj.toISOString().split("T")[0]
        }
      });
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).send(error.message);
    }
  });
}
var init_pm_dashboard_routes = __esm({
  "server/portfolio/pm-dashboard-routes.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_commission_service();
  }
});

// server/index.ts
import express5 from "express";
import path7 from "path";
import { fileURLToPath as fileURLToPath4 } from "url";

// server/routes.ts
import { createServer } from "http";

// server/saas-storage.ts
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
import { eq, desc, and } from "drizzle-orm";

// shared/saas-schema.ts
import { pgTable, text, integer, timestamp, boolean, uuid, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var signupRequests = pgTable("signup_requests", {
  id: uuid("id").primaryKey().defaultRandom(),
  companyName: text("company_name").notNull(),
  contactName: text("contact_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone"),
  country: text("country").notNull(),
  website: text("website"),
  propertyCount: integer("property_count"),
  requestedFeatures: jsonb("requested_features").$type(),
  businessType: text("business_type"),
  // hotel, villa, resort, apartment
  message: text("message"),
  // Enhanced SaaS fields
  subscriptionTier: text("subscription_tier").notNull().default("professional"),
  // starter, professional, enterprise
  subscriptionType: text("subscription_type").notNull().default("trial"),
  // trial, paid
  pmsSystem: text("pms_system"),
  // hostaway, guesty, lodgify, none
  staffStructure: jsonb("staff_structure").$type(),
  estimatedMonthlyRevenue: text("estimated_monthly_revenue"),
  // 0-10k, 10k-50k, 50k+
  currentSoftware: text("current_software"),
  // What they use currently
  integrationPriority: jsonb("integration_priority").$type(),
  // hostaway, stripe, quickbooks, etc
  status: text("status").notNull().default("pending"),
  // pending, approved, rejected
  submittedAt: timestamp("submitted_at").defaultNow(),
  reviewedAt: timestamp("reviewed_at"),
  reviewedBy: text("reviewed_by"),
  rejectionReason: text("rejection_reason")
});
var clientOrganizations = pgTable("client_organizations", {
  id: uuid("id").primaryKey().defaultRandom(),
  organizationId: text("organization_id").notNull().unique(),
  // client_12345
  companyName: text("company_name").notNull(),
  subdomain: text("subdomain").notNull().unique(),
  // acme.hostpilotpro.com
  databaseUrl: text("database_url").notNull(),
  schemaName: text("schema_name").notNull(),
  planType: text("plan_type").notNull().default("professional"),
  // starter, professional, enterprise
  subscriptionType: text("subscription_type").notNull().default("trial"),
  // trial, paid
  status: text("status").notNull().default("active"),
  // active, suspended, terminated
  createdAt: timestamp("created_at").defaultNow(),
  activatedAt: timestamp("activated_at"),
  suspendedAt: timestamp("suspended_at"),
  terminatedAt: timestamp("terminated_at"),
  trialEndsAt: timestamp("trial_ends_at"),
  maxProperties: integer("max_properties").default(10),
  maxUsers: integer("max_users").default(5),
  features: jsonb("features").$type(),
  adminUserId: text("admin_user_id"),
  contactEmail: text("contact_email").notNull(),
  billingEmail: text("billing_email"),
  // Pricing and billing
  monthlyPrice: integer("monthly_price"),
  // in cents
  pricePerProperty: integer("price_per_property"),
  // in cents
  currency: text("currency").default("USD"),
  billingCycle: text("billing_cycle").default("monthly"),
  // monthly, yearly
  // PMS and integrations
  pmsSystem: text("pms_system"),
  // hostaway, guesty, lodgify
  pmsConnected: boolean("pms_connected").default(false),
  onboardingCompleted: boolean("onboarding_completed").default(false),
  onboardingStep: text("onboarding_step").default("welcome")
  // welcome, pms_connect, staff_setup, complete
});
var clientApiKeys = pgTable("client_api_keys", {
  id: uuid("id").primaryKey().defaultRandom(),
  organizationId: text("organization_id").notNull(),
  service: text("service").notNull(),
  // hostaway, stripe, twilio, openai
  keyName: text("key_name").notNull(),
  encryptedKey: text("encrypted_key").notNull(),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow(),
  lastUsed: timestamp("last_used")
});
var clientDeployments = pgTable("client_deployments", {
  id: uuid("id").primaryKey().defaultRandom(),
  organizationId: text("organization_id").notNull(),
  deploymentStatus: text("deployment_status").notNull(),
  // provisioning, ready, failed
  environmentUrl: text("environment_url"),
  databaseStatus: text("database_status"),
  // creating, migrating, ready, failed
  seedDataStatus: text("seed_data_status"),
  // pending, seeding, completed, failed
  deploymentLogs: jsonb("deployment_logs").$type(),
  createdAt: timestamp("created_at").defaultNow(),
  completedAt: timestamp("completed_at"),
  errorLogs: jsonb("error_logs").$type()
});
var saasAuditLog = pgTable("saas_audit_log", {
  id: uuid("id").primaryKey().defaultRandom(),
  action: text("action").notNull(),
  // signup_request, approval, rejection, deployment, suspension
  organizationId: text("organization_id"),
  performedBy: text("performed_by").notNull(),
  details: jsonb("details").$type(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  timestamp: timestamp("timestamp").defaultNow()
});
var insertSignupRequestSchema = createInsertSchema(signupRequests).omit({
  id: true,
  submittedAt: true,
  reviewedAt: true,
  reviewedBy: true,
  rejectionReason: true
}).extend({
  // Ensure proper typing for complex fields
  propertyCount: z.number().optional(),
  staffStructure: z.object({
    ceoCount: z.number(),
    managerCount: z.number(),
    supervisorCount: z.number(),
    staffCount: z.number(),
    agentCount: z.number()
  }).optional(),
  integrationPriority: z.array(z.string()).optional(),
  requestedFeatures: z.array(z.string()).optional()
});
var insertClientOrganizationSchema = createInsertSchema(clientOrganizations);
var insertClientApiKeySchema = createInsertSchema(clientApiKeys);
var insertClientDeploymentSchema = createInsertSchema(clientDeployments);
var insertSaasAuditLogSchema = createInsertSchema(saasAuditLog);

// server/saas-storage.ts
import crypto from "crypto";
var masterDb = drizzle(neon(process.env.MASTER_DATABASE_URL || process.env.DATABASE_URL));
var SaasStorage = class {
  // ===== SIGNUP REQUESTS =====
  async createSignupRequest(request) {
    const [created] = await masterDb.insert(signupRequests).values(request).returning();
    return created;
  }
  async getSignupRequests(status) {
    const query = status ? masterDb.select().from(signupRequests).where(eq(signupRequests.status, status)) : masterDb.select().from(signupRequests);
    return await query.orderBy(desc(signupRequests.submittedAt));
  }
  async getSignupRequest(id) {
    const [request] = await masterDb.select().from(signupRequests).where(eq(signupRequests.id, id));
    return request || null;
  }
  async updateSignupRequestStatus(id, status, reviewedBy, rejectionReason) {
    const [updated] = await masterDb.update(signupRequests).set({
      status,
      reviewedAt: /* @__PURE__ */ new Date(),
      reviewedBy,
      rejectionReason
    }).where(eq(signupRequests.id, id)).returning();
    return updated;
  }
  // ===== TENANT ORGANIZATIONS =====
  async createTenantOrganization(tenant) {
    const [created] = await masterDb.insert(clientOrganizations).values(tenant).returning();
    return created;
  }
  async getTenantOrganizations() {
    return await masterDb.select().from(clientOrganizations).orderBy(desc(clientOrganizations.createdAt));
  }
  async getTenantBySubdomain(subdomain) {
    const [tenant] = await masterDb.select().from(clientOrganizations).where(eq(clientOrganizations.subdomain, subdomain));
    return tenant || null;
  }
  async getTenantByOrganizationId(organizationId2) {
    const [tenant] = await masterDb.select().from(clientOrganizations).where(eq(clientOrganizations.organizationId, organizationId2));
    return tenant || null;
  }
  async updateTenantStatus(organizationId2, status) {
    const updateData = { status };
    if (status === "suspended") updateData.suspendedAt = /* @__PURE__ */ new Date();
    if (status === "terminated") updateData.terminatedAt = /* @__PURE__ */ new Date();
    if (status === "active") {
      updateData.suspendedAt = null;
      updateData.terminatedAt = null;
    }
    const [updated] = await masterDb.update(clientOrganizations).set(updateData).where(eq(clientOrganizations.organizationId, organizationId2)).returning();
    return updated;
  }
  // ===== TENANT API KEYS =====
  async setTenantApiKey(organizationId2, service, keyName, apiKey) {
    const encryptedKey = this.encryptApiKey(apiKey);
    const existing = await masterDb.select().from(clientApiKeys).where(and(
      eq(clientApiKeys.organizationId, organizationId2),
      eq(clientApiKeys.service, service),
      eq(clientApiKeys.keyName, keyName)
    ));
    if (existing.length > 0) {
      const [updated] = await masterDb.update(clientApiKeys).set({ encryptedKey, lastUsed: /* @__PURE__ */ new Date() }).where(eq(clientApiKeys.id, existing[0].id)).returning();
      return updated;
    } else {
      const [created] = await masterDb.insert(clientApiKeys).values({
        organizationId: organizationId2,
        service,
        keyName,
        encryptedKey
      }).returning();
      return created;
    }
  }
  async getTenantApiKey(organizationId2, service, keyName) {
    const [result] = await masterDb.select().from(clientApiKeys).where(and(
      eq(clientApiKeys.organizationId, organizationId2),
      eq(clientApiKeys.service, service),
      eq(clientApiKeys.keyName, keyName),
      eq(clientApiKeys.isActive, true)
    ));
    if (!result) return null;
    await masterDb.update(tenantApiKeys).set({ lastUsed: /* @__PURE__ */ new Date() }).where(eq(tenantApiKeys.id, result.id));
    return this.decryptApiKey(result.encryptedKey);
  }
  async getTenantApiKeys(organizationId2) {
    return await masterDb.select().from(tenantApiKeys).where(and(
      eq(tenantApiKeys.organizationId, organizationId2),
      eq(tenantApiKeys.isActive, true)
    ));
  }
  // ===== TENANT DEPLOYMENTS =====
  async createTenantDeployment(deployment) {
    const [created] = await masterDb.insert(tenantDeployments).values(deployment).returning();
    return created;
  }
  async updateTenantDeployment(id, updates) {
    const [updated] = await masterDb.update(tenantDeployments).set(updates).where(eq(tenantDeployments.id, id)).returning();
    return updated;
  }
  async getTenantDeployment(organizationId2) {
    const [deployment] = await masterDb.select().from(tenantDeployments).where(eq(tenantDeployments.organizationId, organizationId2)).orderBy(desc(tenantDeployments.createdAt));
    return deployment || null;
  }
  // ===== AUDIT LOGGING =====
  async logSaasAction(log2) {
    const [created] = await masterDb.insert(saasAuditLog).values(log2).returning();
    return created;
  }
  async getSaasAuditLogs(organizationId2) {
    const query = organizationId2 ? masterDb.select().from(saasAuditLog).where(eq(saasAuditLog.organizationId, organizationId2)) : masterDb.select().from(saasAuditLog);
    return await query.orderBy(desc(saasAuditLog.createdAt));
  }
  // ===== UTILITY METHODS =====
  encryptApiKey(apiKey) {
    const cipher = crypto.createCipher("aes192", process.env.ENCRYPTION_KEY || "default-key");
    let encrypted = cipher.update(apiKey, "utf8", "hex");
    encrypted += cipher.final("hex");
    return encrypted;
  }
  decryptApiKey(encryptedKey) {
    const decipher = crypto.createDecipher("aes192", process.env.ENCRYPTION_KEY || "default-key");
    let decrypted = decipher.update(encryptedKey, "hex", "utf8");
    decrypted += decipher.final("utf8");
    return decrypted;
  }
  async generateOrganizationId() {
    let organizationId2;
    let attempts = 0;
    do {
      organizationId2 = `client_${crypto.randomBytes(4).toString("hex")}`;
      attempts++;
      const existing = await this.getTenantByOrganizationId(organizationId2);
      if (!existing) break;
    } while (attempts < 10);
    return organizationId2;
  }
  async generateSubdomain(companyName) {
    let baseSubdomain = companyName.toLowerCase().replace(/[^a-z0-9]/g, "").substring(0, 20);
    let subdomain = baseSubdomain;
    let counter = 1;
    while (await this.getTenantBySubdomain(subdomain)) {
      subdomain = `${baseSubdomain}${counter}`;
      counter++;
    }
    return subdomain;
  }
};
var saasStorage = new SaasStorage();

// server/saas-provisioner.ts
import { neon as neon2 } from "@neondatabase/serverless";
import { drizzle as drizzle2 } from "drizzle-orm/neon-http";
var SaasProvisioner = class {
  async provisionTenantEnvironment(signupRequest, approvedBy, hostawayApiKey) {
    try {
      const organizationId2 = await saasStorage.generateOrganizationId();
      const subdomain = await saasStorage.generateSubdomain(signupRequest.companyName);
      const schemaName = `tenant_${organizationId2.replace("client_", "")}`;
      const deployment = await saasStorage.createTenantDeployment({
        organizationId: organizationId2,
        deploymentStatus: "provisioning",
        databaseStatus: "creating",
        seedDataStatus: "pending",
        deploymentLogs: [`Starting provisioning for ${signupRequest.companyName}`]
      });
      const tenant = {
        organizationId: organizationId2,
        companyName: signupRequest.companyName,
        subdomain,
        databaseUrl: process.env.DATABASE_URL,
        // Same DB, different schema
        schemaName,
        planType: this.determinePlanType(signupRequest.propertyCount || 5),
        status: "active",
        activatedAt: /* @__PURE__ */ new Date(),
        maxProperties: this.getMaxProperties(signupRequest.propertyCount || 5),
        maxUsers: this.getMaxUsers(signupRequest.propertyCount || 5),
        features: this.getFeatures(signupRequest.requestedFeatures || []),
        contactEmail: signupRequest.email,
        billingEmail: signupRequest.email
      };
      await saasStorage.createTenantOrganization(tenant);
      await saasStorage.updateTenantDeployment(deployment.id, {
        databaseStatus: "migrating",
        deploymentLogs: [
          ...deployment.deploymentLogs,
          `Created organization: ${organizationId2}`,
          `Assigned subdomain: ${subdomain}.hostpilotpro.com`
        ]
      });
      await this.createTenantSchema(schemaName);
      await saasStorage.updateTenantDeployment(deployment.id, {
        databaseStatus: "ready",
        seedDataStatus: "seeding",
        deploymentLogs: [
          ...deployment.deploymentLogs,
          `Created database schema: ${schemaName}`,
          `Migrated all tables successfully`
        ]
      });
      await this.seedTenantData(schemaName, signupRequest, organizationId2);
      if (hostawayApiKey) {
        await saasStorage.setTenantApiKey(organizationId2, "hostaway", "api_key", hostawayApiKey);
      }
      await saasStorage.updateTenantDeployment(deployment.id, {
        deploymentStatus: "ready",
        seedDataStatus: "completed",
        environmentUrl: `https://${subdomain}.hostpilotpro.com`,
        completedAt: /* @__PURE__ */ new Date(),
        deploymentLogs: [
          ...deployment.deploymentLogs,
          `Seeded initial data for ${signupRequest.companyName}`,
          `Environment ready at: ${subdomain}.hostpilotpro.com`,
          `Deployment completed successfully`
        ]
      });
      await saasStorage.logSaasAction({
        action: "tenant_provisioned",
        organizationId: organizationId2,
        performedBy: approvedBy,
        details: {
          companyName: signupRequest.companyName,
          subdomain,
          schemaName,
          features: tenant.features,
          planType: tenant.planType
        }
      });
      return organizationId2;
    } catch (error) {
      console.error("Provisioning failed:", error);
      await saasStorage.logSaasAction({
        action: "provisioning_failed",
        organizationId: organizationId || "unknown",
        performedBy: approvedBy,
        details: {
          error: error instanceof Error ? error.message : "Unknown error",
          companyName: signupRequest.companyName
        }
      });
      throw new Error(`Failed to provision environment: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async createTenantSchema(schemaName) {
    const db2 = drizzle2(neon2(process.env.DATABASE_URL));
    await db2.execute(`CREATE SCHEMA IF NOT EXISTS ${schemaName}`);
    const tables = [
      `CREATE TABLE ${schemaName}.users (
        id TEXT PRIMARY KEY,
        organization_id TEXT NOT NULL DEFAULT '${schemaName}',
        email TEXT UNIQUE NOT NULL,
        name TEXT,
        role TEXT NOT NULL DEFAULT 'staff',
        created_at TIMESTAMP DEFAULT NOW()
      )`,
      `CREATE TABLE ${schemaName}.properties (
        id SERIAL PRIMARY KEY,
        organization_id TEXT NOT NULL DEFAULT '${schemaName}',
        name TEXT NOT NULL,
        address TEXT,
        bedrooms INTEGER,
        bathrooms INTEGER,
        max_guests INTEGER,
        price_per_night INTEGER,
        status TEXT DEFAULT 'active',
        owner_id TEXT,
        portfolio_manager_id TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )`,
      `CREATE TABLE ${schemaName}.tasks (
        id SERIAL PRIMARY KEY,
        organization_id TEXT NOT NULL DEFAULT '${schemaName}',
        title TEXT NOT NULL,
        description TEXT,
        assigned_to_id TEXT,
        property_id INTEGER,
        priority TEXT DEFAULT 'medium',
        status TEXT DEFAULT 'pending',
        due_date DATE,
        created_at TIMESTAMP DEFAULT NOW()
      )`,
      `CREATE TABLE ${schemaName}.bookings (
        id SERIAL PRIMARY KEY,
        organization_id TEXT NOT NULL DEFAULT '${schemaName}',
        property_id INTEGER NOT NULL,
        guest_name TEXT NOT NULL,
        guest_email TEXT,
        check_in DATE NOT NULL,
        check_out DATE NOT NULL,
        total_amount INTEGER,
        status TEXT DEFAULT 'confirmed',
        guests INTEGER DEFAULT 1,
        created_at TIMESTAMP DEFAULT NOW()
      )`
    ];
    for (const tableSQL of tables) {
      await db2.execute(tableSQL);
    }
  }
  async seedTenantData(schemaName, signupRequest, organizationId2) {
    const db2 = drizzle2(neon2(process.env.DATABASE_URL));
    await db2.execute(`
      INSERT INTO ${schemaName}.users (id, organization_id, email, name, role)
      VALUES ('admin-${organizationId2}', '${organizationId2}', '${signupRequest.email}', '${signupRequest.contactName}', 'admin')
    `);
    if (signupRequest.propertyCount && signupRequest.propertyCount > 0) {
      for (let i = 1; i <= Math.min(signupRequest.propertyCount, 3); i++) {
        await db2.execute(`
          INSERT INTO ${schemaName}.properties (organization_id, name, address, bedrooms, bathrooms, max_guests, price_per_night, owner_id)
          VALUES ('${organizationId2}', 'Property ${i}', 'Location ${i}', ${2 + i}, ${1 + i}, ${4 + i * 2}, ${5e3 + i * 2e3}, 'admin-${organizationId2}')
        `);
      }
    }
    await db2.execute(`
      INSERT INTO ${schemaName}.tasks (organization_id, title, description, assigned_to_id, priority, status)
      VALUES ('${organizationId2}', 'Welcome to HostPilotPro!', 'Complete your onboarding and explore the platform features.', 'admin-${organizationId2}', 'high', 'pending')
    `);
  }
  determinePlanType(propertyCount) {
    if (propertyCount <= 5) return "basic";
    if (propertyCount <= 15) return "pro";
    return "enterprise";
  }
  getMaxProperties(propertyCount) {
    const planType = this.determinePlanType(propertyCount);
    switch (planType) {
      case "basic":
        return 5;
      case "pro":
        return 20;
      case "enterprise":
        return 100;
      default:
        return 5;
    }
  }
  getMaxUsers(propertyCount) {
    const planType = this.determinePlanType(propertyCount);
    switch (planType) {
      case "basic":
        return 5;
      case "pro":
        return 15;
      case "enterprise":
        return 50;
      default:
        return 5;
    }
  }
  getFeatures(requestedFeatures) {
    const baseFeatures = ["property_management", "task_tracking", "booking_calendar"];
    const allFeatures = [
      ...baseFeatures,
      "financial_reporting",
      "api_integrations",
      "advanced_analytics",
      "multi_language",
      "white_label"
    ];
    return [...baseFeatures, ...requestedFeatures.filter((f) => allFeatures.includes(f))];
  }
};
var saasProvisioner = new SaasProvisioner();

// server/saas-routes.ts
function registerSaasRoutes(app2) {
  app2.post("/api/saas/signup-request", async (req, res) => {
    try {
      const requestData = insertSignupRequestSchema.parse(req.body);
      const signupRequest = await saasStorage.createSignupRequest({
        ...requestData,
        status: "pending"
      });
      await saasStorage.logSaasAction({
        action: "signup_request",
        organizationId: null,
        performedBy: requestData.email,
        details: {
          companyName: requestData.companyName,
          contactName: requestData.contactName,
          country: requestData.country,
          propertyCount: requestData.propertyCount
        },
        ipAddress: req.ip,
        userAgent: req.get("User-Agent") || null
      });
      res.status(201).json({
        message: "Signup request submitted successfully",
        requestId: signupRequest.id
      });
    } catch (error) {
      console.error("Error creating signup request:", error);
      res.status(400).json({
        error: "Invalid request data",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/saas/signup-requests", async (req, res) => {
    if (!req.isAuthenticated() || !req.user || req.user.role !== "admin") {
      return res.status(403).json({ error: "Admin access required" });
    }
    try {
      const status = req.query.status;
      const requests = await saasStorage.getSignupRequests(status);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching signup requests:", error);
      res.status(500).json({ error: "Failed to fetch signup requests" });
    }
  });
  app2.post("/api/saas/signup-requests/:id/approve", async (req, res) => {
    if (!req.isAuthenticated() || !req.user || req.user.role !== "admin") {
      return res.status(403).json({ error: "Admin access required" });
    }
    try {
      const requestId = req.params.id;
      const { hostawayApiKey } = req.body;
      const signupRequest = await saasStorage.getSignupRequest(requestId);
      if (!signupRequest) {
        return res.status(404).json({ error: "Signup request not found" });
      }
      if (signupRequest.status !== "pending") {
        return res.status(400).json({ error: "Request has already been processed" });
      }
      await saasStorage.updateSignupRequestStatus(
        requestId,
        "approved",
        req.user.id
      );
      const organizationId2 = await saasProvisioner.provisionTenantEnvironment(
        signupRequest,
        req.user.id,
        hostawayApiKey
      );
      res.json({
        message: "Request approved and environment provisioning started",
        organizationId: organizationId2
      });
    } catch (error) {
      console.error("Error approving request:", error);
      res.status(500).json({
        error: "Failed to approve request",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post("/api/saas/signup-requests/:id/reject", async (req, res) => {
    if (!req.isAuthenticated() || !req.user || req.user.role !== "admin") {
      return res.status(403).json({ error: "Admin access required" });
    }
    try {
      const requestId = req.params.id;
      const { reason } = req.body;
      if (!reason?.trim()) {
        return res.status(400).json({ error: "Rejection reason is required" });
      }
      const signupRequest = await saasStorage.getSignupRequest(requestId);
      if (!signupRequest) {
        return res.status(404).json({ error: "Signup request not found" });
      }
      if (signupRequest.status !== "pending") {
        return res.status(400).json({ error: "Request has already been processed" });
      }
      await saasStorage.updateSignupRequestStatus(
        requestId,
        "rejected",
        req.user.id,
        reason
      );
      await saasStorage.logSaasAction({
        action: "signup_rejected",
        organizationId: null,
        performedBy: req.user.id,
        details: {
          companyName: signupRequest.companyName,
          reason
        }
      });
      res.json({ message: "Request rejected successfully" });
    } catch (error) {
      console.error("Error rejecting request:", error);
      res.status(500).json({ error: "Failed to reject request" });
    }
  });
  app2.get("/api/saas/tenant-organizations", async (req, res) => {
    if (!req.isAuthenticated() || !req.user || req.user.role !== "admin") {
      return res.status(403).json({ error: "Admin access required" });
    }
    try {
      const organizations3 = await saasStorage.getTenantOrganizations();
      res.json(organizations3);
    } catch (error) {
      console.error("Error fetching tenant organizations:", error);
      res.status(500).json({ error: "Failed to fetch organizations" });
    }
  });
  app2.patch("/api/saas/tenant-organizations/:organizationId/status", async (req, res) => {
    if (!req.isAuthenticated() || !req.user || req.user.role !== "admin") {
      return res.status(403).json({ error: "Admin access required" });
    }
    try {
      const { organizationId: organizationId2 } = req.params;
      const { status } = req.body;
      if (!["active", "suspended", "terminated"].includes(status)) {
        return res.status(400).json({ error: "Invalid status" });
      }
      const updatedOrg = await saasStorage.updateTenantStatus(organizationId2, status);
      await saasStorage.logSaasAction({
        action: "status_updated",
        organizationId: organizationId2,
        performedBy: req.user.id,
        details: {
          newStatus: status,
          companyName: updatedOrg.companyName
        }
      });
      res.json(updatedOrg);
    } catch (error) {
      console.error("Error updating tenant status:", error);
      res.status(500).json({ error: "Failed to update status" });
    }
  });
  app2.get("/api/saas/deployments/:organizationId", async (req, res) => {
    if (!req.isAuthenticated() || !req.user || req.user.role !== "admin") {
      return res.status(403).json({ error: "Admin access required" });
    }
    try {
      const { organizationId: organizationId2 } = req.params;
      const deployment = await saasStorage.getTenantDeployment(organizationId2);
      if (!deployment) {
        return res.status(404).json({ error: "Deployment not found" });
      }
      res.json(deployment);
    } catch (error) {
      console.error("Error fetching deployment:", error);
      res.status(500).json({ error: "Failed to fetch deployment" });
    }
  });
  app2.get("/api/saas/audit-logs", async (req, res) => {
    if (!req.isAuthenticated() || !req.user || req.user.role !== "admin") {
      return res.status(403).json({ error: "Admin access required" });
    }
    try {
      const organizationId2 = req.query.organizationId;
      const logs = await saasStorage.getSaasAuditLogs(organizationId2);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      res.status(500).json({ error: "Failed to fetch audit logs" });
    }
  });
}

// server/finance-routes.ts
init_storage();
init_demoAuth();
init_schema();
init_db();
init_currencyConversionService();
import { eq as eq3 } from "drizzle-orm";
function registerFinanceRoutes(app2) {
  app2.get("/api/finance", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { propertyId } = req.query;
      let finances3 = await storage.getFinances(organizationId2);
      if (propertyId) {
        finances3 = finances3.filter((f) => f.propertyId === parseInt(propertyId));
      }
      res.json(finances3);
    } catch (error) {
      console.error("Error fetching finances:", error);
      res.status(500).json({ message: "Failed to fetch finances" });
    }
  });
  app2.post("/api/finance", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const financeData = insertFinanceSchema.parse({
        ...req.body,
        organizationId: organizationId2
      });
      const finance = await storage.createFinance(financeData);
      res.status(201).json(finance);
    } catch (error) {
      console.error("Error creating finance record:", error);
      res.status(500).json({ message: "Failed to create finance record" });
    }
  });
  app2.get("/api/finance/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const {
        propertyId,
        department,
        costCenter,
        budgetCategory,
        businessUnit,
        dateStart,
        dateEnd,
        status,
        type,
        category,
        channelSource,
        revenueStream,
        fiscalYear,
        tags,
        comparisonPeriod
        // previous-period, previous-year, custom
      } = req.query;
      let finances3 = await storage.getFinances(organizationId2);
      const bookingsWithSource = await storage.getBookingsWithSource(organizationId2);
      let serviceBookingsQuery = db.select().from(addonBookings).where(eq3(addonBookings.organizationId, organizationId2));
      const allServiceBookings = await serviceBookingsQuery;
      let tasksQuery = db.select().from(tasks).where(eq3(tasks.organizationId, organizationId2));
      const allTasks = await tasksQuery;
      const isFromBookingsTable = (booking) => {
        const source = (booking.source || "").toLowerCase();
        return source === "hostaway" || source === "local" || source.includes("direct booking") || source.includes("retail agent");
      };
      const filteredFinances = finances3.filter((f) => {
        if (propertyId && f.propertyId !== parseInt(propertyId)) return false;
        if (department && f.department !== department) return false;
        if (costCenter && f.costCenter !== costCenter) return false;
        if (budgetCategory && f.budgetCategory !== budgetCategory) return false;
        if (businessUnit && f.businessUnit !== businessUnit) return false;
        if (status && f.status !== status) return false;
        if (type && f.type !== type) return false;
        if (category && f.category !== category) return false;
        if (channelSource && f.channelSource !== channelSource) return false;
        if (revenueStream && f.revenueStream !== revenueStream) return false;
        if (fiscalYear && f.fiscalYear !== parseInt(fiscalYear)) return false;
        if (dateStart || dateEnd) {
          const transactionDate = new Date(f.date);
          if (dateStart && transactionDate < new Date(dateStart)) return false;
          if (dateEnd && transactionDate > new Date(dateEnd)) return false;
        }
        if (tags) {
          const searchTags = tags.split(",");
          const transactionTags = f.tags || [];
          if (!searchTags.some((tag) => transactionTags.includes(tag.trim()))) return false;
        }
        return true;
      });
      const filteredBookingsWithSource = bookingsWithSource.filter((b) => {
        if (propertyId && b.propertyId !== parseInt(propertyId)) return false;
        return true;
      });
      const filteredServiceBookings = allServiceBookings.filter((sb) => {
        if (propertyId && sb.propertyId !== parseInt(propertyId)) return false;
        return true;
      });
      const filteredTasks = allTasks.filter((t) => {
        if (propertyId && t.propertyId !== parseInt(propertyId)) return false;
        return true;
      });
      const serviceBookingRevenue = filteredServiceBookings.filter((sb) => {
        const billingType = sb.billingType || "";
        const status2 = (sb.status || "").toLowerCase();
        const isBillable = ["auto_guest", "auto_owner"].includes(billingType);
        const isPaidOrCompleted = ["paid", "completed"].includes(status2);
        return isBillable && isPaidOrCompleted && sb.priceCents && sb.priceCents > 0;
      }).reduce((sum4, sb) => {
        const amount = sb.priceCents ? sb.priceCents / 100 : 0;
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const taskExpenses2 = filteredTasks.reduce((sum4, t) => {
        const amount = t.totalExpenseAmount ? typeof t.totalExpenseAmount === "string" ? parseFloat(t.totalExpenseAmount) : t.totalExpenseAmount : 0;
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const totalRevenue = filteredBookingsWithSource.filter((b) => {
        const status2 = (b.status || "").toLowerCase();
        if (status2 === "cancelled") return false;
        if (isFromBookingsTable(b)) {
          return ["confirmed", "checked-in", "checked-out"].includes(status2);
        } else {
          return status2 === "paid";
        }
      }).reduce((sum4, b) => {
        const amount = typeof b.totalAmount === "string" ? parseFloat(b.totalAmount) : b.totalAmount || 0;
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const pendingBookings = filteredBookingsWithSource.filter((b) => {
        const status2 = (b.status || "").toLowerCase();
        return status2 === "pending" || status2 === "pending_payment" || status2 === "awaiting_payment";
      });
      const pendingAmountsInTHB = await Promise.all(
        pendingBookings.map(async (b) => {
          const amount = typeof b.totalAmount === "string" ? parseFloat(b.totalAmount) : b.totalAmount || 0;
          if (isNaN(amount) || amount === 0) return 0;
          const sourceCurrency = b.currency || "USD";
          if (sourceCurrency === "THB") {
            return amount;
          }
          return await convertAmount(amount, sourceCurrency, "THB");
        })
      );
      const pendingPayments = pendingAmountsInTHB.reduce((sum4, amount) => sum4 + amount, 0);
      const totalExpenses = filteredFinances.filter((f) => f.type === "expense").reduce((sum4, f) => {
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const totalCommissions = filteredFinances.filter((f) => f.type === "commission").reduce((sum4, f) => {
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const totalFees = filteredFinances.filter((f) => f.type === "fees").reduce((sum4, f) => {
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const totalPayouts = filteredFinances.filter((f) => f.type === "payout").reduce((sum4, f) => {
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const totalAllExpenses = totalExpenses + totalCommissions + totalFees + totalPayouts + taskExpenses2;
      const combinedTotalRevenue = totalRevenue + serviceBookingRevenue;
      const departmentBreakdown = filteredFinances.reduce((acc, f) => {
        const dept = f.department || "unassigned";
        if (!acc[dept]) {
          acc[dept] = { revenue: 0, expenses: 0, commissions: 0, count: 0 };
        }
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        if (f.type === "income") acc[dept].revenue += amount;
        if (f.type === "expense") acc[dept].expenses += amount;
        if (f.type === "commission") acc[dept].commissions += amount;
        acc[dept].count += 1;
        return acc;
      }, {});
      const channelBreakdown = filteredFinances.filter((f) => f.type === "income" && f.channelSource).reduce((acc, f) => {
        const channel = f.channelSource || "direct";
        if (!acc[channel]) {
          acc[channel] = { revenue: 0, count: 0, avgTransaction: 0 };
        }
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        acc[channel].revenue += amount;
        acc[channel].count += 1;
        acc[channel].avgTransaction = acc[channel].revenue / acc[channel].count;
        return acc;
      }, {});
      const businessUnitBreakdown = filteredFinances.reduce((acc, f) => {
        const unit = f.businessUnit || "unassigned";
        if (!acc[unit]) {
          acc[unit] = { revenue: 0, expenses: 0, netProfit: 0, count: 0 };
        }
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        if (f.type === "income") acc[unit].revenue += amount;
        if (f.type === "expense") acc[unit].expenses += amount;
        acc[unit].netProfit = acc[unit].revenue - acc[unit].expenses;
        acc[unit].count += 1;
        return acc;
      }, {});
      const netProfit2 = combinedTotalRevenue - totalAllExpenses;
      const profitMargin2 = combinedTotalRevenue > 0 ? netProfit2 / combinedTotalRevenue * 100 : 0;
      const now = /* @__PURE__ */ new Date();
      const currentMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
      const currentMonthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);
      const monthlyRevenue = filteredFinances.filter((f) => {
        const fDate = new Date(f.date);
        return f.type === "income" && fDate >= currentMonthStart && fDate <= currentMonthEnd;
      }).reduce((sum4, f) => {
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const monthlyExpenses = filteredFinances.filter((f) => {
        const fDate = new Date(f.date);
        return f.type === "expense" && fDate >= currentMonthStart && fDate <= currentMonthEnd;
      }).reduce((sum4, f) => {
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const analytics = {
        // Currency for all amounts (base currency - THB)
        currency: "THB",
        // Summary metrics (Revenue from bookings + services, Expenses from finance + tasks)
        totalRevenue: Math.round(combinedTotalRevenue * 100) / 100,
        // Booking revenue + service booking revenue
        totalExpenses: Math.round(totalAllExpenses * 100) / 100,
        // All expense types + task expenses
        totalCommissions: Math.round(totalCommissions * 100) / 100,
        totalFees: Math.round(totalFees * 100) / 100,
        totalPayouts: Math.round(totalPayouts * 100) / 100,
        netProfit: Math.round(netProfit2 * 100) / 100,
        profitMargin: Math.round(profitMargin2 * 100) / 100,
        // Revenue breakdown
        revenueBySource: {
          bookings: Math.round(totalRevenue * 100) / 100,
          services: Math.round(serviceBookingRevenue * 100) / 100
        },
        // Expense breakdown by type
        expensesByType: {
          expense: Math.round(totalExpenses * 100) / 100,
          commission: Math.round(totalCommissions * 100) / 100,
          fees: Math.round(totalFees * 100) / 100,
          payout: Math.round(totalPayouts * 100) / 100,
          taskExpenses: Math.round(taskExpenses2 * 100) / 100
        },
        // Booking metrics
        pendingPayments: Math.round(pendingPayments * 100) / 100,
        confirmedBookingsCount: filteredBookingsWithSource.filter((b) => {
          const status2 = (b.status || "").toLowerCase();
          if (isFromBookingsTable(b)) {
            return ["confirmed", "checked-in", "checked-out"].includes(status2);
          } else {
            return status2 === "paid";
          }
        }).length,
        pendingBookingsCount: filteredBookingsWithSource.filter((b) => {
          const status2 = (b.status || "").toLowerCase();
          return status2 === "pending" || status2 === "pending_payment" || status2 === "awaiting_payment";
        }).length,
        // Monthly metrics (current month)
        monthlyRevenue: Math.round(monthlyRevenue * 100) / 100,
        monthlyExpenses: Math.round(monthlyExpenses * 100) / 100,
        // Transaction metrics
        transactionCount: filteredFinances.length,
        averageTransaction: filteredFinances.length > 0 ? Math.round(totalRevenue / filteredFinances.filter((f) => f.type === "income").length * 100) / 100 : 0,
        // Breakdowns
        departmentBreakdown,
        channelBreakdown,
        businessUnitBreakdown,
        // Period information
        period: {
          start: dateStart || null,
          end: dateEnd || null,
          fiscalYear: fiscalYear || null
        },
        // Applied filters summary
        appliedFilters: {
          propertyId: propertyId || null,
          department: department || null,
          costCenter: costCenter || null,
          budgetCategory: budgetCategory || null,
          businessUnit: businessUnit || null,
          status: status || null,
          type: type || null,
          category: category || null,
          channelSource: channelSource || null,
          revenueStream: revenueStream || null,
          tags: tags ? tags.split(",") : null
        }
      };
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching finance analytics:", error);
      res.status(500).json({ message: "Failed to fetch finance analytics" });
    }
  });
  app2.get("/api/finance/summary-by-property", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const finances3 = await storage.getFinances();
      const properties2 = await storage.getProperties();
      const summary = properties2.map((property) => {
        const propertyFinances = finances3.filter((f) => f.propertyId === property.id);
        const revenue = propertyFinances.filter((f) => f.type === "income").reduce((sum4, f) => {
          const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
          return sum4 + (isNaN(amount) ? 0 : amount);
        }, 0);
        const expenses = propertyFinances.filter((f) => f.type === "expense").reduce((sum4, f) => {
          const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
          return sum4 + (isNaN(amount) ? 0 : amount);
        }, 0);
        return {
          propertyId: property.id,
          propertyName: property.name,
          revenue: Math.round(revenue * 100) / 100,
          expenses: Math.round(expenses * 100) / 100,
          netProfit: Math.round((revenue - expenses) * 100) / 100,
          transactionCount: propertyFinances.length
        };
      });
      res.json(summary);
    } catch (error) {
      console.error("Error fetching finance summary by property:", error);
      res.status(500).json({ message: "Failed to fetch finance summary by property" });
    }
  });
  app2.get("/api/finance/monthly-report", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { year = (/* @__PURE__ */ new Date()).getFullYear(), month = (/* @__PURE__ */ new Date()).getMonth() + 1 } = req.query;
      const finances3 = await storage.getFinances();
      const monthlyFinances = finances3.filter((f) => {
        if (!f.createdAt) return false;
        const financeDate = new Date(f.createdAt);
        return financeDate.getFullYear() === parseInt(year) && financeDate.getMonth() === parseInt(month) - 1;
      });
      const report = {
        period: `${year}-${month.toString().padStart(2, "0")}`,
        totalRevenue: monthlyFinances.filter((f) => f.type === "income").reduce((sum4, f) => sum4 + (f.amount || 0), 0),
        totalExpenses: monthlyFinances.filter((f) => f.type === "expense").reduce((sum4, f) => sum4 + (f.amount || 0), 0),
        transactionCount: monthlyFinances.length,
        transactionsByCategory: monthlyFinances.reduce((acc, f) => {
          const category = f.category || "uncategorized";
          if (!acc[category]) {
            acc[category] = { income: 0, expense: 0, count: 0 };
          }
          if (f.type === "income") {
            acc[category].income += f.amount || 0;
          } else {
            acc[category].expense += f.amount || 0;
          }
          acc[category].count += 1;
          return acc;
        }, {})
      };
      res.json(report);
    } catch (error) {
      console.error("Error generating monthly finance report:", error);
      res.status(500).json({ message: "Failed to generate monthly finance report" });
    }
  });
  app2.get("/api/finance/categories", isDemoAuthenticated, async (req, res) => {
    try {
      const finances3 = await storage.getFinances();
      const categories = [...new Set(finances3.map((f) => f.category).filter(Boolean))];
      res.json(categories);
    } catch (error) {
      console.error("Error fetching finance categories:", error);
      res.status(500).json({ message: "Failed to fetch finance categories" });
    }
  });
  app2.get("/api/finance/villa/:villaId", isDemoAuthenticated, async (req, res) => {
    try {
      const { villaId } = req.params;
      const { dateStart, dateEnd } = req.query;
      const organizationId2 = req.user?.organizationId || "default-org";
      const bookings3 = await storage.getBookings();
      const filteredBookings = bookings3.filter((booking) => {
        const matchesVilla = booking.propertyId === parseInt(villaId);
        if (!dateStart || !dateEnd) return matchesVilla;
        const checkIn = new Date(booking.checkIn);
        const checkOut = new Date(booking.checkOut);
        const startDate = new Date(dateStart);
        const endDate = new Date(dateEnd);
        return matchesVilla && checkIn >= startDate && checkOut <= endDate;
      });
      const totalRevenue = filteredBookings.reduce((sum4, booking) => {
        const amount = typeof booking.totalAmount === "number" ? booking.totalAmount : parseFloat(booking.totalAmount || "0");
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const finances3 = await storage.getFinances();
      const commissionRecords = finances3.filter(
        (f) => f.propertyId === parseInt(villaId) && f.category === "commission" && (!dateStart || !dateEnd || f.createdAt && new Date(f.createdAt) >= new Date(dateStart) && new Date(f.createdAt) <= new Date(dateEnd))
      );
      const totalCommission = commissionRecords.reduce((sum4, record) => {
        const amount = typeof record.amount === "number" ? record.amount : parseFloat(record.amount || "0");
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      res.json({
        villaId: parseInt(villaId),
        dateStart: dateStart || null,
        dateEnd: dateEnd || null,
        totalRevenue: Math.round(totalRevenue * 100) / 100,
        totalCommission: Math.round(totalCommission * 100) / 100,
        bookingCount: filteredBookings.length,
        commissionRecords: commissionRecords.length
      });
    } catch (error) {
      console.error("Error fetching villa finance data:", error);
      res.status(500).json({ error: "Finance endpoint error", details: error.message });
    }
  });
  app2.get("/api/finance/department-report", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { department, dateStart, dateEnd } = req.query;
      const finances3 = await storage.getFinances();
      const filteredFinances = finances3.filter((f) => {
        if (department && f.department !== department) return false;
        if (dateStart || dateEnd) {
          const transactionDate = new Date(f.date);
          if (dateStart && transactionDate < new Date(dateStart)) return false;
          if (dateEnd && transactionDate > new Date(dateEnd)) return false;
        }
        return true;
      });
      const departmentStats = filteredFinances.reduce((acc, f) => {
        const dept = f.department || "unassigned";
        if (!acc[dept]) {
          acc[dept] = {
            revenue: 0,
            expenses: 0,
            commissions: 0,
            payouts: 0,
            transactionCount: 0,
            avgTransactionSize: 0,
            profitMargin: 0,
            topCategories: {}
          };
        }
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        if (f.type === "income") acc[dept].revenue += amount;
        if (f.type === "expense") acc[dept].expenses += amount;
        if (f.type === "commission") acc[dept].commissions += amount;
        if (f.type === "payout") acc[dept].payouts += amount;
        acc[dept].transactionCount += 1;
        const category = f.category || "uncategorized";
        if (!acc[dept].topCategories[category]) {
          acc[dept].topCategories[category] = 0;
        }
        acc[dept].topCategories[category] += amount;
        return acc;
      }, {});
      Object.keys(departmentStats).forEach((dept) => {
        const stats = departmentStats[dept];
        stats.avgTransactionSize = stats.transactionCount > 0 ? Math.round(stats.revenue / stats.transactionCount * 100) / 100 : 0;
        stats.profitMargin = stats.revenue > 0 ? Math.round((stats.revenue - stats.expenses) / stats.revenue * 1e4) / 100 : 0;
        stats.topCategories = Object.entries(stats.topCategories).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([category, amount]) => ({ category, amount }));
      });
      res.json(departmentStats);
    } catch (error) {
      console.error("Error fetching department report:", error);
      res.status(500).json({ message: "Failed to fetch department report" });
    }
  });
  app2.get("/api/finance/period-comparison", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const {
        currentStart,
        currentEnd,
        compareStart,
        compareEnd,
        groupBy = "month"
        // day, week, month, quarter
      } = req.query;
      const finances3 = await storage.getFinances();
      const getCurrentPeriodData = () => {
        return finances3.filter((f) => {
          const transactionDate = new Date(f.date);
          return transactionDate >= new Date(currentStart) && transactionDate <= new Date(currentEnd);
        });
      };
      const getComparisonPeriodData = () => {
        return finances3.filter((f) => {
          const transactionDate = new Date(f.date);
          return transactionDate >= new Date(compareStart) && transactionDate <= new Date(compareEnd);
        });
      };
      const calculatePeriodMetrics = (periodData) => {
        const revenue = periodData.filter((f) => f.type === "income").reduce((sum4, f) => sum4 + (parseFloat(f.amount || "0") || 0), 0);
        const expenses = periodData.filter((f) => f.type === "expense").reduce((sum4, f) => sum4 + (parseFloat(f.amount || "0") || 0), 0);
        const commissions = periodData.filter((f) => f.type === "commission").reduce((sum4, f) => sum4 + (parseFloat(f.amount || "0") || 0), 0);
        return {
          revenue: Math.round(revenue * 100) / 100,
          expenses: Math.round(expenses * 100) / 100,
          commissions: Math.round(commissions * 100) / 100,
          netProfit: Math.round((revenue - expenses) * 100) / 100,
          transactionCount: periodData.length
        };
      };
      const currentPeriod = calculatePeriodMetrics(getCurrentPeriodData());
      const comparisonPeriod = calculatePeriodMetrics(getComparisonPeriodData());
      const calculateChange = (current, previous) => {
        if (previous === 0) return current > 0 ? 100 : 0;
        return Math.round((current - previous) / previous * 1e4) / 100;
      };
      const comparison = {
        current: currentPeriod,
        previous: comparisonPeriod,
        changes: {
          revenue: calculateChange(currentPeriod.revenue, comparisonPeriod.revenue),
          expenses: calculateChange(currentPeriod.expenses, comparisonPeriod.expenses),
          commissions: calculateChange(currentPeriod.commissions, comparisonPeriod.commissions),
          netProfit: calculateChange(currentPeriod.netProfit, comparisonPeriod.netProfit),
          transactionCount: calculateChange(currentPeriod.transactionCount, comparisonPeriod.transactionCount)
        },
        periods: {
          current: { start: currentStart, end: currentEnd },
          comparison: { start: compareStart, end: compareEnd }
        }
      };
      res.json(comparison);
    } catch (error) {
      console.error("Error fetching period comparison:", error);
      res.status(500).json({ message: "Failed to fetch period comparison" });
    }
  });
  app2.get("/api/finance/filter-options", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const finances3 = await storage.getFinances();
      const properties2 = await storage.getProperties();
      const filterOptions = {
        properties: properties2.map((p) => ({ id: p.id, name: p.name })),
        departments: [...new Set(finances3.map((f) => f.department).filter(Boolean))],
        costCenters: [...new Set(finances3.map((f) => f.costCenter).filter(Boolean))],
        budgetCategories: [...new Set(finances3.map((f) => f.budgetCategory).filter(Boolean))],
        businessUnits: [...new Set(finances3.map((f) => f.businessUnit).filter(Boolean))],
        types: [...new Set(finances3.map((f) => f.type).filter(Boolean))],
        categories: [...new Set(finances3.map((f) => f.category).filter(Boolean))],
        channelSources: [...new Set(finances3.map((f) => f.channelSource).filter(Boolean))],
        revenueStreams: [...new Set(finances3.map((f) => f.revenueStream).filter(Boolean))],
        statuses: [...new Set(finances3.map((f) => f.status).filter(Boolean))],
        tags: [...new Set(finances3.flatMap((f) => f.tags || []))],
        dateRange: {
          earliest: finances3.reduce((earliest, f) => {
            const date3 = new Date(f.date);
            return !earliest || date3 < earliest ? date3 : earliest;
          }, null),
          latest: finances3.reduce((latest, f) => {
            const date3 = new Date(f.date);
            return !latest || date3 > latest ? date3 : latest;
          }, null)
        }
      };
      res.json(filterOptions);
    } catch (error) {
      console.error("Error fetching filter options:", error);
      res.status(500).json({ message: "Failed to fetch filter options" });
    }
  });
  app2.get("/api/finance/dashboard", isDemoAuthenticated, async (req, res) => {
    try {
      const finances3 = await storage.getFinances();
      const properties2 = await storage.getProperties();
      const currentDate = /* @__PURE__ */ new Date();
      const currentMonthFinances = finances3.filter((f) => {
        if (!f.createdAt) return false;
        const financeDate = new Date(f.createdAt);
        return financeDate.getFullYear() === currentDate.getFullYear() && financeDate.getMonth() === currentDate.getMonth();
      });
      const monthlyRevenue = currentMonthFinances.filter((f) => f.type === "income").reduce((sum4, f) => {
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const monthlyExpenses = currentMonthFinances.filter((f) => f.type === "expense").reduce((sum4, f) => {
        const amount = typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0");
        return sum4 + (isNaN(amount) ? 0 : amount);
      }, 0);
      const dashboard = {
        totalProperties: properties2.length,
        monthlyRevenue: Math.round(monthlyRevenue * 100) / 100,
        monthlyExpenses: Math.round(monthlyExpenses * 100) / 100,
        totalTransactions: currentMonthFinances.length,
        recentTransactions: finances3.sort((a, b) => new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime()).slice(0, 5).map((f) => ({
          ...f,
          amount: typeof f.amount === "number" ? f.amount : parseFloat(f.amount || "0")
        }))
      };
      res.json(dashboard);
    } catch (error) {
      console.error("Error fetching finance dashboard:", error);
      res.status(500).json({ message: "Failed to fetch finance dashboard" });
    }
  });
}

// server/routes/admin-finance-routes.ts
import { Router } from "express";

// server/services/CoreFinancialCalculationService.ts
init_db();
init_schema();
import { eq as eq4, and as and5, between, inArray as inArray2 } from "drizzle-orm";
var CoreFinancialCalculationService = class {
  /**
   * Get hierarchical commission settings with property and booking overrides
   */
  async getCommissionSettings(organizationId2, propertyId, bookingId) {
    let globalSettings;
    try {
      const global = await db.query.sql`
        SELECT * FROM global_commission_settings 
        WHERE organization_id = ${organizationId2}
        LIMIT 1
      `;
      globalSettings = global[0] || {
        management_fee_pct: 15,
        pm_split_pct: 50,
        referral_agent_pct: 10,
        retail_agent_pct: 10,
        retail_agent_basis: "management_fee"
      };
    } catch {
      globalSettings = {
        management_fee_pct: 15,
        pm_split_pct: 50,
        referral_agent_pct: 10,
        retail_agent_pct: 10,
        retail_agent_basis: "management_fee"
      };
    }
    let settings = {
      managementFeePct: Number(globalSettings.management_fee_pct),
      pmSplitPct: Number(globalSettings.pm_split_pct),
      referralAgentPct: Number(globalSettings.referral_agent_pct),
      retailAgentPct: Number(globalSettings.retail_agent_pct),
      retailAgentBasis: globalSettings.retail_agent_basis || "management_fee",
      propertyOverrides: {},
      propertyManagers: {}
    };
    if (propertyId) {
      try {
        const propertyOverrides = await db.query.sql`
          SELECT * FROM property_commission_overrides 
          WHERE organization_id = ${organizationId2} AND property_id = ${propertyId}
          LIMIT 1
        `;
        if (propertyOverrides[0]) {
          const override = propertyOverrides[0];
          if (override.management_fee_pct) settings.managementFeePct = Number(override.management_fee_pct);
          if (override.pm_split_pct) settings.pmSplitPct = Number(override.pm_split_pct);
          if (override.referral_agent_pct) settings.referralAgentPct = Number(override.referral_agent_pct);
          if (override.retail_agent_pct) settings.retailAgentPct = Number(override.retail_agent_pct);
          if (override.retail_agent_basis) settings.retailAgentBasis = override.retail_agent_basis;
          if (override.pm_user_id) settings.propertyManagers[propertyId] = override.pm_user_id;
        }
      } catch (e) {
        console.log("No property overrides found");
      }
    }
    if (bookingId) {
      try {
        const bookingOverrides = await db.query.sql`
          SELECT * FROM booking_commission_overrides 
          WHERE organization_id = ${organizationId2} AND booking_id = ${bookingId}
          LIMIT 1
        `;
        if (bookingOverrides[0]) {
          const override = bookingOverrides[0];
          if (override.management_fee_pct) settings.managementFeePct = Number(override.management_fee_pct);
          if (override.pm_split_pct) settings.pmSplitPct = Number(override.pm_split_pct);
          if (override.referral_agent_pct) settings.referralAgentPct = Number(override.referral_agent_pct);
          if (override.retail_agent_pct) settings.retailAgentPct = Number(override.retail_agent_pct);
          if (override.retail_agent_basis) settings.retailAgentBasis = override.retail_agent_basis;
        }
      } catch (e) {
        console.log("No booking overrides found");
      }
    }
    return settings;
  }
  /**
   * Get property defaults with all configuration
   */
  async getPropertyDefaults(organizationId2, propertyId) {
    const property = await db.select().from(properties).where(eq4(properties.id, propertyId)).limit(1);
    if (!property[0]) throw new Error("Property not found");
    const prop = property[0];
    const channelRouting = {};
    try {
      const routingRules = await db.query.sql`
        SELECT channel, routing_type, owner_split_pct, company_split_pct
        FROM channel_payout_routing 
        WHERE organization_id = ${organizationId2} AND property_id = ${propertyId}
      `;
      for (const rule of routingRules) {
        channelRouting[rule.channel] = {
          routingType: rule.routing_type,
          ownerSplitPct: rule.owner_split_pct ? Number(rule.owner_split_pct) : void 0,
          companySplitPct: rule.company_split_pct ? Number(rule.company_split_pct) : void 0
        };
      }
    } catch (e) {
      console.log("No channel routing found for property");
    }
    const defaultExpenses = [];
    try {
      const expenses = await db.query.sql`
        SELECT expense_type, amount, description
        FROM property_default_expenses 
        WHERE organization_id = ${organizationId2} AND property_id = ${propertyId}
      `;
      for (const expense of expenses) {
        defaultExpenses.push({
          expenseType: expense.expense_type,
          amount: Number(expense.amount),
          description: expense.description
        });
      }
    } catch (e) {
      console.log("No default expenses found for property");
    }
    return {
      managementFeePct: Number(prop.managementFeePct) || 15,
      pmUserId: prop.pmUserId || void 0,
      pmSplitPct: Number(prop.pmSplitPct) || 50,
      referralAgentId: prop.referralAgentId || void 0,
      retailAgentId: prop.retailAgentId || void 0,
      defaultExpenses,
      channelRouting
    };
  }
  /**
   * Calculate financial breakdown for a specific booking using exact core logic
   * Step 1: Apply channel payout routing (where money goes initially)
   * Step 2: Apply calculations (fees, PM splits, owner payouts)
   */
  async calculateBookingBreakdown(organizationId2, bookingId, grossBookingRevenue, channel = "airbnb", platformFees = 0) {
    const booking = await db.select().from(bookings).where(eq4(bookings.id, bookingId)).limit(1);
    if (!booking[0]) throw new Error("Booking not found");
    const propertyId = booking[0].propertyId;
    const propertyDefaults = await this.getPropertyDefaults(organizationId2, propertyId);
    const channelRouting = propertyDefaults.channelRouting[channel] || { routingType: "company_100" };
    let initialPayoutToCompany = 0;
    let initialPayoutToOwner = 0;
    switch (channelRouting.routingType) {
      case "company_100":
        initialPayoutToCompany = grossBookingRevenue;
        initialPayoutToOwner = 0;
        break;
      case "owner_100":
        initialPayoutToCompany = 0;
        initialPayoutToOwner = grossBookingRevenue;
        break;
      case "split":
        initialPayoutToOwner = grossBookingRevenue * (channelRouting.ownerSplitPct || 50) / 100;
        initialPayoutToCompany = grossBookingRevenue - initialPayoutToOwner;
        break;
    }
    const netBasis = grossBookingRevenue - platformFees;
    const managementFeePct = propertyDefaults.managementFeePct;
    const managementFeeAmount = grossBookingRevenue * managementFeePct / 100;
    const pmSplitPct = propertyDefaults.pmSplitPct;
    const pmShare = managementFeeAmount * pmSplitPct / 100;
    const companyShare = managementFeeAmount - pmShare;
    let referralAgentCommission = 0;
    let retailAgentCommission = 0;
    const settings = await this.getCommissionSettings(organizationId2, propertyId, bookingId);
    if (propertyDefaults.referralAgentId) {
      referralAgentCommission = managementFeeAmount * settings.referralAgentPct / 100;
    }
    if (propertyDefaults.retailAgentId) {
      const retailBasis = settings.retailAgentBasis === "gross" ? grossBookingRevenue : managementFeeAmount;
      retailAgentCommission = retailBasis * settings.retailAgentPct / 100;
    }
    const ownerBillableExpenses = propertyDefaults.defaultExpenses.reduce((total, expense) => total + expense.amount, 0);
    const finalOwnerPayout = grossBookingRevenue - managementFeeAmount - ownerBillableExpenses;
    const finalCompanyRetention = companyShare - referralAgentCommission - retailAgentCommission;
    return {
      // Channel routing (applied first)
      channelPayoutRouting: channelRouting,
      initialPayoutToCompany,
      initialPayoutToOwner,
      // Core revenue flow
      grossBookingRevenue,
      platformFees,
      netBasis,
      // Management fee calculations
      managementFeePct,
      managementFeeAmount,
      // PM split
      pmSplitPct,
      pmShare,
      companyShare,
      // Agent commissions
      referralAgentPct: settings.referralAgentPct,
      referralAgentCommission,
      retailAgentPct: settings.retailAgentPct,
      retailAgentBasis: settings.retailAgentBasis,
      retailAgentCommission,
      // Owner billable expenses
      ownerBillableExpenses,
      // Final payouts
      finalOwnerPayout,
      finalCompanyRetention
    };
  }
  /**
   * Calculate owner payouts with exact owner payout formula
   */
  async calculateOwnerPayouts(organizationId2, filters) {
    const conditions = [eq4(bookings.organizationId, organizationId2)];
    if (filters.startDate && filters.endDate) {
      conditions.push(between(bookings.checkIn, filters.startDate.toISOString().split("T")[0], filters.endDate.toISOString().split("T")[0]));
    }
    if (filters.propertyIds && filters.propertyIds.length > 0) {
      conditions.push(inArray2(bookings.propertyId, filters.propertyIds));
    }
    const relevantBookings = await db.select().from(bookings).where(and5(...conditions));
    const ownerPayouts2 = /* @__PURE__ */ new Map();
    for (const booking of relevantBookings) {
      if (!booking.propertyId) continue;
      const property = await db.select().from(properties).where(eq4(properties.id, booking.propertyId)).limit(1);
      if (!property[0] || !property[0].ownerId) continue;
      const ownerId = property[0].ownerId;
      const propertyName = property[0].name;
      const grossBookingRevenue = Number(booking.totalAmount) || 1e3;
      const platformFees = grossBookingRevenue * 0.03;
      const ownerBillableExpenses = 0;
      const breakdown = await this.calculateBookingBreakdown(
        organizationId2,
        booking.id,
        grossBookingRevenue,
        platformFees,
        ownerBillableExpenses
      );
      if (!ownerPayouts2.has(ownerId)) {
        const owner = await db.select().from(users).where(eq4(users.id, ownerId)).limit(1);
        const ownerName = owner[0] ? `${owner[0].firstName} ${owner[0].lastName}` : ownerId;
        ownerPayouts2.set(ownerId, {
          stakeholderId: ownerId,
          stakeholderName: ownerName,
          stakeholderType: "owner",
          earnings: {
            gross: 0,
            // Total gross booking revenue
            net: 0,
            // Total owner payouts using exact formula
            deductions: 0,
            // Total management fees + expenses
            status: "pending"
          },
          properties: []
        });
      }
      const ownerData = ownerPayouts2.get(ownerId);
      ownerData.earnings.gross += breakdown.grossBookingRevenue;
      ownerData.earnings.net += breakdown.ownerPayout;
      ownerData.earnings.deductions += breakdown.managementFeeAmount + breakdown.ownerBillableExpenses;
      const existingProperty = ownerData.properties.find((p) => p.propertyId === booking.propertyId);
      if (existingProperty) {
        existingProperty.revenue += breakdown.grossBookingRevenue;
        existingProperty.commission += breakdown.ownerPayout;
      } else {
        ownerData.properties.push({
          propertyId: booking.propertyId,
          propertyName,
          revenue: breakdown.grossBookingRevenue,
          commission: breakdown.ownerPayout
        });
      }
    }
    return Array.from(ownerPayouts2.values());
  }
  /**
   * Calculate property manager earnings using exact PM share formula
   */
  async calculatePropertyManagerEarnings(organizationId2, filters) {
    const conditions = [eq4(bookings.organizationId, organizationId2)];
    if (filters.startDate && filters.endDate) {
      conditions.push(between(bookings.checkIn, filters.startDate.toISOString().split("T")[0], filters.endDate.toISOString().split("T")[0]));
    }
    if (filters.propertyIds && filters.propertyIds.length > 0) {
      conditions.push(inArray2(bookings.propertyId, filters.propertyIds));
    }
    const relevantBookings = await db.select().from(bookings).where(and5(...conditions));
    const pmEarnings = /* @__PURE__ */ new Map();
    for (const booking of relevantBookings) {
      if (!booking.propertyId) continue;
      const settings = await this.getCommissionSettings(organizationId2, booking.propertyId, booking.id);
      const pmUserId = settings.propertyManagers[booking.propertyId];
      if (!pmUserId || filters.managerIds && !filters.managerIds.includes(pmUserId)) continue;
      const grossBookingRevenue = Number(booking.totalAmount) || 1e3;
      const platformFees = grossBookingRevenue * 0.03;
      const breakdown = await this.calculateBookingBreakdown(
        organizationId2,
        booking.id,
        grossBookingRevenue,
        platformFees
      );
      if (!pmEarnings.has(pmUserId)) {
        const pm = await db.select().from(users).where(eq4(users.id, pmUserId)).limit(1);
        const pmName = pm[0] ? `${pm[0].firstName} ${pm[0].lastName}` : pmUserId;
        pmEarnings.set(pmUserId, {
          stakeholderId: pmUserId,
          stakeholderName: pmName,
          stakeholderType: "property_manager",
          earnings: {
            gross: 0,
            net: 0,
            // This will be PM share using exact formula
            deductions: 0,
            status: "pending"
          },
          properties: []
        });
      }
      const pmData = pmEarnings.get(pmUserId);
      pmData.earnings.gross += breakdown.grossBookingRevenue;
      pmData.earnings.net += breakdown.pmShare;
      const property = await db.select().from(properties).where(eq4(properties.id, booking.propertyId)).limit(1);
      const existingProperty = pmData.properties.find((p) => p.propertyId === booking.propertyId);
      if (existingProperty) {
        existingProperty.revenue += breakdown.grossBookingRevenue;
        existingProperty.commission += breakdown.pmShare;
      } else {
        pmData.properties.push({
          propertyId: booking.propertyId,
          propertyName: property[0]?.name || `Property ${booking.propertyId}`,
          revenue: breakdown.grossBookingRevenue,
          commission: breakdown.pmShare
        });
      }
    }
    return Array.from(pmEarnings.values());
  }
  /**
   * Get staff wage configurations
   */
  async getStaffWageConfigs(organizationId2) {
    return [
      {
        userId: "staff-1",
        userName: "Maria Santos",
        department: "housekeeping",
        monthlyWage: 2500,
        billTo: "company"
      },
      {
        userId: "staff-2",
        userName: "John Doe",
        department: "maintenance",
        monthlyWage: 3e3,
        billTo: "owner",
        propertyId: 1
      }
    ];
  }
  /**
   * Update global commission settings
   */
  async updateGlobalSettings(organizationId2, settings) {
    await db.query.sql`
      INSERT INTO global_commission_settings (
        organization_id, management_fee_pct, pm_split_pct, 
        referral_agent_pct, retail_agent_pct, retail_agent_basis
      ) VALUES (
        ${organizationId2}, ${settings.managementFeePct}, ${settings.pmSplitPct},
        ${settings.referralAgentPct}, ${settings.retailAgentPct}, ${settings.retailAgentBasis}
      )
      ON CONFLICT (organization_id) DO UPDATE SET
        management_fee_pct = EXCLUDED.management_fee_pct,
        pm_split_pct = EXCLUDED.pm_split_pct,
        referral_agent_pct = EXCLUDED.referral_agent_pct,
        retail_agent_pct = EXCLUDED.retail_agent_pct,
        retail_agent_basis = EXCLUDED.retail_agent_basis,
        updated_at = NOW()
    `;
  }
};
var coreFinancialCalculationService = new CoreFinancialCalculationService();

// server/secureAuth.ts
init_storage();
import bcrypt2 from "bcrypt";
async function hashPassword(password) {
  const saltRounds = 12;
  return await bcrypt2.hash(password, saltRounds);
}
async function comparePasswords(password, hashedPassword) {
  return await bcrypt2.compare(password, hashedPassword);
}
var DEFAULT_PERMISSIONS = {
  "admin": {
    properties: { view: true, create: true, edit: true, delete: true },
    users: { view: true, create: true, edit: true, delete: true },
    finances: { view: true, create: true, edit: true, delete: true },
    bookings: { view: true, create: true, edit: true, delete: true },
    tasks: { view: true, create: true, edit: true, delete: true },
    reports: { view: true, create: true, edit: true, delete: true }
  },
  "portfolio-manager": {
    properties: { view: true, create: true, edit: true, delete: false },
    users: { view: true, create: false, edit: true, delete: false },
    finances: { view: true, create: true, edit: true, delete: false },
    bookings: { view: true, create: true, edit: true, delete: false },
    tasks: { view: true, create: true, edit: true, delete: false },
    reports: { view: true, create: true, edit: false, delete: false }
  },
  "owner": {
    properties: { view: true, create: false, edit: false, delete: false },
    users: { view: false, create: false, edit: false, delete: false },
    finances: { view: true, create: false, edit: false, delete: false },
    bookings: { view: true, create: false, edit: false, delete: false },
    tasks: { view: true, create: true, edit: false, delete: false },
    reports: { view: true, create: false, edit: false, delete: false }
  },
  "retail-agent": {
    properties: { view: true, create: false, edit: false, delete: false },
    users: { view: false, create: false, edit: false, delete: false },
    finances: { view: true, create: false, edit: false, delete: false },
    bookings: { view: true, create: true, edit: true, delete: false },
    tasks: { view: false, create: false, edit: false, delete: false },
    reports: { view: true, create: false, edit: false, delete: false }
  },
  "referral-agent": {
    properties: { view: true, create: false, edit: false, delete: false },
    users: { view: false, create: false, edit: false, delete: false },
    finances: { view: true, create: false, edit: false, delete: false },
    bookings: { view: true, create: true, edit: false, delete: false },
    tasks: { view: false, create: false, edit: false, delete: false },
    reports: { view: true, create: false, edit: false, delete: false }
  },
  "staff": {
    properties: { view: true, create: false, edit: false, delete: false },
    users: { view: false, create: false, edit: false, delete: false },
    finances: { view: false, create: false, edit: false, delete: false },
    bookings: { view: true, create: false, edit: false, delete: false },
    tasks: { view: true, create: false, edit: true, delete: false },
    reports: { view: false, create: false, edit: false, delete: false }
  },
  "guest": {
    properties: { view: true, create: false, edit: false, delete: false },
    users: { view: false, create: false, edit: false, delete: false },
    finances: { view: false, create: false, edit: false, delete: false },
    bookings: { view: true, create: false, edit: false, delete: false },
    tasks: { view: false, create: false, edit: false, delete: false },
    reports: { view: false, create: false, edit: false, delete: false }
  }
};
function generateListingsAccess(role, userId) {
  switch (role) {
    case "admin":
    case "portfolio-manager":
      return [];
    // Empty array means access to all listings
    case "owner":
      return [1, 2];
    // Mock property IDs
    case "retail-agent":
    case "referral-agent":
      return [1, 2, 3];
    // Agents have access to certain properties
    case "staff":
      return [1];
    // Staff typically assigned to specific properties
    case "guest":
      return [1];
    // Guests only see their booking property
    default:
      return [];
  }
}
function requireAuth(req, res, next) {
  if (!req.session?.userId) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  next();
}
function requireRole(allowedRoles) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const userRole = req.user.role;
    if (!allowedRoles.includes(userRole)) {
      return res.status(403).json({
        message: "Forbidden",
        required: allowedRoles,
        current: userRole
      });
    }
    next();
  };
}
function setupSecureAuth(app2) {
  app2.use(async (req, res, next) => {
    if (req.session?.userId) {
      try {
        const user = await storage.getUser(req.session.userId);
        if (user) {
          req.user = {
            ...user,
            permissions: DEFAULT_PERMISSIONS[user.primaryRole || user.role] || DEFAULT_PERMISSIONS["guest"],
            listingsAccess: generateListingsAccess(user.primaryRole || user.role, user.id)
          };
        }
      } catch (error) {
        console.error("Error loading user from session:", error);
      }
    }
    next();
  });
  app2.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password, role } = req.body;
      if (!email || !password) {
        return res.status(400).json({ message: "Email and password are required" });
      }
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      const isPasswordValid = await comparePasswords(password, user.password);
      if (!isPasswordValid) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      if (role && user.primaryRole === "admin") {
        user.primaryRole = role;
      }
      req.session.userId = user.id;
      req.session.userRole = user.primaryRole || user.role;
      const authUser = {
        ...user,
        password: void 0,
        // Don't send password to client
        permissions: DEFAULT_PERMISSIONS[user.primaryRole || user.role] || DEFAULT_PERMISSIONS["guest"],
        listingsAccess: generateListingsAccess(user.primaryRole || user.role, user.id)
      };
      res.json({
        message: "Login successful",
        user: authUser,
        token: req.sessionID
        // Use session ID as token
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/auth/user", (req, res) => {
    if (!req.user) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const { password, ...userWithoutPassword } = req.user;
    res.json(userWithoutPassword);
  });
  app2.post("/api/auth/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        console.error("Logout error:", err);
        return res.status(500).json({ message: "Failed to logout" });
      }
      res.json({ message: "Logout successful" });
    });
  });
  app2.put(
    "/api/auth/users/:userId/role",
    requireAuth,
    requireRole(["admin"]),
    async (req, res) => {
      try {
        const { userId } = req.params;
        const { role } = req.body;
        if (!role || !DEFAULT_PERMISSIONS[role]) {
          return res.status(400).json({ message: "Invalid role" });
        }
        const updatedUser = await storage.updateUserRole(userId, role);
        if (!updatedUser) {
          return res.status(404).json({ message: "User not found" });
        }
        res.json({
          message: "Role updated successfully",
          user: { ...updatedUser, password: void 0 }
        });
      } catch (error) {
        console.error("Role update error:", error);
        res.status(500).json({ message: "Failed to update role" });
      }
    }
  );
  app2.get("/api/auth/permissions", requireAuth, (req, res) => {
    if (!req.user?.permissions) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    res.json({
      permissions: req.user.permissions,
      listingsAccess: req.user.listingsAccess,
      role: req.user.primaryRole || req.user.role
    });
  });
}

// server/routes/admin-finance-routes.ts
var router = Router();
router.use(requireAuth);
router.get("/overview", async (req, res) => {
  try {
    const { organizationId: organizationId2 } = req.user;
    const { startDate, endDate, propertyIds } = req.query;
    const filters = {};
    if (startDate) filters.startDate = new Date(startDate);
    if (endDate) filters.endDate = new Date(endDate);
    if (propertyIds) filters.propertyIds = propertyIds.split(",").map(Number);
    const breakdown = {
      totalRevenue: 5e4,
      managementFeeEarned: 7500,
      // 15% of revenue
      ownerPayout: 42500,
      // Revenue - management fee
      propertyManagerEarning: 3750,
      // 50% of management fee
      agentCommission: 750,
      // 10% of management fee
      staffWages: 5500,
      companyRetention: 3e3
      // Management fee - PM share - agent commission
    };
    res.json(breakdown);
  } catch (error) {
    console.error("Error calculating financial overview:", error);
    res.status(500).json({ error: "Failed to calculate financial overview" });
  }
});
router.get("/owner-payouts", async (req, res) => {
  try {
    const { organizationId: organizationId2 } = req.user;
    const { startDate, endDate, propertyIds, ownerIds } = req.query;
    const filters = {};
    if (startDate) filters.startDate = new Date(startDate);
    if (endDate) filters.endDate = new Date(endDate);
    if (propertyIds) filters.propertyIds = propertyIds.split(",").map(Number);
    if (ownerIds) filters.ownerIds = ownerIds.split(",");
    const ownerPayouts2 = await coreFinancialCalculationService.calculateOwnerPayouts(
      organizationId2,
      filters
    );
    res.json(ownerPayouts2);
  } catch (error) {
    console.error("Error calculating owner payouts:", error);
    res.status(500).json({ error: "Failed to calculate owner payouts" });
  }
});
router.get("/pm-earnings", async (req, res) => {
  try {
    const { organizationId: organizationId2 } = req.user;
    const { startDate, endDate, propertyIds, managerIds } = req.query;
    const filters = {};
    if (startDate) filters.startDate = new Date(startDate);
    if (endDate) filters.endDate = new Date(endDate);
    if (propertyIds) filters.propertyIds = propertyIds.split(",").map(Number);
    if (managerIds) filters.managerIds = managerIds.split(",");
    const pmEarnings = await coreFinancialCalculationService.calculatePropertyManagerEarnings(
      organizationId2,
      filters
    );
    res.json(pmEarnings);
  } catch (error) {
    console.error("Error calculating PM earnings:", error);
    res.status(500).json({ error: "Failed to calculate PM earnings" });
  }
});
router.get("/agent-referral", async (req, res) => {
  try {
    const { organizationId: organizationId2 } = req.user;
    const { startDate, endDate, agentIds } = req.query;
    const filters = {};
    if (startDate) filters.startDate = new Date(startDate);
    if (endDate) filters.endDate = new Date(endDate);
    if (agentIds) filters.agentIds = agentIds.split(",");
    const agentEarnings = [
      {
        stakeholderId: "referral-agent-1",
        stakeholderName: "Sarah Johnson",
        stakeholderType: "agent_referral",
        earnings: {
          gross: 5e3,
          net: 500,
          // 10% of management fee
          deductions: 0,
          status: "pending"
        },
        properties: [
          {
            propertyId: 1,
            propertyName: "Villa Majesta",
            revenue: 5e3,
            commission: 500
          }
        ]
      }
    ];
    res.json(agentEarnings);
  } catch (error) {
    console.error("Error calculating agent referral earnings:", error);
    res.status(500).json({ error: "Failed to calculate agent referral earnings" });
  }
});
router.get("/agent-retail", async (req, res) => {
  try {
    const { organizationId: organizationId2 } = req.user;
    const { startDate, endDate, agentIds } = req.query;
    const filters = {};
    if (startDate) filters.startDate = new Date(startDate);
    if (endDate) filters.endDate = new Date(endDate);
    if (agentIds) filters.agentIds = agentIds.split(",");
    const agentEarnings = [
      {
        stakeholderId: "retail-agent-1",
        stakeholderName: "Mike Chen",
        stakeholderType: "agent_retail",
        earnings: {
          gross: 8e3,
          net: 800,
          // 10% of management fee or gross (configurable)
          deductions: 0,
          status: "pending"
        },
        properties: [
          {
            propertyId: 2,
            propertyName: "Villa Paradise",
            revenue: 8e3,
            commission: 800
          }
        ]
      }
    ];
    res.json(agentEarnings);
  } catch (error) {
    console.error("Error calculating agent retail earnings:", error);
    res.status(500).json({ error: "Failed to calculate agent retail earnings" });
  }
});
router.get("/staff-wages", async (req, res) => {
  try {
    const { organizationId: organizationId2 } = req.user;
    const staffConfigs = await coreFinancialCalculationService.getStaffWageConfigs(organizationId2);
    const staffWages = staffConfigs.map((config) => ({
      stakeholderId: config.userId,
      stakeholderName: config.userName,
      stakeholderType: "staff",
      department: config.department,
      earnings: {
        gross: config.monthlyWage,
        net: config.monthlyWage,
        // Simplified - would subtract deductions
        deductions: 0,
        status: "pending"
      },
      billTo: config.billTo,
      propertyId: config.propertyId,
      properties: config.propertyId ? [
        { propertyId: config.propertyId, propertyName: `Property ${config.propertyId}` }
      ] : []
    }));
    res.json(staffWages);
  } catch (error) {
    console.error("Error calculating staff wages:", error);
    res.status(500).json({ error: "Failed to calculate staff wages" });
  }
});
router.get("/commission-settings", async (req, res) => {
  try {
    const { organizationId: organizationId2 } = req.user;
    const settings = await coreFinancialCalculationService.getCommissionSettings(organizationId2);
    res.json(settings);
  } catch (error) {
    console.error("Error fetching commission settings:", error);
    res.status(500).json({ error: "Failed to fetch commission settings" });
  }
});
router.put("/commission-settings", async (req, res) => {
  try {
    const { organizationId: organizationId2 } = req.user;
    const settings = req.body;
    res.json({ success: true, settings });
  } catch (error) {
    console.error("Error updating commission settings:", error);
    res.status(500).json({ error: "Failed to update commission settings" });
  }
});
router.post("/mark-paid", async (req, res) => {
  try {
    const { stakeholderId, stakeholderType, amount, paymentMethod, receiptUrl, notes } = req.body;
    res.json({
      success: true,
      paymentId: `payment_${Date.now()}`,
      paidAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("Error marking payment as paid:", error);
    res.status(500).json({ error: "Failed to mark payment as paid" });
  }
});
router.get("/export/:type", async (req, res) => {
  try {
    const { type } = req.params;
    const { format = "csv" } = req.query;
    let csvData = "";
    let filename = "";
    switch (type) {
      case "owner-payouts":
        csvData = "Owner,Property,Revenue,Management Fee,Net Payout,Status\n";
        filename = "owner-payouts.csv";
        break;
      case "pm-earnings":
        csvData = "Property Manager,Property,Revenue,Commission Rate,Earnings,Status\n";
        filename = "pm-earnings.csv";
        break;
      case "agent-referral":
        csvData = "Agent,Referrals,Commission Rate,Earnings,Status\n";
        filename = "agent-referral.csv";
        break;
      case "agent-retail":
        csvData = "Agent,Bookings,Commission Rate,Earnings,Status\n";
        filename = "agent-retail.csv";
        break;
      case "staff-wages":
        csvData = "Staff Member,Position,Hours,Rate,Gross,Deductions,Net,Status\n";
        filename = "staff-wages.csv";
        break;
      default:
        return res.status(400).json({ error: "Invalid export type" });
    }
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", `attachment; filename=${filename}`);
    res.send(csvData);
  } catch (error) {
    console.error("Error exporting data:", error);
    res.status(500).json({ error: "Failed to export data" });
  }
});
var admin_finance_routes_default = router;

// server/routes.ts
init_storage();

// server/replitAuth.ts
init_storage();
import * as client from "openid-client";
import { Strategy } from "openid-client/passport";
import passport from "passport";
import session2 from "express-session";
import memoize from "memoizee";
import connectPg2 from "connect-pg-simple";
if (process.env.REPL_ID && !process.env.REPLIT_DOMAINS) {
  throw new Error("Environment variable REPLIT_DOMAINS not provided");
}
if (!process.env.REPLIT_DOMAINS) {
  console.warn("\u26A0\uFE0F REPLIT_DOMAINS not set - Replit Auth will not be available. Use alternative authentication.");
}
var getOidcConfig = memoize(
  async () => {
    const clientId = process.env.REPL_ID;
    if (!clientId) {
      throw new Error("REPL_ID environment variable is required for Replit Auth");
    }
    return await client.discovery(
      new URL(process.env.ISSUER_URL ?? "https://replit.com/oidc"),
      clientId
    );
  },
  { maxAge: 3600 * 1e3 }
);
function getSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1e3;
  const pgStore = connectPg2(session2);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: false,
    ttl: sessionTtl,
    tableName: "sessions"
  });
  return session2({
    secret: process.env.SESSION_SECRET,
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: true,
      maxAge: sessionTtl
    }
  });
}
function updateUserSession(user, tokens) {
  user.claims = tokens.claims();
  user.access_token = tokens.access_token;
  user.refresh_token = tokens.refresh_token;
  user.expires_at = user.claims?.exp;
}
async function upsertUser(claims, organizationId2 = "default-org") {
  await storage.upsertUser({
    id: claims["sub"],
    email: claims["email"],
    firstName: claims["first_name"],
    lastName: claims["last_name"],
    profileImageUrl: claims["profile_image_url"],
    organizationId: organizationId2
  });
}
async function setupAuth(app2) {
  if (!process.env.REPL_ID || !process.env.REPLIT_DOMAINS) {
    console.warn("\u26A0\uFE0F Skipping Replit Auth setup - missing REPL_ID or REPLIT_DOMAINS");
    return;
  }
  app2.set("trust proxy", 1);
  app2.use(getSession());
  app2.use(passport.initialize());
  app2.use(passport.session());
  const config = await getOidcConfig();
  const verify = async (tokens, verified) => {
    const user = {};
    updateUserSession(user, tokens);
    await upsertUser(tokens.claims(), "default-org");
    verified(null, user);
  };
  for (const domain of process.env.REPLIT_DOMAINS.split(",")) {
    const strategy = new Strategy(
      {
        name: `replitauth:${domain}`,
        config,
        scope: "openid email profile offline_access",
        callbackURL: `https://${domain}/api/callback`
      },
      verify
    );
    passport.use(strategy);
  }
  passport.serializeUser((user, cb) => cb(null, user));
  passport.deserializeUser((user, cb) => cb(null, user));
  app2.get("/api/login", (req, res, next) => {
    passport.authenticate(`replitauth:${req.hostname}`, {
      prompt: "login consent",
      scope: ["openid", "email", "profile", "offline_access"]
    })(req, res, next);
  });
  app2.get("/api/callback", (req, res, next) => {
    passport.authenticate(`replitauth:${req.hostname}`, {
      successReturnToOrRedirect: "/",
      failureRedirect: "/api/login"
    })(req, res, next);
  });
  app2.get("/api/logout", (req, res) => {
    req.logout(() => {
      res.redirect(
        client.buildEndSessionUrl(config, {
          client_id: process.env.REPL_ID,
          post_logout_redirect_uri: `${req.protocol}://${req.hostname}`
        }).href
      );
    });
  });
}

// server/routes.ts
init_demoAuth();

// server/multiTenant.ts
init_db();
init_schema();
import { eq as eq5, and as and6 } from "drizzle-orm";
function getTenantContext(req) {
  const tenant = req.tenant;
  if (!tenant) {
    console.warn("Tenant context not found - using default demo organization");
    return {
      organizationId: "demo",
      organization: { id: "demo", name: "Demo Organization", subdomain: "demo", isActive: true },
      user: null
    };
  }
  return tenant;
}
var ApiKeyManager = class {
  static {
    this.ENCRYPTION_KEY = process.env.API_KEY_ENCRYPTION_SECRET || "default-dev-key-change-in-production";
  }
  static encrypt(value) {
    return Buffer.from(value).toString("base64");
  }
  static decrypt(encryptedValue) {
    return Buffer.from(encryptedValue, "base64").toString("utf-8");
  }
};

// server/routes.ts
init_schema();
init_db();
init_schema();
init_realtime_events();
import { eq as eq10, and as and11 } from "drizzle-orm";

// server/staffRoutes.ts
init_storage();
init_schema();
async function getStaffMembers(req, res) {
  try {
    const { organizationId: organizationId2 } = req.query;
    const { department, status } = req.query;
    if (!organizationId2 || typeof organizationId2 !== "string") {
      return res.status(400).json({
        error: "Organization ID is required"
      });
    }
    const filters = {};
    if (department && typeof department === "string") filters.department = department;
    if (status && typeof status === "string") filters.status = status;
    const staffMembers2 = await storage.getStaffMembers(organizationId2, filters);
    res.json(staffMembers2);
  } catch (error) {
    console.error("Error in getStaffMembers:", error);
    res.status(500).json({
      error: "Failed to fetch staff members",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function getStaffMember(req, res) {
  try {
    const { id } = req.params;
    const staffId = parseInt(id);
    if (isNaN(staffId)) {
      return res.status(400).json({
        error: "Invalid staff member ID"
      });
    }
    const staffMember = await storage.getStaffMember(staffId);
    if (!staffMember) {
      return res.status(404).json({
        error: "Staff member not found"
      });
    }
    res.json(staffMember);
  } catch (error) {
    console.error("Error in getStaffMember:", error);
    res.status(500).json({
      error: "Failed to fetch staff member",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function createStaffMember(req, res) {
  try {
    const validation = insertStaffMemberSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({
        error: "Validation failed",
        details: validation.error.errors
      });
    }
    const staffMember = await storage.createStaffMember(validation.data);
    res.status(201).json(staffMember);
  } catch (error) {
    console.error("Error in createStaffMember:", error);
    res.status(500).json({
      error: "Failed to create staff member",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function updateStaffMember(req, res) {
  try {
    const { id } = req.params;
    const staffId = parseInt(id);
    if (isNaN(staffId)) {
      return res.status(400).json({
        error: "Invalid staff member ID"
      });
    }
    const validation = insertStaffMemberSchema.partial().safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({
        error: "Validation failed",
        details: validation.error.errors
      });
    }
    const updatedStaffMember = await storage.updateStaffMember(staffId, validation.data);
    if (!updatedStaffMember) {
      return res.status(404).json({
        error: "Staff member not found"
      });
    }
    res.json(updatedStaffMember);
  } catch (error) {
    console.error("Error in updateStaffMember:", error);
    res.status(500).json({
      error: "Failed to update staff member",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function deleteStaffMember(req, res) {
  try {
    const { id } = req.params;
    const staffId = parseInt(id);
    if (isNaN(staffId)) {
      return res.status(400).json({
        error: "Invalid staff member ID"
      });
    }
    const success = await storage.deleteStaffMember(staffId);
    if (!success) {
      return res.status(404).json({
        error: "Staff member not found"
      });
    }
    res.json({ message: "Staff member deleted successfully" });
  } catch (error) {
    console.error("Error in deleteStaffMember:", error);
    res.status(500).json({
      error: "Failed to delete staff member",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function getStaffDocuments(req, res) {
  try {
    const { staffMemberId } = req.params;
    const staffId = parseInt(staffMemberId);
    if (isNaN(staffId)) {
      return res.status(400).json({
        error: "Invalid staff member ID"
      });
    }
    const documents = await storage.getStaffDocuments(staffId);
    res.json(documents);
  } catch (error) {
    console.error("Error in getStaffDocuments:", error);
    res.status(500).json({
      error: "Failed to fetch staff documents",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function createStaffDocument(req, res) {
  try {
    const validation = insertStaffDocumentSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({
        error: "Validation failed",
        details: validation.error.errors
      });
    }
    const document = await storage.createStaffDocument(validation.data);
    res.status(201).json(document);
  } catch (error) {
    console.error("Error in createStaffDocument:", error);
    res.status(500).json({
      error: "Failed to create staff document",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function getPayrollRecords(req, res) {
  try {
    const { organizationId: organizationId2 } = req.query;
    const { staffMemberId, payPeriodStart, payPeriodEnd } = req.query;
    if (!organizationId2 || typeof organizationId2 !== "string") {
      return res.status(400).json({
        error: "Organization ID is required"
      });
    }
    const filters = {};
    if (staffMemberId && typeof staffMemberId === "string") {
      const id = parseInt(staffMemberId);
      if (!isNaN(id)) filters.staffMemberId = id;
    }
    if (payPeriodStart && typeof payPeriodStart === "string") filters.payPeriodStart = payPeriodStart;
    if (payPeriodEnd && typeof payPeriodEnd === "string") filters.payPeriodEnd = payPeriodEnd;
    const payrollRecords2 = await storage.getPayrollRecords(organizationId2, filters);
    res.json(payrollRecords2);
  } catch (error) {
    console.error("Error in getPayrollRecords:", error);
    res.status(500).json({
      error: "Failed to fetch payroll records",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function createPayrollRecord(req, res) {
  try {
    const validation = insertPayrollRecordSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({
        error: "Validation failed",
        details: validation.error.errors
      });
    }
    const payrollRecord = await storage.createPayrollRecord(validation.data);
    res.status(201).json(payrollRecord);
  } catch (error) {
    console.error("Error in createPayrollRecord:", error);
    res.status(500).json({
      error: "Failed to create payroll record",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function getStaffAnalytics(req, res) {
  try {
    const { organizationId: organizationId2 } = req.query;
    if (!organizationId2 || typeof organizationId2 !== "string") {
      return res.status(400).json({
        error: "Organization ID is required"
      });
    }
    const analytics = await storage.getStaffAnalytics(organizationId2);
    res.json(analytics);
  } catch (error) {
    console.error("Error in getStaffAnalytics:", error);
    res.status(500).json({
      error: "Failed to fetch staff analytics",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}

// server/routes.ts
import { z as z2 } from "zod";

// server/staffWalletStorage.ts
var StaffWalletStorage = class {
  constructor() {
    this.wallets = /* @__PURE__ */ new Map();
    this.transactions = /* @__PURE__ */ new Map();
    this.pendingCheckouts = /* @__PURE__ */ new Map();
    this.initializeDemoData();
  }
  initializeDemoData() {
    this.wallets.set("staff-pool", {
      staffId: "staff-pool",
      currentBalance: 6750,
      basePettyCash: 5e3,
      totalCollected: 2500,
      totalExpenses: 750,
      lastCleared: "2025-01-22"
    });
    const demoTransactions = [
      {
        id: "1",
        staffId: "staff-pool",
        type: "income",
        amount: 1750,
        description: "Check-out cash collection - Villa Aruna electricity",
        category: "checkout_cash",
        date: "2025-01-23",
        time: "14:30",
        guestName: "John Smith",
        propertyName: "Villa Aruna",
        status: "pending"
      },
      {
        id: "2",
        staffId: "staff-pool",
        type: "expense",
        amount: 450,
        description: "Gasoline for property visits",
        category: "transport",
        date: "2025-01-23",
        time: "10:15",
        receipt: "Receipt-GAS-001.jpg",
        status: "pending"
      }
    ];
    demoTransactions.forEach((transaction) => {
      this.transactions.set(transaction.id, transaction);
    });
    const demoPendingCheckouts = [
      {
        id: "1",
        guestName: "Michael Johnson",
        propertyName: "Villa Aruna",
        checkoutDate: "2025-01-23",
        checkoutTime: "11:00",
        electricityReading: { start: 1250, end: 1387, rate: 7 },
        estimatedCash: 959,
        status: "pending_collection"
      },
      {
        id: "2",
        guestName: "Emma Wilson",
        propertyName: "Villa Breeze",
        checkoutDate: "2025-01-23",
        checkoutTime: "14:30",
        electricityReading: { start: 2100, end: 2198, rate: 7 },
        estimatedCash: 686,
        status: "pending_collection"
      }
    ];
    demoPendingCheckouts.forEach((checkout) => {
      this.pendingCheckouts.set(checkout.id, checkout);
    });
  }
  // Wallet operations
  getWallet(staffId) {
    return this.wallets.get(staffId);
  }
  updateWalletBalance(staffId, amount, type) {
    const wallet = this.wallets.get(staffId);
    if (wallet) {
      if (type === "add") {
        wallet.currentBalance += amount;
        wallet.totalCollected += amount;
      } else {
        wallet.currentBalance -= amount;
        wallet.totalExpenses += amount;
      }
      this.wallets.set(staffId, wallet);
    }
  }
  clearWalletBalance(staffId, reason) {
    const wallet = this.wallets.get(staffId);
    if (wallet) {
      wallet.currentBalance = wallet.basePettyCash;
      wallet.lastCleared = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      this.wallets.set(staffId, wallet);
    }
  }
  // Transaction operations
  getTransactions(staffId) {
    const allTransactions = Array.from(this.transactions.values());
    if (staffId) {
      return allTransactions.filter((t) => t.staffId === staffId);
    }
    return allTransactions;
  }
  getPendingTransactions() {
    return Array.from(this.transactions.values()).filter((t) => t.status === "pending");
  }
  getReviewedTransactions() {
    return Array.from(this.transactions.values()).filter((t) => t.status === "approved");
  }
  addTransaction(transaction) {
    const id = Date.now().toString();
    const newTransaction = {
      id,
      ...transaction
    };
    this.transactions.set(id, newTransaction);
    if (transaction.type === "income") {
      this.updateWalletBalance(transaction.staffId, transaction.amount, "add");
    } else {
      this.updateWalletBalance(transaction.staffId, transaction.amount, "subtract");
    }
    return newTransaction;
  }
  reviewTransaction(transactionId, finalCategory, property, reviewNotes, reviewedBy) {
    const transaction = this.transactions.get(transactionId);
    if (transaction) {
      transaction.status = "approved";
      transaction.finalCategory = finalCategory;
      transaction.property = property;
      transaction.reviewNotes = reviewNotes;
      transaction.reviewedBy = reviewedBy;
      transaction.reviewDate = (/* @__PURE__ */ new Date()).toISOString();
      this.transactions.set(transactionId, transaction);
      return true;
    }
    return false;
  }
  // Checkout operations
  getPendingCheckouts() {
    return Array.from(this.pendingCheckouts.values()).filter((c) => c.status === "pending_collection");
  }
  recordCashCollection(checkoutId, actualAmount, collectionMethod, notes, receiptPhoto) {
    const checkout = this.pendingCheckouts.get(checkoutId);
    if (checkout) {
      checkout.status = "collected";
      this.pendingCheckouts.set(checkoutId, checkout);
      this.addTransaction({
        staffId: "staff-pool",
        // Current staff member
        type: "income",
        amount: actualAmount,
        description: `Check-out cash collection - ${checkout.propertyName}`,
        category: "checkout_cash",
        date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        time: (/* @__PURE__ */ new Date()).toTimeString().slice(0, 5),
        guestName: checkout.guestName,
        propertyName: checkout.propertyName,
        receipt: receiptPhoto,
        status: "pending"
      });
      return true;
    }
    return false;
  }
};
var staffWalletStorage = new StaffWalletStorage();

// server/staffPermissionStorage.ts
var StaffPermissionStorage = class {
  constructor() {
    this.permissions = /* @__PURE__ */ new Map();
    this.taskCreationCount = /* @__PURE__ */ new Map();
    this.initializeDemoData();
  }
  initializeDemoData() {
    const demoPermission = {
      id: 1,
      organizationId: "default-org",
      staffUserId: "staff-pool",
      canCreateTasks: false,
      // Initially disabled - admin must enable
      canEditOwnTasks: true,
      canDeleteOwnTasks: false,
      canViewAllTasks: true,
      maxTasksPerDay: 3,
      allowedDepartments: ["cleaning", "maintenance", "general"],
      requiresApproval: true,
      grantedBy: "admin",
      reason: "Standard staff permissions",
      isActive: true,
      expiresAt: void 0,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
    this.permissions.set("staff-pool", demoPermission);
  }
  // Get staff task permissions
  getStaffPermissions(staffUserId) {
    return this.permissions.get(staffUserId) || null;
  }
  // Check if staff can create tasks
  canStaffCreateTasks(staffUserId) {
    const permission = this.getStaffPermissions(staffUserId);
    if (!permission || !permission.isActive) return false;
    if (permission.expiresAt && permission.expiresAt < /* @__PURE__ */ new Date()) {
      return false;
    }
    return permission.canCreateTasks;
  }
  // Check daily task limit
  canStaffCreateMoreTasks(staffUserId) {
    const permission = this.getStaffPermissions(staffUserId);
    if (!permission) return false;
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const countData = this.taskCreationCount.get(staffUserId);
    if (!countData || countData.date !== today) {
      this.taskCreationCount.set(staffUserId, { date: today, count: 0 });
      return true;
    }
    return countData.count < permission.maxTasksPerDay;
  }
  // Increment task creation count
  incrementTaskCount(staffUserId) {
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const countData = this.taskCreationCount.get(staffUserId);
    if (!countData || countData.date !== today) {
      this.taskCreationCount.set(staffUserId, { date: today, count: 1 });
    } else {
      countData.count++;
    }
  }
  // Check if staff can create tasks for specific department
  canStaffCreateTaskForDepartment(staffUserId, department) {
    const permission = this.getStaffPermissions(staffUserId);
    if (!permission) return false;
    return permission.allowedDepartments.includes(department) || permission.allowedDepartments.includes("all");
  }
  // Update staff permissions (admin only)
  updateStaffPermissions(staffUserId, updates, updatedBy) {
    const existing = this.getStaffPermissions(staffUserId);
    const updated = {
      ...existing || {
        id: Date.now(),
        organizationId: "default-org",
        staffUserId,
        canCreateTasks: false,
        canEditOwnTasks: true,
        canDeleteOwnTasks: false,
        canViewAllTasks: true,
        maxTasksPerDay: 3,
        allowedDepartments: ["general"],
        requiresApproval: true,
        grantedBy: updatedBy,
        reason: "Permission update",
        isActive: true,
        createdAt: /* @__PURE__ */ new Date()
      },
      ...updates,
      updatedAt: /* @__PURE__ */ new Date()
    };
    this.permissions.set(staffUserId, updated);
    return updated;
  }
  // Get all staff permissions (admin only)
  getAllStaffPermissions() {
    return Array.from(this.permissions.values());
  }
  // Grant task creation permission to staff
  grantTaskCreationPermission(staffUserId, grantedBy, reason, departments = ["general"], maxTasksPerDay = 3, expiresAt) {
    return this.updateStaffPermissions(staffUserId, {
      canCreateTasks: true,
      allowedDepartments: departments,
      maxTasksPerDay,
      grantedBy,
      reason,
      expiresAt,
      isActive: true
    }, grantedBy);
  }
  // Revoke task creation permission
  revokeTaskCreationPermission(staffUserId, revokedBy, reason) {
    return this.updateStaffPermissions(staffUserId, {
      canCreateTasks: false,
      grantedBy: revokedBy,
      reason,
      isActive: false
    }, revokedBy);
  }
};
var staffPermissionStorage = new StaffPermissionStorage();

// server/utility-alert-automation.ts
init_storage();
init_logger();
import cron from "node-cron";
var UtilityAlertAutomation = class {
  static {
    this.isRunning = false;
  }
  /**
   * Initialize the daily utility alert cron job
   */
  static initializeCronJob() {
    cron.schedule("0 9 * * *", async () => {
      if (this.isRunning) {
        logger.info("Utility alert check already running, skipping");
        return;
      }
      this.isRunning = true;
      try {
        await this.performDailyUtilityCheck();
      } catch (error) {
        logger.error("Error in daily utility check:", error);
      } finally {
        this.isRunning = false;
      }
    });
    logger.info("Utility alert automation cron job initialized (daily at 9:00 AM)");
  }
  /**
   * Main daily check function - examines all properties for missing utility bills
   */
  static async performDailyUtilityCheck() {
    try {
      logger.info("Starting daily utility alert check");
      const today = /* @__PURE__ */ new Date();
      const currentDay = today.getDate();
      const currentMonth = today.getMonth() + 1;
      const currentYear = today.getFullYear();
      const organizations3 = await storage.getAllOrganizations();
      for (const org of organizations3) {
        await this.checkOrganizationUtilities(org.id, currentDay, currentMonth, currentYear);
      }
      logger.info("Completed daily utility alert check");
    } catch (error) {
      logger.error("Error in daily utility check:", error);
      throw error;
    }
  }
  /**
   * Check utilities for a specific organization
   */
  static async checkOrganizationUtilities(organizationId2, currentDay, currentMonth, currentYear) {
    try {
      const propertiesWithUtilities = await storage.getPropertiesWithUtilitySettings(organizationId2);
      for (const property of propertiesWithUtilities) {
        await this.checkPropertyUtilities(property, currentDay, currentMonth, currentYear);
      }
    } catch (error) {
      logger.error(`Error checking utilities for organization ${organizationId2}:`, error);
    }
  }
  /**
   * Check utilities for a specific property
   */
  static async checkPropertyUtilities(property, currentDay, currentMonth, currentYear) {
    try {
      const utilities = await storage.getPropertyUtilities(property.id, property.organizationId);
      for (const utility of utilities) {
        if (utility.dueDay === currentDay) {
          await this.checkUtilityBillStatus(property, utility, currentMonth, currentYear);
        }
      }
    } catch (error) {
      logger.error(`Error checking utilities for property ${property.id}:`, error);
    }
  }
  /**
   * Check if utility bill receipt exists for current month
   */
  static async checkUtilityBillStatus(property, utility, currentMonth, currentYear) {
    try {
      const hasCurrentMonthReceipt = await storage.hasUtilityReceiptForMonth(
        property.id,
        utility.id,
        currentMonth,
        currentYear,
        property.organizationId
      );
      if (!hasCurrentMonthReceipt) {
        await this.generateMissingBillAlert(property, utility, currentMonth, currentYear);
      }
    } catch (error) {
      logger.error(`Error checking utility bill status:`, error);
    }
  }
  /**
   * Generate alert for missing utility bill
   */
  static async generateMissingBillAlert(property, utility, currentMonth, currentYear) {
    try {
      const monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ];
      const alertTitle = `Missing ${utility.utilityType} Bill - ${property.name}`;
      const alertMessage = `\u26A0\uFE0F Villa ${property.name} is missing the ${utility.utilityType} bill for ${monthNames[currentMonth - 1]} ${currentYear}. Please upload or confirm payment.`;
      const alert = await storage.createUtilityBillAlert({
        organizationId: property.organizationId,
        propertyId: property.id,
        utilityId: utility.id,
        alertType: "missing_receipt",
        alertTitle,
        alertMessage,
        alertSeverity: "warning",
        sentToRoles: ["admin", "portfolio-manager", "owner"],
        alertStatus: "active"
      });
      await this.sendAlertNotifications(property, utility, alertMessage, alertTitle);
      logger.info(`Generated missing bill alert for ${property.name} - ${utility.utilityType}`);
    } catch (error) {
      logger.error(`Error generating missing bill alert:`, error);
    }
  }
  /**
   * Send notifications to admin, manager, and owner
   */
  static async sendAlertNotifications(property, utility, alertMessage, alertTitle) {
    try {
      const admins = await storage.getUsersByRole("admin", property.organizationId);
      const portfolioManagers = await storage.getUsersByRole("portfolio-manager", property.organizationId);
      const owner = property.ownerId ? await storage.getUserById(property.ownerId) : null;
      const recipients = [...admins, ...portfolioManagers];
      if (owner) recipients.push(owner);
      for (const user of recipients) {
        await storage.createNotification({
          organizationId: property.organizationId,
          userId: user.id,
          title: alertTitle,
          message: alertMessage,
          type: "utility_alert",
          severity: "warning",
          relatedEntityType: "property",
          relatedEntityId: property.id,
          isRead: false
        });
      }
      logger.info(`Sent utility alert notifications to ${recipients.length} recipients for ${property.name}`);
    } catch (error) {
      logger.error(`Error sending alert notifications:`, error);
    }
  }
  /**
   * Manual trigger for utility check (for testing)
   */
  static async triggerManualCheck(organizationId2) {
    try {
      logger.info(`Manual utility check triggered for organization ${organizationId2}`);
      const today = /* @__PURE__ */ new Date();
      const currentDay = today.getDate();
      const currentMonth = today.getMonth() + 1;
      const currentYear = today.getFullYear();
      await this.checkOrganizationUtilities(organizationId2, currentDay, currentMonth, currentYear);
      logger.info(`Manual utility check completed for organization ${organizationId2}`);
    } catch (error) {
      logger.error(`Error in manual utility check:`, error);
      throw error;
    }
  }
  /**
   * Check for overdue bills (run weekly)
   */
  static initializeOverdueCheck() {
    cron.schedule("0 10 * * 1", async () => {
      try {
        await this.checkOverdueBills();
      } catch (error) {
        logger.error("Error in overdue bills check:", error);
      }
    });
    logger.info("Overdue bills check cron job initialized (weekly on Mondays)");
  }
  /**
   * Check for bills that are overdue
   */
  static async checkOverdueBills() {
    try {
      logger.info("Starting overdue bills check");
      const organizations3 = await storage.getAllOrganizations();
      for (const org of organizations3) {
        const overdueBills = await storage.getOverdueUtilityBills(org.id);
        for (const bill of overdueBills) {
          await this.generateOverdueAlert(bill);
        }
      }
      logger.info("Completed overdue bills check");
    } catch (error) {
      logger.error("Error in overdue bills check:", error);
    }
  }
  /**
   * Generate alert for overdue bill
   */
  static async generateOverdueAlert(bill) {
    try {
      const daysOverdue = Math.floor((Date.now() - new Date(bill.dueDate).getTime()) / (1e3 * 60 * 60 * 24));
      const alertTitle = `Overdue ${bill.utilityType} Bill - ${bill.propertyName}`;
      const alertMessage = `\u{1F6A8} URGENT: ${bill.propertyName} ${bill.utilityType} bill is ${daysOverdue} days overdue. Immediate action required to avoid service disconnection.`;
      await storage.createUtilityBillAlert({
        organizationId: bill.organizationId,
        propertyId: bill.propertyId,
        utilityId: bill.utilityId,
        alertType: "overdue_bill",
        alertTitle,
        alertMessage,
        alertSeverity: "urgent",
        sentToRoles: ["admin", "portfolio-manager", "owner"],
        alertStatus: "active"
      });
      logger.info(`Generated overdue alert for ${bill.propertyName} - ${bill.utilityType} (${daysOverdue} days)`);
    } catch (error) {
      logger.error(`Error generating overdue alert:`, error);
    }
  }
};
function initializeUtilityAutomation() {
  UtilityAlertAutomation.initializeCronJob();
  UtilityAlertAutomation.initializeOverdueCheck();
  logger.info("Utility alert automation initialized");
}

// server/routes.ts
init_bulk_delete_api();
async function registerRoutes(app2) {
  setupSecureAuth(app2);
  if (process.env.REPLIT_DOMAINS && process.env.REPL_ID) {
    await setupAuth(app2);
    console.log("\u2705 Replit Auth enabled");
  } else {
    console.log("\u26A0\uFE0F Replit Auth disabled - using secure auth only (external deployment mode)");
  }
  app2.get("/api/notifications", isDemoAuthenticated, (req, res) => {
    res.json([]);
  });
  app2.get("/api/notifications/unread", isDemoAuthenticated, (req, res) => {
    res.json([]);
  });
  app2.get("/api/realtime/events", (req, res) => {
    const organizationId2 = req.query.organizationId ? parseInt(req.query.organizationId) : void 0;
    realtimeEvents.addClient(res, organizationId2);
    req.on("close", () => {
      console.log("[SSE] Request closed");
    });
  });
  app2.get("/api/realtime/status", (req, res) => {
    res.json({
      activeClients: realtimeEvents.getClientCount(),
      status: "running"
    });
  });
  console.log("[INIT] Real-time SSE endpoint mounted \u2705");
  const { ensureStandardDemoProperties: ensureStandardDemoProperties2 } = await Promise.resolve().then(() => (init_standardDemoProperties(), standardDemoProperties_exports));
  initializeUtilityAutomation();
  console.log("\u2705 Automation systems initialized successfully");
  registerSaasRoutes(app2);
  registerFinanceRoutes(app2);
  app2.use("/api/admin/finance", admin_finance_routes_default);
  registerBulkDeleteRoutes(app2);
  const { registerFastRoutes: registerFastRoutes2 } = await Promise.resolve().then(() => (init_fastRoutes(), fastRoutes_exports));
  registerFastRoutes2(app2);
  const optimizedRoutes = await Promise.resolve().then(() => (init_optimizedRoutes(), optimizedRoutes_exports));
  app2.use(optimizedRoutes.default);
  const { processQuestion: processQuestion2, invalidateCache: invalidateCortexCache } = await Promise.resolve().then(() => (init_cortex(), cortex_exports));
  app2.post("/api/cortex/answer", isDemoAuthenticated, async (req, res) => {
    try {
      const { question } = req.body;
      if (!question || typeof question !== "string") {
        return res.status(400).json({
          error: "Question is required and must be a string"
        });
      }
      const user = req.user;
      const organizationId2 = user?.organizationId || "default-org";
      const userId = user?.id;
      const result = await processQuestion2({
        question,
        organizationId: organizationId2,
        userId
      });
      res.json(result);
    } catch (error) {
      console.error("[CORTEX API] Error:", error);
      res.status(500).json({
        error: "Failed to process question",
        message: error.message
      });
    }
  });
  app2.post("/api/cortex/cache/invalidate", isDemoAuthenticated, async (req, res) => {
    try {
      const { pattern } = req.body;
      invalidateCortexCache(pattern);
      res.json({ success: true, message: "Cache invalidated" });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  console.log("[INIT] Captain Cortex AI routes mounted \u2705");
  app2.get("/api/smart-pricing/dashboard", isDemoAuthenticated, (req, res) => {
    res.json({
      totalRevenue: 168e4,
      averageNightlyRate: 12500,
      occupancyRate: 78.5,
      priceOptimizationScore: 84,
      monthlyData: [
        { month: "Jan", revenue: 145e3, rate: 12e3, occupancy: 75 },
        { month: "Feb", revenue: 158e3, rate: 12800, occupancy: 82 },
        { month: "Mar", revenue: 142e3, rate: 11500, occupancy: 76 }
      ]
    });
  });
  app2.get("/api/smart-pricing/year-on-year", isDemoAuthenticated, (req, res) => {
    res.json({
      currentYear: 2025,
      previousYear: 2024,
      growth: 15.2,
      data: [
        { month: "Jan", current: 145e3, previous: 125e3 },
        { month: "Feb", current: 158e3, previous: 138e3 },
        { month: "Mar", current: 142e3, previous: 128e3 }
      ]
    });
  });
  app2.get("/api/smart-pricing/holidays", isDemoAuthenticated, (req, res) => {
    res.json([
      { name: "Chinese New Year", date: "2025-01-29", impact: "high", priceIncrease: 25 },
      { name: "Songkran", date: "2025-04-13", impact: "very-high", priceIncrease: 40 },
      { name: "Loy Krathong", date: "2025-11-05", impact: "medium", priceIncrease: 15 }
    ]);
  });
  app2.get("/api/smart-pricing/price-deviation", isDemoAuthenticated, (req, res) => {
    res.json({
      averageMarketRate: 11500,
      currentRate: 12500,
      deviation: 8.7,
      recommendation: "optimal",
      competitorRates: [
        { name: "Similar Villa A", rate: 11200 },
        { name: "Similar Villa B", rate: 12800 },
        { name: "Similar Villa C", rate: 11900 }
      ]
    });
  });
  app2.get("/api/smart-pricing/booking-gaps", isDemoAuthenticated, (req, res) => {
    res.json([
      {
        id: 1,
        startDate: "2025-02-15",
        endDate: "2025-02-20",
        duration: 5,
        potentialRevenue: 62500,
        suggestedAction: "Reduce rate by 10%",
        resolved: false
      },
      {
        id: 2,
        startDate: "2025-03-10",
        endDate: "2025-03-12",
        duration: 2,
        potentialRevenue: 25e3,
        suggestedAction: "Add promotion",
        resolved: false
      }
    ]);
  });
  app2.get("/api/smart-pricing/alerts", isDemoAuthenticated, (req, res) => {
    res.json([
      {
        id: 1,
        type: "pricing",
        priority: "high",
        message: "Villa Aruna rate 15% below market average",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        read: false
      },
      {
        id: 2,
        type: "occupancy",
        priority: "medium",
        message: "Low occupancy predicted for next week",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        read: false
      }
    ]);
  });
  app2.get("/api/smart-pricing/ai-summary", isDemoAuthenticated, (req, res) => {
    res.json({
      summary: "Your pricing strategy is performing well with 84% optimization score. Consider adjusting Villa Aruna rates during peak season for 12% additional revenue.",
      recommendations: [
        "Increase weekend rates by 8-12% during February",
        "Add last-minute booking discounts for gap periods",
        "Implement dynamic pricing for holiday seasons"
      ],
      confidence: 87
    });
  });
  app2.get("/api/smart-pricing/direct-booking", isDemoAuthenticated, (req, res) => {
    res.json({
      totalDirectBookings: 23,
      directBookingRate: 31.5,
      averageDirectRate: 13200,
      potentialSavings: 95e3,
      monthlyTrend: [
        { month: "Jan", direct: 8, total: 25, rate: 32 },
        { month: "Feb", direct: 7, total: 22, rate: 31.8 },
        { month: "Mar", direct: 8, total: 26, rate: 30.7 }
      ]
    });
  });
  app2.get("/api/smart-pricing/heatmap", isDemoAuthenticated, (req, res) => {
    res.json({
      data: [
        { date: "2025-01-15", occupancy: 85, rate: 12500 },
        { date: "2025-01-16", occupancy: 92, rate: 13e3 },
        { date: "2025-01-17", occupancy: 78, rate: 11800 },
        { date: "2025-01-18", occupancy: 95, rate: 14e3 }
      ],
      optimalRates: {
        weekday: 11500,
        weekend: 14500,
        holiday: 18e3
      }
    });
  });
  app2.get("/api/smart-pricing/historical-patterns", isDemoAuthenticated, (req, res) => {
    res.json({
      patterns: [
        { pattern: "Weekend Premium", impact: "+18%", frequency: "weekly" },
        { pattern: "Holiday Surge", impact: "+35%", frequency: "seasonal" },
        { pattern: "Low Season Discount", impact: "-15%", frequency: "seasonal" }
      ],
      seasonality: {
        high: ["Dec", "Jan", "Feb", "Mar"],
        medium: ["Apr", "May", "Oct", "Nov"],
        low: ["Jun", "Jul", "Aug", "Sep"]
      }
    });
  });
  app2.patch("/api/smart-pricing/alerts/:id/read", isDemoAuthenticated, (req, res) => {
    res.json({ success: true, message: "Alert marked as read" });
  });
  app2.patch("/api/smart-pricing/alerts/:id/resolve", isDemoAuthenticated, (req, res) => {
    res.json({ success: true, message: "Alert resolved successfully" });
  });
  app2.patch("/api/smart-pricing/booking-gaps/:id/resolve", isDemoAuthenticated, (req, res) => {
    res.json({ success: true, message: "Booking gap resolved" });
  });
  app2.get("/api/property-appliances", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : void 0;
      const appliances = await storage.getPropertyAppliances(organizationId2, propertyId);
      res.json(appliances);
    } catch (error) {
      console.error("Error fetching appliances:", error);
      res.status(500).json({ error: "Failed to fetch appliances" });
    }
  });
  app2.post("/api/property-appliances", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const appliance = await storage.createPropertyAppliance(organizationId2, req.body);
      res.status(201).json(appliance);
    } catch (error) {
      console.error("Error creating appliance:", error);
      res.status(500).json({ error: "Failed to create appliance" });
    }
  });
  app2.get("/api/property-appliances/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const applianceId = parseInt(req.params.id);
      const appliance = await storage.getPropertyApplianceById(organizationId2, applianceId);
      if (!appliance) {
        return res.status(404).json({ error: "Appliance not found" });
      }
      res.json(appliance);
    } catch (error) {
      console.error("Error fetching appliance:", error);
      res.status(500).json({ error: "Failed to fetch appliance" });
    }
  });
  app2.put("/api/property-appliances/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const applianceId = parseInt(req.params.id);
      const appliance = await storage.updatePropertyAppliance(organizationId2, applianceId, req.body);
      if (!appliance) {
        return res.status(404).json({ error: "Appliance not found" });
      }
      res.json(appliance);
    } catch (error) {
      console.error("Error updating appliance:", error);
      res.status(500).json({ error: "Failed to update appliance" });
    }
  });
  app2.delete("/api/property-appliances/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const applianceId = parseInt(req.params.id);
      const success = await storage.deletePropertyAppliance(organizationId2, applianceId);
      if (!success) {
        return res.status(404).json({ error: "Appliance not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting appliance:", error);
      res.status(500).json({ error: "Failed to delete appliance" });
    }
  });
  app2.get("/api/property-appliances/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const analytics = await storage.getAppliancesAnalytics(organizationId2);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching appliances analytics:", error);
      res.status(500).json({ error: "Failed to fetch analytics" });
    }
  });
  app2.get("/api/appliance-repairs", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const applianceId = req.query.applianceId ? parseInt(req.query.applianceId) : void 0;
      const repairs = await storage.getApplianceRepairs(organizationId2, applianceId);
      res.json(repairs);
    } catch (error) {
      console.error("Error fetching repairs:", error);
      res.status(500).json({ error: "Failed to fetch repairs" });
    }
  });
  app2.post("/api/appliance-repairs", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const repair = await storage.createApplianceRepair(organizationId2, req.body);
      res.status(201).json(repair);
    } catch (error) {
      console.error("Error creating repair:", error);
      res.status(500).json({ error: "Failed to create repair" });
    }
  });
  app2.get("/api/appliance-repairs/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const repairId = parseInt(req.params.id);
      const repair = await storage.getApplianceRepairById(organizationId2, repairId);
      if (!repair) {
        return res.status(404).json({ error: "Repair not found" });
      }
      res.json(repair);
    } catch (error) {
      console.error("Error fetching repair:", error);
      res.status(500).json({ error: "Failed to fetch repair" });
    }
  });
  app2.put("/api/appliance-repairs/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const repairId = parseInt(req.params.id);
      const repair = await storage.updateApplianceRepair(organizationId2, repairId, req.body);
      if (!repair) {
        return res.status(404).json({ error: "Repair not found" });
      }
      res.json(repair);
    } catch (error) {
      console.error("Error updating repair:", error);
      res.status(500).json({ error: "Failed to update repair" });
    }
  });
  app2.delete("/api/appliance-repairs/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const repairId = parseInt(req.params.id);
      const success = await storage.deleteApplianceRepair(organizationId2, repairId);
      if (!success) {
        return res.status(404).json({ error: "Repair not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting repair:", error);
      res.status(500).json({ error: "Failed to delete repair" });
    }
  });
  app2.post("/api/fix-demo-data", isDemoAuthenticated, async (req, res) => {
    try {
      console.log("\u{1F527} Fixing demo data relationships...");
      const props = await storage.getProperties("default-org");
      console.log(`Found ${props.length} properties`);
      const currentDate = /* @__PURE__ */ new Date();
      const linkedBookings = [
        {
          organizationId: "default-org",
          externalId: "BK-2025-001",
          propertyId: props[0]?.id || 1,
          guestName: "John Smith",
          guestEmail: "john.smith@email.com",
          guestPhone: "+1 555 0123",
          checkInDate: /* @__PURE__ */ new Date("2025-07-21"),
          checkOutDate: /* @__PURE__ */ new Date("2025-07-26"),
          totalAmount: 1e5,
          // 5 nights x 20000 THB
          status: "confirmed",
          adults: 2,
          children: 0,
          source: "Airbnb"
        },
        {
          organizationId: "default-org",
          externalId: "BK-2025-002",
          propertyId: props[1]?.id || 2,
          guestName: "Emily Davis",
          guestEmail: "emily.davis@email.com",
          guestPhone: "+44 20 1234 5678",
          checkInDate: new Date(currentDate.getTime() - 2 * 24 * 60 * 60 * 1e3),
          checkOutDate: new Date(currentDate.getTime() + 3 * 24 * 60 * 60 * 1e3),
          totalAmount: 32500,
          status: "active",
          adults: 2,
          children: 0,
          source: "Booking.com"
        },
        {
          organizationId: "default-org",
          externalId: "BK-2025-003",
          propertyId: props[2]?.id || 3,
          guestName: "Michael Thompson",
          guestEmail: "michael.thompson@email.com",
          guestPhone: "+1 415 555 0199",
          checkInDate: new Date(currentDate.getTime() - 1 * 24 * 60 * 60 * 1e3),
          checkOutDate: new Date(currentDate.getTime() + 6 * 24 * 60 * 60 * 1e3),
          totalAmount: 14e4,
          status: "active",
          adults: 4,
          children: 0,
          source: "VRBO"
        }
      ];
      for (const booking of linkedBookings) {
        try {
          await storage.createBooking(booking);
        } catch (error) {
          console.log(`Booking ${booking.externalId} might already exist`);
        }
      }
      const linkedFinances = [
        {
          organizationId: "default-org",
          propertyId: props[0]?.id || 1,
          type: "income",
          category: "booking_revenue",
          amount: 32500,
          description: "December booking revenue",
          date: /* @__PURE__ */ new Date("2024-12-20"),
          paymentMethod: "bank_transfer",
          receiptNumber: "REC-2024-001"
        },
        {
          organizationId: "default-org",
          propertyId: props[1]?.id || 2,
          type: "expense",
          category: "utilities_electricity",
          amount: 3500,
          description: "Monthly electricity bill",
          date: new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 15),
          paymentMethod: "bank_transfer",
          receiptNumber: "ELEC-2025-001"
        }
      ];
      for (const finance of linkedFinances) {
        try {
          await storage.createFinance(finance);
        } catch (error) {
          console.log(`Finance record might already exist`);
        }
      }
      res.json({
        message: "Demo data relationships fixed!",
        properties: props.length,
        bookingsCreated: linkedBookings.length,
        financesCreated: linkedFinances.length
      });
    } catch (error) {
      console.error("Error fixing demo data:", error);
      res.status(500).json({ error: "Failed to fix demo data" });
    }
  });
  app2.get("/api/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      console.log("Fetching invoices for organization:", organizationId2);
      let invoices2 = [];
      try {
        invoices2 = await storage.getInvoices(organizationId2);
        console.log("Found invoices in database:", invoices2.length);
      } catch (dbError) {
        console.log("Database invoice fetch failed, using demo data:", dbError.message);
        invoices2 = [];
      }
      res.json(invoices2);
    } catch (error) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ message: "Error fetching invoices", error: error.message });
    }
  });
  app2.post("/api/invoices/test", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      console.log("Creating test invoice for organization:", organizationId2);
      const testInvoice = {
        number: `INV-TEST-${Date.now()}`,
        clientName: "Test Client",
        amount: 15e3,
        status: "pending",
        date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        dueDate: new Date(Date.now() + 15 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
        // 15 days from now
        organizationId: organizationId2
      };
      try {
        const newInvoice = await storage.createInvoice(testInvoice);
        console.log("Test invoice created:", newInvoice.id);
        res.status(201).json(newInvoice);
      } catch (dbError) {
        console.log("Database invoice creation failed, returning test data:", dbError.message);
        res.status(201).json({
          id: Date.now(),
          ...testInvoice,
          createdAt: /* @__PURE__ */ new Date()
        });
      }
    } catch (error) {
      console.error("Error creating test invoice:", error);
      res.status(500).json({ message: "Error creating test invoice", error: error.message });
    }
  });
  app2.get("/api/finance-intelligence/data", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const period = req.query.period || "monthly";
      console.log("Fetching finance intelligence data for:", organizationId2, period);
      const financeRecords = await storage.getFinances(organizationId2);
      const salaryData = await storage.getStaffSalaries?.(organizationId2) || [];
      const intelligenceData = financeRecords.map((record) => ({
        id: record.id,
        category: record.category || "Other",
        amount: record.amount,
        type: record.type,
        date: record.date,
        description: record.description,
        department: record.category?.includes("cleaning") ? "Cleaning" : record.category?.includes("pool") ? "Pool Service" : record.category?.includes("garden") ? "Garden Service" : record.category?.includes("laundry") ? "Laundry" : record.category?.includes("rental") ? "Rental Income" : record.category?.includes("management") ? "Management Fees" : record.category?.includes("utility") ? "Utilities" : "Other Services"
      }));
      salaryData.forEach((salary) => {
        intelligenceData.push({
          id: `salary-${salary.id}`,
          category: "Salaries & Wages",
          amount: salary.monthlySalary || salary.amount || 0,
          type: "expense",
          date: (/* @__PURE__ */ new Date()).toISOString(),
          description: `Salary for ${salary.staffName || "Staff Member"}`,
          department: "Salaries & Wages"
        });
      });
      res.json(intelligenceData);
    } catch (error) {
      console.error("Error fetching finance intelligence data:", error);
      res.status(500).json({ message: "Failed to fetch finance intelligence data", error: error.message });
    }
  });
  app2.post("/api/finance-intelligence/ai-analysis", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const {
        totalRevenue,
        totalExpenses,
        netProfit: netProfit2,
        profitMargin: profitMargin2,
        departmentAnalysis: departmentAnalysis2,
        monthlyTrends,
        period
      } = req.body;
      console.log("Generating AI analysis for finance intelligence...");
      const openai3 = new (await import("openai")).default({
        apiKey: process.env.OPENAI_API_KEY
      });
      const analysisPrompt = `
You are a financial advisor AI analyzing business performance for a property management company. 

Financial Data:
- Total Revenue: ${totalRevenue} THB
- Total Expenses: ${totalExpenses} THB  
- Net Profit: ${netProfit2} THB
- Profit Margin: ${profitMargin2}%
- Period: ${period}

Department Breakdown:
${departmentAnalysis2.map(
        (dept) => `${dept.department}: Revenue ${dept.totalRevenue} THB, Expenses ${dept.totalExpenses} THB, Profit Margin ${dept.profitMargin}%`
      ).join("\n")}

Monthly Trends:
${monthlyTrends.map(
        (month) => `${month.month}: Revenue ${month.revenue} THB, Expenses ${month.expenses} THB, Profit ${month.profit} THB`
      ).join("\n")}

Please provide a JSON response with the following structure:
{
  "overallHealth": "excellent|good|warning|critical",
  "profitMargin": ${profitMargin2},
  "recommendations": ["recommendation1", "recommendation2", ...],
  "redFlags": ["flag1", "flag2", ...],
  "opportunities": ["opportunity1", "opportunity2", ...],
  "forecast": {
    "nextMonth": estimated_profit_next_month,
    "nextQuarter": estimated_profit_next_quarter,
    "confidence": confidence_percentage
  },
  "departmentInsights": [
    {
      "department": "department_name",
      "status": "profitable|concerning|loss",
      "insight": "detailed_insight",
      "action": "recommended_action"
    }
  ]
}

Focus on:
1. Cost optimization opportunities
2. Revenue growth potential
3. Department efficiency analysis
4. Cash flow improvements
5. Market positioning recommendations
6. Operational efficiency suggestions

Be specific and actionable in your recommendations.`;
      const response = await openai3.chat.completions.create({
        model: "gpt-4o",
        // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
        messages: [
          {
            role: "system",
            content: "You are a financial intelligence AI providing business analysis and recommendations. Always respond with valid JSON only."
          },
          {
            role: "user",
            content: analysisPrompt
          }
        ],
        response_format: { type: "json_object" },
        temperature: 0.7,
        max_tokens: 2e3
      });
      const aiAnalysis = JSON.parse(response.choices[0].message.content);
      console.log("AI Analysis generated:", aiAnalysis.overallHealth);
      res.json(aiAnalysis);
    } catch (error) {
      console.error("Error generating AI analysis:", error);
      const fallbackAnalysis = {
        overallHealth: netProfit > 0 ? "good" : "warning",
        profitMargin,
        recommendations: [
          "Review highest expense categories for cost reduction opportunities",
          "Increase revenue through premium service offerings",
          "Optimize staff allocation based on property occupancy",
          "Implement automated expense tracking for better visibility"
        ],
        redFlags: [
          netProfit < 0 ? "Negative profit margin requires immediate attention" : null,
          profitMargin < 10 ? "Profit margin below industry average" : null
        ].filter(Boolean),
        opportunities: [
          "Expand successful service offerings to underperforming properties",
          "Negotiate better rates with utility providers",
          "Implement energy-saving measures to reduce costs"
        ],
        forecast: {
          nextMonth: netProfit * 1.05,
          nextQuarter: netProfit * 3.1,
          confidence: 75
        },
        departmentInsights: departmentAnalysis.slice(0, 3).map((dept) => ({
          department: dept.department,
          status: dept.profit > 0 ? "profitable" : dept.profit < -1e3 ? "loss" : "concerning",
          insight: `${dept.department} shows ${dept.profitMargin > 0 ? "positive" : "negative"} margins`,
          action: dept.profitMargin < 0 ? "Review costs and pricing" : "Maintain current performance"
        }))
      };
      res.json(fallbackAnalysis);
    }
  });
  app2.post("/api/finance-intelligence/export", isDemoAuthenticated, async (req, res) => {
    try {
      const { period, includeAiAnalysis, data } = req.body;
      const reportData = {
        title: `Finance Intelligence Report - ${period}`,
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        summary: data.departmentAnalysis,
        aiInsights: includeAiAnalysis ? data.aiAnalysis : null
      };
      res.json({
        success: true,
        message: "Report generated successfully",
        data: reportData
      });
    } catch (error) {
      console.error("Error exporting finance report:", error);
      res.status(500).json({ message: "Failed to export report", error: error.message });
    }
  });
  app2.get("/api/staff-salaries/summary", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const demoSalaryData = [
        {
          id: 1,
          staffId: "staff-1",
          staffName: "Malee Kasem",
          department: "Housekeeping",
          monthlySalary: 15e3,
          currency: "THB",
          status: "active"
        },
        {
          id: 2,
          staffId: "staff-2",
          staffName: "Niran Thaksin",
          department: "Pool Service",
          monthlySalary: 12e3,
          currency: "THB",
          status: "active"
        },
        {
          id: 3,
          staffId: "staff-3",
          staffName: "Kamon Saetang",
          department: "Garden Service",
          monthlySalary: 11e3,
          currency: "THB",
          status: "active"
        }
      ];
      res.json(demoSalaryData);
    } catch (error) {
      console.error("Error fetching staff salary summary:", error);
      res.status(500).json({ message: "Failed to fetch salary data", error: error.message });
    }
  });
  app2.post("/api/ai-bot/query", isDemoAuthenticated, async (req, res) => {
    console.log("\u{1F916} AI Bot query endpoint hit");
    try {
      const { question } = req.body;
      const user = req.user;
      console.log("\u{1F464} User:", user?.id, "Role:", user?.role, "Org:", user?.organizationId);
      console.log("\u2753 Question:", question);
      if (!question) {
        console.warn("\u26A0\uFE0F No question provided in request");
        return res.status(400).json({ error: "Question is required" });
      }
      console.log("\u{1F4E6} Importing AI Bot Engine...");
      const { aiBotEngine: aiBotEngine2 } = await Promise.resolve().then(() => (init_ai_bot_engine(), ai_bot_engine_exports));
      const context = {
        organizationId: user.organizationId || "default-org",
        userRole: user.role || "admin",
        userId: user.id
      };
      console.log("\u{1F504} Processing query with context:", context);
      const response = await aiBotEngine2.processQuery(question, context);
      console.log("\u2705 AI Bot response generated, length:", response?.length || 0);
      res.json({
        response,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        context: context.organizationId
      });
    } catch (error) {
      console.error("\u274C AI Bot query error:", error);
      console.error("Stack:", error.stack);
      res.status(500).json({
        error: "Failed to process AI query",
        message: error.message
      });
    }
  });
  app2.get("/api/ai-bot/suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { aiBotEngine: aiBotEngine2 } = await Promise.resolve().then(() => (init_ai_bot_engine(), ai_bot_engine_exports));
      const context = {
        organizationId: user.organizationId || "default-org",
        userRole: user.role || "admin",
        userId: user.id
      };
      const suggestions = await aiBotEngine2.getSuggestedQuestions(context);
      res.json(suggestions);
    } catch (error) {
      console.error("AI Bot suggestions error:", error);
      res.status(500).json({
        error: "Failed to get suggestions",
        message: error.message
      });
    }
  });
  const { ultraFastCache: ultraFastCache2 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
  app2.use("/api/dashboard/stats", ultraFastCache2(30));
  app2.get("/api/health", (req, res) => {
    res.json({
      status: "healthy",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      environment: process.env.NODE_ENV || "development"
    });
  });
  app2.get("/api/auth/user", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
  const requireAdmin = (req, res, next) => {
    if (req.user?.role !== "admin") {
      return res.status(403).json({ message: "Admin access required" });
    }
    next();
  };
  app2.get("/api/admin/users", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const users3 = await storage.getUsers();
      const formattedUsers = users3.filter((user) => user.organizationId === organizationId2).map((user) => ({
        id: user.id,
        organizationId: user.organizationId,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
        isActive: user.isActive,
        lastLoginAt: user.lastLoginAt,
        createdAt: user.createdAt,
        // Add default permissions structure
        permissions: {
          listings: { view: false, edit: false, create: false, delete: false },
          reservations: { view: false, edit: false, create: false, delete: false },
          calendar: { view: false, edit: false, create: false, delete: false },
          financials: { view: false, edit: false, create: false, delete: false },
          ownerStatements: { view: false, edit: false, create: false, delete: false },
          tasks: { view: false, edit: false, create: false, delete: false },
          utilities: { view: false, edit: false, create: false, delete: false },
          adminAccess: user.role === "admin",
          financialDataAccess: ["admin", "portfolio-manager", "owner"].includes(user.role),
          otaPayoutDataOnly: ["owner", "retail-agent", "referral-agent"].includes(user.role)
        },
        listingsAccess: []
        // Will be enhanced later
      }));
      res.json(formattedUsers);
    } catch (error) {
      console.error("Error fetching users for access management:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });
  app2.put("/api/admin/users/:userId/permissions", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const { permissions, listingsAccess } = req.body;
      const { userId } = req.params;
      console.log(`Admin ${req.user.id} updated permissions for user ${userId}:`, {
        permissions,
        listingsAccess,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      res.json({
        success: true,
        message: "Permissions updated successfully",
        userId,
        permissions,
        listingsAccess
      });
    } catch (error) {
      console.error("Error updating user permissions:", error);
      res.status(500).json({ message: "Failed to update permissions" });
    }
  });
  const requirePortfolioManagerOrAdmin = (req, res, next) => {
    if (!["admin", "portfolio-manager"].includes(req.user?.role)) {
      return res.status(403).json({ message: "Portfolio Manager or Admin access required" });
    }
    next();
  };
  const requireStaffTaskPermission = (req, res, next) => {
    if (req.user?.role !== "staff") {
      return next();
    }
    const staffUserId = req.user.id;
    if (!staffPermissionStorage.canStaffCreateTasks(staffUserId)) {
      return res.status(403).json({
        message: "Task creation permission not granted. Contact your administrator to request permission."
      });
    }
    if (!staffPermissionStorage.canStaffCreateMoreTasks(staffUserId)) {
      const permissions = staffPermissionStorage.getStaffPermissions(staffUserId);
      return res.status(403).json({
        message: `Daily task limit reached (${permissions?.maxTasksPerDay} tasks per day). Try again tomorrow.`
      });
    }
    next();
  };
  app2.get("/api/user-management/users", isDemoAuthenticated, requirePortfolioManagerOrAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const filters = {
        search: req.query.search,
        role: req.query.role,
        propertyId: req.query.propertyId ? parseInt(req.query.propertyId) : void 0,
        isActive: req.query.isActive ? req.query.isActive === "true" : void 0,
        limit: req.query.limit ? parseInt(req.query.limit) : 50,
        offset: req.query.offset ? parseInt(req.query.offset) : 0
      };
      const users3 = await userMgmt.getAllUsers(filters);
      res.json(users3);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });
  app2.get("/api/user-management/users/:userId", isDemoAuthenticated, requirePortfolioManagerOrAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const user = await userMgmt.getUserById(req.params.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
  app2.put("/api/user-management/users/:userId/role", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const { primaryRole, subRole } = req.body;
      const userId = req.params.userId;
      const assignedBy = req.user.id;
      const existingUser = await userMgmt.getUserById(userId);
      if (!existingUser) {
        return res.status(404).json({ message: "User not found" });
      }
      let result;
      if (existingUser.userRole) {
        result = await userMgmt.updateUserRole(userId, { primaryRole, subRole, assignedBy });
      } else {
        result = await userMgmt.assignUserRole({ userId, primaryRole, subRole, assignedBy });
      }
      if (!result) {
        return res.status(500).json({ message: "Failed to update role" });
      }
      res.json(result);
    } catch (error) {
      console.error("Error updating user role:", error);
      res.status(500).json({ message: "Failed to update user role" });
    }
  });
  app2.put("/api/user-management/users/:userId/permissions", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const { moduleAccess } = req.body;
      const userId = req.params.userId;
      const updatedBy = req.user.id;
      const result = await userMgmt.updateUserPermissions(userId, moduleAccess, updatedBy);
      if (!result) {
        return res.status(500).json({ message: "Failed to update permissions" });
      }
      res.json(result);
    } catch (error) {
      console.error("Error updating user permissions:", error);
      res.status(500).json({ message: "Failed to update user permissions" });
    }
  });
  app2.put("/api/user-management/users/:userId/status", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const { isActive } = req.body;
      const userId = req.params.userId;
      const updatedBy = req.user.id;
      const success = await userMgmt.updateUserStatus(userId, isActive, updatedBy);
      if (!success) {
        return res.status(500).json({ message: "Failed to update user status" });
      }
      res.json({ success: true, message: `User ${isActive ? "activated" : "deactivated"} successfully` });
    } catch (error) {
      console.error("Error updating user status:", error);
      res.status(500).json({ message: "Failed to update user status" });
    }
  });
  app2.post("/api/user-management/users/:userId/properties", isDemoAuthenticated, requirePortfolioManagerOrAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const { propertyId, assignmentType, startDate, endDate } = req.body;
      const userId = req.params.userId;
      const assignedBy = req.user.id;
      const assignment = await userMgmt.assignUserToProperty({
        userId,
        propertyId,
        assignmentType,
        startDate: startDate || null,
        endDate: endDate || null,
        assignedBy
      });
      res.json(assignment);
    } catch (error) {
      console.error("Error assigning property to user:", error);
      res.status(500).json({ message: "Failed to assign property to user" });
    }
  });
  app2.delete("/api/user-management/users/:userId/properties/:propertyId", isDemoAuthenticated, requirePortfolioManagerOrAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const userId = req.params.userId;
      const propertyId = parseInt(req.params.propertyId);
      const success = await userMgmt.removeUserFromProperty(userId, propertyId);
      if (!success) {
        return res.status(500).json({ message: "Failed to remove property assignment" });
      }
      res.json({ success: true, message: "Property assignment removed successfully" });
    } catch (error) {
      console.error("Error removing property assignment:", error);
      res.status(500).json({ message: "Failed to remove property assignment" });
    }
  });
  app2.get("/api/user-management/users/:userId/activity", isDemoAuthenticated, requirePortfolioManagerOrAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const userId = req.params.userId;
      const limit = req.query.limit ? parseInt(req.query.limit) : 50;
      const activities = await userMgmt.getUserActivityHistory(userId, limit);
      res.json(activities);
    } catch (error) {
      console.error("Error fetching user activity:", error);
      res.status(500).json({ message: "Failed to fetch user activity" });
    }
  });
  app2.post("/api/user-management/invitations", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const { email, roleAssignment, subRoleAssignment, propertyAssignments, modulePermissions, expiresAt } = req.body;
      const invitedBy = req.user.id;
      const invitation = await userMgmt.createUserInvitation({
        email,
        roleAssignment,
        subRoleAssignment: subRoleAssignment || null,
        propertyAssignments: propertyAssignments || null,
        modulePermissions: modulePermissions || null,
        expiresAt: expiresAt ? new Date(expiresAt) : null,
        invitedBy
      });
      res.json(invitation);
    } catch (error) {
      console.error("Error sending invitation:", error);
      res.status(500).json({ message: "Failed to send invitation" });
    }
  });
  app2.get("/api/user-management/invitations", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const invitations = await userMgmt.getPendingInvitations();
      res.json(invitations);
    } catch (error) {
      console.error("Error fetching invitations:", error);
      res.status(500).json({ message: "Failed to fetch invitations" });
    }
  });
  app2.post("/api/user-management/invitations/:inviteCode/accept", async (req, res) => {
    try {
      const { inviteCode } = req.params;
      res.json({ message: "Invitation system ready - requires full authentication flow" });
    } catch (error) {
      console.error("Error accepting invitation:", error);
      res.status(500).json({ message: "Failed to accept invitation" });
    }
  });
  app2.get("/api/user-management/freelancer-requests", isDemoAuthenticated, requirePortfolioManagerOrAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const freelancerId = req.query.freelancerId;
      const status = req.query.status;
      const requests = await userMgmt.getFreelancerTaskRequests(freelancerId, status);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching freelancer requests:", error);
      res.status(500).json({ message: "Failed to fetch freelancer requests" });
    }
  });
  app2.post("/api/user-management/freelancer-requests", isDemoAuthenticated, requirePortfolioManagerOrAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const requestData = {
        ...req.body,
        requestedBy: req.user.id
      };
      const request = await userMgmt.createFreelancerTaskRequest(requestData);
      res.json(request);
    } catch (error) {
      console.error("Error creating freelancer request:", error);
      res.status(500).json({ message: "Failed to create freelancer request" });
    }
  });
  app2.put("/api/user-management/freelancer-requests/:requestId", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const requestId = parseInt(req.params.requestId);
      const updates = req.body;
      const request = await userMgmt.updateFreelancerTaskRequest(requestId, updates);
      if (!request) {
        return res.status(404).json({ message: "Request not found" });
      }
      res.json(request);
    } catch (error) {
      console.error("Error updating freelancer request:", error);
      res.status(500).json({ message: "Failed to update freelancer request" });
    }
  });
  app2.get("/api/user-management/freelancers/:freelancerId/availability", isDemoAuthenticated, requirePortfolioManagerOrAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const freelancerId = req.params.freelancerId;
      const startDate = req.query.startDate;
      const endDate = req.query.endDate;
      const availability = await userMgmt.getFreelancerAvailability(freelancerId, startDate, endDate);
      res.json(availability);
    } catch (error) {
      console.error("Error fetching freelancer availability:", error);
      res.status(500).json({ message: "Failed to fetch freelancer availability" });
    }
  });
  app2.post("/api/user-management/freelancers/:freelancerId/availability", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const freelancerId = req.params.freelancerId;
      if (req.user.id !== freelancerId && !["admin", "portfolio-manager"].includes(req.user.role)) {
        return res.status(403).json({ message: "Can only update your own availability" });
      }
      const availabilityData = {
        ...req.body,
        freelancerId
      };
      const availability = await userMgmt.updateFreelancerAvailability(availabilityData);
      res.json(availability);
    } catch (error) {
      console.error("Error updating freelancer availability:", error);
      res.status(500).json({ message: "Failed to update freelancer availability" });
    }
  });
  app2.get("/api/user-management/audit-log", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const limit = req.query.limit ? parseInt(req.query.limit) : 100;
      const activities = await userMgmt.getSystemActivityLog(limit);
      res.json(activities);
    } catch (error) {
      console.error("Error fetching audit log:", error);
      res.status(500).json({ message: "Failed to fetch audit log" });
    }
  });
  app2.get("/api/user-management/users/:userId/performance", isDemoAuthenticated, requirePortfolioManagerOrAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const userId = req.params.userId;
      const periodYear = req.query.year ? parseInt(req.query.year) : void 0;
      const periodMonth = req.query.month ? parseInt(req.query.month) : void 0;
      const metrics = await userMgmt.getUserPerformanceMetrics(userId, periodYear, periodMonth);
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching user performance:", error);
      res.status(500).json({ message: "Failed to fetch user performance" });
    }
  });
  app2.post("/api/user-management/users/:userId/performance", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const userMgmt = new UserManagementStorage(organizationId2);
      const userId = req.params.userId;
      const metricsData = {
        ...req.body,
        userId
      };
      const metrics = await userMgmt.updateUserPerformanceMetrics(metricsData);
      res.json(metrics);
    } catch (error) {
      console.error("Error updating user performance:", error);
      res.status(500).json({ message: "Failed to update user performance" });
    }
  });
  const { PropertyVisibilityStorage: PropertyVisibilityStorage2 } = await Promise.resolve().then(() => (init_propertyVisibilityStorage(), propertyVisibilityStorage_exports));
  app2.get("/api/property-visibility/access-matrix", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const { userId, propertyId, canView, canManage } = req.query;
      const accessMatrix = await propertyVisibility.getPropertyAccessControl({
        userId: userId || void 0,
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        canView: canView === "true" ? true : canView === "false" ? false : void 0,
        canManage: canManage === "true" ? true : canManage === "false" ? false : void 0
      });
      res.json(accessMatrix);
    } catch (error) {
      console.error("Error fetching access matrix:", error);
      res.status(500).json({ message: "Failed to fetch access matrix" });
    }
  });
  app2.get("/api/property-visibility/visibility-matrix", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const { userId, accessLevel, hasFullAccess } = req.query;
      const visibilityMatrix = await propertyVisibility.getVisibilityMatrix({
        userId: userId || void 0,
        accessLevel: accessLevel || void 0,
        hasFullAccess: hasFullAccess === "true" ? true : hasFullAccess === "false" ? false : void 0
      });
      res.json(visibilityMatrix);
    } catch (error) {
      console.error("Error fetching visibility matrix:", error);
      res.status(500).json({ message: "Failed to fetch visibility matrix" });
    }
  });
  app2.post("/api/property-visibility/access", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const accessData = {
        ...req.body,
        assignedBy: req.user.id
      };
      const accessRecord = await propertyVisibility.createPropertyAccess(accessData);
      res.status(201).json(accessRecord);
    } catch (error) {
      console.error("Error creating property access:", error);
      res.status(500).json({ message: "Failed to create property access" });
    }
  });
  app2.put("/api/property-visibility/access/:id", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const id = parseInt(req.params.id);
      const accessData = req.body;
      const accessRecord = await propertyVisibility.updatePropertyAccess(id, accessData);
      if (!accessRecord) {
        return res.status(404).json({ message: "Access record not found" });
      }
      res.json(accessRecord);
    } catch (error) {
      console.error("Error updating property access:", error);
      res.status(500).json({ message: "Failed to update property access" });
    }
  });
  app2.delete("/api/property-visibility/access/:id", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const id = parseInt(req.params.id);
      const success = await propertyVisibility.deletePropertyAccess(id);
      if (!success) {
        return res.status(404).json({ message: "Access record not found" });
      }
      res.json({ success: true, message: "Access record deleted successfully" });
    } catch (error) {
      console.error("Error deleting property access:", error);
      res.status(500).json({ message: "Failed to delete property access" });
    }
  });
  app2.put("/api/property-visibility/users/:userId/bulk-access", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const userId = req.params.userId;
      const { propertyIds, accessData } = req.body;
      const accessRecords = await propertyVisibility.bulkUpdatePropertyAccess(
        userId,
        propertyIds,
        { ...accessData, assignedBy: req.user.id }
      );
      res.json(accessRecords);
    } catch (error) {
      console.error("Error bulk updating property access:", error);
      res.status(500).json({ message: "Failed to bulk update property access" });
    }
  });
  app2.get("/api/property-visibility/templates", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const { targetRole } = req.query;
      const templates = await propertyVisibility.getAccessTemplates(targetRole || void 0);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching access templates:", error);
      res.status(500).json({ message: "Failed to fetch access templates" });
    }
  });
  app2.post("/api/property-visibility/templates", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const templateData = {
        ...req.body,
        createdBy: req.user.id
      };
      const template = await propertyVisibility.createAccessTemplate(templateData);
      res.status(201).json(template);
    } catch (error) {
      console.error("Error creating access template:", error);
      res.status(500).json({ message: "Failed to create access template" });
    }
  });
  app2.post("/api/property-visibility/templates/:templateId/apply", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const templateId = parseInt(req.params.templateId);
      const { userId, propertyIds } = req.body;
      const accessRecords = await propertyVisibility.applyTemplateToUser(templateId, userId, propertyIds);
      res.json(accessRecords);
    } catch (error) {
      console.error("Error applying template:", error);
      res.status(500).json({ message: "Failed to apply template" });
    }
  });
  app2.get("/api/property-visibility/session-permissions", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const userId = req.user.id;
      const sessionId = req.headers["x-session-id"] || void 0;
      const sessionPermissions = await propertyVisibility.getUserSessionPermissions(userId, sessionId);
      res.json(sessionPermissions);
    } catch (error) {
      console.error("Error fetching session permissions:", error);
      res.status(500).json({ message: "Failed to fetch session permissions" });
    }
  });
  app2.post("/api/property-visibility/sync-session", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const userId = req.user.id;
      const sessionId = req.headers["x-session-id"] || `session-${Date.now()}`;
      const sessionPermissions = await propertyVisibility.syncUserSessionPermissions(userId, sessionId);
      res.json(sessionPermissions);
    } catch (error) {
      console.error("Error syncing session permissions:", error);
      res.status(500).json({ message: "Failed to sync session permissions" });
    }
  });
  app2.get("/api/property-visibility/demo/visibility-matrix", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const demoMatrix = await propertyVisibility.getDemoVisibilityMatrix();
      res.json(demoMatrix);
    } catch (error) {
      console.error("Error fetching demo visibility matrix:", error);
      res.status(500).json({ message: "Failed to fetch demo visibility matrix" });
    }
  });
  app2.get("/api/property-visibility/demo/access-matrix", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const demoAccess = await propertyVisibility.getDemoPropertyAccess();
      res.json(demoAccess);
    } catch (error) {
      console.error("Error fetching demo access matrix:", error);
      res.status(500).json({ message: "Failed to fetch demo access matrix" });
    }
  });
  app2.get("/api/property-visibility/demo/templates", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const propertyVisibility = new PropertyVisibilityStorage2(organizationId2);
      const demoTemplates = await propertyVisibility.getDemoAccessTemplates();
      res.json(demoTemplates);
    } catch (error) {
      console.error("Error fetching demo templates:", error);
      res.status(500).json({ message: "Failed to fetch demo templates" });
    }
  });
  app2.get("/api/properties", isDemoAuthenticated, async (req, res) => {
    try {
      console.log("\u{1F3E0} GET /api/properties - Fetching properties with stats...");
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      clearCache2("properties");
      const orgId = req.user?.organizationId || "default-org";
      const source = req.query.source;
      const [allProperties, allBookings, allTasks] = await Promise.all([
        storage.getProperties(source),
        storage.getBookings(orgId),
        storage.getTasks()
      ]);
      const now = /* @__PURE__ */ new Date();
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
      const enhancedProperties = allProperties.map((property) => {
        const propertyBookings = allBookings.filter((b) => b.propertyId === property.id && b.status !== "cancelled");
        const lastBookingDate = propertyBookings.length > 0 ? propertyBookings.filter((b) => b.checkOut).sort((a, b) => new Date(b.checkOut).getTime() - new Date(a.checkOut).getTime())[0]?.checkOut || null : null;
        const monthlyRevenue = propertyBookings.filter((b) => {
          const checkIn = new Date(b.checkIn);
          return checkIn >= startOfMonth && checkIn <= endOfMonth;
        }).reduce((sum4, b) => sum4 + parseFloat(b.platformPayout || b.totalAmount || "0"), 0);
        const daysInMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
        let occupiedDays = 0;
        propertyBookings.forEach((booking) => {
          const checkIn = new Date(booking.checkIn);
          const checkOut = new Date(booking.checkOut);
          const rangeStart = checkIn < startOfMonth ? startOfMonth : checkIn;
          const rangeEnd = checkOut > endOfMonth ? endOfMonth : checkOut;
          if (rangeStart <= rangeEnd && rangeStart <= endOfMonth && rangeEnd >= startOfMonth) {
            const days = Math.ceil((rangeEnd.getTime() - rangeStart.getTime()) / (1e3 * 60 * 60 * 24));
            occupiedDays += days;
          }
        });
        const occupancyRate = Math.min(100, Math.round(occupiedDays / daysInMonth * 100));
        const propertyTasks = allTasks.filter(
          (t) => t.propertyId === property.id && (t.status === "pending" || t.status === "in-progress")
        );
        const maintenanceTasks = propertyTasks.length;
        const highPriorityTasks = propertyTasks.filter(
          (t) => t.priority === "high" || t.priority === "urgent"
        ).length;
        const recentAssignedTask = propertyTasks.filter((t) => t.assignedTo).sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())[0];
        const taskAssignee = recentAssignedTask?.assignedTo || null;
        const totalAssignedTasks = propertyTasks.filter((t) => t.assignedTo).length;
        return {
          ...property,
          lastBookingDate,
          monthlyRevenue,
          occupancyRate,
          maintenanceTasks,
          highPriorityTasks,
          taskAssignee,
          totalAssignedTasks,
          maintenanceCosts: 0,
          roi: 0
        };
      });
      console.log(`\u{1F3E0} Enhanced ${enhancedProperties.length} properties with booking stats`);
      res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
      res.setHeader("Pragma", "no-cache");
      res.setHeader("Expires", "0");
      console.log(`\u{1F3E0} Enhanced ${enhancedProperties.length} properties with booking stats`);
      res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
      res.setHeader("Pragma", "no-cache");
      res.setHeader("Expires", "0");
      res.json(enhancedProperties);
    } catch (error) {
      console.error("\u274C Error fetching properties:", error);
      res.status(500).json({ message: "Failed to fetch properties" });
    }
  });
  app2.get("/api/properties/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const property = await storage.getProperty(id);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }
      res.json(property);
    } catch (error) {
      console.error("Error fetching property:", error);
      res.status(500).json({ message: "Failed to fetch property" });
    }
  });
  app2.post("/api/properties", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const organizationId2 = req.user.organizationId || "default-org";
      console.log("=== PROPERTY CREATION DEBUG ===");
      console.log("User ID:", userId);
      console.log("Organization ID:", organizationId2);
      console.log("Request body:", req.body);
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      clearCache2("properties");
      const propertyData = {
        organizationId: organizationId2,
        name: req.body.name,
        address: req.body.address,
        description: req.body.description || "",
        bedrooms: req.body.bedrooms ? parseInt(req.body.bedrooms) : null,
        bathrooms: req.body.bathrooms ? parseInt(req.body.bathrooms) : null,
        maxGuests: req.body.maxGuests ? parseInt(req.body.maxGuests) : null,
        pricePerNight: req.body.pricePerNight ? parseFloat(req.body.pricePerNight) : null,
        currency: req.body.currency || "THB",
        status: req.body.status || "active",
        amenities: req.body.amenities || [],
        images: req.body.images || [],
        ownerId: userId
      };
      console.log("Final property data:", propertyData);
      const property = await storage.createProperty(propertyData);
      console.log("Created property:", property);
      res.status(201).json(property);
    } catch (error) {
      console.error("=== PROPERTY CREATION FAILED ===");
      console.error("Error:", error);
      console.error("Stack:", error.stack);
      res.status(500).json({ message: "Failed to create property", details: error.message });
    }
  });
  app2.put("/api/properties/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const propertyData = req.body;
      const property = await storage.updateProperty(id, propertyData);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }
      res.json(property);
    } catch (error) {
      console.error("Error updating property:", error);
      res.status(500).json({ message: "Failed to update property" });
    }
  });
  app2.delete("/api/properties/:id", isDemoAuthenticated, async (req, res) => {
    const id = parseInt(req.params.id);
    try {
      console.log(`\u{1F5D1}\uFE0F DELETE request for property ${id}`);
      const success = await storage.deleteProperty(id);
      if (!success) {
        console.log(`\u274C Property ${id} not found`);
        return res.status(404).json({ message: "Property not found" });
      }
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      clearCache2("properties");
      console.log(`\u2705 Successfully deleted property ${id}`);
      res.status(204).send();
    } catch (error) {
      console.error(`\u274C Error deleting property ${id}:`, error);
      console.error("Error message:", error.message);
      console.error("Error details:", error.detail || error.toString());
      console.error("Error stack:", error.stack);
      res.status(500).json({
        message: "Failed to delete property",
        error: error.message,
        details: error.detail || error.toString()
      });
    }
  });
  app2.get("/api/tasks", isDemoAuthenticated, async (req, res) => {
    const { sendCachedOrFetch: sendCachedOrFetch2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
    const userId = req.user.id;
    const user = req.user;
    const { due_from, due_to } = req.query;
    const cacheKey = `tasks-${user?.role}-${userId}${due_from ? `-from-${due_from}` : ""}${due_to ? `-to-${due_to}` : ""}`;
    return sendCachedOrFetch2(
      cacheKey,
      async () => {
        let tasks2;
        if (user?.role === "staff") {
          tasks2 = await storage.getTasksByAssignee(userId, due_from, due_to);
        } else {
          tasks2 = await storage.getTasks(due_from, due_to);
        }
        tasks2.sort((a, b) => {
          if (a.dueDate === null && b.dueDate === null) return 0;
          if (a.dueDate === null) return 1;
          if (b.dueDate === null) return -1;
          return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime();
        });
        return tasks2;
      },
      res,
      5
      // 5 minute cache for tasks
    );
  });
  app2.post("/api/tasks", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = req.user;
      console.log("=== URGENT TASK CREATION DEBUG ===");
      console.log("User:", userId);
      console.log("Request body:", req.body);
      const assignmentValue = req.body.assignedTo;
      let assignedTo = null;
      let assignedToStaffId = null;
      if (assignmentValue && assignmentValue !== "unassigned") {
        if (assignmentValue.startsWith("staff-")) {
          assignedToStaffId = parseInt(assignmentValue.replace("staff-", ""));
        } else {
          assignedTo = assignmentValue;
        }
      }
      const taskData = {
        organizationId: req.user?.organizationId || "default-org",
        createdBy: userId,
        title: req.body.title || "",
        description: req.body.description || "",
        type: req.body.type || "maintenance",
        priority: req.body.priority || "medium",
        status: "pending",
        propertyId: req.body.propertyId ? parseInt(req.body.propertyId) : null,
        assignedTo,
        assignedToStaffId,
        dueDate: req.body.dueDate ? new Date(req.body.dueDate) : null,
        estimatedCost: req.body.estimatedCost ? parseFloat(req.body.estimatedCost) : null,
        department: req.body.department || null
      };
      console.log("Final task data:", taskData);
      if (!taskData.title || taskData.title.trim() === "") {
        return res.status(400).json({
          message: "Invalid task data",
          errors: [{ path: ["title"], message: "Title is required" }]
        });
      }
      const task = await storage.createTask(taskData);
      console.log("Created task:", task);
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      const { clearUltraFastCache: clearUltraFastCache2 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
      clearCache2("tasks");
      clearCache2("properties");
      clearUltraFastCache2("/api/tasks");
      clearUltraFastCache2("/api/properties");
      clearUltraFastCache2("/api/dashboard");
      console.log("\u2705 All caches (tasks + properties) cleared after creating task ID", task.id);
      if (task.assignedTo && task.assignedTo !== userId) {
        try {
          await storage.notifyTaskAssignment(task.id, task.assignedTo, userId);
        } catch (notifyError) {
          console.log("Notification sending failed, but task created successfully");
        }
      }
      res.status(201).json(task);
    } catch (error) {
      console.error("=== TASK CREATION FAILED ===");
      console.error("Error:", error);
      console.error("Stack:", error.stack);
      res.status(500).json({ message: "Failed to create task", details: error.message });
    }
  });
  app2.put("/api/tasks/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const taskData = req.body;
      const userData = req.user;
      const userId = userData?.claims?.sub || userData?.id;
      if (taskData.dueDate && typeof taskData.dueDate === "string") {
        taskData.dueDate = new Date(taskData.dueDate);
      }
      const task = await storage.updateTask(id, taskData);
      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      const { clearUltraFastCache: clearUltraFastCache2 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
      clearCache2("tasks");
      clearCache2("properties");
      clearUltraFastCache2("tasks");
      clearUltraFastCache2("/api/tasks");
      clearUltraFastCache2("/api/properties");
      clearUltraFastCache2("/api/dashboard");
      if (taskData.status === "completed" && task.evidencePhotos && task.evidencePhotos.length > 0) {
        try {
          const { finances: finances3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          if (task.financeRecordId) {
            await db.update(finances3).set({
              attachments: task.evidencePhotos
            }).where(eq10(finances3.id, task.financeRecordId));
            console.log(`\u2705 Updated finance record ${task.financeRecordId} with ${task.evidencePhotos.length} evidence photos`);
            const { clearCache: clearCache3 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
            const { clearUltraFastCache: clearUltraFastCache3 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
            clearCache3("finances");
            clearUltraFastCache3("/api/finance");
          }
        } catch (error) {
          console.error("\u274C Error updating finance record with evidence:", error);
        }
      }
      if ((taskData.status === "completed" || taskData.status === "approved") && userId) {
        try {
          const organizationId2 = userData?.organizationId || "default-org";
          let [userStats] = await db.select().from(userGameStats).where(and11(
            eq10(userGameStats.userId, userId),
            eq10(userGameStats.organizationId, organizationId2)
          ));
          if (!userStats) {
            [userStats] = await db.insert(userGameStats).values({
              userId,
              organizationId: organizationId2,
              totalPoints: 0,
              level: 1,
              currentStreak: 0,
              longestStreak: 0,
              tasksCompleted: 0,
              bookingsProcessed: 0,
              propertiesManaged: 0
            }).returning();
          }
          const { tasks: tasksTable, properties: properties2, bookings: bookings3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const { sql: sql13 } = await import("drizzle-orm");
          const [taskStats] = await db.select({ count: sql13`COUNT(*)` }).from(tasksTable).where(and11(
            eq10(tasksTable.organizationId, organizationId2),
            eq10(tasksTable.status, "completed")
          ));
          console.log("\u{1F50D} Task stats query result:", taskStats);
          const [propertyStats] = await db.select({ count: sql13`COUNT(*)` }).from(properties2).where(and11(
            eq10(properties2.organizationId, organizationId2),
            eq10(properties2.ownerId, userId)
          ));
          const [bookingStats] = await db.select({ count: sql13`COUNT(DISTINCT ${bookings3.id})` }).from(bookings3).innerJoin(properties2, eq10(bookings3.propertyId, properties2.id)).where(and11(
            eq10(bookings3.organizationId, organizationId2),
            eq10(properties2.ownerId, userId)
          ));
          const tasksCompleted = Number(taskStats?.count || 0);
          console.log("\u{1F50D} Calculated tasksCompleted:", tasksCompleted, "from raw count:", taskStats?.count);
          const bookingsProcessed = Number(bookingStats?.count || 0);
          const propertiesManaged = Number(propertyStats?.count || 0);
          const totalPoints = tasksCompleted * 10 + bookingsProcessed * 25 + propertiesManaged * 50;
          const level = Math.floor(Math.log2(totalPoints / 100 + 1)) + 1;
          await db.update(userGameStats).set({
            tasksCompleted,
            bookingsProcessed,
            propertiesManaged,
            totalPoints,
            level,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq10(userGameStats.id, userStats.id));
          const allAchievements = await db.select().from(achievements).where(eq10(achievements.organizationId, organizationId2));
          for (const achievement of allAchievements) {
            const alreadyEarned = await db.select().from(userAchievements).where(and11(
              eq10(userAchievements.userId, userId),
              eq10(userAchievements.achievementId, achievement.id)
            ));
            if (alreadyEarned.length === 0) {
              let earned = false;
              if (achievement.type === "task" && tasksCompleted >= achievement.threshold) {
                earned = true;
              } else if (achievement.type === "booking" && bookingsProcessed >= achievement.threshold) {
                earned = true;
              } else if (achievement.type === "property" && propertiesManaged >= achievement.threshold) {
                earned = true;
              }
              if (earned) {
                await db.insert(userAchievements).values({
                  userId,
                  achievementId: achievement.id,
                  organizationId: organizationId2,
                  earnedAt: /* @__PURE__ */ new Date()
                });
              }
            }
          }
          console.log(`\u2705 Achievement check completed for user ${userId}: ${tasksCompleted} tasks completed`);
        } catch (achievementError) {
          console.error("Achievement check failed:", achievementError);
        }
      }
      const taskCost = task.actualCost || task.estimatedCost;
      if ((taskData.status === "completed" || taskData.status === "approved") && taskCost && parseFloat(String(taskCost)) > 0) {
        try {
          const organizationId2 = userData?.organizationId || "default-org";
          const costAmount = parseFloat(String(taskCost));
          console.log(`\u{1F4B0} Auto-creating finance record for completed task ${task.id} with cost ${costAmount} (actual: ${task.actualCost}, estimated: ${task.estimatedCost})`);
          const financeRecord = await storage.createFinance({
            organizationId: organizationId2,
            propertyId: task.propertyId,
            type: "expense",
            source: "company-expense",
            category: task.type || "maintenance",
            // Use task type as category
            subcategory: task.department || null,
            amount: String(costAmount),
            currency: task.currency || "THB",
            // Use task's currency instead of defaulting to USD
            description: `Task: ${task.title}${task.completionNotes ? " - " + task.completionNotes : ""}`,
            date: task.completedAt || /* @__PURE__ */ new Date(),
            status: "paid",
            department: task.department || "maintenance",
            costCenter: "property-level",
            budgetCategory: "operational",
            businessUnit: "property-operations",
            referenceNumber: `TASK-${task.id}`,
            notes: task.evidencePhotos && task.evidencePhotos.length > 0 ? `Completed with ${task.evidencePhotos.length} evidence photo(s)` : "Task completed",
            attachments: task.evidencePhotos || []
          });
          if (financeRecord && financeRecord.id) {
            await storage.updateTask(id, { financeRecordId: financeRecord.id });
            task.financeRecordId = financeRecord.id;
            console.log(`\u{1F517} Linked finance record ${financeRecord.id} to task ${task.id}`);
          }
          const { clearCache: clearCache3 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
          const { clearUltraFastCache: clearUltraFastCache3 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
          clearCache3("finance");
          clearCache3("finances");
          clearUltraFastCache3("/api/finance");
          clearUltraFastCache3("/api/finance/analytics");
          clearUltraFastCache3("/api/finances");
          clearUltraFastCache3("/api/dashboard");
          console.log(`\u2705 Finance record auto-created for task ${task.id} with ${task.actualCost ? "actual" : "estimated"} cost of ${costAmount}`);
        } catch (financeError) {
          console.error("Failed to auto-create finance record:", financeError);
        }
      }
      res.json(task);
    } catch (error) {
      console.error("Error updating task:", error);
      res.status(500).json({ message: "Failed to update task" });
    }
  });
  app2.patch("/api/tasks/:id/complete", isDemoAuthenticated, async (req, res) => {
    try {
      const userData = req.user;
      const id = parseInt(req.params.id);
      const { evidencePhotos = [], issuesFound = [], notes } = req.body;
      const task = await storage.completeTask(id, userData.claims.sub, evidencePhotos, issuesFound, notes);
      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      const { clearUltraFastCache: clearUltraFastCache2 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
      clearCache2("tasks");
      clearCache2("properties");
      clearUltraFastCache2("tasks");
      clearUltraFastCache2("/api/tasks");
      clearUltraFastCache2("/api/properties");
      clearUltraFastCache2("/api/dashboard");
      res.json(task);
    } catch (error) {
      console.error("Error completing task:", error);
      res.status(500).json({ message: "Failed to complete task" });
    }
  });
  app2.patch("/api/tasks/:id/skip", isDemoAuthenticated, async (req, res) => {
    try {
      const userData = req.user;
      const id = parseInt(req.params.id);
      const { reason } = req.body;
      if (!reason) {
        return res.status(400).json({ message: "Skip reason is required" });
      }
      const task = await storage.skipTask(id, userData.claims.sub, reason);
      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      const { clearUltraFastCache: clearUltraFastCache2 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
      clearCache2("tasks");
      clearCache2("properties");
      clearUltraFastCache2("tasks");
      clearUltraFastCache2("/api/tasks");
      clearUltraFastCache2("/api/properties");
      clearUltraFastCache2("/api/dashboard");
      res.json(task);
    } catch (error) {
      console.error("Error skipping task:", error);
      res.status(500).json({ message: "Failed to skip task" });
    }
  });
  app2.patch("/api/tasks/:id/reschedule", isDemoAuthenticated, async (req, res) => {
    try {
      const userData = req.user;
      const id = parseInt(req.params.id);
      const { newDate, reason } = req.body;
      if (!newDate || !reason) {
        return res.status(400).json({ message: "New date and reason are required" });
      }
      const task = await storage.rescheduleTask(id, userData.claims.sub, new Date(newDate), reason);
      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      const { clearUltraFastCache: clearUltraFastCache2 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
      clearCache2("tasks");
      clearCache2("properties");
      clearUltraFastCache2("tasks");
      clearUltraFastCache2("/api/tasks");
      clearUltraFastCache2("/api/properties");
      clearUltraFastCache2("/api/dashboard");
      res.json(task);
    } catch (error) {
      console.error("Error rescheduling task:", error);
      res.status(500).json({ message: "Failed to reschedule task" });
    }
  });
  app2.patch("/api/tasks/:id/start", isDemoAuthenticated, async (req, res) => {
    try {
      const userData = req.user;
      const id = parseInt(req.params.id);
      const task = await storage.startTask(id, userData.claims.sub);
      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      const { clearUltraFastCache: clearUltraFastCache2 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
      clearCache2("tasks");
      clearCache2("properties");
      clearUltraFastCache2("tasks");
      clearUltraFastCache2("/api/tasks");
      clearUltraFastCache2("/api/properties");
      clearUltraFastCache2("/api/dashboard");
      res.json(task);
    } catch (error) {
      console.error("Error starting task:", error);
      res.status(500).json({ message: "Failed to start task" });
    }
  });
  app2.get("/api/tasks/:id/history", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const history = await storage.getTaskHistory(id);
      res.json(history);
    } catch (error) {
      console.error("Error fetching task history:", error);
      res.status(500).json({ message: "Failed to fetch task history" });
    }
  });
  app2.get("/api/properties/:id/task-history", isDemoAuthenticated, async (req, res) => {
    try {
      const propertyId = parseInt(req.params.id);
      const history = await storage.getTaskHistoryByProperty(propertyId);
      res.json(history);
    } catch (error) {
      console.error("Error fetching property task history:", error);
      res.status(500).json({ message: "Failed to fetch property task history" });
    }
  });
  app2.get("/api/bookings", isDemoAuthenticated, async (req, res) => {
    const { sendCachedOrFetch: sendCachedOrFetch2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
    const organizationId2 = req.user?.organizationId || "default-org";
    const source = req.query.source;
    const cacheKey = source ? `bookings-${organizationId2}-${source}` : `bookings-${organizationId2}`;
    return sendCachedOrFetch2(
      cacheKey,
      () => storage.getBookings(organizationId2, source),
      res,
      10
      // 10 minute cache for bookings
    );
  });
  app2.get("/api/bookings/with-source", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId } = req.query;
      const bookings3 = await storage.getBookingsWithSource(
        organizationId2,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(bookings3);
    } catch (error) {
      console.error("Error fetching bookings with source:", error);
      res.status(500).json({ message: "Failed to fetch bookings with source information" });
    }
  });
  app2.post("/api/bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const bookingData = insertBookingSchema.parse({
        ...req.body,
        organizationId: organizationId2,
        status: req.body.status || "pending"
      });
      const totalAmount = parseFloat(bookingData.totalAmount || "0");
      const amountPaid = parseFloat(bookingData.amountPaid || "0");
      if (isNaN(totalAmount) || !isFinite(totalAmount)) {
        return res.status(400).json({
          message: "Total amount must be a valid number"
        });
      }
      if (isNaN(amountPaid) || !isFinite(amountPaid)) {
        return res.status(400).json({
          message: "Amount paid must be a valid number"
        });
      }
      if (totalAmount < 0) {
        return res.status(400).json({
          message: "Total amount cannot be negative"
        });
      }
      if (amountPaid < 0) {
        return res.status(400).json({
          message: "Amount paid cannot be negative"
        });
      }
      if (amountPaid > totalAmount) {
        return res.status(400).json({
          message: "Amount paid cannot exceed total amount"
        });
      }
      bookingData.totalAmount = totalAmount.toFixed(2);
      bookingData.amountPaid = amountPaid.toFixed(2);
      bookingData.amountDue = Math.max(0, totalAmount - amountPaid).toFixed(2);
      const booking = await storage.createBooking(bookingData);
      if (booking.amountPaid && parseFloat(booking.amountPaid.toString()) > 0) {
        try {
          const financeData = insertFinanceSchema.parse({
            organizationId: booking.organizationId,
            propertyId: booking.propertyId,
            bookingId: booking.id,
            type: "income",
            source: "guest-payment",
            category: "Booking Payment",
            department: "front-office",
            amount: booking.amountPaid,
            currency: booking.currency || "USD",
            description: `Payment from ${booking.guestName} (Booking #${booking.id})`,
            date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
            status: booking.paymentStatus === "paid" ? "completed" : "pending",
            referenceNumber: `BOOKING-${booking.id}`
          });
          await storage.createFinance(financeData);
          console.log(`\u{1F4B0} Finance income record created for booking #${booking.id}, amount: ${booking.amountPaid}`);
        } catch (financeError) {
          console.error("Error creating finance record for booking payment:", financeError);
        }
      }
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      const { clearUltraFastCache: clearUltraFastCache2 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
      console.log(`\u{1F5D1}\uFE0F Clearing bookings cache for organizationId: ${organizationId2}`);
      clearCache2("bookings");
      clearCache2("properties");
      if (booking.amountPaid && parseFloat(booking.amountPaid.toString()) > 0) {
        clearCache2("finance");
        clearCache2("finances");
        clearUltraFastCache2("/api/finance");
        clearUltraFastCache2("/api/finance/analytics");
        clearUltraFastCache2("/api/finances");
        clearUltraFastCache2("/api/dashboard");
        console.log(`\u{1F4B3} Finance caches cleared after booking payment tracking`);
      }
      console.log(`\u2705 Bookings cache cleared after creating booking ID ${booking.id}`);
      res.status(201).json(booking);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        console.error("Booking validation errors:", error.errors);
        return res.status(400).json({
          message: "Invalid booking data",
          errors: error.errors.map((err) => ({
            field: err.path.join("."),
            message: err.message
          }))
        });
      }
      console.error("Error creating booking:", error);
      res.status(500).json({ message: "Failed to create booking" });
    }
  });
  app2.get("/api/bookings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const bookingId = parseInt(req.params.id);
      if (isNaN(bookingId)) {
        return res.status(400).json({ message: "Invalid booking ID" });
      }
      const booking = await storage.getBooking(bookingId);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      if (booking.organizationId !== organizationId2) {
        return res.status(403).json({ message: "Unauthorized to access this booking" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error fetching booking:", error);
      res.status(500).json({ message: "Failed to fetch booking" });
    }
  });
  app2.patch("/api/bookings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const bookingId = parseInt(req.params.id);
      if (isNaN(bookingId)) {
        return res.status(400).json({ message: "Invalid booking ID" });
      }
      const booking = await storage.getBooking(bookingId);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      if (booking.organizationId !== organizationId2) {
        return res.status(403).json({ message: "Unauthorized to update this booking" });
      }
      const isPaymentUpdate = req.body.amountPaid !== void 0;
      const oldAmountPaid = parseFloat(booking.amountPaid?.toString() || "0");
      if (isPaymentUpdate) {
        const totalAmount = parseFloat(req.body.totalAmount?.toString() || booking.totalAmount?.toString() || "0");
        const newAmountPaid = parseFloat(req.body.amountPaid?.toString() || "0");
        if (isNaN(newAmountPaid) || !isFinite(newAmountPaid)) {
          return res.status(400).json({
            message: "Amount paid must be a valid number"
          });
        }
        if (newAmountPaid < 0) {
          return res.status(400).json({
            message: "Amount paid cannot be negative"
          });
        }
        if (newAmountPaid > totalAmount) {
          return res.status(400).json({
            message: "Amount paid cannot exceed total amount"
          });
        }
        if (newAmountPaid === 0) {
          req.body.paymentStatus = "pending";
        } else if (newAmountPaid >= totalAmount) {
          req.body.paymentStatus = "paid";
        } else {
          req.body.paymentStatus = "partial";
        }
        req.body.amountDue = Math.max(0, totalAmount - newAmountPaid).toFixed(2);
      }
      const updatedBooking = await storage.updateBooking(bookingId, req.body);
      if (isPaymentUpdate && updatedBooking) {
        const newAmountPaid = parseFloat(updatedBooking.amountPaid?.toString() || "0");
        try {
          const allFinances = await storage.getFinances();
          const existingFinanceRecord = allFinances.find(
            (f) => f.bookingId === bookingId && f.source === "guest-payment"
          );
          if (newAmountPaid > 0) {
            const financeData = {
              organizationId: updatedBooking.organizationId,
              propertyId: updatedBooking.propertyId,
              bookingId: updatedBooking.id,
              type: "income",
              source: "guest-payment",
              category: "Booking Payment",
              department: "front-office",
              amount: updatedBooking.amountPaid,
              currency: updatedBooking.currency || "USD",
              description: `Payment from ${updatedBooking.guestName} (Booking #${updatedBooking.id})`,
              date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
              status: updatedBooking.paymentStatus === "paid" ? "completed" : "pending",
              referenceNumber: `BOOKING-${updatedBooking.id}`
            };
            if (existingFinanceRecord) {
              await storage.updateFinance(existingFinanceRecord.id, financeData);
              console.log(`\u{1F4B0} Finance income record updated for booking #${updatedBooking.id}, amount: ${updatedBooking.amountPaid}`);
            } else {
              await storage.createFinance(financeData);
              console.log(`\u{1F4B0} Finance income record created for booking #${updatedBooking.id}, amount: ${updatedBooking.amountPaid}`);
            }
          } else if (existingFinanceRecord && newAmountPaid === 0) {
            await storage.updateFinance(existingFinanceRecord.id, {
              amount: "0",
              status: "pending"
            });
            console.log(`\u{1F4B0} Finance income record updated to 0 for booking #${updatedBooking.id}`);
          }
        } catch (financeError) {
          console.error("Error creating/updating finance record for booking payment:", financeError);
        }
      }
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      const { clearUltraFastCache: clearUltraFastCache2 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
      console.log(`\u{1F5D1}\uFE0F Clearing bookings cache for organizationId: ${organizationId2}`);
      clearCache2("properties");
      clearCache2("bookings");
      if (isPaymentUpdate) {
        clearCache2("finance");
        clearCache2("finances");
        clearUltraFastCache2("/api/finance");
        clearUltraFastCache2("/api/finance/analytics");
        clearUltraFastCache2("/api/finances");
        clearUltraFastCache2("/api/dashboard");
        console.log(`\u{1F4B3} Finance caches cleared after booking payment update`);
        try {
          await fetch(`${process.env.REPL_ID ? "https://" + process.env.REPL_SLUG + "." + process.env.REPL_OWNER + ".repl.co" : "http://localhost:5000"}/api/finance/ultra-fast`).catch(() => {
          });
          await fetch(`${process.env.REPL_ID ? "https://" + process.env.REPL_SLUG + "." + process.env.REPL_OWNER + ".repl.co" : "http://localhost:5000"}/api/finance/analytics/ultra-fast`).catch(() => {
          });
        } catch (fetchError) {
        }
      }
      console.log(`\u2705 Booking #${bookingId} updated successfully`);
      res.json(updatedBooking);
    } catch (error) {
      console.error("Error updating booking:", error);
      res.status(500).json({ message: "Failed to update booking" });
    }
  });
  app2.get("/api/bookings/:id/invoice", async (req, res) => {
    try {
      const bookingId = parseInt(req.params.id);
      if (isNaN(bookingId)) {
        return res.status(400).send("<h1>Invalid booking ID</h1>");
      }
      const booking = await storage.getBooking(bookingId);
      if (!booking) {
        return res.status(404).send("<h1>Booking not found</h1>");
      }
      const property = await storage.getProperty(booking.propertyId);
      const propertyName = property?.name || "Unknown Property";
      const invoiceHTML = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Invoice - Booking #${booking.id}</title>
          <style>
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
              line-height: 1.6;
              color: #333;
              max-width: 800px;
              margin: 0 auto;
              padding: 20px;
              background: #f5f5f5;
            }
            .invoice-container {
              background: white;
              padding: 40px;
              border-radius: 8px;
              box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .header {
              border-bottom: 3px solid #2563eb;
              padding-bottom: 20px;
              margin-bottom: 30px;
            }
            .header h1 {
              margin: 0;
              color: #2563eb;
              font-size: 28px;
            }
            .header p {
              margin: 5px 0 0 0;
              color: #666;
            }
            .info-section {
              margin-bottom: 30px;
            }
            .info-section h2 {
              color: #2563eb;
              font-size: 18px;
              margin-bottom: 15px;
              border-bottom: 2px solid #e5e7eb;
              padding-bottom: 8px;
            }
            .info-grid {
              display: grid;
              grid-template-columns: 150px 1fr;
              gap: 10px;
            }
            .info-label {
              font-weight: 600;
              color: #666;
            }
            .info-value {
              color: #333;
            }
            .amount-section {
              background: #f8fafc;
              padding: 20px;
              border-radius: 8px;
              margin-top: 30px;
            }
            .amount-row {
              display: flex;
              justify-content: space-between;
              padding: 10px 0;
              font-size: 24px;
              font-weight: 700;
              color: #2563eb;
            }
            .footer {
              margin-top: 40px;
              padding-top: 20px;
              border-top: 1px solid #e5e7eb;
              text-align: center;
              color: #666;
              font-size: 14px;
            }
            @media print {
              body {
                background: white;
              }
              .invoice-container {
                box-shadow: none;
              }
            }
          </style>
        </head>
        <body>
          <div class="invoice-container">
            <div class="header">
              <h1>INVOICE</h1>
              <p>Booking Reference: #${booking.id}</p>
            </div>

            <div class="info-section">
              <h2>Guest Information</h2>
              <div class="info-grid">
                <div class="info-label">Name:</div>
                <div class="info-value">${booking.guestName}</div>
                <div class="info-label">Email:</div>
                <div class="info-value">${booking.guestEmail || "N/A"}</div>
                <div class="info-label">Phone:</div>
                <div class="info-value">${booking.guestPhone || "N/A"}</div>
                <div class="info-label">Guests:</div>
                <div class="info-value">${booking.guests} ${booking.guests === 1 ? "guest" : "guests"}</div>
              </div>
            </div>

            <div class="info-section">
              <h2>Property Details</h2>
              <div class="info-grid">
                <div class="info-label">Property:</div>
                <div class="info-value">${propertyName}</div>
                <div class="info-label">Check-in:</div>
                <div class="info-value">${new Date(booking.checkIn).toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" })}</div>
                <div class="info-label">Check-out:</div>
                <div class="info-value">${new Date(booking.checkOut).toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" })}</div>
                <div class="info-label">Status:</div>
                <div class="info-value" style="text-transform: capitalize;">${booking.status}</div>
              </div>
            </div>

            ${booking.specialRequests ? `
            <div class="info-section">
              <h2>Special Requests</h2>
              <p>${booking.specialRequests}</p>
            </div>
            ` : ""}

            <div class="amount-section">
              <div class="amount-row">
                <span>Total Amount:</span>
                <span>${booking.currency || "USD"} ${parseFloat(booking.totalAmount).toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
              </div>
            </div>

            <div class="footer">
              <p>Thank you for your booking!</p>
              <p style="margin-top: 10px; font-size: 12px;">Generated on ${(/* @__PURE__ */ new Date()).toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })}</p>
            </div>
          </div>
        </body>
        </html>
      `;
      res.setHeader("Content-Type", "text/html");
      res.send(invoiceHTML);
    } catch (error) {
      console.error("Error generating invoice:", error);
      res.status(500).send("<h1>Failed to generate invoice</h1>");
    }
  });
  app2.get("/api/finances", isDemoAuthenticated, async (req, res) => {
    try {
      const finances3 = await storage.getFinances();
      res.json(finances3);
    } catch (error) {
      console.error("Error fetching finances:", error);
      res.status(500).json({ message: "Failed to fetch finances" });
    }
  });
  app2.post("/api/finances", isDemoAuthenticated, async (req, res) => {
    try {
      console.log("\u{1F4CA} Finance POST received:", JSON.stringify(req.body, null, 2));
      const financeData = insertFinanceSchema.parse(req.body);
      const finance = await storage.createFinance(financeData);
      res.status(201).json(finance);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        console.error("\u274C Finance validation errors:", JSON.stringify(error.errors, null, 2));
        return res.status(400).json({ message: "Invalid finance data", errors: error.errors });
      }
      console.error("Error creating finance record:", error);
      res.status(500).json({ message: "Failed to create finance record" });
    }
  });
  app2.get("/api/inventory/:propertyId", isDemoAuthenticated, async (req, res) => {
    try {
      const propertyId = parseInt(req.params.propertyId);
      if (isNaN(propertyId)) {
        return res.status(400).json({ message: "Invalid property ID" });
      }
      const inventory2 = await storage.getInventoryByProperty(propertyId);
      res.json(inventory2);
    } catch (error) {
      console.error("Error fetching inventory:", error);
      res.status(500).json({ message: "Failed to fetch inventory" });
    }
  });
  app2.get("/api/owner-onboarding/processes", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const organizationId2 = "demo-org";
      let processes;
      if (user?.role === "admin" || user?.role === "portfolio-manager") {
        processes = await storage.getOwnerOnboardingProcesses(organizationId2);
      } else if (user?.role === "owner") {
        processes = await storage.getOwnerOnboardingProcesses(organizationId2, { ownerId: user.id });
      } else {
        return res.status(403).json({ message: "Access denied" });
      }
      res.json(processes);
    } catch (error) {
      console.error("Error fetching onboarding processes:", error);
      res.status(500).json({ message: "Failed to fetch onboarding processes" });
    }
  });
  app2.get("/api/owner-onboarding/processes/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const user = req.user;
      const process2 = await storage.getOwnerOnboardingProcess(parseInt(id));
      if (!process2) {
        return res.status(404).json({ message: "Onboarding process not found" });
      }
      if (user?.role !== "admin" && user?.role !== "portfolio-manager" && process2.ownerId !== user.id) {
        return res.status(403).json({ message: "Access denied" });
      }
      res.json(process2);
    } catch (error) {
      console.error("Error fetching onboarding process:", error);
      res.status(500).json({ message: "Failed to fetch onboarding process" });
    }
  });
  app2.post("/api/owner-onboarding/processes", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (user?.role !== "admin" && user?.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied" });
      }
      const processData = {
        ...req.body,
        organizationId: "demo-org",
        createdBy: user.id,
        currentStep: 1,
        status: "in_progress"
      };
      const process2 = await storage.createOwnerOnboardingProcess(processData);
      res.status(201).json(process2);
    } catch (error) {
      console.error("Error creating onboarding process:", error);
      res.status(500).json({ message: "Failed to create onboarding process" });
    }
  });
  app2.put("/api/owner-onboarding/processes/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const user = req.user;
      const process2 = await storage.getOwnerOnboardingProcess(parseInt(id));
      if (!process2) {
        return res.status(404).json({ message: "Onboarding process not found" });
      }
      if (user?.role !== "admin" && user?.role !== "portfolio-manager" && process2.ownerId !== user.id) {
        return res.status(403).json({ message: "Access denied" });
      }
      const updatedProcess = await storage.updateOwnerOnboardingProcess(parseInt(id), req.body);
      res.json(updatedProcess);
    } catch (error) {
      console.error("Error updating onboarding process:", error);
      res.status(500).json({ message: "Failed to update onboarding process" });
    }
  });
  app2.get("/api/owner-onboarding/processes/:processId/steps", isDemoAuthenticated, async (req, res) => {
    try {
      const { processId } = req.params;
      const user = req.user;
      const organizationId2 = "demo-org";
      const process2 = await storage.getOwnerOnboardingProcess(parseInt(processId));
      if (!process2) {
        return res.status(404).json({ message: "Onboarding process not found" });
      }
      if (user?.role !== "admin" && user?.role !== "portfolio-manager" && process2.ownerId !== user.id) {
        return res.status(403).json({ message: "Access denied" });
      }
      const steps = await storage.getOnboardingStepDetails(organizationId2, { processId: parseInt(processId) });
      res.json(steps);
    } catch (error) {
      console.error("Error fetching onboarding steps:", error);
      res.status(500).json({ message: "Failed to fetch onboarding steps" });
    }
  });
  app2.put("/api/owner-onboarding/steps/:stepId", isDemoAuthenticated, async (req, res) => {
    try {
      const { stepId } = req.params;
      const user = req.user;
      const step = await storage.getOnboardingStepDetail(parseInt(stepId));
      if (!step) {
        return res.status(404).json({ message: "Onboarding step not found" });
      }
      const process2 = await storage.getOwnerOnboardingProcess(step.processId);
      if (!process2) {
        return res.status(404).json({ message: "Associated onboarding process not found" });
      }
      if (user?.role !== "admin" && user?.role !== "portfolio-manager" && process2.ownerId !== user.id) {
        return res.status(403).json({ message: "Access denied" });
      }
      const updatedStep = await storage.updateOnboardingStepDetail(parseInt(stepId), {
        ...req.body,
        updatedBy: user.id,
        updatedAt: /* @__PURE__ */ new Date()
      });
      res.json(updatedStep);
    } catch (error) {
      console.error("Error updating onboarding step:", error);
      res.status(500).json({ message: "Failed to update onboarding step" });
    }
  });
  app2.get("/api/owner-onboarding/documents", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const organizationId2 = "demo-org";
      const { ownerId, category, processId } = req.query;
      const filters = {};
      if (ownerId) filters.ownerId = ownerId;
      if (category) filters.category = category;
      if (processId) filters.processId = parseInt(processId);
      if (user?.role === "owner") {
        filters.ownerId = user.id;
      }
      const documents = await storage.getOwnerDocuments(organizationId2, filters);
      res.json(documents);
    } catch (error) {
      console.error("Error fetching owner documents:", error);
      res.status(500).json({ message: "Failed to fetch owner documents" });
    }
  });
  app2.post("/api/owner-onboarding/documents", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const documentData = {
        ...req.body,
        organizationId: "demo-org",
        uploadedBy: user.id,
        status: "pending"
      };
      const document = await storage.createOwnerDocument(documentData);
      res.status(201).json(document);
    } catch (error) {
      console.error("Error uploading owner document:", error);
      res.status(500).json({ message: "Failed to upload owner document" });
    }
  });
  app2.get("/api/dashboard/stats", isDemoAuthenticated, async (req, res) => {
    const { sendCachedOrFetch: sendCachedOrFetch2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
    const organizationId2 = req.user?.organizationId || "default-org";
    const cacheKey = `dashboard-stats-${organizationId2}`;
    return sendCachedOrFetch2(
      cacheKey,
      async () => {
        const properties2 = await storage.getProperties();
        const bookings3 = await storage.getBookings(organizationId2);
        const tasks2 = await storage.getTasks(organizationId2);
        const finances3 = await storage.getFinances(organizationId2);
        const activeBookings = bookings3.filter((b) => b.status === "confirmed" || b.status === "checked-in");
        const pendingTasks = tasks2.filter((t) => t.status === "pending" || t.status === "in-progress");
        const monthlyRevenue = finances3.filter((f) => f.type === "income" && new Date(f.date).getMonth() === (/* @__PURE__ */ new Date()).getMonth()).reduce((sum4, f) => sum4 + parseFloat(f.amount || "0"), 0);
        return {
          totalProperties: properties2.length,
          activeBookings: activeBookings.length,
          pendingTasks: pendingTasks.length,
          monthlyRevenue
        };
      },
      res,
      30
      // 30 minute cache for dashboard stats
    );
  });
  app2.get("/api/admin/settings", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const settings = await storage.getPlatformSettings();
      res.json(settings);
    } catch (error) {
      console.error("Error fetching platform settings:", error);
      res.status(500).json({ message: "Failed to fetch platform settings" });
    }
  });
  app2.get("/api/admin/settings/:category", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { category } = req.params;
      const settings = await storage.getPlatformSettingsByCategory(category);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching platform settings by category:", error);
      res.status(500).json({ message: "Failed to fetch platform settings" });
    }
  });
  app2.put("/api/admin/settings/:key", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { key } = req.params;
      const settingData = insertPlatformSettingSchema.parse({
        ...req.body,
        settingKey: key,
        updatedBy: userId
      });
      const setting = await storage.upsertPlatformSetting(settingData);
      res.json(setting);
    } catch (error) {
      console.error("Error updating platform setting:", error);
      if (error instanceof z2.ZodError) {
        res.status(400).json({ message: "Invalid setting data", errors: error.errors });
      } else {
        res.status(500).json({ message: "Failed to update platform setting" });
      }
    }
  });
  app2.delete("/api/admin/settings/:key", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (user?.role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { key } = req.params;
      const deleted = await storage.deletePlatformSetting(key);
      if (!deleted) {
        return res.status(404).json({ message: "Setting not found" });
      }
      res.json({ message: "Setting deleted successfully" });
    } catch (error) {
      console.error("Error deleting platform setting:", error);
      res.status(500).json({ message: "Failed to delete platform setting" });
    }
  });
  app2.get("/api/addon-services", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const services = await storage.getAddonServices();
      res.json(services);
    } catch (error) {
      console.error("Error fetching addon services:", error);
      res.status(500).json({ message: "Failed to fetch addon services" });
    }
  });
  app2.post("/api/addon-services", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const userData = req.user;
      const validatedData = insertAddonServiceSchema.parse({
        ...req.body,
        organizationId: organizationId2
      });
      const service = await storage.createAddonService(validatedData);
      res.status(201).json(service);
    } catch (error) {
      console.error("Error creating addon service:", error);
      res.status(500).json({ message: "Failed to create addon service" });
    }
  });
  app2.get("/api/addon-bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const bookings3 = await storage.getAddonBookings();
      res.json(bookings3);
    } catch (error) {
      console.error("Error fetching addon bookings:", error);
      res.status(500).json({ message: "Failed to fetch addon bookings" });
    }
  });
  app2.post("/api/addon-bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const userData = req.user;
      const validatedData = insertAddonBookingSchema.parse({
        ...req.body,
        organizationId: organizationId2,
        bookedBy: userData.id,
        chargedTo: req.body.billingType?.includes("guest") ? "guest" : req.body.billingType?.includes("owner") ? "owner" : "company"
      });
      const booking = await storage.createAddonBooking(validatedData);
      if (booking.totalPrice > 0) {
        const financeData = {
          organizationId: organizationId2,
          propertyId: booking.propertyId,
          type: booking.billingType?.includes("gift") ? "expense" : "income",
          source: booking.billingType === "owner-gift" ? "complimentary" : booking.billingType === "company-gift" ? "complimentary" : booking.billingType === "auto-bill-owner" ? "owner-charge" : "guest-payment",
          sourceType: booking.billingType?.includes("gift") ? booking.billingType : null,
          category: "add-on-service",
          subcategory: req.body.serviceCategory || "general",
          amount: booking.totalPrice.toString(),
          description: `Add-on service: ${req.body.serviceName} for ${booking.guestName}`,
          date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
          status: booking.billingType?.includes("gift") ? "paid" : "pending",
          processedBy: userData.id,
          referenceNumber: `ADDON-${booking.id}`
        };
        await storage.createFinance(financeData);
      }
      res.status(201).json(booking);
    } catch (error) {
      console.error("Error creating addon booking:", error);
      res.status(500).json({ message: "Failed to create addon booking" });
    }
  });
  app2.get("/api/welcome-pack-items", isDemoAuthenticated, async (req, res) => {
    try {
      const items = await storage.getWelcomePackItems();
      res.json(items);
    } catch (error) {
      console.error("Error fetching welcome pack items:", error);
      res.status(500).json({ message: "Failed to fetch welcome pack items" });
    }
  });
  app2.post("/api/welcome-pack-items", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const validatedData = {
        ...req.body,
        organizationId: organizationId2
      };
      const item = await storage.createWelcomePackItem(validatedData);
      res.status(201).json(item);
    } catch (error) {
      console.error("Error creating welcome pack item:", error);
      res.status(500).json({ message: "Failed to create welcome pack item" });
    }
  });
  app2.get("/api/welcome-pack-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const templates = await storage.getWelcomePackTemplates();
      res.json(templates);
    } catch (error) {
      console.error("Error fetching welcome pack templates:", error);
      res.status(500).json({ message: "Failed to fetch welcome pack templates" });
    }
  });
  app2.get("/api/welcome-pack-templates/property/:propertyId", isDemoAuthenticated, async (req, res) => {
    try {
      const propertyId = parseInt(req.params.propertyId);
      const templates = await storage.getWelcomePackTemplatesByProperty(propertyId);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching property welcome pack templates:", error);
      res.status(500).json({ message: "Failed to fetch property welcome pack templates" });
    }
  });
  app2.post("/api/welcome-pack-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const validatedData = {
        ...req.body,
        organizationId: organizationId2
      };
      const template = await storage.createWelcomePackTemplate(validatedData);
      res.status(201).json(template);
    } catch (error) {
      console.error("Error creating welcome pack template:", error);
      res.status(500).json({ message: "Failed to create welcome pack template" });
    }
  });
  app2.get("/api/welcome-pack-usage", isDemoAuthenticated, async (req, res) => {
    try {
      const usage = await storage.getWelcomePackUsage();
      res.json(usage);
    } catch (error) {
      console.error("Error fetching welcome pack usage:", error);
      res.status(500).json({ message: "Failed to fetch welcome pack usage" });
    }
  });
  app2.post("/api/welcome-pack-usage/checkout", isDemoAuthenticated, async (req, res) => {
    try {
      const userData = req.user;
      const { bookingId, propertyId } = req.body;
      const usageRecords = await storage.logWelcomePackUsageFromCheckout(
        bookingId,
        propertyId,
        userData.claims.sub
      );
      res.status(201).json(usageRecords);
    } catch (error) {
      console.error("Error logging welcome pack checkout usage:", error);
      res.status(500).json({ message: "Failed to log welcome pack checkout usage" });
    }
  });
  app2.get("/api/inventory/stats", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const { propertyId, staffId, fromDate, toDate } = req.query;
      const filters = {
        propertyId,
        staffId,
        fromDate: fromDate ? new Date(fromDate) : void 0,
        toDate: toDate ? new Date(toDate) : void 0
      };
      const stats = await storage.getInventoryStats(organizationId2, filters);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching inventory stats:", error);
      res.status(500).json({ message: "Failed to fetch inventory stats" });
    }
  });
  app2.get("/api/welcome-pack-usage/detailed", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const { propertyId, staffId, fromDate, toDate } = req.query;
      const filters = {
        propertyId,
        staffId,
        fromDate: fromDate ? new Date(fromDate) : void 0,
        toDate: toDate ? new Date(toDate) : void 0
      };
      const usage = await storage.getDetailedWelcomePackUsage(organizationId2, filters);
      res.json(usage);
    } catch (error) {
      console.error("Error fetching detailed welcome pack usage:", error);
      res.status(500).json({ message: "Failed to fetch detailed welcome pack usage" });
    }
  });
  app2.get("/api/staff/salary/:userId", isDemoAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;
      const salary = await storage.getStaffSalary(userId);
      res.json(salary);
    } catch (error) {
      console.error("Error fetching staff salary:", error);
      res.status(500).json({ message: "Failed to fetch staff salary" });
    }
  });
  app2.post("/api/staff/salary", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const salaryData = { ...req.body, organizationId: organizationId2 };
      const salary = await storage.createStaffSalary(salaryData);
      res.status(201).json(salary);
    } catch (error) {
      console.error("Error creating staff salary:", error);
      res.status(500).json({ message: "Failed to create staff salary" });
    }
  });
  app2.get("/api/commission-earnings/:userId", isDemoAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;
      const { period } = req.query;
      const earnings = await storage.getCommissionEarnings(userId, period);
      res.json(earnings);
    } catch (error) {
      console.error("Error fetching commission earnings:", error);
      res.status(500).json({ message: "Failed to fetch commission earnings" });
    }
  });
  app2.get("/api/portfolio-manager/earnings/:managerId", isDemoAuthenticated, async (req, res) => {
    try {
      const { managerId } = req.params;
      const { period } = req.query;
      const earnings = await storage.getPortfolioManagerEarnings(managerId, period);
      res.json(earnings);
    } catch (error) {
      console.error("Error fetching portfolio manager earnings:", error);
      res.status(500).json({ message: "Failed to fetch portfolio manager earnings" });
    }
  });
  app2.get("/api/portfolio-assignments/:managerId", isDemoAuthenticated, async (req, res) => {
    try {
      const { managerId } = req.params;
      const assignments = await storage.getPortfolioAssignments(managerId);
      res.json(assignments);
    } catch (error) {
      console.error("Error fetching portfolio assignments:", error);
      res.status(500).json({ message: "Failed to fetch portfolio assignments" });
    }
  });
  app2.post("/api/portfolio-assignments", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const assignmentData = { ...req.body, organizationId: organizationId2 };
      const assignment = await storage.assignPortfolioProperty(assignmentData);
      res.status(201).json(assignment);
    } catch (error) {
      console.error("Error creating portfolio assignment:", error);
      res.status(500).json({ message: "Failed to create portfolio assignment" });
    }
  });
  app2.get("/api/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const { userId, type, status } = req.query;
      const filters = {
        userId,
        type,
        status
      };
      const invoices2 = await storage.getInvoices(organizationId2, filters);
      res.json(invoices2);
    } catch (error) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });
  app2.get("/api/invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const invoice = await storage.getInvoice(parseInt(id));
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json(invoice);
    } catch (error) {
      console.error("Error fetching invoice:", error);
      res.status(500).json({ message: "Failed to fetch invoice" });
    }
  });
  app2.post("/api/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const userData = req.user;
      const { lineItems, ...invoiceData } = req.body;
      const invoiceNumber = await storage.generateInvoiceNumber(organizationId2);
      const invoice = await storage.createInvoice(
        {
          ...invoiceData,
          organizationId: organizationId2,
          invoiceNumber,
          createdBy: userData.claims.sub
        },
        lineItems || []
      );
      res.status(201).json(invoice);
    } catch (error) {
      console.error("Error creating invoice:", error);
      res.status(500).json({ message: "Failed to create invoice" });
    }
  });
  app2.patch("/api/invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const invoice = await storage.updateInvoice(parseInt(id), req.body);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json(invoice);
    } catch (error) {
      console.error("Error updating invoice:", error);
      res.status(500).json({ message: "Failed to update invoice" });
    }
  });
  app2.delete("/api/invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteInvoice(parseInt(id));
      if (!deleted) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting invoice:", error);
      res.status(500).json({ message: "Failed to delete invoice" });
    }
  });
  app2.get("/api/owner-payouts", isDemoAuthenticated, async (req, res) => {
    try {
      const { status, ownerId, propertyId } = req.query;
      let payouts;
      if (status) {
        payouts = await storage.getOwnerPayoutsByStatus(status);
      } else if (ownerId) {
        payouts = await storage.getOwnerPayoutsByOwner(ownerId);
      } else if (propertyId) {
        payouts = await storage.getOwnerPayoutsByProperty(parseInt(propertyId));
      } else {
        payouts = await storage.getOwnerPayouts();
      }
      res.json(payouts);
    } catch (error) {
      console.error("Error fetching owner payouts:", error);
      res.status(500).json({ message: "Failed to fetch owner payouts" });
    }
  });
  app2.get("/api/owner-payouts/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const payoutId = parseInt(req.params.id);
      const payout = await storage.getOwnerPayout(payoutId);
      if (!payout) {
        return res.status(404).json({ message: "Owner payout not found" });
      }
      res.json(payout);
    } catch (error) {
      console.error("Error fetching owner payout:", error);
      res.status(500).json({ message: "Failed to fetch owner payout" });
    }
  });
  app2.post("/api/owner-payouts", isDemoAuthenticated, async (req, res) => {
    try {
      const userData = req.user;
      const { organizationId: organizationId2 } = getTenantContext(req);
      const validatedData = {
        ...req.body,
        organizationId: organizationId2,
        requestedBy: userData.claims.sub,
        status: "pending",
        requestDate: /* @__PURE__ */ new Date()
      };
      const payout = await storage.createOwnerPayout(validatedData);
      res.status(201).json(payout);
    } catch (error) {
      console.error("Error creating owner payout:", error);
      res.status(500).json({ message: "Failed to create owner payout" });
    }
  });
  app2.patch("/api/owner-payouts/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const userData = req.user;
      const payoutId = parseInt(req.params.id);
      const { approvalNotes } = req.body;
      const updatedPayout = await storage.approveOwnerPayout(
        payoutId,
        userData.claims.sub,
        approvalNotes
      );
      if (!updatedPayout) {
        return res.status(404).json({ message: "Owner payout not found" });
      }
      await storage.notifyPayoutAction(payoutId, updatedPayout.requestedBy, "approved", userData.claims.sub);
      res.json(updatedPayout);
    } catch (error) {
      console.error("Error approving owner payout:", error);
      res.status(500).json({ message: "Failed to approve owner payout" });
    }
  });
  app2.patch("/api/owner-payouts/:id/mark-paid", isDemoAuthenticated, async (req, res) => {
    try {
      const userData = req.user;
      const payoutId = parseInt(req.params.id);
      const { paymentMethod, paymentReference } = req.body;
      const updatedPayout = await storage.markOwnerPayoutPaid(
        payoutId,
        userData.claims.sub,
        paymentMethod,
        paymentReference
      );
      if (!updatedPayout) {
        return res.status(404).json({ message: "Owner payout not found" });
      }
      res.json(updatedPayout);
    } catch (error) {
      console.error("Error marking owner payout as paid:", error);
      res.status(500).json({ message: "Failed to mark owner payout as paid" });
    }
  });
  app2.patch("/api/owner-payouts/:id/upload-receipt", isDemoAuthenticated, async (req, res) => {
    try {
      const userData = req.user;
      const payoutId = parseInt(req.params.id);
      const { receiptUrl } = req.body;
      const updatedPayout = await storage.uploadOwnerPayoutReceipt(
        payoutId,
        receiptUrl,
        userData.claims.sub
      );
      if (!updatedPayout) {
        return res.status(404).json({ message: "Owner payout not found" });
      }
      res.json(updatedPayout);
    } catch (error) {
      console.error("Error uploading owner payout receipt:", error);
      res.status(500).json({ message: "Failed to upload owner payout receipt" });
    }
  });
  app2.patch("/api/owner-payouts/:id/confirm-received", isDemoAuthenticated, async (req, res) => {
    try {
      const userData = req.user;
      const payoutId = parseInt(req.params.id);
      const updatedPayout = await storage.confirmOwnerPayoutReceived(
        payoutId,
        userData.claims.sub
      );
      if (!updatedPayout) {
        return res.status(404).json({ message: "Owner payout not found" });
      }
      res.json(updatedPayout);
    } catch (error) {
      console.error("Error confirming owner payout received:", error);
      res.status(500).json({ message: "Failed to confirm owner payout received" });
    }
  });
  app2.get("/api/owner-balance/:ownerId", isDemoAuthenticated, async (req, res) => {
    try {
      const { ownerId } = req.params;
      const { propertyId, startDate, endDate } = req.query;
      const balance = await storage.calculateOwnerBalance(
        ownerId,
        propertyId ? parseInt(propertyId) : void 0,
        startDate,
        endDate
      );
      res.json(balance);
    } catch (error) {
      console.error("Error calculating owner balance:", error);
      res.status(500).json({ message: "Failed to calculate owner balance" });
    }
  });
  app2.post("/api/notifications/:id/read", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const success = await storage.markNotificationRead(parseInt(id));
      if (success) {
        res.json({ message: "Notification marked as read" });
      } else {
        res.status(404).json({ message: "Notification not found" });
      }
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });
  app2.post("/api/notifications/read-all", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }
      const success = await storage.markAllNotificationsRead(userId);
      res.json({ message: "All notifications marked as read", success });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ message: "Failed to mark all notifications as read" });
    }
  });
  app2.delete("/api/notifications/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const success = await storage.deleteNotification(parseInt(id));
      if (success) {
        res.json({ message: "Notification deleted" });
      } else {
        res.status(404).json({ message: "Notification not found" });
      }
    } catch (error) {
      console.error("Error deleting notification:", error);
      res.status(500).json({ message: "Failed to delete notification" });
    }
  });
  app2.post("/api/test-notification", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }
      const notification = await storage.createNotification({
        organizationId: organizationId2,
        userId,
        type: "task_assignment",
        title: "Test Notification",
        message: "This is a test notification to verify the system is working",
        relatedEntityType: "test",
        relatedEntityId: 1,
        priority: "normal",
        actionUrl: "/dashboard",
        actionLabel: "View Dashboard",
        createdBy: userId
      });
      res.json(notification);
    } catch (error) {
      console.error("Error creating test notification:", error);
      res.status(500).json({ message: "Failed to create test notification" });
    }
  });
  app2.get("/api/notification-preferences", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }
      const preferences = await storage.getUserNotificationPreferences(userId);
      res.json(preferences);
    } catch (error) {
      console.error("Error fetching notification preferences:", error);
      res.status(500).json({ message: "Failed to fetch notification preferences" });
    }
  });
  app2.post("/api/notification-preferences", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }
      const preferencesData = {
        ...req.body,
        organizationId: organizationId2,
        userId
      };
      const preferences = await storage.upsertNotificationPreferences(preferencesData);
      res.json(preferences);
    } catch (error) {
      console.error("Error updating notification preferences:", error);
      res.status(500).json({ message: "Failed to update notification preferences" });
    }
  });
  app2.get("/api/staff-wallet/:staffId", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId } = req.params;
      const wallet = staffWalletStorage.getWallet(staffId);
      if (!wallet) {
        return res.status(404).json({ message: "Staff wallet not found" });
      }
      res.json(wallet);
    } catch (error) {
      console.error("Error fetching staff wallet:", error);
      res.status(500).json({ message: "Failed to fetch staff wallet" });
    }
  });
  app2.get("/api/staff-wallet/:staffId/transactions", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId } = req.params;
      const transactions = staffWalletStorage.getTransactions(staffId);
      res.json(transactions);
    } catch (error) {
      console.error("Error fetching staff transactions:", error);
      res.status(500).json({ message: "Failed to fetch staff transactions" });
    }
  });
  app2.post("/api/staff-wallet/:staffId/expenses", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId } = req.params;
      const { amount, description, category, property, receipt, receiptPhoto } = req.body;
      const transaction = staffWalletStorage.addTransaction({
        staffId,
        type: "expense",
        amount: parseFloat(amount),
        description,
        category,
        propertyName: property,
        date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        time: (/* @__PURE__ */ new Date()).toTimeString().slice(0, 5),
        receipt,
        receiptPhoto,
        status: "pending"
      });
      res.status(201).json(transaction);
    } catch (error) {
      console.error("Error adding expense:", error);
      res.status(500).json({ message: "Failed to add expense" });
    }
  });
  app2.get("/api/staff-wallet/pending-checkouts", isDemoAuthenticated, async (req, res) => {
    try {
      const pendingCheckouts = staffWalletStorage.getPendingCheckouts();
      res.json(pendingCheckouts);
    } catch (error) {
      console.error("Error fetching pending checkouts:", error);
      res.status(500).json({ message: "Failed to fetch pending checkouts" });
    }
  });
  app2.post("/api/staff-wallet/cash-collection", isDemoAuthenticated, async (req, res) => {
    try {
      const { checkoutId, actualAmount, collectionMethod, notes, receiptPhoto } = req.body;
      const success = staffWalletStorage.recordCashCollection(
        checkoutId,
        parseFloat(actualAmount),
        collectionMethod,
        notes,
        receiptPhoto
      );
      if (!success) {
        return res.status(404).json({ message: "Checkout not found" });
      }
      res.json({ success: true, message: "Cash collection recorded successfully" });
    } catch (error) {
      console.error("Error recording cash collection:", error);
      res.status(500).json({ message: "Failed to record cash collection" });
    }
  });
  app2.post("/api/staff-wallet/:staffId/cash-income", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId } = req.params;
      const { amount, source, guestName, property, notes, receiptPhoto } = req.body;
      const transaction = staffWalletStorage.addTransaction({
        staffId,
        type: "income",
        amount: parseFloat(amount),
        description: `Cash collection - ${source}`,
        category: source,
        date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        time: (/* @__PURE__ */ new Date()).toTimeString().slice(0, 5),
        guestName,
        propertyName: property,
        receiptPhoto,
        status: "approved"
        // Cash collections are automatically approved
      });
      res.status(201).json(transaction);
    } catch (error) {
      console.error("Error recording cash income:", error);
      res.status(500).json({ message: "Failed to record cash income" });
    }
  });
  app2.post("/api/staff-wallet/:staffId/clear-balance", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId } = req.params;
      const { reason } = req.body;
      if (!["admin", "portfolio-manager"].includes(req.user?.role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      staffWalletStorage.clearWalletBalance(staffId, reason);
      res.json({ success: true, message: "Wallet balance cleared successfully" });
    } catch (error) {
      console.error("Error clearing wallet balance:", error);
      res.status(500).json({ message: "Failed to clear wallet balance" });
    }
  });
  app2.get("/api/staff-expenses/pending", isDemoAuthenticated, async (req, res) => {
    try {
      if (!["admin", "portfolio-manager"].includes(req.user?.role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const pendingExpenses = staffWalletStorage.getPendingTransactions();
      res.json(pendingExpenses);
    } catch (error) {
      console.error("Error fetching pending expenses:", error);
      res.status(500).json({ message: "Failed to fetch pending expenses" });
    }
  });
  app2.get("/api/staff-expenses/reviewed", isDemoAuthenticated, async (req, res) => {
    try {
      if (!["admin", "portfolio-manager"].includes(req.user?.role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const reviewedExpenses = staffWalletStorage.getReviewedTransactions();
      res.json(reviewedExpenses);
    } catch (error) {
      console.error("Error fetching reviewed expenses:", error);
      res.status(500).json({ message: "Failed to fetch reviewed expenses" });
    }
  });
  app2.patch("/api/staff-expenses/:transactionId/review", isDemoAuthenticated, async (req, res) => {
    try {
      if (!["admin", "portfolio-manager"].includes(req.user?.role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const { transactionId } = req.params;
      const { finalCategory, property, reviewNotes } = req.body;
      const reviewedBy = req.user?.email || req.user?.id || "Admin";
      const success = staffWalletStorage.reviewTransaction(
        transactionId,
        finalCategory,
        property,
        reviewNotes,
        reviewedBy
      );
      if (!success) {
        return res.status(404).json({ message: "Transaction not found" });
      }
      res.json({ success: true, message: "Expense reviewed and categorized successfully" });
    } catch (error) {
      console.error("Error reviewing expense:", error);
      res.status(500).json({ message: "Failed to review expense" });
    }
  });
  app2.get("/api/admin/staff-permissions", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const permissions = staffPermissionStorage.getAllStaffPermissions();
      res.json(permissions);
    } catch (error) {
      console.error("Error fetching staff permissions:", error);
      res.status(500).json({ message: "Failed to fetch staff permissions" });
    }
  });
  app2.get("/api/admin/staff-permissions/:staffId", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const { staffId } = req.params;
      const permissions = staffPermissionStorage.getStaffPermissions(staffId);
      if (!permissions) {
        return res.status(404).json({ message: "Staff permissions not found" });
      }
      res.json(permissions);
    } catch (error) {
      console.error("Error fetching staff permissions:", error);
      res.status(500).json({ message: "Failed to fetch staff permissions" });
    }
  });
  app2.post("/api/admin/staff-permissions/:staffId/grant-task-creation", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const { staffId } = req.params;
      const { reason, departments = ["general"], maxTasksPerDay = 3, expiresAt } = req.body;
      const adminId = req.user.id;
      const permissions = staffPermissionStorage.grantTaskCreationPermission(
        staffId,
        adminId,
        reason,
        departments,
        maxTasksPerDay,
        expiresAt ? new Date(expiresAt) : void 0
      );
      res.json(permissions);
    } catch (error) {
      console.error("Error granting task creation permission:", error);
      res.status(500).json({ message: "Failed to grant permission" });
    }
  });
  app2.post("/api/admin/staff-permissions/:staffId/revoke-task-creation", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const { staffId } = req.params;
      const { reason } = req.body;
      const adminId = req.user.id;
      const permissions = staffPermissionStorage.revokeTaskCreationPermission(staffId, adminId, reason);
      res.json(permissions);
    } catch (error) {
      console.error("Error revoking task creation permission:", error);
      res.status(500).json({ message: "Failed to revoke permission" });
    }
  });
  app2.put("/api/admin/staff-permissions/:staffId", isDemoAuthenticated, requireAdmin, async (req, res) => {
    try {
      const { staffId } = req.params;
      const adminId = req.user.id;
      const updates = req.body;
      const permissions = staffPermissionStorage.updateStaffPermissions(staffId, updates, adminId);
      res.json(permissions);
    } catch (error) {
      console.error("Error updating staff permissions:", error);
      res.status(500).json({ message: "Failed to update permissions" });
    }
  });
  app2.get("/api/staff/can-create-tasks", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const userRole = req.user.role;
      if (userRole !== "staff") {
        return res.json({ canCreateTasks: true, reason: "Non-staff user" });
      }
      const canCreateTasks = staffPermissionStorage.canStaffCreateTasks(userId);
      const canCreateMore = staffPermissionStorage.canStaffCreateMoreTasks(userId);
      const permissions = staffPermissionStorage.getStaffPermissions(userId);
      res.json({
        canCreateTasks: canCreateTasks && canCreateMore,
        hasPermission: canCreateTasks,
        withinDailyLimit: canCreateMore,
        maxTasksPerDay: permissions?.maxTasksPerDay || 0,
        allowedDepartments: permissions?.allowedDepartments || [],
        reason: !canCreateTasks ? "Permission not granted" : !canCreateMore ? "Daily limit reached" : "Allowed"
      });
    } catch (error) {
      console.error("Error checking task creation permission:", error);
      res.status(500).json({ message: "Failed to check permissions" });
    }
  });
  app2.post("/api/ai/test", isDemoAuthenticated, async (req, res) => {
    try {
      const { prompt } = req.body;
      const { askAssistant: askAssistant2 } = await Promise.resolve().then(() => (init_aiHelper(), aiHelper_exports));
      const result = await askAssistant2(prompt);
      res.json({ result });
    } catch (error) {
      console.error("AI test error:", error);
      res.status(500).json({ message: "AI test failed", error: error.message });
    }
  });
  app2.post("/api/assistant", isDemoAuthenticated, async (req, res) => {
    try {
      const { prompt } = req.body;
      const user = req.user;
      const organizationId2 = user?.organizationId || "default-org";
      const { askAssistant: askAssistant2 } = await Promise.resolve().then(() => (init_aiHelper(), aiHelper_exports));
      const result = await askAssistant2(prompt, organizationId2);
      res.json({ result });
    } catch (error) {
      console.error("AI Assistant Error:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.post("/api/ai/property-description", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyDetails } = req.body;
      const { generatePropertyDescription: generatePropertyDescription2 } = await Promise.resolve().then(() => (init_aiHelper(), aiHelper_exports));
      const description = await generatePropertyDescription2(propertyDetails);
      res.json({ description });
    } catch (error) {
      console.error("Property description error:", error);
      res.status(500).json({ message: "Failed to generate property description", error: error.message });
    }
  });
  app2.post("/api/ai/analyze-review", isDemoAuthenticated, async (req, res) => {
    try {
      const { reviewText } = req.body;
      const { analyzeGuestReview: analyzeGuestReview2 } = await Promise.resolve().then(() => (init_aiHelper(), aiHelper_exports));
      const analysis = await analyzeGuestReview2(reviewText);
      res.json({ analysis });
    } catch (error) {
      console.error("Review analysis error:", error);
      res.status(500).json({ message: "Failed to analyze review", error: error.message });
    }
  });
  app2.post("/api/ai/maintenance-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyType, lastMaintenanceDate } = req.body;
      const { generateMaintenanceTaskSuggestion: generateMaintenanceTaskSuggestion2 } = await Promise.resolve().then(() => (init_aiHelper(), aiHelper_exports));
      const suggestions = await generateMaintenanceTaskSuggestion2(propertyType, lastMaintenanceDate);
      res.json({ suggestions });
    } catch (error) {
      console.error("Maintenance suggestions error:", error);
      res.status(500).json({ message: "Failed to generate maintenance suggestions", error: error.message });
    }
  });
  app2.post("/api/ai/custom", isDemoAuthenticated, async (req, res) => {
    try {
      const { prompt } = req.body;
      const { askAssistant: askAssistant2 } = await Promise.resolve().then(() => (init_aiHelper(), aiHelper_exports));
      const result = await askAssistant2(prompt);
      res.json({ result });
    } catch (error) {
      console.error("Custom AI prompt error:", error);
      res.status(500).json({ message: "Failed to process custom prompt", error: error.message });
    }
  });
  app2.get("/api/ai/feedback", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const { propertyId, processed, requiresAction } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (processed !== void 0) filters.processed = processed === "true";
      if (requiresAction !== void 0) filters.requiresAction = requiresAction === "true";
      const feedback = await storage.getGuestFeedback(organizationId2, filters);
      res.json(feedback);
    } catch (error) {
      console.error("Error fetching guest feedback:", error);
      res.status(500).json({ message: "Failed to fetch guest feedback" });
    }
  });
  app2.post("/api/ai/feedback", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const user = req.user;
      const feedbackData = {
        ...req.body,
        organizationId: organizationId2,
        receivedAt: /* @__PURE__ */ new Date()
      };
      const aiAnalysis = await storage.processMessageForKeywords(
        feedbackData.originalMessage,
        organizationId2
      );
      const feedback = await storage.createGuestFeedback({
        ...feedbackData,
        detectedKeywords: aiAnalysis.detectedKeywords,
        aiConfidence: aiAnalysis.matchedRules.length > 0 ? 0.85 : 0.1,
        requiresAction: aiAnalysis.matchedRules.length > 0
      });
      if (aiAnalysis.matchedRules.length > 0) {
        for (const rule of aiAnalysis.matchedRules) {
          try {
            await storage.createTaskFromFeedback(feedback.id, rule.id);
          } catch (error) {
            console.error("Error creating task from feedback:", error);
          }
        }
      }
      res.json({
        feedback,
        aiAnalysis,
        autoTasksCreated: aiAnalysis.matchedRules.length
      });
    } catch (error) {
      console.error("Error creating guest feedback:", error);
      res.status(500).json({ message: "Failed to create guest feedback" });
    }
  });
  app2.put("/api/ai/feedback/:id/process", isDemoAuthenticated, async (req, res) => {
    try {
      const feedbackId = parseInt(req.params.id);
      const user = req.user;
      const { processingNotes, assignedTaskId, createTask, ruleId } = req.body;
      if (createTask && ruleId) {
        const task = await storage.createTaskFromFeedback(feedbackId, ruleId);
        const feedback = await storage.processGuestFeedback(
          feedbackId,
          user.username,
          processingNotes,
          task.id
        );
        res.json({ feedback, createdTask: task });
      } else {
        const feedback = await storage.processGuestFeedback(
          feedbackId,
          user.username,
          processingNotes,
          assignedTaskId
        );
        res.json({ feedback });
      }
    } catch (error) {
      console.error("Error processing feedback:", error);
      res.status(500).json({ message: "Failed to process feedback" });
    }
  });
  const requireAdminRole = (req, res, next) => {
    if (req.user?.role !== "admin") {
      return res.status(403).json({
        message: "Admin access required",
        userRole: req.user?.role || "unknown"
      });
    }
    next();
  };
  app2.get("/api/staff-members", isDemoAuthenticated, getStaffMembers);
  app2.get("/api/staff-members/:id", isDemoAuthenticated, getStaffMember);
  app2.post("/api/staff-members", isDemoAuthenticated, requireAdminRole, createStaffMember);
  app2.put("/api/staff-members/:id", isDemoAuthenticated, requireAdminRole, updateStaffMember);
  app2.delete("/api/staff-members/:id", isDemoAuthenticated, requireAdminRole, deleteStaffMember);
  app2.get("/api/staff-members/:staffMemberId/documents", isDemoAuthenticated, requireAdminRole, getStaffDocuments);
  app2.post("/api/staff-documents", isDemoAuthenticated, requireAdminRole, createStaffDocument);
  app2.get("/api/payroll-records", isDemoAuthenticated, requireAdminRole, getPayrollRecords);
  app2.post("/api/payroll-records", isDemoAuthenticated, requireAdminRole, createPayrollRecord);
  app2.get("/api/staff-analytics", isDemoAuthenticated, requireAdminRole, getStaffAnalytics);
  app2.get("/api/guest-messages/:guestId", async (req, res) => {
    try {
      const guestId = req.params.guestId;
      const organizationId2 = "default-org";
      const messages = await storage.getGuestMessages(organizationId2, guestId);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching guest messages:", error);
      res.status(500).json({ message: "Failed to fetch guest messages" });
    }
  });
  app2.post("/api/guest-messages", async (req, res) => {
    try {
      const messageData = {
        ...req.body,
        organizationId: "default-org"
      };
      const newMessage = await storage.createGuestMessage(messageData);
      res.status(201).json(newMessage);
    } catch (error) {
      console.error("Error creating guest message:", error);
      res.status(500).json({ message: "Failed to create guest message" });
    }
  });
  app2.get("/api/guest-service-requests/:guestId", async (req, res) => {
    try {
      const guestId = req.params.guestId;
      const organizationId2 = "default-org";
      const requests = await storage.getGuestServiceRequests(organizationId2, guestId);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching guest service requests:", error);
      res.status(500).json({ message: "Failed to fetch guest service requests" });
    }
  });
  app2.post("/api/guest-service-requests", async (req, res) => {
    try {
      const requestData = {
        ...req.body,
        organizationId: "default-org"
      };
      const newRequest = await storage.createGuestServiceRequest(requestData);
      res.status(201).json(newRequest);
    } catch (error) {
      console.error("Error creating guest service request:", error);
      res.status(500).json({ message: "Failed to create guest service request" });
    }
  });
  app2.get("/api/guest-bookings/:guestId", async (req, res) => {
    try {
      const guestId = req.params.guestId;
      const bookings3 = await storage.getGuestBookings(guestId);
      res.json(bookings3);
    } catch (error) {
      console.error("Error fetching guest bookings:", error);
      res.status(500).json({ message: "Failed to fetch guest bookings" });
    }
  });
  app2.get("/api/ai-generated-tasks", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const tasks2 = await storage.getAIGeneratedTasks(organizationId2);
      res.json(tasks2);
    } catch (error) {
      console.error("Error fetching AI generated tasks:", error);
      res.status(500).json({ message: "Failed to fetch AI generated tasks" });
    }
  });
  app2.get("/api/ai/rules", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const { isActive, department } = req.query;
      const filters = {};
      if (isActive !== void 0) filters.isActive = isActive === "true";
      if (department) filters.department = department;
      const rules = await storage.getAiTaskRules(organizationId2, filters);
      res.json(rules);
    } catch (error) {
      console.error("Error fetching AI task rules:", error);
      res.status(500).json({ message: "Failed to fetch AI task rules" });
    }
  });
  app2.post("/api/ai/rules", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const user = req.user;
      const ruleData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: user.username,
        triggerCount: 0
      };
      const rule = await storage.createAiTaskRule(ruleData);
      res.json(rule);
    } catch (error) {
      console.error("Error creating AI task rule:", error);
      res.status(500).json({ message: "Failed to create AI task rule" });
    }
  });
  app2.put("/api/ai/rules/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const ruleId = parseInt(req.params.id);
      const rule = await storage.updateAiTaskRule(ruleId, req.body);
      res.json(rule);
    } catch (error) {
      console.error("Error updating AI task rule:", error);
      res.status(500).json({ message: "Failed to update AI task rule" });
    }
  });
  app2.delete("/api/ai/rules/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const ruleId = parseInt(req.params.id);
      const success = await storage.deleteAiTaskRule(ruleId);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting AI task rule:", error);
      res.status(500).json({ message: "Failed to delete AI task rule" });
    }
  });
  app2.get("/api/ai/processing-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const { feedbackId } = req.query;
      const logs = await storage.getProcessingLogs(
        organizationId2,
        feedbackId ? parseInt(feedbackId) : void 0
      );
      res.json(logs);
    } catch (error) {
      console.error("Error fetching processing logs:", error);
      res.status(500).json({ message: "Failed to fetch processing logs" });
    }
  });
  app2.get("/api/ai/processing-log", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const { feedbackId } = req.query;
      const logs = await storage.getProcessingLogs(
        organizationId2,
        feedbackId ? parseInt(feedbackId) : void 0
      );
      res.json(logs);
    } catch (error) {
      console.error("Error fetching processing logs:", error);
      res.status(500).json({ message: "Failed to fetch processing logs" });
    }
  });
  app2.get("/api/ai/task-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const rules = await storage.getAiTaskRules(organizationId2);
      res.json(rules);
    } catch (error) {
      console.error("Error fetching AI task rules:", error);
      res.status(500).json({ message: "Failed to fetch AI task rules" });
    }
  });
  app2.get("/api/ai/feedback-analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const analytics = {
        totalFeedback: 127,
        unprocessedCount: 8,
        highUrgencyCount: 3,
        averageProcessingTime: 125,
        // seconds
        topIssueCategories: [
          { category: "Maintenance", count: 45 },
          { category: "Cleanliness", count: 32 },
          { category: "Pool Issues", count: 28 },
          { category: "Garden/Landscaping", count: 22 }
        ],
        recentTrends: [
          { date: "2025-01-01", count: 12 },
          { date: "2025-01-02", count: 15 },
          { date: "2025-01-03", count: 8 },
          { date: "2025-01-04", count: 18 },
          { date: "2025-01-05", count: 11 }
        ],
        automationRate: 87
      };
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching feedback analytics:", error);
      res.status(500).json({ message: "Failed to fetch feedback analytics" });
    }
  });
  app2.post("/api/ai/feedback/:id/process", isDemoAuthenticated, async (req, res) => {
    try {
      const feedbackId = parseInt(req.params.id);
      const { action, notes } = req.body;
      const user = req.user;
      let result = {
        success: true,
        action,
        feedbackId
      };
      if (action === "create_task") {
        result.taskTitle = "Maintenance Task - Guest Feedback";
        result.taskId = Math.floor(Math.random() * 1e3) + 1;
        await storage.updateGuestFeedbackProcessing(feedbackId, {
          isProcessed: true,
          processedBy: user.username,
          processingNotes: notes || "Auto-generated task from feedback",
          assignedTaskId: result.taskId,
          processedAt: /* @__PURE__ */ new Date()
        });
      } else if (action === "mark_resolved") {
        await storage.updateGuestFeedbackProcessing(feedbackId, {
          isProcessed: true,
          processedBy: user.username,
          processingNotes: notes || "Marked as resolved manually",
          processedAt: /* @__PURE__ */ new Date()
        });
      }
      res.json(result);
    } catch (error) {
      console.error("Error processing feedback:", error);
      res.status(500).json({ message: "Failed to process feedback" });
    }
  });
  app2.post("/api/ai/auto-process-feedback", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const urgentFeedback = await storage.getGuestFeedback(organizationId2, {
        processed: false,
        urgencyLevel: "high"
      });
      let processedCount = 0;
      for (const feedback of urgentFeedback) {
        try {
          await storage.updateGuestFeedbackProcessing(feedback.id, {
            isProcessed: true,
            processedBy: "system",
            processingNotes: "Auto-processed due to high urgency",
            processedAt: /* @__PURE__ */ new Date()
          });
          processedCount++;
        } catch (error) {
          console.error(`Error auto-processing feedback ${feedback.id}:`, error);
        }
      }
      res.json({
        success: true,
        processedCount,
        message: `Auto-processed ${processedCount} high-urgency feedback items`
      });
    } catch (error) {
      console.error("Error auto-processing feedback:", error);
      res.status(500).json({ message: "Failed to auto-process feedback" });
    }
  });
  app2.get("/api/ai/config", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const config = await storage.getAiConfiguration(organizationId2);
      res.json(config || {
        organizationId: organizationId2,
        isEnabled: true,
        autoTaskCreation: true,
        confidenceThreshold: 0.7,
        enabledDepartments: ["maintenance", "housekeeping", "front-desk"],
        openaiApiKey: null,
        customPrompts: {}
      });
    } catch (error) {
      console.error("Error fetching AI config:", error);
      res.status(500).json({ message: "Failed to fetch AI configuration" });
    }
  });
  app2.put("/api/ai/config", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const configData = {
        ...req.body,
        organizationId: organizationId2
      };
      const config = await storage.upsertAiConfiguration(configData);
      res.json(config);
    } catch (error) {
      console.error("Error updating AI config:", error);
      res.status(500).json({ message: "Failed to update AI configuration" });
    }
  });
  app2.post("/api/ai/analyze-message", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const { message } = req.body;
      if (!message) {
        return res.status(400).json({ message: "Message is required" });
      }
      const analysis = await storage.processMessageForKeywords(message, organizationId2);
      res.json(analysis);
    } catch (error) {
      console.error("Error analyzing message:", error);
      res.status(500).json({ message: "Failed to analyze message" });
    }
  });
  app2.post("/api/ai/create-task-from-feedback", isDemoAuthenticated, async (req, res) => {
    try {
      const { feedbackId, ruleId, assignedTo } = req.body;
      if (!feedbackId || !ruleId) {
        return res.status(400).json({ message: "feedbackId and ruleId are required" });
      }
      const task = await storage.createTaskFromFeedback(
        parseInt(feedbackId),
        parseInt(ruleId),
        assignedTo
      );
      res.json(task);
    } catch (error) {
      console.error("Error creating task from feedback:", error);
      res.status(500).json({ message: "Failed to create task from feedback" });
    }
  });
  app2.get("/api/guest-activity-recommendations/:propertyId", async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const propertyId = parseInt(req.params.propertyId);
      const { category, isFeatured, suitableFor } = req.query;
      const filters = {};
      if (category) filters.category = category;
      if (isFeatured !== void 0) filters.isFeatured = isFeatured === "true";
      if (suitableFor) filters.suitableFor = suitableFor.split(",");
      const recommendations = await storage.getPropertyActivityRecommendations(organizationId2, propertyId, filters);
      res.json(recommendations);
    } catch (error) {
      console.error("Error fetching activity recommendations:", error);
      res.status(500).json({ message: "Failed to fetch activity recommendations" });
    }
  });
  app2.get("/api/guest-activity-recommendations/:propertyId/personalized", async (req, res) => {
    try {
      const propertyId = parseInt(req.params.propertyId);
      const { reservationId, guestId } = req.query;
      if (!reservationId || !guestId) {
        return res.status(400).json({ message: "reservationId and guestId are required" });
      }
      const recommendations = await storage.getPersonalizedRecommendations(
        reservationId,
        guestId,
        propertyId
      );
      res.json(recommendations);
    } catch (error) {
      console.error("Error fetching personalized recommendations:", error);
      res.status(500).json({ message: "Failed to fetch personalized recommendations" });
    }
  });
  app2.get("/api/guest-activity-preferences/:reservationId", async (req, res) => {
    try {
      const reservationId = req.params.reservationId;
      const preferences = await storage.getGuestActivityPreferences(reservationId);
      res.json(preferences);
    } catch (error) {
      console.error("Error fetching guest preferences:", error);
      res.status(500).json({ message: "Failed to fetch guest preferences" });
    }
  });
  app2.post("/api/guest-activity-preferences", async (req, res) => {
    try {
      const preferences = await storage.createGuestActivityPreferences(req.body);
      res.status(201).json(preferences);
    } catch (error) {
      console.error("Error creating guest preferences:", error);
      res.status(500).json({ message: "Failed to create guest preferences" });
    }
  });
  app2.get("/api/organization/current", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User organization not found" });
      }
      const organization = await storage.getCurrentOrganization(user.organizationId);
      if (!organization) {
        return res.status(404).json({ message: "Organization not found" });
      }
      res.json(organization);
    } catch (error) {
      console.error("Error fetching current organization:", error);
      res.status(500).json({ message: "Failed to fetch organization details" });
    }
  });
  app2.put("/api/organization/branding", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User organization not found" });
      }
      if (user.role !== "admin") {
        return res.status(403).json({ message: "Only administrators can update organization branding" });
      }
      const { customDomain, brandingLogoUrl, themeColor } = req.body;
      const updatedOrganization = await storage.updateOrganizationBranding(user.organizationId, {
        customDomain,
        brandingLogoUrl,
        themeColor
      });
      res.json(updatedOrganization);
    } catch (error) {
      console.error("Error updating organization branding:", error);
      res.status(500).json({ message: "Failed to update organization branding" });
    }
  });
  app2.get("/api/legal-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const { countryCode, docType } = req.query;
      const templates = await storage.getLegalTemplates({
        countryCode,
        docType
      });
      res.json(templates);
    } catch (error) {
      console.error("Error fetching legal templates:", error);
      res.status(500).json({ message: "Failed to fetch legal templates" });
    }
  });
  app2.post("/api/legal-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (user.role !== "admin") {
        return res.status(403).json({ message: "Only administrators can create legal templates" });
      }
      const { countryCode, docType, templateText } = req.body;
      if (!countryCode || !docType || !templateText) {
        return res.status(400).json({ message: "Country code, document type, and template text are required" });
      }
      const newTemplate = await storage.createLegalTemplate({
        countryCode,
        docType,
        templateText
      });
      res.status(201).json(newTemplate);
    } catch (error) {
      console.error("Error creating legal template:", error);
      res.status(500).json({ message: "Failed to create legal template" });
    }
  });
  app2.put("/api/legal-templates/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (user.role !== "admin") {
        return res.status(403).json({ message: "Only administrators can update legal templates" });
      }
      const id = parseInt(req.params.id);
      const { countryCode, docType, templateText } = req.body;
      const updatedTemplate = await storage.updateLegalTemplate(id, {
        countryCode,
        docType,
        templateText
      });
      if (!updatedTemplate) {
        return res.status(404).json({ message: "Legal template not found" });
      }
      res.json(updatedTemplate);
    } catch (error) {
      console.error("Error updating legal template:", error);
      res.status(500).json({ message: "Failed to update legal template" });
    }
  });
  app2.delete("/api/legal-templates/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (user.role !== "admin") {
        return res.status(403).json({ message: "Only administrators can delete legal templates" });
      }
      const id = parseInt(req.params.id);
      await storage.deleteLegalTemplate(id);
      res.json({ message: "Legal template deleted successfully" });
    } catch (error) {
      console.error("Error deleting legal template:", error);
      res.status(500).json({ message: "Failed to delete legal template" });
    }
  });
  app2.get("/api/legal-templates/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const template = await storage.getLegalTemplateById(id);
      if (!template) {
        return res.status(404).json({ message: "Legal template not found" });
      }
      res.json(template);
    } catch (error) {
      console.error("Error fetching legal template:", error);
      res.status(500).json({ message: "Failed to fetch legal template" });
    }
  });
  app2.get("/api/legal-templates/country/:countryCode/type/:docType", isDemoAuthenticated, async (req, res) => {
    try {
      const { countryCode, docType } = req.params;
      const templates = await storage.getTemplatesByCountryAndType(countryCode, docType);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching templates by country and type:", error);
      res.status(500).json({ message: "Failed to fetch templates" });
    }
  });
  app2.get("/api/legal-templates/countries", isDemoAuthenticated, async (req, res) => {
    try {
      const countries = await storage.getAvailableCountries();
      res.json(countries);
    } catch (error) {
      console.error("Error fetching available countries:", error);
      res.status(500).json({ message: "Failed to fetch available countries" });
    }
  });
  app2.get("/api/legal-templates/doc-types", isDemoAuthenticated, async (req, res) => {
    try {
      const docTypes = await storage.getAvailableDocTypes();
      res.json(docTypes);
    } catch (error) {
      console.error("Error fetching available document types:", error);
      res.status(500).json({ message: "Failed to fetch available document types" });
    }
  });
  app2.get("/api/upsell-recommendations", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { propertyId, recommendationType, status } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (recommendationType) filters.recommendationType = recommendationType;
      if (status) filters.status = status;
      const recommendations = await storage.getUpsellRecommendations(organizationId2, filters);
      res.json(recommendations);
    } catch (error) {
      console.error("Error fetching upsell recommendations:", error);
      res.status(500).json({ message: "Failed to fetch upsell recommendations" });
    }
  });
  app2.get("/api/upsell-recommendations/search", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { q, propertyId, recommendationType, status } = req.query;
      if (!q) {
        return res.status(400).json({ message: "Search query is required" });
      }
      const results = await storage.searchUpsellRecommendations(organizationId2, q);
      res.json(results);
    } catch (error) {
      console.error("Error searching upsell recommendations:", error);
      res.status(500).json({ message: "Failed to search upsell recommendations" });
    }
  });
  app2.get("/api/upsell-recommendations/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const analytics = await storage.getUpsellRecommendationAnalytics(organizationId2);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching upsell analytics:", error);
      res.status(500).json({ message: "Failed to fetch upsell analytics" });
    }
  });
  app2.get("/api/upsell-recommendations/types", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const types = await storage.getUpsellRecommendationTypes(organizationId2);
      res.json(types);
    } catch (error) {
      console.error("Error fetching upsell recommendation types:", error);
      res.status(500).json({ message: "Failed to fetch upsell recommendation types" });
    }
  });
  app2.post("/api/upsell-recommendations", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const recommendationData = {
        ...req.body,
        organizationId: organizationId2
      };
      const recommendation = await storage.createUpsellRecommendation(recommendationData);
      res.status(201).json(recommendation);
    } catch (error) {
      console.error("Error creating upsell recommendation:", error);
      res.status(500).json({ message: "Failed to create upsell recommendation" });
    }
  });
  app2.put("/api/upsell-recommendations/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const recommendation = await storage.updateUpsellRecommendation(parseInt(id), req.body);
      if (!recommendation) {
        return res.status(404).json({ message: "Upsell recommendation not found" });
      }
      res.json(recommendation);
    } catch (error) {
      console.error("Error updating upsell recommendation:", error);
      res.status(500).json({ message: "Failed to update upsell recommendation" });
    }
  });
  app2.delete("/api/upsell-recommendations/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const success = await storage.deleteUpsellRecommendation(parseInt(id));
      if (!success) {
        return res.status(404).json({ message: "Upsell recommendation not found" });
      }
      res.json({ message: "Upsell recommendation deleted successfully" });
    } catch (error) {
      console.error("Error deleting upsell recommendation:", error);
      res.status(500).json({ message: "Failed to delete upsell recommendation" });
    }
  });
  app2.post("/api/upsell-recommendations/generate", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { guestId, propertyId } = req.body;
      if (!guestId || !propertyId) {
        return res.status(400).json({ message: "guestId and propertyId are required" });
      }
      const result = await storage.generateSmartUpsellRecommendations(organizationId2, guestId, propertyId);
      res.json(result);
    } catch (error) {
      console.error("Error generating smart upsell recommendations:", error);
      res.status(500).json({ message: "Failed to generate smart upsell recommendations" });
    }
  });
  app2.put("/api/guest-activity-preferences/:reservationId", async (req, res) => {
    try {
      const reservationId = req.params.reservationId;
      const preferences = await storage.updateGuestActivityPreferences(reservationId, req.body);
      res.json(preferences);
    } catch (error) {
      console.error("Error updating guest preferences:", error);
      res.status(500).json({ message: "Failed to update guest preferences" });
    }
  });
  app2.post("/api/guest-recommendation-interactions", async (req, res) => {
    try {
      const interaction = await storage.createRecommendationInteraction(req.body);
      res.status(201).json(interaction);
    } catch (error) {
      console.error("Error tracking recommendation interaction:", error);
      res.status(500).json({ message: "Failed to track recommendation interaction" });
    }
  });
  app2.get("/api/guest-recommendation-interactions/:reservationId", async (req, res) => {
    try {
      const reservationId = req.params.reservationId;
      const { recommendationId, interactionType } = req.query;
      const filters = {};
      if (recommendationId) filters.recommendationId = parseInt(recommendationId);
      if (interactionType) filters.interactionType = interactionType;
      const interactions = await storage.getRecommendationInteractions(reservationId, filters);
      res.json(interactions);
    } catch (error) {
      console.error("Error fetching recommendation interactions:", error);
      res.status(500).json({ message: "Failed to fetch recommendation interactions" });
    }
  });
  app2.get("/api/recommendation-analytics/:propertyId", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const propertyId = parseInt(req.params.propertyId);
      const { fromDate, toDate, category } = req.query;
      const filters = {};
      if (fromDate) filters.fromDate = new Date(fromDate);
      if (toDate) filters.toDate = new Date(toDate);
      if (category) filters.category = category;
      const analytics = await storage.getRecommendationAnalytics(organizationId2, propertyId, filters);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching recommendation analytics:", error);
      res.status(500).json({ message: "Failed to fetch recommendation analytics" });
    }
  });
  app2.post("/api/admin/property-activity-recommendations", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied. Admin or Portfolio Manager role required." });
      }
      const recommendationData = {
        ...req.body,
        organizationId: "default-org",
        createdBy: user.username
      };
      const recommendation = await storage.createPropertyActivityRecommendation(recommendationData);
      res.status(201).json(recommendation);
    } catch (error) {
      console.error("Error creating property recommendation:", error);
      res.status(500).json({ message: "Failed to create property recommendation" });
    }
  });
  app2.put("/api/admin/property-activity-recommendations/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied. Admin or Portfolio Manager role required." });
      }
      const recommendationId = parseInt(req.params.id);
      const recommendation = await storage.updatePropertyActivityRecommendation(recommendationId, req.body);
      res.json(recommendation);
    } catch (error) {
      console.error("Error updating property recommendation:", error);
      res.status(500).json({ message: "Failed to update property recommendation" });
    }
  });
  app2.delete("/api/admin/property-activity-recommendations/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied. Admin or Portfolio Manager role required." });
      }
      const recommendationId = parseInt(req.params.id);
      const success = await storage.deletePropertyActivityRecommendation(recommendationId);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting property recommendation:", error);
      res.status(500).json({ message: "Failed to delete property recommendation" });
    }
  });
  app2.get("/api/guest-addon-services", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const { category, isActive } = req.query;
      const filters = {};
      if (category) filters.category = category;
      if (isActive !== void 0) filters.isActive = isActive === "true";
      const services = await storage.getGuestAddonServices(organizationId2, filters);
      res.json(services);
    } catch (error) {
      console.error("Error fetching guest addon services:", error);
      res.status(500).json({ message: "Failed to fetch guest addon services" });
    }
  });
  app2.get("/api/guest-addon-services/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const serviceId = parseInt(req.params.id);
      const service = await storage.getGuestAddonServiceById(serviceId);
      if (!service) {
        return res.status(404).json({ message: "Guest addon service not found" });
      }
      res.json(service);
    } catch (error) {
      console.error("Error fetching guest addon service:", error);
      res.status(500).json({ message: "Failed to fetch guest addon service" });
    }
  });
  app2.post("/api/guest-addon-services", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const user = req.user;
      const serviceData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: user.id
      };
      const service = await storage.createGuestAddonService(serviceData);
      res.status(201).json(service);
    } catch (error) {
      console.error("Error creating guest addon service:", error);
      res.status(500).json({ message: "Failed to create guest addon service" });
    }
  });
  app2.put("/api/guest-addon-services/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const serviceId = parseInt(req.params.id);
      const service = await storage.updateGuestAddonService(serviceId, req.body);
      if (!service) {
        return res.status(404).json({ message: "Guest addon service not found" });
      }
      res.json(service);
    } catch (error) {
      console.error("Error updating guest addon service:", error);
      res.status(500).json({ message: "Failed to update guest addon service" });
    }
  });
  app2.delete("/api/guest-addon-services/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const serviceId = parseInt(req.params.id);
      const success = await storage.deleteGuestAddonService(serviceId);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting guest addon service:", error);
      res.status(500).json({ message: "Failed to delete guest addon service" });
    }
  });
  app2.get("/api/guest-addon-bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const { propertyId, status, billingRoute } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (status) filters.status = status;
      if (billingRoute) filters.billingRoute = billingRoute;
      const bookings3 = await storage.getGuestAddonBookings(organizationId2, filters);
      res.json(bookings3);
    } catch (error) {
      console.error("Error fetching guest addon bookings:", error);
      res.status(500).json({ message: "Failed to fetch guest addon bookings" });
    }
  });
  app2.get("/api/guest-addon-bookings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const bookingId = parseInt(req.params.id);
      const booking = await storage.getGuestAddonBookingById(bookingId);
      if (!booking) {
        return res.status(404).json({ message: "Guest addon booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error fetching guest addon booking:", error);
      res.status(500).json({ message: "Failed to fetch guest addon booking" });
    }
  });
  app2.post("/api/guest-addon-bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const bookingData = {
        ...req.body,
        organizationId: organizationId2,
        bookingDate: /* @__PURE__ */ new Date()
      };
      const booking = await storage.createGuestAddonBooking(bookingData);
      res.status(201).json(booking);
    } catch (error) {
      console.error("Error creating guest addon booking:", error);
      res.status(500).json({ message: "Failed to create guest addon booking" });
    }
  });
  app2.put("/api/guest-addon-bookings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const bookingId = parseInt(req.params.id);
      const booking = await storage.updateGuestAddonBooking(bookingId, req.body);
      if (!booking) {
        return res.status(404).json({ message: "Guest addon booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error updating guest addon booking:", error);
      res.status(500).json({ message: "Failed to update guest addon booking" });
    }
  });
  app2.put("/api/guest-addon-bookings/:id/confirm", isDemoAuthenticated, async (req, res) => {
    try {
      const bookingId = parseInt(req.params.id);
      const user = req.user;
      const booking = await storage.confirmGuestAddonBooking(bookingId, user.username);
      if (!booking) {
        return res.status(404).json({ message: "Guest addon booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error confirming guest addon booking:", error);
      res.status(500).json({ message: "Failed to confirm guest addon booking" });
    }
  });
  app2.put("/api/guest-addon-bookings/:id/cancel", isDemoAuthenticated, async (req, res) => {
    try {
      const bookingId = parseInt(req.params.id);
      const user = req.user;
      const { reason } = req.body;
      const booking = await storage.cancelGuestAddonBooking(bookingId, user.username, reason);
      if (!booking) {
        return res.status(404).json({ message: "Guest addon booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error cancelling guest addon booking:", error);
      res.status(500).json({ message: "Failed to cancel guest addon booking" });
    }
  });
  app2.put("/api/guest-addon-bookings/:id/payment", isDemoAuthenticated, async (req, res) => {
    try {
      const bookingId = parseInt(req.params.id);
      const { paymentStatus, paymentMethod, stripePaymentIntentId } = req.body;
      const booking = await storage.updateBookingPaymentStatus(
        bookingId,
        paymentStatus,
        paymentMethod,
        stripePaymentIntentId
      );
      if (!booking) {
        return res.status(404).json({ message: "Guest addon booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error updating booking payment status:", error);
      res.status(500).json({ message: "Failed to update booking payment status" });
    }
  });
  app2.get("/api/guest-portal/:accessToken", async (req, res) => {
    try {
      const { accessToken } = req.params;
      const access = await storage.getGuestPortalAccess(accessToken);
      if (!access || !access.isActive || access.expiresAt < /* @__PURE__ */ new Date()) {
        return res.status(401).json({ message: "Invalid or expired access token" });
      }
      await storage.updateGuestPortalAccessActivity(accessToken);
      res.json(access);
    } catch (error) {
      console.error("Error verifying guest portal access:", error);
      res.status(500).json({ message: "Failed to verify guest portal access" });
    }
  });
  app2.post("/api/guest-portal", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const user = req.user;
      const accessData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: user.id,
        accessToken: `guest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        isActive: true,
        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3)
        // 30 days
      };
      const access = await storage.createGuestPortalAccess(accessData);
      res.status(201).json(access);
    } catch (error) {
      console.error("Error creating guest portal access:", error);
      res.status(500).json({ message: "Failed to create guest portal access" });
    }
  });
  app2.put("/api/guest-portal/:accessToken/deactivate", isDemoAuthenticated, async (req, res) => {
    try {
      const { accessToken } = req.params;
      const success = await storage.deactivateGuestPortalAccess(accessToken);
      res.json({ success });
    } catch (error) {
      console.error("Error deactivating guest portal access:", error);
      res.status(500).json({ message: "Failed to deactivate guest portal access" });
    }
  });
  app2.get("/api/guest-addon-analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const { fromDate, toDate } = req.query;
      const filters = {};
      if (fromDate) filters.fromDate = new Date(fromDate);
      if (toDate) filters.toDate = new Date(toDate);
      const analytics = await storage.getGuestAddonServiceAnalytics(organizationId2, filters);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching guest addon service analytics:", error);
      res.status(500).json({ message: "Failed to fetch guest addon service analytics" });
    }
  });
  app2.get("/api/agent-media-library", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId;
      const agentId = user.id;
      const { propertyStatus: propertyStatus3, mediaType } = req.query;
      const filters = {};
      if (propertyStatus3) filters.propertyStatus = propertyStatus3;
      if (mediaType) filters.mediaType = mediaType;
      const data = await storage.getAgentMediaLibraryData(organizationId2, agentId, filters);
      res.json(data);
    } catch (error) {
      console.error("Error fetching agent media library data:", error);
      res.status(500).json({ message: "Failed to fetch agent media library data" });
    }
  });
  app2.get("/api/property-media", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId;
      const { propertyId, mediaType, isAgentApproved } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (mediaType) filters.mediaType = mediaType;
      if (user.role === "retail-agent" || user.role === "referral-agent") {
        filters.isAgentApproved = true;
      } else if (isAgentApproved !== void 0) {
        filters.isAgentApproved = isAgentApproved === "true";
      }
      const media = await storage.getPropertyMedia(organizationId2, filters);
      res.json(media);
    } catch (error) {
      console.error("Error fetching property media:", error);
      res.status(500).json({ message: "Failed to fetch property media" });
    }
  });
  app2.post("/api/property-media", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Only admins and portfolio managers can upload media" });
      }
      const organizationId2 = user.organizationId;
      const {
        propertyId,
        mediaType,
        title,
        description,
        mediaUrl,
        thumbnailUrl,
        fileSize,
        mimeType,
        displayOrder,
        tags
      } = req.body;
      if (!propertyId || !mediaType || !title || !mediaUrl) {
        return res.status(400).json({ message: "Property ID, media type, title, and media URL are required" });
      }
      const mediaData = {
        organizationId: organizationId2,
        propertyId: parseInt(propertyId),
        mediaType,
        title,
        description,
        mediaUrl,
        thumbnailUrl,
        fileSize: fileSize ? parseInt(fileSize) : null,
        mimeType,
        displayOrder: displayOrder || 0,
        tags: tags || [],
        isAgentApproved: false,
        // New uploads need approval
        uploadedBy: user.id
      };
      const newMedia = await storage.createPropertyMedia(mediaData);
      res.status(201).json(newMedia);
    } catch (error) {
      console.error("Error uploading property media:", error);
      res.status(500).json({ message: "Failed to upload property media" });
    }
  });
  app2.patch("/api/property-media/:id/approve", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Only admins and portfolio managers can approve media" });
      }
      const mediaId = parseInt(req.params.id);
      const approvedMedia = await storage.approveMediaForAgents(mediaId, user.id);
      if (!approvedMedia) {
        return res.status(404).json({ message: "Media not found" });
      }
      res.json(approvedMedia);
    } catch (error) {
      console.error("Error approving media:", error);
      res.status(500).json({ message: "Failed to approve media" });
    }
  });
  app2.patch("/api/property-media/:id", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Only admins and portfolio managers can update media" });
      }
      const mediaId = parseInt(req.params.id);
      const updates = req.body;
      const updatedMedia = await storage.updatePropertyMedia(mediaId, updates);
      if (!updatedMedia) {
        return res.status(404).json({ message: "Media not found" });
      }
      res.json(updatedMedia);
    } catch (error) {
      console.error("Error updating property media:", error);
      res.status(500).json({ message: "Failed to update property media" });
    }
  });
  app2.delete("/api/property-media/:id", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Only admins and portfolio managers can delete media" });
      }
      const mediaId = parseInt(req.params.id);
      await storage.deletePropertyMedia(mediaId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting property media:", error);
      res.status(500).json({ message: "Failed to delete property media" });
    }
  });
  app2.get("/api/guest-dashboard/current-booking", async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const guestId = "guest-1";
      const booking = await storage.getCurrentGuestBooking(organizationId2, guestId);
      res.json(booking);
    } catch (error) {
      console.error("Error fetching current booking:", error);
      res.status(500).json({ message: "Failed to fetch current booking" });
    }
  });
  app2.get("/api/guest-dashboard/property-amenities/:propertyId", async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const propertyId = parseInt(req.params.propertyId);
      const amenities = await storage.getPropertyAmenities(organizationId2, propertyId);
      res.json(amenities);
    } catch (error) {
      console.error("Error fetching property amenities:", error);
      res.status(500).json({ message: "Failed to fetch property amenities" });
    }
  });
  app2.get("/api/guest-dashboard/ai-recommendations/:propertyId", async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const propertyId = parseInt(req.params.propertyId);
      const recommendations = await storage.getAiRecommendations(organizationId2, propertyId);
      res.json(recommendations);
    } catch (error) {
      console.error("Error fetching AI recommendations:", error);
      res.status(500).json({ message: "Failed to fetch AI recommendations" });
    }
  });
  app2.get("/api/guest-dashboard/booking-overview/:guestId", async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const guestId = req.params.guestId;
      const bookingOverview = await storage.getGuestBookingOverview(organizationId2, guestId);
      res.json(bookingOverview);
    } catch (error) {
      console.error("Error fetching guest booking overview:", error);
      res.status(500).json({ message: "Failed to fetch booking overview" });
    }
  });
  app2.get("/api/guest-dashboard/services-ordered/:bookingId", async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const bookingId = parseInt(req.params.bookingId);
      const servicesOrdered = await storage.getGuestServicesOrdered(organizationId2, bookingId);
      res.json(servicesOrdered);
    } catch (error) {
      console.error("Error fetching guest services ordered:", error);
      res.status(500).json({ message: "Failed to fetch services ordered" });
    }
  });
  app2.get("/api/guest-dashboard/electricity-billing/:bookingId", async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const bookingId = parseInt(req.params.bookingId);
      const electricityBilling = await storage.getGuestElectricityBilling(organizationId2, bookingId);
      res.json(electricityBilling);
    } catch (error) {
      console.error("Error fetching guest electricity billing:", error);
      res.status(500).json({ message: "Failed to fetch electricity billing" });
    }
  });
  app2.get("/api/guest-dashboard/deposit-overview/:bookingId", async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const bookingId = parseInt(req.params.bookingId);
      const depositOverview = await storage.getGuestDepositOverview(organizationId2, bookingId);
      res.json(depositOverview);
    } catch (error) {
      console.error("Error fetching guest deposit overview:", error);
      res.status(500).json({ message: "Failed to fetch deposit overview" });
    }
  });
  app2.get("/api/guest-dashboard/service-timeline/:propertyId", async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const propertyId = parseInt(req.params.propertyId);
      const timeline = await storage.getGuestServiceTimeline(organizationId2, propertyId);
      res.json(timeline);
    } catch (error) {
      console.error("Error fetching service timeline:", error);
      res.status(500).json({ message: "Failed to fetch service timeline" });
    }
  });
  app2.get("/api/property-internal-notes", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId;
      const { propertyId, category, isVisibleToAgents } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (category) filters.category = category;
      if (user.role === "retail-agent" || user.role === "referral-agent") {
        filters.isVisibleToAgents = true;
      } else if (isVisibleToAgents !== void 0) {
        filters.isVisibleToAgents = isVisibleToAgents === "true";
      }
      const notes = await storage.getPropertyInternalNotes(organizationId2, filters);
      res.json(notes);
    } catch (error) {
      console.error("Error fetching property internal notes:", error);
      res.status(500).json({ message: "Failed to fetch property internal notes" });
    }
  });
  app2.post("/api/property-internal-notes", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Only admins and portfolio managers can create internal notes" });
      }
      const organizationId2 = user.organizationId;
      const {
        propertyId,
        category,
        title,
        content,
        isVisibleToAgents,
        tags
      } = req.body;
      if (!propertyId || !title || !content) {
        return res.status(400).json({ message: "Property ID, title, and content are required" });
      }
      const noteData = {
        organizationId: organizationId2,
        propertyId: parseInt(propertyId),
        category: category || "general",
        title,
        content,
        isVisibleToAgents: isVisibleToAgents || false,
        tags: tags || [],
        createdBy: user.id
      };
      const newNote = await storage.createPropertyInternalNote(noteData);
      res.status(201).json(newNote);
    } catch (error) {
      console.error("Error creating property internal note:", error);
      res.status(500).json({ message: "Failed to create property internal note" });
    }
  });
  app2.patch("/api/property-internal-notes/:id", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Only admins and portfolio managers can update internal notes" });
      }
      const noteId = parseInt(req.params.id);
      const updates = req.body;
      const updatedNote = await storage.updatePropertyInternalNote(noteId, updates);
      if (!updatedNote) {
        return res.status(404).json({ message: "Internal note not found" });
      }
      res.json(updatedNote);
    } catch (error) {
      console.error("Error updating property internal note:", error);
      res.status(500).json({ message: "Failed to update property internal note" });
    }
  });
  app2.delete("/api/property-internal-notes/:id", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Only admins and portfolio managers can delete internal notes" });
      }
      const noteId = parseInt(req.params.id);
      await storage.deletePropertyInternalNote(noteId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting property internal note:", error);
      res.status(500).json({ message: "Failed to delete property internal note" });
    }
  });
  app2.post("/api/agent-media-access", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const { mediaId, actionType } = req.body;
      if (!mediaId || !actionType) {
        return res.status(400).json({ message: "Media ID and action type are required" });
      }
      const accessData = {
        organizationId: user.organizationId,
        agentId: user.id,
        mediaId: parseInt(mediaId),
        accessGrantedBy: user.id,
        // Self-granted for agent access
        lastViewedAt: actionType === "view" ? /* @__PURE__ */ new Date() : null,
        copyCount: actionType === "copy" ? 1 : 0
      };
      if (actionType === "view") {
        await storage.updateAgentMediaLastViewed(user.id, parseInt(mediaId));
      } else if (actionType === "copy") {
        await storage.incrementCopyCount(user.id, parseInt(mediaId));
      }
      const accessRecord = await storage.trackAgentMediaAccess(accessData);
      res.status(201).json(accessRecord);
    } catch (error) {
      console.error("Error tracking agent media access:", error);
      res.status(500).json({ message: "Failed to track agent media access" });
    }
  });
  app2.get("/api/guest-addon-services", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const { category, isActive } = req.query;
      const filters = {};
      if (category) filters.category = category;
      if (isActive !== void 0) filters.isActive = isActive === "true";
      const services = await storage.getGuestAddonServices(organizationId2, filters);
      res.json(services);
    } catch (error) {
      console.error("Error fetching guest add-on services:", error);
      res.status(500).json({ message: "Failed to fetch services" });
    }
  });
  app2.get("/api/guest-addon-services/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const service = await storage.getGuestAddonServiceById(parseInt(req.params.id));
      if (!service) {
        return res.status(404).json({ message: "Service not found" });
      }
      res.json(service);
    } catch (error) {
      console.error("Error fetching guest add-on service:", error);
      res.status(500).json({ message: "Failed to fetch service" });
    }
  });
  app2.post("/api/guest-addon-services", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const serviceData = {
        ...req.body,
        organizationId: organizationId2
      };
      const service = await storage.createGuestAddonService(serviceData);
      res.status(201).json(service);
    } catch (error) {
      console.error("Error creating guest add-on service:", error);
      res.status(500).json({ message: "Failed to create service" });
    }
  });
  app2.patch("/api/guest-addon-services/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const service = await storage.updateGuestAddonService(parseInt(req.params.id), req.body);
      if (!service) {
        return res.status(404).json({ message: "Service not found" });
      }
      res.json(service);
    } catch (error) {
      console.error("Error updating guest add-on service:", error);
      res.status(500).json({ message: "Failed to update service" });
    }
  });
  app2.delete("/api/guest-addon-services/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const success = await storage.deleteGuestAddonService(parseInt(req.params.id));
      if (!success) {
        return res.status(404).json({ message: "Service not found" });
      }
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting guest add-on service:", error);
      res.status(500).json({ message: "Failed to delete service" });
    }
  });
  app2.get("/api/guest-addon-bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const { propertyId, status, billingRoute } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (status) filters.status = status;
      if (billingRoute) filters.billingRoute = billingRoute;
      const bookings3 = await storage.getGuestAddonBookings(organizationId2, filters);
      res.json(bookings3);
    } catch (error) {
      console.error("Error fetching guest add-on bookings:", error);
      res.status(500).json({ message: "Failed to fetch bookings" });
    }
  });
  app2.get("/api/guest-addon-bookings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const booking = await storage.getGuestAddonBookingById(parseInt(req.params.id));
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error fetching guest add-on booking:", error);
      res.status(500).json({ message: "Failed to fetch booking" });
    }
  });
  app2.post("/api/guest-addon-bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const bookingData = {
        ...req.body,
        organizationId: organizationId2
      };
      const booking = await storage.createGuestAddonBooking(bookingData);
      if (booking.status === "completed") {
        const service = await storage.getGuestAddonServiceById(booking.serviceId);
        const property = await storage.getPropertyById(booking.propertyId);
        if (service && property) {
          await storage.createFinance({
            organizationId: organizationId2,
            amount: booking.totalAmount,
            type: booking.billingRoute === "guest_billable" ? "income" : "expense",
            description: `${service.serviceName} - ${booking.guestName}`,
            category: `addon_${service.category}`,
            propertyId: booking.propertyId,
            source: booking.billingRoute,
            referenceNumber: `ADDON-${booking.id}`,
            processedBy: req.user.id
          });
        }
      }
      res.status(201).json(booking);
    } catch (error) {
      console.error("Error creating guest add-on booking:", error);
      res.status(500).json({ message: "Failed to create booking" });
    }
  });
  app2.patch("/api/guest-addon-bookings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const booking = await storage.updateGuestAddonBooking(parseInt(req.params.id), req.body);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      if (req.body.status === "completed" && booking.status === "completed") {
        const service = await storage.getGuestAddonServiceById(booking.serviceId);
        const property = await storage.getPropertyById(booking.propertyId);
        if (service && property) {
          await storage.createFinance({
            organizationId: req.user.organizationId,
            amount: booking.totalAmount,
            type: booking.billingRoute === "guest_billable" ? "income" : "expense",
            description: `${service.serviceName} - ${booking.guestName}`,
            category: `addon_${service.category}`,
            propertyId: booking.propertyId,
            source: booking.billingRoute,
            referenceNumber: `ADDON-${booking.id}`,
            processedBy: req.user.id
          });
        }
      }
      res.json(booking);
    } catch (error) {
      console.error("Error updating guest add-on booking:", error);
      res.status(500).json({ message: "Failed to update booking" });
    }
  });
  app2.post("/api/guest-addon-bookings/:id/confirm", isDemoAuthenticated, async (req, res) => {
    try {
      const booking = await storage.confirmGuestAddonBooking(parseInt(req.params.id), req.user.id);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error confirming guest add-on booking:", error);
      res.status(500).json({ message: "Failed to confirm booking" });
    }
  });
  app2.post("/api/guest-addon-bookings/:id/cancel", isDemoAuthenticated, async (req, res) => {
    try {
      const { reason } = req.body;
      const booking = await storage.cancelGuestAddonBooking(parseInt(req.params.id), req.user.id, reason);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error cancelling guest add-on booking:", error);
      res.status(500).json({ message: "Failed to cancel booking" });
    }
  });
  const { OwnerTargetUpgradeStorage: OwnerTargetUpgradeStorage2 } = await Promise.resolve().then(() => (init_ownerTargetUpgradeStorage(), ownerTargetUpgradeStorage_exports));
  app2.get("/api/targets", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const { propertyId, targetYear, targetQuarter, isActive } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (targetYear) filters.targetYear = parseInt(targetYear);
      if (targetQuarter) filters.targetQuarter = parseInt(targetQuarter);
      if (isActive !== void 0) filters.isActive = isActive === "true";
      const targets = await targetStorage.getRevenueTargets(filters);
      res.json(targets);
    } catch (error) {
      console.error("Error fetching revenue targets:", error);
      res.status(500).json({ message: "Failed to fetch revenue targets" });
    }
  });
  app2.get("/api/targets/demo", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const targets = await targetStorage.getDemoRevenueTargets();
      res.json(targets);
    } catch (error) {
      console.error("Error fetching demo revenue targets:", error);
      res.status(500).json({ message: "Failed to fetch demo revenue targets" });
    }
  });
  app2.post("/api/targets", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const user = req.user;
      const targetData = {
        ...req.body,
        createdBy: user.id
      };
      const target = await targetStorage.createRevenueTarget(targetData);
      res.json(target);
    } catch (error) {
      console.error("Error creating revenue target:", error);
      res.status(500).json({ message: "Failed to create revenue target" });
    }
  });
  app2.put("/api/targets/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const targetId = parseInt(req.params.id);
      const target = await targetStorage.updateRevenueTarget(targetId, req.body);
      if (!target) {
        return res.status(404).json({ message: "Revenue target not found" });
      }
      res.json(target);
    } catch (error) {
      console.error("Error updating revenue target:", error);
      res.status(500).json({ message: "Failed to update revenue target" });
    }
  });
  app2.delete("/api/targets/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const targetId = parseInt(req.params.id);
      const deleted = await targetStorage.deleteRevenueTarget(targetId);
      if (!deleted) {
        return res.status(404).json({ message: "Revenue target not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting revenue target:", error);
      res.status(500).json({ message: "Failed to delete revenue target" });
    }
  });
  app2.get("/api/upgrades", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const { propertyId, targetId, status, priority, category } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (targetId) filters.targetId = parseInt(targetId);
      if (status) filters.status = status;
      if (priority) filters.priority = priority;
      if (category) filters.category = category;
      const upgrades = await targetStorage.getUpgradeWishlist(filters);
      res.json(upgrades);
    } catch (error) {
      console.error("Error fetching upgrade wishlist:", error);
      res.status(500).json({ message: "Failed to fetch upgrade wishlist" });
    }
  });
  app2.get("/api/upgrades/demo", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const upgrades = await targetStorage.getDemoUpgradeWishlist();
      res.json(upgrades);
    } catch (error) {
      console.error("Error fetching demo upgrade wishlist:", error);
      res.status(500).json({ message: "Failed to fetch demo upgrade wishlist" });
    }
  });
  app2.post("/api/upgrades", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const user = req.user;
      const upgradeData = {
        ...req.body,
        createdBy: user.id
      };
      const upgrade = await targetStorage.createUpgradeItem(upgradeData);
      res.json(upgrade);
    } catch (error) {
      console.error("Error creating upgrade item:", error);
      res.status(500).json({ message: "Failed to create upgrade item" });
    }
  });
  app2.put("/api/upgrades/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const upgradeId = parseInt(req.params.id);
      const upgrade = await targetStorage.updateUpgradeItem(upgradeId, req.body);
      if (!upgrade) {
        return res.status(404).json({ message: "Upgrade item not found" });
      }
      res.json(upgrade);
    } catch (error) {
      console.error("Error updating upgrade item:", error);
      res.status(500).json({ message: "Failed to update upgrade item" });
    }
  });
  app2.post("/api/upgrades/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const upgradeId = parseInt(req.params.id);
      const user = req.user;
      const upgrade = await targetStorage.approveUpgradeItem(upgradeId, user.id);
      if (!upgrade) {
        return res.status(404).json({ message: "Upgrade item not found" });
      }
      res.json(upgrade);
    } catch (error) {
      console.error("Error approving upgrade item:", error);
      res.status(500).json({ message: "Failed to approve upgrade item" });
    }
  });
  app2.post("/api/upgrades/:id/complete", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const upgradeId = parseInt(req.params.id);
      const upgrade = await targetStorage.completeUpgradeItem(upgradeId);
      if (!upgrade) {
        return res.status(404).json({ message: "Upgrade item not found" });
      }
      res.json(upgrade);
    } catch (error) {
      console.error("Error completing upgrade item:", error);
      res.status(500).json({ message: "Failed to complete upgrade item" });
    }
  });
  app2.delete("/api/upgrades/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const upgradeId = parseInt(req.params.id);
      const deleted = await targetStorage.deleteUpgradeItem(upgradeId);
      if (!deleted) {
        return res.status(404).json({ message: "Upgrade item not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting upgrade item:", error);
      res.status(500).json({ message: "Failed to delete upgrade item" });
    }
  });
  app2.get("/api/target-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const { propertyId, suggestionType, isRead, isDismissed } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (suggestionType) filters.suggestionType = suggestionType;
      if (isRead !== void 0) filters.isRead = isRead === "true";
      if (isDismissed !== void 0) filters.isDismissed = isDismissed === "true";
      const suggestions = await targetStorage.getSuggestions(filters);
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching target suggestions:", error);
      res.status(500).json({ message: "Failed to fetch target suggestions" });
    }
  });
  app2.get("/api/target-suggestions/demo", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const suggestions = await targetStorage.getDemoSuggestions();
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching demo target suggestions:", error);
      res.status(500).json({ message: "Failed to fetch demo target suggestions" });
    }
  });
  app2.post("/api/target-suggestions/:id/read", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const suggestionId = parseInt(req.params.id);
      const suggestion = await targetStorage.markSuggestionAsRead(suggestionId);
      if (!suggestion) {
        return res.status(404).json({ message: "Suggestion not found" });
      }
      res.json(suggestion);
    } catch (error) {
      console.error("Error marking suggestion as read:", error);
      res.status(500).json({ message: "Failed to mark suggestion as read" });
    }
  });
  app2.post("/api/target-suggestions/:id/dismiss", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const suggestionId = parseInt(req.params.id);
      const suggestion = await targetStorage.dismissSuggestion(suggestionId);
      if (!suggestion) {
        return res.status(404).json({ message: "Suggestion not found" });
      }
      res.json(suggestion);
    } catch (error) {
      console.error("Error dismissing suggestion:", error);
      res.status(500).json({ message: "Failed to dismiss suggestion" });
    }
  });
  app2.get("/api/target-dashboard", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const { propertyId } = req.query;
      const dashboard = await targetStorage.getTargetDashboard(
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(dashboard);
    } catch (error) {
      console.error("Error fetching target dashboard:", error);
      res.status(500).json({ message: "Failed to fetch target dashboard" });
    }
  });
  app2.get("/api/targets/:id/progress", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const targetId = parseInt(req.params.id);
      const progress = await targetStorage.getProgressTracking(targetId);
      res.json(progress);
    } catch (error) {
      console.error("Error fetching target progress:", error);
      res.status(500).json({ message: "Failed to fetch target progress" });
    }
  });
  app2.post("/api/targets/:id/progress", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const targetStorage = new OwnerTargetUpgradeStorage2(organizationId2);
      const targetId = parseInt(req.params.id);
      const user = req.user;
      const progressData = {
        ...req.body,
        targetId,
        createdBy: user.id
      };
      const progress = await targetStorage.createProgressRecord(progressData);
      res.json(progress);
    } catch (error) {
      console.error("Error creating progress record:", error);
      res.status(500).json({ message: "Failed to create progress record" });
    }
  });
  app2.get("/api/owner/dashboard/stats", isDemoAuthenticated, async (req, res) => {
    try {
      const { startDate, endDate, propertyId } = req.query;
      const filters = {
        startDate,
        endDate,
        propertyId: propertyId ? parseInt(propertyId) : void 0
      };
      const stats = await storage.getOwnerDashboardStats(req.user.organizationId, req.user.id, filters);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching owner dashboard stats:", error);
      res.status(500).json({ message: "Failed to fetch dashboard stats" });
    }
  });
  app2.get("/api/owner/dashboard/financial-summary", isDemoAuthenticated, async (req, res) => {
    try {
      const { startDate, endDate, propertyId, currency } = req.query;
      const filters = {
        startDate,
        endDate,
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        currency
      };
      const summary = await storage.getOwnerFinancialSummary(req.user.organizationId, req.user.id, filters);
      res.json(summary);
    } catch (error) {
      console.error("Error fetching owner financial summary:", error);
      res.status(500).json({ message: "Failed to fetch financial summary" });
    }
  });
  app2.get("/api/owner/dashboard/activity", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyId, activityType, startDate, endDate, limit } = req.query;
      const filters = {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        activityType,
        startDate,
        endDate,
        limit: limit ? parseInt(limit) : void 0
      };
      const activities = await storage.getOwnerActivityTimeline(req.user.organizationId, req.user.id, filters);
      res.json(activities);
    } catch (error) {
      console.error("Error fetching owner activity timeline:", error);
      res.status(500).json({ message: "Failed to fetch activity timeline" });
    }
  });
  app2.post("/api/owner/dashboard/activity", isDemoAuthenticated, async (req, res) => {
    try {
      const validatedData = insertOwnerActivityTimelineSchema.parse({
        ...req.body,
        organizationId: req.user.organizationId,
        createdBy: req.user.id
      });
      const activity = await storage.createOwnerActivityTimeline(validatedData);
      res.json(activity);
    } catch (error) {
      console.error("Error creating owner activity:", error);
      res.status(500).json({ message: "Failed to create activity" });
    }
  });
  app2.get("/api/owner/dashboard/payouts", isDemoAuthenticated, async (req, res) => {
    try {
      const { status, startDate, endDate } = req.query;
      const filters = {
        status,
        startDate,
        endDate
      };
      const payouts = await storage.getOwnerPayoutRequests(req.user.organizationId, req.user.id, filters);
      res.json(payouts);
    } catch (error) {
      console.error("Error fetching owner payout requests:", error);
      res.status(500).json({ message: "Failed to fetch payout requests" });
    }
  });
  app2.post("/api/owner/dashboard/payouts", isDemoAuthenticated, async (req, res) => {
    try {
      const validatedData = insertOwnerPayoutRequestSchema.parse({
        ...req.body,
        organizationId: req.user.organizationId,
        ownerId: req.user.id,
        status: "pending"
      });
      const payout = await storage.createOwnerPayoutRequest(validatedData);
      res.json(payout);
    } catch (error) {
      console.error("Error creating owner payout request:", error);
      res.status(500).json({ message: "Failed to create payout request" });
    }
  });
  app2.patch("/api/owner/dashboard/payouts/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      const payout = await storage.updateOwnerPayoutRequest(parseInt(id), updates);
      if (!payout) {
        return res.status(404).json({ message: "Payout request not found" });
      }
      res.json(payout);
    } catch (error) {
      console.error("Error updating payout request:", error);
      res.status(500).json({ message: "Failed to update payout request" });
    }
  });
  app2.post("/api/owner/dashboard/payouts/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { notes } = req.body;
      const payout = await storage.approvePayoutRequest(parseInt(id), req.user.id, notes);
      if (!payout) {
        return res.status(404).json({ message: "Payout request not found" });
      }
      res.json(payout);
    } catch (error) {
      console.error("Error approving payout request:", error);
      res.status(500).json({ message: "Failed to approve payout request" });
    }
  });
  app2.post("/api/owner/dashboard/payouts/:id/complete", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { paymentMethod, paymentReference, paymentReceiptUrl } = req.body;
      const payout = await storage.completePayoutRequest(parseInt(id), req.user.id, {
        paymentMethod,
        paymentReference,
        paymentReceiptUrl
      });
      if (!payout) {
        return res.status(404).json({ message: "Payout request not found" });
      }
      res.json(payout);
    } catch (error) {
      console.error("Error completing payout request:", error);
      res.status(500).json({ message: "Failed to complete payout request" });
    }
  });
  app2.get("/api/owner/dashboard/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyId, invoiceType, status, startDate, endDate } = req.query;
      const filters = {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        invoiceType,
        status,
        startDate,
        endDate
      };
      const invoices2 = await storage.getOwnerInvoices(req.user.organizationId, req.user.id, filters);
      res.json(invoices2);
    } catch (error) {
      console.error("Error fetching owner invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });
  app2.post("/api/owner/dashboard/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const invoiceNumber = `INV-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const validatedData = insertOwnerInvoiceSchema.parse({
        ...req.body,
        organizationId: req.user.organizationId,
        invoiceNumber,
        createdBy: req.user.id
      });
      const invoice = await storage.createOwnerInvoice(validatedData);
      res.json(invoice);
    } catch (error) {
      console.error("Error creating owner invoice:", error);
      res.status(500).json({ message: "Failed to create invoice" });
    }
  });
  app2.patch("/api/owner/dashboard/invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      const invoice = await storage.updateOwnerInvoice(parseInt(id), updates);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json(invoice);
    } catch (error) {
      console.error("Error updating invoice:", error);
      res.status(500).json({ message: "Failed to update invoice" });
    }
  });
  app2.get("/api/owner/dashboard/preferences", isDemoAuthenticated, async (req, res) => {
    try {
      const preferences = await storage.getOwnerPreferences(req.user.organizationId, req.user.id);
      res.json(preferences);
    } catch (error) {
      console.error("Error fetching owner preferences:", error);
      res.status(500).json({ message: "Failed to fetch preferences" });
    }
  });
  app2.post("/api/owner/dashboard/preferences", isDemoAuthenticated, async (req, res) => {
    try {
      const validatedData = insertOwnerPreferencesSchema.parse({
        ...req.body,
        organizationId: req.user.organizationId,
        ownerId: req.user.id
      });
      const preferences = await storage.upsertOwnerPreferences(validatedData);
      res.json(preferences);
    } catch (error) {
      console.error("Error updating owner preferences:", error);
      res.status(500).json({ message: "Failed to update preferences" });
    }
  });
  app2.get("/api/owner/dashboard/bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const { startDate, endDate, status, propertyId } = req.query;
      const ownerProperties = await storage.getProperties(req.user.organizationId, { ownerId: req.user.id });
      const propertyIds = ownerProperties.map((p) => p.id);
      if (propertyIds.length === 0) {
        return res.json([]);
      }
      const filters = { propertyIds };
      if (startDate) filters.startDate = startDate;
      if (endDate) filters.endDate = endDate;
      if (status) filters.status = status;
      if (propertyId) filters.propertyId = parseInt(propertyId);
      const bookings3 = await storage.getBookings(req.user.organizationId, filters);
      const enhancedBookings = await Promise.all(
        bookings3.map(async (booking) => {
          const property = ownerProperties.find((p) => p.id === booking.propertyId);
          const finances3 = await storage.getFinances(req.user.organizationId, {
            bookingId: booking.id
          });
          const revenue = finances3.filter((f) => f.type === "income").reduce((sum4, f) => sum4 + parseFloat(f.amount), 0);
          return {
            ...booking,
            propertyName: property?.name,
            revenue,
            source: booking.source || "Direct"
          };
        })
      );
      res.json(enhancedBookings);
    } catch (error) {
      console.error("Error fetching owner bookings:", error);
      res.status(500).json({ message: "Failed to fetch bookings" });
    }
  });
  app2.get("/api/pm/dashboard/financial-overview", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.financialOverview || {
          totalCommissionEarnings: 0,
          propertyBreakdown: [],
          monthlyTrend: []
        });
        return;
      }
      res.json({
        totalCommissionEarnings: 0,
        propertyBreakdown: [],
        monthlyTrend: []
      });
    } catch (error) {
      console.error("Error fetching PM financial overview:", error);
      res.status(500).json({ message: "Failed to fetch financial overview" });
    }
  });
  app2.get("/api/pm/dashboard/balance", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.balance || {
          totalEarned: 0,
          totalPaid: 0,
          currentBalance: 0,
          lastPayoutDate: null
        });
        return;
      }
      res.json({
        totalEarned: 0,
        totalPaid: 0,
        currentBalance: 0,
        lastPayoutDate: null
      });
    } catch (error) {
      console.error("Error fetching PM balance:", error);
      res.status(500).json({ message: "Failed to fetch balance" });
    }
  });
  app2.get("/api/portfolio/property-access", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.propertyAccess || {});
        return;
      }
      res.json({});
    } catch (error) {
      console.error("Error fetching property access:", error);
      res.status(500).json({ message: "Failed to fetch property access" });
    }
  });
  app2.get("/api/portfolio/documents", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.documents || []);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching documents:", error);
      res.status(500).json({ message: "Failed to fetch documents" });
    }
  });
  app2.get("/api/portfolio/maintenance", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.maintenanceTasks || []);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching maintenance tasks:", error);
      res.status(500).json({ message: "Failed to fetch maintenance tasks" });
    }
  });
  app2.get("/api/portfolio/service-tracker", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.serviceTimeline || []);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching service timeline:", error);
      res.status(500).json({ message: "Failed to fetch service timeline" });
    }
  });
  app2.get("/api/portfolio/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.invoices || []);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });
  app2.get("/api/pm/dashboard/payouts", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: managerId } = req.user;
      const { status, startDate, endDate } = req.query;
      const payouts = await storage.getPMPayoutRequests(organizationId2, managerId, {
        status,
        startDate,
        endDate
      });
      res.json(payouts);
    } catch (error) {
      console.error("Error fetching PM payouts:", error);
      res.status(500).json({ message: "Failed to fetch payouts" });
    }
  });
  app2.post("/api/pm/dashboard/payouts", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: managerId } = req.user;
      const { amount, requestNotes } = req.body;
      const payoutRequest = await storage.createPMPayoutRequest({
        organizationId: organizationId2,
        managerId,
        amount: parseFloat(amount),
        requestNotes,
        currency: "AUD"
      });
      await storage.createNotification({
        organizationId: organizationId2,
        userId: "admin",
        // TODO: Get actual admin users
        type: "payout_request",
        title: "New PM Payout Request",
        message: `Portfolio Manager has requested a payout of $${amount}`,
        relatedType: "payout",
        relatedId: payoutRequest.id.toString(),
        priority: "medium"
      });
      res.json(payoutRequest);
    } catch (error) {
      console.error("Error creating PM payout request:", error);
      res.status(500).json({ message: "Failed to create payout request" });
    }
  });
  app2.patch("/api/pm/dashboard/payouts/:id/received", isDemoAuthenticated, async (req, res) => {
    try {
      const { id: managerId } = req.user;
      const { id } = req.params;
      const updated = await storage.markPMPaymentReceived(parseInt(id), managerId);
      if (!updated) {
        return res.status(404).json({ message: "Payout request not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error marking payment received:", error);
      res.status(500).json({ message: "Failed to mark payment received" });
    }
  });
  app2.get("/api/pm/dashboard/task-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.taskLogs || []);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching PM task logs:", error);
      res.status(500).json({ message: "Failed to fetch task logs" });
    }
  });
  app2.get("/api/pm/dashboard/portfolio", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json([demoData?.demoProperty]);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching PM portfolio:", error);
      res.status(500).json({ message: "Failed to fetch portfolio" });
    }
  });
  app2.get("/api/pm/dashboard/notifications", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.notifications || []);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching PM notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });
  app2.patch("/api/pm/dashboard/notifications/:id/read", isDemoAuthenticated, async (req, res) => {
    try {
      const { id: managerId } = req.user;
      const { id } = req.params;
      const updated = await storage.markPMNotificationAsRead(parseInt(id), managerId);
      if (!updated) {
        return res.status(404).json({ message: "Notification not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });
  app2.patch("/api/pm/dashboard/notifications/read-all", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: managerId } = req.user;
      await storage.markAllPMNotificationsAsRead(organizationId2, managerId);
      res.json({ message: "All notifications marked as read" });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ message: "Failed to mark all notifications as read" });
    }
  });
  app2.get("/api/owner/dashboard/ai-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyId } = req.query;
      const filters = {
        propertyId: propertyId ? parseInt(propertyId) : void 0
      };
      const suggestions = await storage.getOwnerAISuggestions(req.user.organizationId, req.user.id, filters);
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching AI suggestions:", error);
      res.status(500).json({ message: "Failed to fetch AI suggestions" });
    }
  });
  app2.post("/api/owner/dashboard/ai-suggestions/:id/respond", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { action, notes } = req.body;
      const suggestion = await storage.respondToAISuggestion(parseInt(id), action, notes, req.user.id);
      res.json(suggestion);
    } catch (error) {
      console.error("Error responding to AI suggestion:", error);
      res.status(500).json({ message: "Failed to respond to suggestion" });
    }
  });
  app2.get("/api/owner/dashboard/booking-insights", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyId } = req.query;
      const filters = {
        propertyId: propertyId ? parseInt(propertyId) : void 0
      };
      const insights = await storage.getOwnerBookingInsights(req.user.organizationId, req.user.id, filters);
      res.json(insights);
    } catch (error) {
      console.error("Error fetching booking insights:", error);
      res.status(500).json({ message: "Failed to fetch booking insights" });
    }
  });
  app2.get("/api/admin/role-permissions", isDemoAuthenticated, async (req, res) => {
    try {
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { organizationId: organizationId2 } = req.user;
      const rolePermissions2 = await storage.getAllRolePermissions(organizationId2);
      res.json(rolePermissions2);
    } catch (error) {
      console.error("Error fetching role permissions:", error);
      res.status(500).json({ message: "Failed to fetch role permissions" });
    }
  });
  app2.patch("/api/admin/role-permissions/:roleId/:moduleKey", isDemoAuthenticated, async (req, res) => {
    try {
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { roleId, moduleKey } = req.params;
      const { visible, access } = req.body;
      const { organizationId: organizationId2 } = req.user;
      const updated = await storage.updateRolePermission(organizationId2, roleId, moduleKey, { visible, access });
      res.json(updated);
    } catch (error) {
      console.error("Error updating role permission:", error);
      res.status(500).json({ message: "Failed to update role permission" });
    }
  });
  app2.post("/api/admin/roles", isDemoAuthenticated, async (req, res) => {
    try {
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { name, displayName, description, cloneFromRole } = req.body;
      const { organizationId: organizationId2 } = req.user;
      const newRole = await storage.createCustomRole(organizationId2, {
        name,
        displayName,
        description,
        cloneFromRole
      });
      res.json(newRole);
    } catch (error) {
      console.error("Error creating role:", error);
      res.status(500).json({ message: "Failed to create role" });
    }
  });
  app2.get("/api/user/permissions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const permissions = await storage.getUserPermissions(organizationId2, role);
      res.json(permissions);
    } catch (error) {
      console.error("Error fetching user permissions:", error);
      res.status(500).json({ message: "Failed to fetch user permissions" });
    }
  });
  app2.get("/api/freelancer/availability", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: freelancerId } = req.user;
      const freelancerRoles = ["electrician", "pest-control", "plumber", "chef", "nanny"];
      if (!freelancerRoles.includes(req.user.role)) {
        return res.status(403).json({ message: "Freelancer access required" });
      }
      const availability = await storage.getFreelancerAvailability(organizationId2, freelancerId);
      res.json(availability);
    } catch (error) {
      console.error("Error fetching freelancer availability:", error);
      res.status(500).json({ message: "Failed to fetch availability" });
    }
  });
  app2.post("/api/freelancer/availability", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: freelancerId } = req.user;
      const { availableDate, timeSlots, isAvailable, notes } = req.body;
      const freelancerRoles = ["electrician", "pest-control", "plumber", "chef", "nanny"];
      if (!freelancerRoles.includes(req.user.role)) {
        return res.status(403).json({ message: "Freelancer access required" });
      }
      const availability = await storage.updateFreelancerAvailability(organizationId2, freelancerId, {
        availableDate,
        timeSlots,
        isAvailable,
        notes
      });
      res.json(availability);
    } catch (error) {
      console.error("Error updating freelancer availability:", error);
      res.status(500).json({ message: "Failed to update availability" });
    }
  });
  app2.get("/api/freelancer/task-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: freelancerId } = req.user;
      const { status } = req.query;
      const freelancerRoles = ["electrician", "pest-control", "plumber", "chef", "nanny"];
      if (!freelancerRoles.includes(req.user.role)) {
        return res.status(403).json({ message: "Freelancer access required" });
      }
      const requests = await storage.getFreelancerTaskRequests(organizationId2, freelancerId, { status });
      res.json(requests);
    } catch (error) {
      console.error("Error fetching task requests:", error);
      res.status(500).json({ message: "Failed to fetch task requests" });
    }
  });
  app2.patch("/api/freelancer/task-requests/:id/respond", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { status, response, counterProposedDate, counterProposedTimeStart, counterProposedTimeEnd } = req.body;
      const { id: freelancerId } = req.user;
      const freelancerRoles = ["electrician", "pest-control", "plumber", "chef", "nanny"];
      if (!freelancerRoles.includes(req.user.role)) {
        return res.status(403).json({ message: "Freelancer access required" });
      }
      const updated = await storage.respondToTaskRequest(parseInt(id), freelancerId, {
        status,
        response,
        counterProposedDate,
        counterProposedTimeStart,
        counterProposedTimeEnd
      });
      res.json(updated);
    } catch (error) {
      console.error("Error responding to task request:", error);
      res.status(500).json({ message: "Failed to respond to task request" });
    }
  });
  app2.post("/api/pm/dashboard/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: managerId } = req.user;
      const {
        receiverType,
        receiverId,
        receiverName,
        receiverAddress,
        invoiceType,
        description,
        lineItems,
        taxRate,
        notes,
        dueDate,
        referenceNumber
      } = req.body;
      const invoiceNumber = await storage.getNextInvoiceNumber(organizationId2);
      const pmUser = await storage.getUser(managerId);
      let clientType = receiverType;
      if (receiverType === "external") {
        clientType = "service_provider";
      }
      const today = /* @__PURE__ */ new Date();
      const issueDateStr = today.toISOString().split("T")[0];
      const dueDateStr = dueDate || new Date(today.getTime() + 30 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0];
      const billingLineItems = lineItems.map((item) => ({
        description: item.description,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        taxRate: taxRate || 0,
        discount: 0
      }));
      const invoice = await storage.createBillingInvoice({
        organizationId: organizationId2,
        invoiceNumber,
        clientType,
        clientId: receiverId || managerId,
        clientName: receiverName,
        clientEmail: receiverAddress,
        propertyId: null,
        templateId: null,
        issueDate: issueDateStr,
        dueDate: dueDateStr,
        description: description || "",
        status: "draft",
        paymentTerms: notes,
        notes: `Type: ${invoiceType}${referenceNumber ? `, Ref: ${referenceNumber}` : ""}`,
        createdBy: managerId
      }, billingLineItems);
      res.json(invoice);
    } catch (error) {
      console.error("Error creating PM invoice:", error);
      res.status(500).json({ message: "Failed to create invoice" });
    }
  });
  app2.get("/api/pm/dashboard/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: managerId } = req.user;
      const result = await storage.getBillingInvoices(organizationId2, {
        createdBy: managerId
      });
      res.json(result.invoices);
    } catch (error) {
      console.error("Error fetching PM invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });
  app2.get("/api/portfolio/property-access", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPropertyAccess: getDemoPropertyAccess2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const propertyAccess = getDemoPropertyAccess2(managerId);
        res.json(propertyAccess);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching property access:", error);
      res.status(500).json({ message: "Failed to fetch property access" });
    }
  });
  app2.get("/api/portfolio/documents", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.documents || []);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching documents:", error);
      res.status(500).json({ message: "Failed to fetch documents" });
    }
  });
  app2.get("/api/portfolio/maintenance", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.maintenanceTasks || []);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching maintenance:", error);
      res.status(500).json({ message: "Failed to fetch maintenance" });
    }
  });
  app2.get("/api/portfolio/service-tracker", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.serviceTimeline || []);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching service tracker:", error);
      res.status(500).json({ message: "Failed to fetch service tracker" });
    }
  });
  app2.get("/api/portfolio/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { email: managerId } = req.user;
      if (managerId === "manager@test.com") {
        const { getDemoPortfolioData: getDemoPortfolioData2 } = await Promise.resolve().then(() => (init_portfolioManagerDemo(), portfolioManagerDemo_exports));
        const demoData = getDemoPortfolioData2(managerId);
        res.json(demoData?.invoices || []);
        return;
      }
      res.json([]);
    } catch (error) {
      console.error("Error fetching portfolio invoices:", error);
      res.status(500).json({ message: "Failed to fetch portfolio invoices" });
    }
  });
  app2.get("/api/agent/properties", isDemoAuthenticated, async (req, res) => {
    try {
      console.log("Agent properties request - User:", req.user?.id, "Role:", req.user?.role, "OrgId:", req.user?.organizationId);
      const { organizationId: organizationId2 } = req.user;
      const {
        checkIn,
        checkOut,
        guests,
        bedrooms,
        priceMin,
        priceMax,
        amenities
      } = req.query;
      console.log("Search filters:", { checkIn, checkOut, guests, bedrooms, priceMin, priceMax });
      if (req.user.role !== "retail-agent" && req.user.id !== "demo-agent") {
        console.log("Access denied for user:", req.user.id, "with role:", req.user.role);
        return res.status(403).json({
          message: "Access denied: Retail agent role required",
          fallbackData: []
        });
      }
      const properties2 = await storage.getAgentAvailableProperties(organizationId2, {
        checkIn,
        checkOut,
        guests: guests ? parseInt(guests) : void 0,
        bedrooms: bedrooms ? parseInt(bedrooms) : void 0,
        priceMin: priceMin ? parseFloat(priceMin) : void 0,
        priceMax: priceMax ? parseFloat(priceMax) : void 0,
        amenities: amenities ? amenities.split(",") : void 0
      });
      console.log("Raw properties from storage:", properties2?.length || 0);
      const safeProperties = Array.isArray(properties2) ? properties2 : [];
      console.log("Safe properties count:", safeProperties.length);
      const enhancedProperties = safeProperties.map((property) => ({
        id: property.id || 0,
        name: property.name || "Villa Property",
        description: property.description || "Beautiful villa property",
        address: property.address || "Koh Samui, Thailand",
        bedrooms: property.bedrooms || 3,
        bathrooms: property.bathrooms || 2,
        maxGuests: property.maxGuests || 6,
        pricePerNight: property.pricePerNight || "5000",
        currency: property.currency || "THB",
        commission: property.commission || 15,
        // Default 15% commission
        commissionRate: property.commissionRate || 15,
        isAvailable: property.isAvailable !== false,
        // Default to available
        amenities: property.amenities || ["wifi", "parking", "pool", "kitchen"],
        images: property.images || [],
        marketingMedia: property.marketingMedia || [],
        status: property.status || "active"
      }));
      console.log("Enhanced properties count:", enhancedProperties.length);
      res.json(enhancedProperties);
    } catch (error) {
      console.error("Error fetching agent properties:", error);
      res.json([]);
    }
  });
  app2.get("/api/agent/bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId } = req.user;
      const { status, propertyId, startDate, endDate } = req.query;
      const bookings3 = await storage.getAgentBookings(organizationId2, agentId, {
        status,
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        startDate,
        endDate
      });
      const safeBookings = Array.isArray(bookings3) ? bookings3 : [];
      res.json(safeBookings);
    } catch (error) {
      console.error("Error fetching agent bookings:", error);
      res.json([]);
    }
  });
  app2.post("/api/agent/bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId } = req.user;
      const bookingData = {
        ...req.body,
        organizationId: organizationId2,
        retailAgentId: agentId,
        bookingStatus: "pending",
        commissionStatus: "pending",
        createdAt: /* @__PURE__ */ new Date()
      };
      const booking = await storage.createAgentBooking(bookingData);
      res.json(booking);
    } catch (error) {
      console.error("Error creating agent booking:", error);
      res.status(500).json({ message: "Failed to create booking" });
    }
  });
  app2.get("/api/agent/commission-summary", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId } = req.user;
      const summary = await storage.getAgentCommissionSummary(organizationId2, agentId);
      const safeSummary = {
        totalCommissionEarned: summary?.totalCommissionEarned || 0,
        totalCommissionPaid: summary?.totalCommissionPaid || 0,
        pendingCommission: summary?.pendingCommission || 0,
        totalBookings: summary?.totalBookings || 0,
        thisMonthCommission: summary?.thisMonthCommission || 0,
        thisMonthBookings: summary?.thisMonthBookings || 0,
        lastMonthCommission: summary?.lastMonthCommission || 0,
        lastMonthBookings: summary?.lastMonthBookings || 0,
        averageCommissionPerBooking: summary?.averageCommissionPerBooking || 0,
        commissionRate: summary?.commissionRate || 15,
        currency: summary?.currency || "THB",
        ...summary
      };
      res.json(safeSummary);
    } catch (error) {
      console.error("Error fetching commission summary:", error);
      const fallbackSummary = {
        totalCommissionEarned: 0,
        totalCommissionPaid: 0,
        pendingCommission: 0,
        totalBookings: 0,
        thisMonthCommission: 0,
        thisMonthBookings: 0,
        lastMonthCommission: 0,
        lastMonthBookings: 0,
        averageCommissionPerBooking: 0,
        commissionRate: 15,
        currency: "THB"
      };
      res.json(fallbackSummary);
    }
  });
  app2.get("/api/agent/payouts", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId } = req.user;
      const { status, startDate, endDate } = req.query;
      const payouts = await storage.getAgentPayouts(organizationId2, agentId, {
        status,
        startDate,
        endDate
      });
      const safePayouts = Array.isArray(payouts) ? payouts : [];
      res.json(safePayouts);
    } catch (error) {
      console.error("Error fetching agent payouts:", error);
      res.json([]);
    }
  });
  app2.post("/api/agent/payouts", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId } = req.user;
      const payoutData = {
        ...req.body,
        organizationId: organizationId2,
        agentId,
        agentType: "retail-agent",
        payoutStatus: "pending",
        requestedAt: /* @__PURE__ */ new Date()
      };
      const payout = await storage.createAgentPayout(payoutData);
      res.json(payout);
    } catch (error) {
      console.error("Error creating agent payout:", error);
      res.status(500).json({ message: "Failed to create payout request" });
    }
  });
  app2.get("/api/agent/marketing-media", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId, mediaType, category } = req.query;
      const media = await storage.getPropertyMarketingMedia(
        organizationId2,
        propertyId ? parseInt(propertyId) : void 0,
        {
          mediaType,
          category,
          agentAccessLevel: "all"
        }
      );
      res.json(media);
    } catch (error) {
      console.error("Error fetching marketing media:", error);
      res.status(500).json({ message: "Failed to fetch marketing media" });
    }
  });
  app2.get("/api/agent/booking-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId } = req.user;
      const { status, propertyId, urgencyLevel } = req.query;
      const requests = await storage.getAgentBookingRequests(organizationId2, agentId, {
        status,
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        urgencyLevel
      });
      res.json(requests);
    } catch (error) {
      console.error("Error fetching booking requests:", error);
      res.status(500).json({ message: "Failed to fetch booking requests" });
    }
  });
  app2.post("/api/agent/booking-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId } = req.user;
      const requestData = {
        ...req.body,
        organizationId: organizationId2,
        agentId,
        status: "pending",
        submittedAt: /* @__PURE__ */ new Date()
      };
      const request = await storage.createAgentBookingRequest(requestData);
      res.json(request);
    } catch (error) {
      console.error("Error creating booking request:", error);
      res.status(500).json({ message: "Failed to create booking request" });
    }
  });
  app2.get("/api/agent/commission-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId } = req.query;
      const rules = await storage.getPropertyCommissionRules(
        organizationId2,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(rules);
    } catch (error) {
      console.error("Error fetching commission rules:", error);
      res.status(500).json({ message: "Failed to fetch commission rules" });
    }
  });
  app2.get("/api/referral-agent/properties", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: referralAgentId } = req.user;
      const properties2 = await storage.getReferralAgentProperties(organizationId2, referralAgentId);
      res.json(properties2);
    } catch (error) {
      console.error("Error fetching referral agent properties:", error);
      res.status(500).json({ message: "Failed to fetch properties" });
    }
  });
  app2.get("/api/referral-agent/earnings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: referralAgentId } = req.user;
      const { month, year, propertyId, status } = req.query;
      const earnings = await storage.getReferralEarnings(organizationId2, referralAgentId, {
        month: month ? parseInt(month) : void 0,
        year: year ? parseInt(year) : void 0,
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        status
      });
      res.json(earnings);
    } catch (error) {
      console.error("Error fetching referral earnings:", error);
      res.status(500).json({ message: "Failed to fetch earnings" });
    }
  });
  app2.get("/api/referral-agent/commission-summary", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: referralAgentId } = req.user;
      const summary = await storage.getReferralCommissionSummary(organizationId2, referralAgentId);
      res.json(summary);
    } catch (error) {
      console.error("Error fetching commission summary:", error);
      res.status(500).json({ message: "Failed to fetch commission summary" });
    }
  });
  app2.get("/api/referral-agent/payouts", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: referralAgentId } = req.user;
      const { status, startDate, endDate } = req.query;
      const payouts = await storage.getReferralPayouts(organizationId2, referralAgentId, {
        status,
        startDate,
        endDate
      });
      res.json(payouts);
    } catch (error) {
      console.error("Error fetching referral payouts:", error);
      res.status(500).json({ message: "Failed to fetch payouts" });
    }
  });
  app2.post("/api/referral-agent/payouts", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: referralAgentId } = req.user;
      const payoutData = {
        ...req.body,
        organizationId: organizationId2,
        agentId: referralAgentId,
        agentType: "referral-agent",
        payoutStatus: "pending",
        requestedAt: /* @__PURE__ */ new Date()
      };
      const payout = await storage.createReferralPayout(payoutData);
      res.json(payout);
    } catch (error) {
      console.error("Error creating referral payout:", error);
      res.status(500).json({ message: "Failed to create payout request" });
    }
  });
  app2.get("/api/referral-agent/program-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { ruleType, isActive } = req.query;
      const rules = await storage.getReferralProgramRules(organizationId2, {
        ruleType,
        isActive: isActive !== void 0 ? isActive === "true" : void 0
      });
      res.json(rules);
    } catch (error) {
      console.error("Error fetching program rules:", error);
      res.status(500).json({ message: "Failed to fetch program rules" });
    }
  });
  app2.get("/api/referral-agent/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: referralAgentId } = req.user;
      const { propertyId, startMonth, startYear, endMonth, endYear } = req.query;
      const analytics = await storage.getPropertyPerformanceAnalytics(organizationId2, referralAgentId, {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        startMonth: startMonth ? parseInt(startMonth) : void 0,
        startYear: startYear ? parseInt(startYear) : void 0,
        endMonth: endMonth ? parseInt(endMonth) : void 0,
        endYear: endYear ? parseInt(endYear) : void 0
      });
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching performance analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });
  app2.get("/api/staff/dashboard/overview", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const staffId = user.id;
      const department = user.department;
      const overview = await storage.getStaffDashboardOverview(organizationId2, staffId, department);
      res.json(overview);
    } catch (error) {
      console.error("Error fetching staff dashboard overview:", error);
      res.status(500).json({ message: "Failed to fetch dashboard overview" });
    }
  });
  app2.get("/api/staff/tasks", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const staffId = user.id;
      const filters = req.query;
      const tasks2 = await storage.getStaffTasks(organizationId2, staffId, filters);
      res.json(tasks2);
    } catch (error) {
      console.error("Error fetching staff tasks:", error);
      res.status(500).json({ message: "Failed to fetch tasks" });
    }
  });
  app2.post("/api/staff/tasks/:taskId/start", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const taskId = parseInt(req.params.taskId);
      const staffId = user.id;
      const task = await storage.startTask(organizationId2, taskId, staffId);
      res.json(task);
    } catch (error) {
      console.error("Error starting task:", error);
      res.status(500).json({ message: "Failed to start task" });
    }
  });
  app2.post("/api/staff/tasks/:taskId/complete", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const taskId = parseInt(req.params.taskId);
      const staffId = user.id;
      const completionData = req.body;
      const task = await storage.completeTask(organizationId2, taskId, staffId, completionData);
      res.json(task);
    } catch (error) {
      console.error("Error completing task:", error);
      res.status(500).json({ message: "Failed to complete task" });
    }
  });
  app2.post("/api/staff/tasks/:taskId/skip", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const taskId = parseInt(req.params.taskId);
      const staffId = user.id;
      const { reason } = req.body;
      const task = await storage.skipTask(organizationId2, taskId, staffId, reason);
      res.json(task);
    } catch (error) {
      console.error("Error skipping task:", error);
      res.status(500).json({ message: "Failed to skip task" });
    }
  });
  app2.post("/api/staff/tasks/:taskId/reschedule", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const taskId = parseInt(req.params.taskId);
      const staffId = user.id;
      const { newDate, reason } = req.body;
      const task = await storage.rescheduleTask(organizationId2, taskId, staffId, new Date(newDate), reason);
      res.json(task);
    } catch (error) {
      console.error("Error rescheduling task:", error);
      res.status(500).json({ message: "Failed to reschedule task" });
    }
  });
  app2.get("/api/staff/salary", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const { period, userId } = req.query;
      const hasFullSalaryAccess = user.role === "admin" || user.role === "hr";
      if (hasFullSalaryAccess) {
        const allSalaries = await storage.getAllStaffSalaries(organizationId2, period);
        res.json(allSalaries);
      } else if (user.role === "staff") {
        const salary = await storage.getStaffSalary(organizationId2, user.id, period);
        res.json(salary);
      } else {
        const salary = await storage.getStaffSalary(organizationId2, user.id, period);
        res.json(salary);
      }
    } catch (error) {
      console.error("Error fetching staff salary:", error);
      res.status(500).json({ message: "Failed to fetch salary information" });
    }
  });
  app2.get("/api/staff/expenses", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const staffId = user.id;
      const filters = req.query;
      const expenses = await storage.getStaffExpenses(organizationId2, staffId, filters);
      res.json(expenses);
    } catch (error) {
      console.error("Error fetching staff expenses:", error);
      res.status(500).json({ message: "Failed to fetch expenses" });
    }
  });
  app2.post("/api/staff/expenses", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const staffId = user.id;
      const expenseData = {
        ...req.body,
        organizationId: organizationId2,
        staffId
      };
      const expense = await storage.createStaffExpense(expenseData);
      res.status(201).json(expense);
    } catch (error) {
      console.error("Error creating staff expense:", error);
      res.status(500).json({ message: "Failed to create expense" });
    }
  });
  app2.get("/api/staff/task-history", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const staffId = user.id;
      const filters = req.query;
      const history = await storage.getStaffTaskHistory(organizationId2, staffId, filters);
      res.json(history);
    } catch (error) {
      console.error("Error fetching task history:", error);
      res.status(500).json({ message: "Failed to fetch task history" });
    }
  });
  app2.get("/api/staff-salary/staff-list", isDemoAuthenticated, async (req, res) => {
    try {
      const mockStaffList = [
        { id: "staff1", name: "Maria Santos", department: "housekeeping", role: "staff" },
        { id: "staff2", name: "Carlos Rivera", department: "pool", role: "staff" },
        { id: "staff3", name: "Ana Rodriguez", department: "maintenance", role: "staff" },
        { id: "staff4", name: "Diego Martinez", department: "security", role: "staff" }
      ];
      res.json(mockStaffList);
    } catch (error) {
      console.error("Error fetching staff list:", error);
      res.status(500).json({ message: "Failed to fetch staff list" });
    }
  });
  app2.get("/api/staff-salary/settings/:staffId", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId } = req.params;
      const mockSettings = {
        id: 1,
        staffId,
        staffName: "Maria Santos",
        department: "housekeeping",
        fixedMonthlySalary: 4500,
        currency: "AUD",
        hourlyOvertime: 35,
        emergencyTaskBonus: 100,
        regularShiftStart: "08:00",
        regularShiftEnd: "16:00",
        workingDays: ["monday", "tuesday", "wednesday", "thursday", "friday"],
        isActive: true,
        effectiveFrom: "2024-01-01"
      };
      res.json(mockSettings);
    } catch (error) {
      console.error("Error fetching salary settings:", error);
      res.status(500).json({ message: "Failed to fetch salary settings" });
    }
  });
  app2.get("/api/staff-salary/clock-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const { month } = req.query;
      const mockClockLogs = [
        {
          id: 1,
          staffId: "demo-staff",
          staffName: "Maria Santos",
          clockInTime: "2024-12-01T08:00:00Z",
          clockOutTime: "2024-12-01T16:30:00Z",
          clockInReason: "regular_shift",
          clockOutReason: "shift_end",
          totalHours: 8.5,
          regularHours: 8,
          overtimeHours: 0.5,
          overtimeType: "emergency",
          overtimeApprovalStatus: "approved",
          notes: "Extended shift for emergency pool cleaning"
        },
        {
          id: 2,
          staffId: "demo-staff",
          staffName: "Maria Santos",
          clockInTime: "2024-12-02T08:00:00Z",
          clockOutTime: "2024-12-02T16:00:00Z",
          clockInReason: "regular_shift",
          clockOutReason: "shift_end",
          totalHours: 8,
          regularHours: 8,
          overtimeHours: 0,
          overtimeApprovalStatus: "approved",
          notes: ""
        }
      ];
      res.json(mockClockLogs);
    } catch (error) {
      console.error("Error fetching clock logs:", error);
      res.status(500).json({ message: "Failed to fetch clock logs" });
    }
  });
  app2.get("/api/staff-salary/payroll-summary", isDemoAuthenticated, async (req, res) => {
    try {
      const { month } = req.query;
      const mockPayrollSummary = {
        id: 1,
        summaryMonth: month || "2024-12",
        totalStaff: 4,
        totalFixedSalaries: 18e3,
        totalOvertimePay: 875,
        totalEmergencyBonuses: 400,
        totalPayroll: 19275,
        departmentBreakdown: {
          housekeeping: 9e3,
          pool: 4500,
          maintenance: 4500,
          security: 1275
        },
        overtimeHoursBreakdown: {
          housekeeping: 12.5,
          pool: 8,
          maintenance: 5.5,
          security: 3
        },
        emergencyTasksCount: 4,
        paymentCompletionRate: 95.5,
        averageOvertimeHours: 7.25
      };
      res.json(mockPayrollSummary);
    } catch (error) {
      console.error("Error fetching payroll summary:", error);
      res.status(500).json({ message: "Failed to fetch payroll summary" });
    }
  });
  app2.post("/api/staff-salary/clock", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { action, reason, notes } = req.body;
      const mockResponse = {
        id: Date.now(),
        staffId: user.id,
        staffName: user.name || "Staff Member",
        action,
        reason,
        notes,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        success: true
      };
      res.json(mockResponse);
    } catch (error) {
      console.error("Error recording clock action:", error);
      res.status(500).json({ message: "Failed to record clock action" });
    }
  });
  app2.post("/api/staff-salary/emergency-bonus", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { taskId, bonusAmount, emergencyType, notes } = req.body;
      const mockResponse = {
        id: Date.now(),
        taskId,
        staffId: user.id,
        staffName: user.name || "Staff Member",
        emergencyType,
        bonusAmount,
        currency: "AUD",
        bonusApprovalStatus: "pending",
        notes,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      res.json(mockResponse);
    } catch (error) {
      console.error("Error recording emergency bonus:", error);
      res.status(500).json({ message: "Failed to record emergency bonus" });
    }
  });
  app2.get("/api/staff-salary/advance-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const hasFullAccess = user.role === "admin" || user.role === "hr";
      const mockAdvanceRequests = [
        {
          id: 1,
          staffId: "demo-staff",
          staffName: "Maria Santos",
          amount: 500,
          reason: "Medical emergency",
          requestedDate: "2024-12-15",
          status: "pending",
          createdAt: "2024-12-01T10:00:00Z",
          approvedBy: null,
          approvedAt: null
        },
        {
          id: 2,
          staffId: "demo-staff-2",
          staffName: "John Pool Cleaner",
          amount: 300,
          reason: "Family celebration",
          requestedDate: "2024-11-20",
          status: "approved",
          createdAt: "2024-11-10T14:30:00Z",
          approvedBy: "admin",
          approvedAt: "2024-11-11T09:15:00Z"
        },
        {
          id: 3,
          staffId: user.id,
          staffName: user.firstName + " " + user.lastName,
          amount: 400,
          reason: "Personal emergency",
          requestedDate: "2024-12-10",
          status: "pending",
          createdAt: "2024-12-05T08:00:00Z",
          approvedBy: null,
          approvedAt: null
        }
      ];
      if (hasFullAccess) {
        res.json(mockAdvanceRequests);
      } else {
        const userRequests = mockAdvanceRequests.filter((req2) => req2.staffId === user.id);
        res.json(userRequests);
      }
    } catch (error) {
      console.error("Error fetching advance requests:", error);
      res.status(500).json({ message: "Failed to fetch advance requests" });
    }
  });
  app2.post("/api/staff-salary/advance-request", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { amount, reason, requestedDate } = req.body;
      const mockResponse = {
        id: Date.now(),
        staffId: user.id,
        staffName: user.name || "Staff Member",
        amount,
        reason,
        requestedDate,
        status: "pending",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        approvedBy: null,
        approvedAt: null
      };
      res.json(mockResponse);
    } catch (error) {
      console.error("Error submitting advance request:", error);
      res.status(500).json({ message: "Failed to submit advance request" });
    }
  });
  app2.get("/api/staff-salary/overtime-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const mockOvertimeRequests = [
        {
          id: 1,
          staffId: "demo-staff",
          staffName: "Maria Santos",
          taskId: 101,
          hoursWorked: 3.5,
          requestType: "pay",
          status: "approved",
          notes: "Emergency pool cleaning after storm",
          createdAt: "2024-12-01T18:00:00Z",
          approvedBy: "admin",
          approvedAt: "2024-12-02T08:30:00Z"
        },
        {
          id: 2,
          staffId: "demo-staff",
          staffName: "Maria Santos",
          taskId: 102,
          hoursWorked: 2,
          requestType: "time_off",
          status: "pending",
          notes: "Extended housekeeping due to large group checkout",
          createdAt: "2024-12-03T16:30:00Z",
          approvedBy: null,
          approvedAt: null
        }
      ];
      res.json(mockOvertimeRequests);
    } catch (error) {
      console.error("Error fetching overtime requests:", error);
      res.status(500).json({ message: "Failed to fetch overtime requests" });
    }
  });
  app2.post("/api/staff-salary/overtime-request", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { taskId, hoursWorked, requestType, notes } = req.body;
      const mockResponse = {
        id: Date.now(),
        staffId: user.id,
        staffName: user.name || "Staff Member",
        taskId,
        hoursWorked,
        requestType,
        status: "pending",
        notes,
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        approvedBy: null,
        approvedAt: null
      };
      res.json(mockResponse);
    } catch (error) {
      console.error("Error submitting overtime request:", error);
      res.status(500).json({ message: "Failed to submit overtime request" });
    }
  });
  app2.post("/api/staff-salary/approve-advance", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { requestId, action, notes } = req.body;
      if (user.role !== "admin" && user.role !== "hr") {
        return res.status(403).json({
          message: "Access denied: Only admin and HR roles can approve advance requests"
        });
      }
      const mockResponse = {
        id: requestId,
        action,
        approvedBy: user.id,
        approvedAt: (/* @__PURE__ */ new Date()).toISOString(),
        notes,
        success: true
      };
      res.json(mockResponse);
    } catch (error) {
      console.error("Error updating advance request:", error);
      res.status(500).json({ message: "Failed to update advance request" });
    }
  });
  app2.post("/api/staff-salary/approve-overtime", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { requestId, action, notes } = req.body;
      const mockResponse = {
        id: requestId,
        action,
        approvedBy: user.id,
        approvedAt: (/* @__PURE__ */ new Date()).toISOString(),
        notes,
        success: true
      };
      res.json(mockResponse);
    } catch (error) {
      console.error("Error updating overtime request:", error);
      res.status(500).json({ message: "Failed to update overtime request" });
    }
  });
  app2.get("/api/staff/task-checklist/:taskType", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = "demo-org-1";
      const { taskType } = req.params;
      const { propertyId } = req.query;
      const checklist = await storage.getTaskChecklist(
        organizationId2,
        taskType,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(checklist);
    } catch (error) {
      console.error("Error fetching task checklist:", error);
      res.status(500).json({ message: "Failed to fetch checklist" });
    }
  });
  const isAdminOnly = (req, res, next) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin") {
        return res.status(403).json({ message: "Access denied. Admin privileges required." });
      }
      next();
    } catch (error) {
      console.error("Error checking admin privileges:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  };
  app2.get("/api/admin/balance-reset/users", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const { userType } = req.query;
      const users3 = await storage.getUsersForBalanceReset(
        organizationId2,
        userType !== "all" ? userType : void 0
      );
      res.json(users3);
    } catch (error) {
      console.error("Error fetching users for reset:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });
  app2.get("/api/admin/balance-reset/user/:userId/balance", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { userId } = req.params;
      const balanceSummary = await storage.getUserBalanceSummary(userId);
      res.json(balanceSummary);
    } catch (error) {
      console.error("Error fetching user balance:", error);
      res.status(500).json({ message: "Failed to fetch balance information" });
    }
  });
  app2.post("/api/admin/balance-reset/execute", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const adminUser = req.user;
      const { userId, resetReason, propertyId } = req.body;
      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }
      const auditRecord = await storage.resetUserBalance(
        userId,
        adminUser.id,
        resetReason,
        propertyId
      );
      res.json({
        success: true,
        message: "Balance reset successfully",
        auditRecord
      });
    } catch (error) {
      console.error("Error resetting balance:", error);
      res.status(500).json({ message: "Failed to reset balance" });
    }
  });
  app2.get("/api/admin/balance-reset/audit", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const { userId, fromDate, toDate } = req.query;
      const filters = {};
      if (userId) filters.userId = userId;
      if (fromDate) filters.fromDate = new Date(fromDate);
      if (toDate) filters.toDate = new Date(toDate);
      const auditLog = await storage.getBalanceResetAuditLog(organizationId2, filters);
      res.json(auditLog);
    } catch (error) {
      console.error("Error fetching audit log:", error);
      res.status(500).json({ message: "Failed to fetch audit log" });
    }
  });
  app2.get("/api/utility-providers", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const { utilityType } = req.query;
      const providers = await storage.getUtilityProviders(organizationId2, utilityType);
      res.json(providers);
    } catch (error) {
      console.error("Error fetching utility providers:", error);
      res.status(500).json({ message: "Failed to fetch utility providers" });
    }
  });
  app2.post("/api/utility-providers", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const user = req.user;
      const providerData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: user.id
      };
      const provider = await storage.createUtilityProvider(providerData);
      res.json(provider);
    } catch (error) {
      console.error("Error creating utility provider:", error);
      res.status(500).json({ message: "Failed to create utility provider" });
    }
  });
  app2.put("/api/utility-providers/:id", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { id } = req.params;
      const provider = await storage.updateUtilityProvider(parseInt(id), req.body);
      res.json(provider);
    } catch (error) {
      console.error("Error updating utility provider:", error);
      res.status(500).json({ message: "Failed to update utility provider" });
    }
  });
  app2.delete("/api/utility-providers/:id", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteUtilityProvider(parseInt(id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting utility provider:", error);
      res.status(500).json({ message: "Failed to delete utility provider" });
    }
  });
  app2.get("/api/custom-expense-categories", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const categories = await storage.getCustomExpenseCategories(organizationId2);
      res.json(categories);
    } catch (error) {
      console.error("Error fetching custom expense categories:", error);
      res.status(500).json({ message: "Failed to fetch custom expense categories" });
    }
  });
  app2.post("/api/custom-expense-categories", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const user = req.user;
      const categoryData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: user.id
      };
      const category = await storage.createCustomExpenseCategory(categoryData);
      res.json(category);
    } catch (error) {
      console.error("Error creating custom expense category:", error);
      res.status(500).json({ message: "Failed to create custom expense category" });
    }
  });
  app2.put("/api/custom-expense-categories/:id", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { id } = req.params;
      const category = await storage.updateCustomExpenseCategory(parseInt(id), req.body);
      res.json(category);
    } catch (error) {
      console.error("Error updating custom expense category:", error);
      res.status(500).json({ message: "Failed to update custom expense category" });
    }
  });
  app2.delete("/api/custom-expense-categories/:id", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteCustomExpenseCategory(parseInt(id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting custom expense category:", error);
      res.status(500).json({ message: "Failed to delete custom expense category" });
    }
  });
  app2.get("/api/property-utility-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const { propertyId } = req.query;
      const settings = await storage.getPropertyUtilitySettings(
        organizationId2,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(settings);
    } catch (error) {
      console.error("Error fetching property utility settings:", error);
      res.status(500).json({ message: "Failed to fetch property utility settings" });
    }
  });
  app2.post("/api/property-utility-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const user = req.user;
      const settingsData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: user.id
      };
      const settings = await storage.createPropertyUtilitySettings(settingsData);
      res.json(settings);
    } catch (error) {
      console.error("Error creating property utility settings:", error);
      res.status(500).json({ message: "Failed to create property utility settings" });
    }
  });
  app2.put("/api/property-utility-settings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const settings = await storage.updatePropertyUtilitySettings(parseInt(id), req.body);
      res.json(settings);
    } catch (error) {
      console.error("Error updating property utility settings:", error);
      res.status(500).json({ message: "Failed to update property utility settings" });
    }
  });
  app2.delete("/api/property-utility-settings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deletePropertyUtilitySettings(parseInt(id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting property utility settings:", error);
      res.status(500).json({ message: "Failed to delete property utility settings" });
    }
  });
  app2.get("/api/property-custom-expenses", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const { propertyId } = req.query;
      const expenses = await storage.getPropertyCustomExpenses(
        organizationId2,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(expenses);
    } catch (error) {
      console.error("Error fetching property custom expenses:", error);
      res.status(500).json({ message: "Failed to fetch property custom expenses" });
    }
  });
  app2.post("/api/property-custom-expenses", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const user = req.user;
      const expenseData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: user.id
      };
      const expense = await storage.createPropertyCustomExpenses(expenseData);
      res.json(expense);
    } catch (error) {
      console.error("Error creating property custom expenses:", error);
      res.status(500).json({ message: "Failed to create property custom expenses" });
    }
  });
  app2.put("/api/property-custom-expenses/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const expense = await storage.updatePropertyCustomExpenses(parseInt(id), req.body);
      res.json(expense);
    } catch (error) {
      console.error("Error updating property custom expenses:", error);
      res.status(500).json({ message: "Failed to update property custom expenses" });
    }
  });
  app2.delete("/api/property-custom-expenses/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deletePropertyCustomExpenses(parseInt(id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting property custom expenses:", error);
      res.status(500).json({ message: "Failed to delete property custom expenses" });
    }
  });
  app2.post("/api/admin/seed-defaults", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const user = req.user;
      await storage.seedDefaultUtilityProviders(organizationId2, user.id);
      await storage.seedDefaultCustomExpenseCategories(organizationId2, user.id);
      res.json({ success: true, message: "Default providers and categories seeded successfully" });
    } catch (error) {
      console.error("Error seeding defaults:", error);
      res.status(500).json({ message: "Failed to seed default data" });
    }
  });
  app2.get("/api/agent/commission-summary", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId, role } = req.user;
      if (!["retail-agent", "referral-agent"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Agent role required." });
      }
      const summary = await storage.getAgentCommissionSummary(organizationId2, agentId, role);
      res.json(summary);
    } catch (error) {
      console.error("Error fetching commission summary:", error);
      res.status(500).json({ message: "Failed to fetch commission summary" });
    }
  });
  app2.get("/api/agent/commission-log", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId, role } = req.user;
      const { propertyId, status, startDate, endDate, limit } = req.query;
      if (!["retail-agent", "referral-agent"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Agent role required." });
      }
      const commissions = await storage.getCommissionLog(organizationId2, {
        agentId,
        agentType: role,
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        status,
        startDate,
        endDate,
        limit: limit ? parseInt(limit) : void 0
      });
      res.json(commissions);
    } catch (error) {
      console.error("Error fetching commission log:", error);
      res.status(500).json({ message: "Failed to fetch commission log" });
    }
  });
  app2.post("/api/agent/generate-invoice", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId, role } = req.user;
      const { periodStart, periodEnd, description, agentNotes } = req.body;
      if (!["retail-agent", "referral-agent"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Agent role required." });
      }
      const commissions = await storage.getCommissionLog(organizationId2, {
        agentId,
        agentType: role,
        status: "pending",
        startDate: periodStart,
        endDate: periodEnd
      });
      if (commissions.length === 0) {
        return res.status(400).json({ message: "No pending commissions found for the selected period" });
      }
      const totalCommissions = commissions.reduce((sum4, comm) => sum4 + Number(comm.commissionAmount), 0);
      const invoiceNumber = await storage.generateInvoiceNumber(organizationId2, role);
      const invoice = await storage.createCommissionInvoice({
        organizationId: organizationId2,
        agentId,
        agentType: role,
        invoiceNumber,
        invoiceDate: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        periodStart,
        periodEnd,
        totalCommissions: totalCommissions.toString(),
        currency: "THB",
        description,
        agentNotes,
        generatedBy: agentId
      });
      for (const commission of commissions) {
        await storage.createInvoiceLineItem({
          organizationId: organizationId2,
          invoiceId: invoice.id,
          commissionLogId: commission.id,
          description: `Commission for ${commission.propertyName || "Property"} - ${commission.referenceNumber}`,
          propertyName: commission.propertyName || "Property",
          referenceNumber: commission.referenceNumber,
          commissionDate: commission.createdAt.toISOString().split("T")[0],
          commissionAmount: commission.commissionAmount
        });
      }
      res.json(invoice);
    } catch (error) {
      console.error("Error generating invoice:", error);
      res.status(500).json({ message: "Failed to generate invoice" });
    }
  });
  app2.get("/api/agent/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId, role } = req.user;
      const { status, startDate, endDate } = req.query;
      if (!["retail-agent", "referral-agent"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Agent role required." });
      }
      const invoices2 = await storage.getAgentInvoices(organizationId2, agentId, {
        status,
        startDate,
        endDate
      });
      res.json(invoices2);
    } catch (error) {
      console.error("Error fetching agent invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });
  app2.patch("/api/agent/invoices/:id/submit", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: agentId, role } = req.user;
      const { id } = req.params;
      if (!["retail-agent", "referral-agent"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Agent role required." });
      }
      const invoice = await storage.submitInvoiceForApproval(parseInt(id), agentId);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json(invoice);
    } catch (error) {
      console.error("Error submitting invoice:", error);
      res.status(500).json({ message: "Failed to submit invoice" });
    }
  });
  app2.get("/api/admin/commission-overview", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { agentType, startDate, endDate, status, format } = req.query;
      const commissions = await storage.getCommissionOverviewForExport(organizationId2, {
        agentType,
        startDate,
        endDate,
        status
      });
      if (format === "csv") {
        const csv = [
          "Agent ID,Agent Name,Agent Email,Agent Type,Property,Reference,Date,Base Amount,Rate %,Commission Amount,Currency,Status,Processed By,Processed Date",
          ...commissions.map(
            (c) => `${c.agentId},"${c.agentName}","${c.agentEmail}",${c.agentType},"${c.propertyName}",${c.referenceNumber},${c.commissionDate.toISOString().split("T")[0]},${c.baseAmount},${c.commissionRate},${c.commissionAmount},${c.currency},${c.status},"${c.processedBy || ""}","${c.processedAt ? c.processedAt.toISOString().split("T")[0] : ""}"`
          )
        ].join("\n");
        res.setHeader("Content-Type", "text/csv");
        res.setHeader("Content-Disposition", `attachment; filename="commission-overview-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv"`);
        res.send(csv);
      } else {
        res.json(commissions);
      }
    } catch (error) {
      console.error("Error fetching commission overview:", error);
      res.status(500).json({ message: "Failed to fetch commission overview" });
    }
  });
  app2.patch("/api/admin/commissions/:id/mark-paid", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { id: adminId } = req.user;
      const { id } = req.params;
      const { notes } = req.body;
      const commission = await storage.markCommissionAsPaid(parseInt(id), adminId, notes);
      if (!commission) {
        return res.status(404).json({ message: "Commission not found" });
      }
      res.json(commission);
    } catch (error) {
      console.error("Error marking commission as paid:", error);
      res.status(500).json({ message: "Failed to mark commission as paid" });
    }
  });
  app2.patch("/api/admin/commissions/:id/adjust", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { id: adminId } = req.user;
      const { id } = req.params;
      const { newAmount, reason } = req.body;
      if (!newAmount || !reason) {
        return res.status(400).json({ message: "New amount and reason are required" });
      }
      const result = await storage.adjustCommissionAmount(parseInt(id), parseFloat(newAmount), adminId, reason);
      res.json(result);
    } catch (error) {
      console.error("Error adjusting commission:", error);
      res.status(500).json({ message: "Failed to adjust commission" });
    }
  });
  app2.patch("/api/admin/invoices/:id/approve", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { id: adminId } = req.user;
      const { id } = req.params;
      const { notes } = req.body;
      const invoice = await storage.approveInvoice(parseInt(id), adminId, notes);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json(invoice);
    } catch (error) {
      console.error("Error approving invoice:", error);
      res.status(500).json({ message: "Failed to approve invoice" });
    }
  });
  app2.patch("/api/admin/invoices/:id/reject", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { id: adminId } = req.user;
      const { id } = req.params;
      const { reason } = req.body;
      if (!reason) {
        return res.status(400).json({ message: "Rejection reason is required" });
      }
      const invoice = await storage.rejectInvoice(parseInt(id), adminId, reason);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json(invoice);
    } catch (error) {
      console.error("Error rejecting invoice:", error);
      res.status(500).json({ message: "Failed to reject invoice" });
    }
  });
  app2.post("/api/admin/commissions/trigger-payout", isDemoAuthenticated, isAdminOnly, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: adminId } = req.user;
      const { agentId, amount, agentType } = req.body;
      if (!agentId || !amount || !agentType) {
        return res.status(400).json({ message: "Agent ID, amount, and agent type are required" });
      }
      const payout = await storage.triggerCommissionPayout(
        agentId,
        organizationId2,
        parseFloat(amount),
        agentType,
        adminId
      );
      res.json(payout);
    } catch (error) {
      console.error("Error triggering payout:", error);
      res.status(500).json({ message: "Failed to trigger payout" });
    }
  });
  app2.get("/api/guest-portal/messages", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId, guestId, messageType, priority, status } = req.query;
      const filters = {
        propertyId,
        guestId,
        messageType,
        priority,
        status
      };
      const messages = await storage.getGuestMessages(organizationId2, filters);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching guest messages:", error);
      res.status(500).json({ message: "Failed to fetch guest messages" });
    }
  });
  app2.post("/api/guest-portal/messages", async (req, res) => {
    try {
      const messageData = {
        ...req.body,
        organizationId: req.body.organizationId || "default-org",
        guestId: req.body.guestId || `guest-${Date.now()}`
      };
      const message = await storage.createGuestMessage(messageData);
      if (message.aiKeywords && message.aiKeywords.length > 0) {
        await storage.generateTaskFromMessage(message.id, message, {
          keywords: message.aiKeywords,
          confidence: parseFloat(message.aiConfidence),
          priority: message.priority
        });
      }
      res.status(201).json(message);
    } catch (error) {
      console.error("Error creating guest message:", error);
      res.status(500).json({ message: "Failed to create guest message" });
    }
  });
  app2.patch("/api/guest-portal/messages/:id/respond", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { response } = req.body;
      const { id: userId } = req.user;
      const message = await storage.respondToGuestMessage(parseInt(id), response, userId);
      res.json(message);
    } catch (error) {
      console.error("Error responding to guest message:", error);
      res.status(500).json({ message: "Failed to respond to guest message" });
    }
  });
  app2.get("/api/guest-portal/ai-tasks", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { department, status, urgency, assignedTo } = req.query;
      const filters = {
        department,
        status,
        urgency,
        assignedTo
      };
      const tasks2 = await storage.getAiGeneratedTasks(organizationId2, filters);
      res.json(tasks2);
    } catch (error) {
      console.error("Error fetching AI-generated tasks:", error);
      res.status(500).json({ message: "Failed to fetch AI-generated tasks" });
    }
  });
  app2.patch("/api/guest-portal/ai-tasks/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { id: userId } = req.user;
      const task = await storage.approveAiTask(parseInt(id), userId);
      res.json(task);
    } catch (error) {
      console.error("Error approving AI task:", error);
      res.status(500).json({ message: "Failed to approve AI task" });
    }
  });
  app2.patch("/api/guest-portal/ai-tasks/:id/reject", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { id: userId } = req.user;
      const task = await storage.rejectAiTask(parseInt(id), userId);
      res.json(task);
    } catch (error) {
      console.error("Error rejecting AI task:", error);
      res.status(500).json({ message: "Failed to reject AI task" });
    }
  });
  app2.get("/api/guest-portal/service-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId, guestId, serviceType, status } = req.query;
      const filters = {
        propertyId,
        guestId,
        serviceType,
        status
      };
      const serviceRequests = await storage.getGuestServiceRequests(organizationId2, filters);
      res.json(serviceRequests);
    } catch (error) {
      console.error("Error fetching guest service requests:", error);
      res.status(500).json({ message: "Failed to fetch guest service requests" });
    }
  });
  app2.post("/api/guest-portal/service-requests", async (req, res) => {
    try {
      const requestData = {
        ...req.body,
        organizationId: req.body.organizationId || "default-org",
        guestId: req.body.guestId || `guest-${Date.now()}`
      };
      const serviceRequest = await storage.createGuestServiceRequest(requestData);
      res.status(201).json(serviceRequest);
    } catch (error) {
      console.error("Error creating guest service request:", error);
      res.status(500).json({ message: "Failed to create guest service request" });
    }
  });
  app2.patch("/api/guest-portal/service-requests/:id/confirm", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { id: userId } = req.user;
      const serviceRequest = await storage.confirmServiceRequest(parseInt(id), userId);
      res.json(serviceRequest);
    } catch (error) {
      console.error("Error confirming service request:", error);
      res.status(500).json({ message: "Failed to confirm service request" });
    }
  });
  app2.patch("/api/guest-portal/service-requests/:id/complete", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { guestRating, guestFeedback: guestFeedback2 } = req.body;
      const serviceRequest = await storage.completeServiceRequest(parseInt(id), guestRating, guestFeedback2);
      res.json(serviceRequest);
    } catch (error) {
      console.error("Error completing service request:", error);
      res.status(500).json({ message: "Failed to complete service request" });
    }
  });
  app2.get("/api/guest-portal/ai-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { suggestionType, targetAudience, status, priority } = req.query;
      const filters = {
        suggestionType,
        targetAudience,
        status,
        priority
      };
      const suggestions = await storage.getAiSmartSuggestions(organizationId2, filters);
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching AI smart suggestions:", error);
      res.status(500).json({ message: "Failed to fetch AI smart suggestions" });
    }
  });
  app2.post("/api/guest-portal/ai-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const suggestionData = {
        ...req.body,
        organizationId: organizationId2
      };
      const suggestion = await storage.createAiSmartSuggestion(suggestionData);
      res.status(201).json(suggestion);
    } catch (error) {
      console.error("Error creating AI smart suggestion:", error);
      res.status(500).json({ message: "Failed to create AI smart suggestion" });
    }
  });
  app2.patch("/api/guest-portal/ai-suggestions/:id/review", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { status, notes } = req.body;
      const { id: userId } = req.user;
      const suggestion = await storage.reviewAiSuggestion(parseInt(id), userId, status, notes);
      res.json(suggestion);
    } catch (error) {
      console.error("Error reviewing AI suggestion:", error);
      res.status(500).json({ message: "Failed to review AI suggestion" });
    }
  });
  app2.patch("/api/guest-portal/ai-suggestions/:id/implement", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const suggestion = await storage.implementAiSuggestion(parseInt(id));
      res.json(suggestion);
    } catch (error) {
      console.error("Error implementing AI suggestion:", error);
      res.status(500).json({ message: "Failed to implement AI suggestion" });
    }
  });
  app2.get("/api/guest-portal/settings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId } = req.query;
      const settings = await storage.getGuestPortalSettings(organizationId2, propertyId ? parseInt(propertyId) : void 0);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching guest portal settings:", error);
      res.status(500).json({ message: "Failed to fetch guest portal settings" });
    }
  });
  app2.put("/api/guest-portal/settings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or PM access required" });
      }
      const settings = await storage.updateGuestPortalSettings(organizationId2, req.body);
      res.json(settings);
    } catch (error) {
      console.error("Error updating guest portal settings:", error);
      res.status(500).json({ message: "Failed to update guest portal settings" });
    }
  });
  app2.get("/api/guest-portal/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { month, propertyId } = req.query;
      const analytics = await storage.getGuestDashboardAnalytics(
        organizationId2,
        month,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching guest dashboard analytics:", error);
      res.status(500).json({ message: "Failed to fetch guest dashboard analytics" });
    }
  });
  app2.post("/api/service-requests/create-with-confirmation", async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const serviceRequestData = {
        ...req.body,
        organizationId: organizationId2
      };
      const serviceRequest = await storage.createServiceRequestWithConfirmation(organizationId2, serviceRequestData);
      res.status(201).json({
        serviceRequest,
        message: "Service request submitted and pending confirmation",
        confirmationRequired: serviceRequest.awaitingConfirmation
      });
    } catch (error) {
      console.error("Error creating service request with confirmation:", error);
      res.status(500).json({ message: "Failed to create service request" });
    }
  });
  app2.get("/api/service-requests/notifications/pending", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const notifications2 = await storage.getPendingServiceRequestNotifications(organizationId2, role);
      res.json(notifications2);
    } catch (error) {
      console.error("Error fetching pending service request notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });
  app2.get("/api/service-requests/:serviceRequestId/details", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { serviceRequestId } = req.params;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const serviceRequest = await storage.getServiceRequestDetails(organizationId2, parseInt(serviceRequestId));
      res.json(serviceRequest);
    } catch (error) {
      console.error("Error fetching service request details:", error);
      res.status(500).json({ message: "Failed to fetch service request details" });
    }
  });
  app2.post("/api/service-requests/:serviceRequestId/confirm", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId, firstName, lastName } = req.user;
      const { serviceRequestId } = req.params;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or PM access required" });
      }
      const confirmationData = {
        ...req.body,
        confirmedBy: userId,
        confirmedByName: `${firstName} ${lastName}`
      };
      const confirmation = await storage.confirmServiceRequest(organizationId2, parseInt(serviceRequestId), confirmationData);
      res.json({
        confirmation,
        message: "Service request confirmed successfully",
        taskCreated: confirmation.autoCreateTask
      });
    } catch (error) {
      console.error("Error confirming service request:", error);
      res.status(500).json({ message: "Failed to confirm service request" });
    }
  });
  app2.post("/api/service-requests/:serviceRequestId/decline", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId, firstName, lastName } = req.user;
      const { serviceRequestId } = req.params;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or PM access required" });
      }
      const declineData = {
        ...req.body,
        declinedBy: userId,
        declinedByName: `${firstName} ${lastName}`
      };
      const decline = await storage.declineServiceRequest(organizationId2, parseInt(serviceRequestId), declineData);
      res.json({
        decline,
        message: "Service request declined"
      });
    } catch (error) {
      console.error("Error declining service request:", error);
      res.status(500).json({ message: "Failed to decline service request" });
    }
  });
  app2.patch("/api/service-requests/notifications/:notificationId/acknowledge", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { notificationId } = req.params;
      const { notes } = req.body;
      const acknowledgment = {
        notificationId: parseInt(notificationId),
        acknowledgedBy: userId,
        acknowledgedAt: /* @__PURE__ */ new Date(),
        notes,
        status: "acknowledged"
      };
      res.json({
        acknowledgment,
        message: "Notification acknowledged"
      });
    } catch (error) {
      console.error("Error acknowledging notification:", error);
      res.status(500).json({ message: "Failed to acknowledge notification" });
    }
  });
  app2.get("/api/service-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { status, priority, serviceCategory, propertyId, awaitingConfirmation } = req.query;
      let serviceRequests = [
        {
          id: 101,
          reservationId: "Demo1234",
          guestName: "Liam Andersen",
          propertyName: "Villa Aruna",
          title: "Private Spa Massage",
          serviceCategory: "spa",
          status: "pending",
          priority: "normal",
          awaitingConfirmation: true,
          estimatedCost: 3500,
          currency: "THB",
          createdAt: /* @__PURE__ */ new Date("2025-07-04T15:30:00Z")
        },
        {
          id: 102,
          reservationId: "Demo1234",
          guestName: "Liam Andersen",
          propertyName: "Villa Aruna",
          title: "Extra Pool Towels",
          serviceCategory: "housekeeping",
          status: "pending",
          priority: "high",
          awaitingConfirmation: true,
          estimatedCost: 0,
          currency: "THB",
          createdAt: /* @__PURE__ */ new Date("2025-07-04T14:45:00Z")
        }
      ];
      if (status) {
        serviceRequests = serviceRequests.filter((req2) => req2.status === status);
      }
      if (priority) {
        serviceRequests = serviceRequests.filter((req2) => req2.priority === priority);
      }
      if (serviceCategory) {
        serviceRequests = serviceRequests.filter((req2) => req2.serviceCategory === serviceCategory);
      }
      if (awaitingConfirmation !== void 0) {
        const needsConfirmation = awaitingConfirmation === "true";
        serviceRequests = serviceRequests.filter((req2) => req2.awaitingConfirmation === needsConfirmation);
      }
      res.json(serviceRequests);
    } catch (error) {
      console.error("Error fetching service requests:", error);
      res.status(500).json({ message: "Failed to fetch service requests" });
    }
  });
  app2.post("/api/guest-portal/analytics/update", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { month, propertyId } = req.body;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or PM access required" });
      }
      const analytics = await storage.updateGuestDashboardAnalytics(organizationId2, month, propertyId);
      res.json(analytics);
    } catch (error) {
      console.error("Error updating guest dashboard analytics:", error);
      res.status(500).json({ message: "Failed to update guest dashboard analytics" });
    }
  });
  app2.get("/api/guest-portal/notifications", isDemoAuthenticated, async (req, res) => {
    try {
      const { id: userId } = req.user;
      const { notificationType, isRead } = req.query;
      const filters = {
        notificationType,
        isRead: isRead !== void 0 ? isRead === "true" : void 0
      };
      const notifications2 = await storage.getGuestCommunicationNotifications(userId, filters);
      res.json(notifications2);
    } catch (error) {
      console.error("Error fetching guest communication notifications:", error);
      res.status(500).json({ message: "Failed to fetch guest communication notifications" });
    }
  });
  app2.patch("/api/guest-portal/notifications/:id/read", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const notification = await storage.markNotificationAsRead(parseInt(id));
      res.json(notification);
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });
  app2.get("/api/guest-portal/session", async (req, res) => {
    try {
      const guestSession = {
        id: 1,
        guestName: "John Smith",
        guestEmail: "john.smith@email.com",
        accessToken: "demo-guest-token",
        isActive: true,
        propertyId: 1,
        currentBookingId: 1,
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3).toISOString()
        // 7 days
      };
      res.json(guestSession);
    } catch (error) {
      console.error("Error fetching guest session:", error);
      res.status(500).json({ message: "Failed to fetch guest session" });
    }
  });
  app2.get("/api/guest-portal/bookings", async (req, res) => {
    try {
      const bookings3 = [
        {
          id: 1,
          propertyName: "Villa Paradise",
          propertyId: 1,
          checkIn: (/* @__PURE__ */ new Date()).toISOString(),
          checkOut: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3).toISOString(),
          guestCount: 4,
          status: "confirmed",
          totalAmount: 2100,
          bookingReference: "VP2024001"
        },
        {
          id: 2,
          propertyName: "Beach House Retreat",
          propertyId: 2,
          checkIn: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3).toISOString(),
          checkOut: new Date(Date.now() + 37 * 24 * 60 * 60 * 1e3).toISOString(),
          guestCount: 6,
          status: "upcoming",
          totalAmount: 3200,
          bookingReference: "BH2024002"
        }
      ];
      res.json(bookings3);
    } catch (error) {
      console.error("Error fetching guest bookings:", error);
      res.status(500).json({ message: "Failed to fetch bookings" });
    }
  });
  app2.get("/api/guest-portal/property-info/:propertyId", async (req, res) => {
    try {
      const propertyId = parseInt(req.params.propertyId);
      const propertyInfo = {
        id: propertyId,
        name: "Villa Paradise",
        address: "123 Paradise Drive, Tropical Island",
        amenities: [
          "Private Pool",
          "WiFi",
          "Air Conditioning",
          "Full Kitchen",
          "Washer/Dryer",
          "Parking",
          "Beach Access",
          "Garden"
        ],
        emergencyContacts: [
          {
            name: "Property Manager",
            phone: "+1-555-123-4567",
            type: "primary"
          },
          {
            name: "Maintenance",
            phone: "+1-555-987-6543",
            type: "maintenance"
          }
        ],
        houseRules: [
          "Check-in: 3:00 PM",
          "Check-out: 11:00 AM",
          "No smoking inside",
          "No pets allowed",
          "Maximum 4 guests",
          "Quiet hours: 10 PM - 8 AM"
        ],
        wifiPassword: "VillaParadise2024"
      };
      res.json(propertyInfo);
    } catch (error) {
      console.error("Error fetching property info:", error);
      res.status(500).json({ message: "Failed to fetch property information" });
    }
  });
  app2.get("/api/guest-portal/addon-services", async (req, res) => {
    try {
      const services = [
        {
          id: 1,
          name: "Private Chef Service",
          description: "Professional chef will prepare a delicious meal for your group",
          price: 150,
          category: "dining",
          duration: "3 hours",
          isAvailable: true
        },
        {
          id: 2,
          name: "Massage Service",
          description: "Relaxing massage service in the comfort of your villa",
          price: 80,
          category: "wellness",
          duration: "1 hour",
          isAvailable: true
        },
        {
          id: 3,
          name: "Extra Cleaning",
          description: "Additional cleaning service during your stay",
          price: 60,
          category: "cleaning",
          duration: "2 hours",
          isAvailable: true
        },
        {
          id: 4,
          name: "Airport Transfer",
          description: "Private transfer to/from the airport",
          price: 45,
          category: "transportation",
          duration: "1 hour",
          isAvailable: true
        },
        {
          id: 5,
          name: "Grocery Delivery",
          description: "Pre-stock your villa with groceries before arrival",
          price: 25,
          category: "convenience",
          duration: "30 minutes",
          isAvailable: true
        }
      ];
      res.json(services);
    } catch (error) {
      console.error("Error fetching addon services:", error);
      res.status(500).json({ message: "Failed to fetch addon services" });
    }
  });
  app2.get("/api/guest-portal/local-attractions", async (req, res) => {
    try {
      const attractions = [
        {
          id: 1,
          name: "Paradise Beach",
          description: "Beautiful white sand beach with crystal clear waters",
          category: "beach",
          distance: "0.2 miles",
          rating: 4.8,
          image: "/images/paradise-beach.jpg"
        },
        {
          id: 2,
          name: "Tropical Restaurant",
          description: "Authentic local cuisine with ocean views",
          category: "dining",
          distance: "0.5 miles",
          rating: 4.6,
          image: "/images/tropical-restaurant.jpg"
        },
        {
          id: 3,
          name: "Island Tours",
          description: "Guided tours around the island's highlights",
          category: "tours",
          distance: "1.0 mile",
          rating: 4.9,
          image: "/images/island-tours.jpg"
        },
        {
          id: 4,
          name: "Adventure Sports Center",
          description: "Kayaking, snorkeling, and water sports rentals",
          category: "activities",
          distance: "1.2 miles",
          rating: 4.7,
          image: "/images/adventure-sports.jpg"
        },
        {
          id: 5,
          name: "Local Market",
          description: "Fresh produce, local crafts, and souvenirs",
          category: "shopping",
          distance: "0.8 miles",
          rating: 4.4,
          image: "/images/local-market.jpg"
        }
      ];
      res.json(attractions);
    } catch (error) {
      console.error("Error fetching local attractions:", error);
      res.status(500).json({ message: "Failed to fetch local attractions" });
    }
  });
  app2.post("/api/guest-portal/report-issue", async (req, res) => {
    try {
      const { category, description, urgency, propertyId, location, images } = req.body;
      const issueReport = {
        id: Date.now(),
        category,
        description,
        urgency,
        propertyId,
        location,
        images: images || [],
        status: "reported",
        reportedBy: "John Smith",
        reportedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const autoTask = await processGuestIssueForAI(issueReport);
      await storage.createNotification({
        organizationId: "demo-org",
        userId: "demo-admin",
        type: "issue_reported",
        title: `Guest Issue Reported: ${category}`,
        message: `${description} (Urgency: ${urgency})`,
        priority: urgency === "urgent" ? "high" : "medium",
        relatedEntityType: "property",
        relatedEntityId: propertyId
      });
      res.json({
        issueReport,
        autoTask,
        message: "Issue reported successfully. We'll address it promptly."
      });
    } catch (error) {
      console.error("Error reporting issue:", error);
      res.status(500).json({ message: "Failed to report issue" });
    }
  });
  app2.post("/api/guest-portal/service-request", async (req, res) => {
    try {
      const { serviceType, description, preferredDate, preferredTime, specialRequests, propertyId } = req.body;
      const serviceRequest = {
        id: Date.now(),
        serviceType,
        description,
        preferredDate,
        preferredTime,
        specialRequests,
        propertyId,
        status: "requested",
        requestedBy: "John Smith",
        requestedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      await storage.createNotification({
        organizationId: "demo-org",
        userId: "demo-admin",
        type: "service_requested",
        title: `Service Request: ${serviceType}`,
        message: `${description} - Preferred: ${preferredDate} at ${preferredTime}`,
        priority: "medium",
        relatedEntityType: "property",
        relatedEntityId: propertyId
      });
      res.json({
        serviceRequest,
        message: "Service request submitted successfully. We'll schedule it for you."
      });
    } catch (error) {
      console.error("Error submitting service request:", error);
      res.status(500).json({ message: "Failed to submit service request" });
    }
  });
  app2.post("/api/guest-portal/addon-booking", async (req, res) => {
    try {
      const { serviceId, quantity, scheduledDate, scheduledTime, notes, propertyId } = req.body;
      const services = [
        { id: 1, price: 150 },
        { id: 2, price: 80 },
        { id: 3, price: 60 },
        { id: 4, price: 45 },
        { id: 5, price: 25 }
      ];
      const service = services.find((s) => s.id === serviceId);
      const totalAmount = service ? service.price * quantity : 0;
      const addonBooking = {
        id: Date.now(),
        serviceId,
        quantity,
        scheduledDate,
        scheduledTime,
        notes,
        propertyId,
        status: "booked",
        bookedBy: "John Smith",
        bookedAt: (/* @__PURE__ */ new Date()).toISOString(),
        totalAmount
      };
      await storage.createNotification({
        organizationId: "demo-org",
        userId: "demo-admin",
        type: "addon_booked",
        title: `Addon Service Booked`,
        message: `Service ID ${serviceId} booked for ${scheduledDate} at ${scheduledTime}`,
        priority: "medium",
        relatedEntityType: "property",
        relatedEntityId: propertyId
      });
      res.json({
        addonBooking,
        message: "Service booked successfully!"
      });
    } catch (error) {
      console.error("Error booking addon service:", error);
      res.status(500).json({ message: "Failed to book service" });
    }
  });
  app2.get("/api/guest-portal/notifications/unread-count", isDemoAuthenticated, async (req, res) => {
    try {
      const { id: userId } = req.user;
      const count3 = await storage.getUnreadNotificationCount(userId);
      res.json({ count: count3 });
    } catch (error) {
      console.error("Error fetching unread notification count:", error);
      res.status(500).json({ message: "Failed to fetch unread notification count" });
    }
  });
  app2.get("/api/guest-portal/chat-messages/:reservationId", async (req, res) => {
    try {
      const { reservationId } = req.params;
      const messages = await storage.getGuestChatMessages(reservationId);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching chat messages:", error);
      res.status(500).json({ message: "Failed to fetch chat messages" });
    }
  });
  app2.post("/api/guest-portal/send-message", async (req, res) => {
    try {
      const { reservationId, messageText, senderType, senderId } = req.body;
      const messageData = {
        organizationId: "Demo1234",
        // Demo organization
        conversationId: 1,
        // Demo conversation
        senderType,
        senderId,
        messageText,
        isSystemGenerated: false
      };
      const message = await storage.createGuestChatMessage(messageData);
      if (senderType === "guest") {
        const aiAnalysis = await storage.analyzeMessageIntent(message.id, messageText);
        if (aiAnalysis && aiAnalysis.requiresAction) {
          await storage.generateServiceRequestFromMessage(message.id, aiAnalysis.intent, aiAnalysis.category);
        }
      }
      res.json(message);
    } catch (error) {
      console.error("Error sending message:", error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });
  app2.get("/api/guest-portal/service-requests/:reservationId", async (req, res) => {
    try {
      const { reservationId } = req.params;
      const requests = await storage.getGuestServiceRequestsByReservation(reservationId);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching service requests:", error);
      res.status(500).json({ message: "Failed to fetch service requests" });
    }
  });
  app2.post("/api/guest-portal/service-requests/:requestId/action", isDemoAuthenticated, async (req, res) => {
    try {
      const { requestId } = req.params;
      const { action, notes } = req.body;
      const { role } = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      let status;
      switch (action) {
        case "accept":
          status = "accepted";
          break;
        case "decline":
          status = "declined";
          break;
        default:
          return res.status(400).json({ message: "Invalid action" });
      }
      const updatedRequest = await storage.updateGuestServiceRequest(parseInt(requestId), {
        status,
        staffNotes: notes,
        processedAt: /* @__PURE__ */ new Date()
      });
      if (status === "accepted" && updatedRequest) {
        await storage.createTaskFromServiceRequest(updatedRequest.id);
      }
      res.json(updatedRequest);
    } catch (error) {
      console.error("Error processing service request action:", error);
      res.status(500).json({ message: "Failed to process service request action" });
    }
  });
  app2.get("/api/property-local-contacts/:propertyId", async (req, res) => {
    try {
      const { propertyId } = req.params;
      const { category } = req.query;
      let contacts;
      if (category) {
        contacts = await storage.getPropertyLocalContactsByCategory(parseInt(propertyId), category);
      } else {
        contacts = await storage.getPropertyLocalContacts(parseInt(propertyId));
      }
      res.json(contacts);
    } catch (error) {
      console.error("Error fetching property local contacts:", error);
      res.status(500).json({ message: "Failed to fetch property local contacts" });
    }
  });
  app2.get("/api/property-local-contacts/contact/:contactId", async (req, res) => {
    try {
      const { contactId } = req.params;
      const contact = await storage.getPropertyLocalContact(parseInt(contactId));
      if (!contact) {
        return res.status(404).json({ message: "Contact not found" });
      }
      res.json(contact);
    } catch (error) {
      console.error("Error fetching property local contact:", error);
      res.status(500).json({ message: "Failed to fetch property local contact" });
    }
  });
  app2.post("/api/property-local-contacts", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      const contactData = {
        ...req.body,
        organizationId: req.body.organizationId || "default-org",
        createdBy: req.user.id
      };
      const contact = await storage.createPropertyLocalContact(contactData);
      res.status(201).json(contact);
    } catch (error) {
      console.error("Error creating property local contact:", error);
      res.status(500).json({ message: "Failed to create property local contact" });
    }
  });
  app2.patch("/api/property-local-contacts/:contactId", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      const { contactId } = req.params;
      const contact = await storage.updatePropertyLocalContact(parseInt(contactId), req.body);
      if (!contact) {
        return res.status(404).json({ message: "Contact not found" });
      }
      res.json(contact);
    } catch (error) {
      console.error("Error updating property local contact:", error);
      res.status(500).json({ message: "Failed to update property local contact" });
    }
  });
  app2.delete("/api/property-local-contacts/:contactId", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      const { contactId } = req.params;
      const success = await storage.deletePropertyLocalContact(parseInt(contactId));
      if (!success) {
        return res.status(404).json({ message: "Contact not found" });
      }
      res.json({ message: "Contact deleted successfully" });
    } catch (error) {
      console.error("Error deleting property local contact:", error);
      res.status(500).json({ message: "Failed to delete property local contact" });
    }
  });
  app2.post("/api/property-local-contacts/reorder", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      const { contactIds, displayOrders } = req.body;
      const success = await storage.reorderPropertyLocalContacts(contactIds, displayOrders);
      res.json({ success });
    } catch (error) {
      console.error("Error reordering property local contacts:", error);
      res.status(500).json({ message: "Failed to reorder property local contacts" });
    }
  });
  app2.get("/api/contact-template-zones", isDemoAuthenticated, async (req, res) => {
    try {
      const { role, organizationId: organizationId2 } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      const templates = await storage.getContactTemplateZones(organizationId2);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching contact template zones:", error);
      res.status(500).json({ message: "Failed to fetch contact template zones" });
    }
  });
  app2.post("/api/contact-template-zones/:templateId/apply", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      const { templateId } = req.params;
      const { propertyId } = req.body;
      const contacts = await storage.applyContactTemplate(propertyId, parseInt(templateId), req.user.id);
      res.json(contacts);
    } catch (error) {
      console.error("Error applying contact template:", error);
      res.status(500).json({ message: "Failed to apply contact template" });
    }
  });
  app2.get("/api/guest-portal/notifications", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      const notifications2 = await storage.getPendingServiceRequestNotifications();
      res.json(notifications2);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });
  app2.get("/api/staff-salary/profiles", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const profiles = await storage.getStaffSalaryProfiles(organizationId2);
      res.json(profiles);
    } catch (error) {
      console.error("Error fetching staff salary profiles:", error);
      res.status(500).json({ message: "Failed to fetch staff salary profiles" });
    }
  });
  app2.get("/api/staff-salary/profiles/:userId", isDemoAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;
      const profile = await storage.getStaffSalaryProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Staff salary profile not found" });
      }
      res.json(profile);
    } catch (error) {
      console.error("Error fetching staff salary profile:", error);
      res.status(500).json({ message: "Failed to fetch staff salary profile" });
    }
  });
  app2.post("/api/staff-salary/profiles", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const profileData = {
        ...req.body,
        organizationId: organizationId2
      };
      const profile = await storage.createStaffSalaryProfile(profileData);
      res.status(201).json(profile);
    } catch (error) {
      console.error("Error creating staff salary profile:", error);
      res.status(500).json({ message: "Failed to create staff salary profile" });
    }
  });
  app2.put("/api/staff-salary/profiles/:userId", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      const { userId } = req.params;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const profile = await storage.updateStaffSalaryProfile(userId, req.body);
      if (!profile) {
        return res.status(404).json({ message: "Staff salary profile not found" });
      }
      res.json(profile);
    } catch (error) {
      console.error("Error updating staff salary profile:", error);
      res.status(500).json({ message: "Failed to update staff salary profile" });
    }
  });
  app2.get("/api/staff-salary/commissions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      const { targetUserId, month, status } = req.query;
      const filters = {
        userId: role === "admin" ? targetUserId : userId,
        month,
        status
      };
      const commissions = await storage.getStaffCommissionLog(organizationId2, filters);
      res.json(commissions);
    } catch (error) {
      console.error("Error fetching staff commission log:", error);
      res.status(500).json({ message: "Failed to fetch staff commission log" });
    }
  });
  app2.post("/api/staff-salary/commissions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or PM access required" });
      }
      const commissionData = {
        ...req.body,
        organizationId: organizationId2
      };
      const commission = await storage.createStaffCommissionLog(commissionData);
      res.status(201).json(commission);
    } catch (error) {
      console.error("Error creating staff commission log:", error);
      res.status(500).json({ message: "Failed to create staff commission log" });
    }
  });
  app2.patch("/api/staff-salary/commissions/:id/status", isDemoAuthenticated, async (req, res) => {
    try {
      const { role, id: userId } = req.user;
      const { id } = req.params;
      const { status } = req.body;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const commission = await storage.updateStaffCommissionStatus(parseInt(id), status, userId);
      if (!commission) {
        return res.status(404).json({ message: "Commission log not found" });
      }
      res.json(commission);
    } catch (error) {
      console.error("Error updating commission status:", error);
      res.status(500).json({ message: "Failed to update commission status" });
    }
  });
  app2.get("/api/staff-salary/time-clocks", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      const { targetUserId, clockType, month } = req.query;
      const filters = {
        userId: role === "admin" ? targetUserId : userId,
        clockType,
        month
      };
      const timeClocks = await storage.getStaffTimeClocks(organizationId2, filters);
      res.json(timeClocks);
    } catch (error) {
      console.error("Error fetching staff time clocks:", error);
      res.status(500).json({ message: "Failed to fetch staff time clocks" });
    }
  });
  app2.post("/api/staff-salary/time-clocks", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const timeClockData = {
        ...req.body,
        organizationId: organizationId2,
        userId,
        clockTime: /* @__PURE__ */ new Date()
      };
      const timeClock = await storage.createStaffTimeClock(timeClockData);
      res.status(201).json(timeClock);
    } catch (error) {
      console.error("Error creating staff time clock:", error);
      res.status(500).json({ message: "Failed to create staff time clock" });
    }
  });
  app2.patch("/api/staff-salary/time-clocks/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const timeClock = await storage.updateStaffTimeClock(parseInt(id), req.body);
      if (!timeClock) {
        return res.status(404).json({ message: "Time clock not found" });
      }
      res.json(timeClock);
    } catch (error) {
      console.error("Error updating staff time clock:", error);
      res.status(500).json({ message: "Failed to update staff time clock" });
    }
  });
  app2.patch("/api/staff-salary/time-clocks/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const { role, id: userId } = req.user;
      const { id } = req.params;
      const { hoursPaid, notes } = req.body;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or PM access required" });
      }
      const timeClock = await storage.approveTimeClock(parseInt(id), userId, parseFloat(hoursPaid), notes);
      if (!timeClock) {
        return res.status(404).json({ message: "Time clock not found" });
      }
      res.json(timeClock);
    } catch (error) {
      console.error("Error approving time clock:", error);
      res.status(500).json({ message: "Failed to approve time clock" });
    }
  });
  app2.get("/api/staff-salary/emergency-summary", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { month } = req.query;
      const summary = await storage.getEmergencyCalloutSummary(organizationId2, month);
      res.json(summary);
    } catch (error) {
      console.error("Error fetching emergency callout summary:", error);
      res.status(500).json({ message: "Failed to fetch emergency callout summary" });
    }
  });
  app2.post("/api/staff-salary/emergency-summary/:userId", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      const { userId } = req.params;
      const { month } = req.body;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const summary = await storage.updateEmergencyCalloutSummary(userId, month);
      res.json(summary);
    } catch (error) {
      console.error("Error updating emergency callout summary:", error);
      res.status(500).json({ message: "Failed to update emergency callout summary" });
    }
  });
  app2.get("/api/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      const { fromPartyId, toPartyId, status } = req.query;
      const filters = {
        fromPartyId: role === "admin" ? fromPartyId : userId,
        toPartyId,
        status
      };
      const invoices2 = await storage.getInvoices(organizationId2, filters);
      res.json(invoices2);
    } catch (error) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });
  app2.get("/api/invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const invoice = await storage.getInvoice(parseInt(id));
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json(invoice);
    } catch (error) {
      console.error("Error fetching invoice:", error);
      res.status(500).json({ message: "Failed to fetch invoice" });
    }
  });
  app2.post("/api/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const invoiceData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId
      };
      const invoice = await storage.createInvoice(invoiceData);
      res.status(201).json(invoice);
    } catch (error) {
      console.error("Error creating invoice:", error);
      res.status(500).json({ message: "Failed to create invoice" });
    }
  });
  app2.put("/api/invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const invoice = await storage.updateInvoice(parseInt(id), req.body);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json(invoice);
    } catch (error) {
      console.error("Error updating invoice:", error);
      res.status(500).json({ message: "Failed to update invoice" });
    }
  });
  app2.delete("/api/invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const success = await storage.deleteInvoice(parseInt(id));
      if (!success) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting invoice:", error);
      res.status(500).json({ message: "Failed to delete invoice" });
    }
  });
  app2.get("/api/invoices/:invoiceId/line-items", isDemoAuthenticated, async (req, res) => {
    try {
      const { invoiceId } = req.params;
      const lineItems = await storage.getInvoiceLineItems(parseInt(invoiceId));
      res.json(lineItems);
    } catch (error) {
      console.error("Error fetching invoice line items:", error);
      res.status(500).json({ message: "Failed to fetch invoice line items" });
    }
  });
  app2.post("/api/invoices/:invoiceId/line-items", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { invoiceId } = req.params;
      const lineItemData = {
        ...req.body,
        organizationId: organizationId2,
        invoiceId: parseInt(invoiceId)
      };
      const lineItem = await storage.createInvoiceLineItem(lineItemData);
      res.status(201).json(lineItem);
    } catch (error) {
      console.error("Error creating invoice line item:", error);
      res.status(500).json({ message: "Failed to create invoice line item" });
    }
  });
  app2.put("/api/invoices/line-items/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const lineItem = await storage.updateInvoiceLineItem(parseInt(id), req.body);
      if (!lineItem) {
        return res.status(404).json({ message: "Invoice line item not found" });
      }
      res.json(lineItem);
    } catch (error) {
      console.error("Error updating invoice line item:", error);
      res.status(500).json({ message: "Failed to update invoice line item" });
    }
  });
  app2.delete("/api/invoices/line-items/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const success = await storage.deleteInvoiceLineItem(parseInt(id));
      if (!success) {
        return res.status(404).json({ message: "Invoice line item not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting invoice line item:", error);
      res.status(500).json({ message: "Failed to delete invoice line item" });
    }
  });
  app2.get("/api/invoices/:invoiceId/payments", isDemoAuthenticated, async (req, res) => {
    try {
      const { invoiceId } = req.params;
      const payments = await storage.getInvoicePayments(parseInt(invoiceId));
      res.json(payments);
    } catch (error) {
      console.error("Error fetching invoice payments:", error);
      res.status(500).json({ message: "Failed to fetch invoice payments" });
    }
  });
  app2.post("/api/invoices/:invoiceId/payments", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const { invoiceId } = req.params;
      const paymentData = {
        ...req.body,
        organizationId: organizationId2,
        invoiceId: parseInt(invoiceId),
        recordedBy: userId
      };
      const payment = await storage.createInvoicePayment(paymentData);
      res.status(201).json(payment);
    } catch (error) {
      console.error("Error creating invoice payment:", error);
      res.status(500).json({ message: "Failed to create invoice payment" });
    }
  });
  app2.get("/api/staff-salary/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { month } = req.query;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const analytics = await storage.getSalaryAnalytics(organizationId2, month);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching salary analytics:", error);
      res.status(500).json({ message: "Failed to fetch salary analytics" });
    }
  });
  app2.post("/api/staff-salary/analytics/:month", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { month } = req.params;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const analytics = await storage.updateSalaryAnalytics(organizationId2, month);
      res.json(analytics);
    } catch (error) {
      console.error("Error updating salary analytics:", error);
      res.status(500).json({ message: "Failed to update salary analytics" });
    }
  });
  app2.get("/api/pm/commission-overview", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { agentType, startDate, endDate, status } = req.query;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Admin or PM role required." });
      }
      const commissions = await storage.getCommissionLog(organizationId2, {
        agentType,
        startDate,
        endDate,
        status
      });
      res.json(commissions);
    } catch (error) {
      console.error("Error fetching PM commission overview:", error);
      res.status(500).json({ message: "Failed to fetch commission overview" });
    }
  });
  app2.get("/api/guest/addon-services", async (req, res) => {
    try {
      const organizationId2 = req.query.organizationId || "default-org";
      const services = await storage.getActiveGuestAddonServices(organizationId2);
      res.json(services);
    } catch (error) {
      console.error("Error fetching guest addon services:", error);
      res.status(500).json({ message: "Failed to fetch guest addon services" });
    }
  });
  app2.post("/api/guest/addon-bookings", async (req, res) => {
    try {
      const {
        serviceId,
        propertyId,
        guestName,
        guestEmail,
        guestPhone,
        serviceDate,
        specialRequests,
        quantity,
        totalAmount,
        currency = "USD",
        organizationId: organizationId2 = "default-org"
      } = req.body;
      const booking = await storage.createGuestAddonBooking({
        serviceId,
        propertyId,
        guestName,
        guestEmail,
        guestPhone,
        bookingDate: /* @__PURE__ */ new Date(),
        serviceDate: new Date(serviceDate),
        specialRequests: specialRequests || "",
        totalAmount: totalAmount.toString(),
        currency,
        status: "pending",
        billingRoute: "guest_billable",
        bookedBy: "guest",
        organizationId: organizationId2
      });
      res.status(201).json(booking);
    } catch (error) {
      console.error("Error creating guest addon booking:", error);
      res.status(500).json({ message: "Failed to create guest addon booking" });
    }
  });
  app2.get("/api/admin/addon-bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Admin or PM role required." });
      }
      const bookings3 = await storage.getGuestAddonBookings(organizationId2);
      const formattedBookings = bookings3.map((booking) => ({
        id: booking.id,
        serviceName: booking.serviceName,
        propertyName: booking.propertyName,
        guestName: booking.guestName,
        guestEmail: booking.guestEmail,
        guestPhone: booking.guestPhone,
        bookingDate: booking.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
        serviceDate: booking.serviceDate.toISOString(),
        status: booking.status,
        totalAmount: booking.totalAmount,
        currency: booking.currency,
        billingRoute: booking.billingRoute,
        complimentaryType: booking.complimentaryType,
        specialRequests: booking.specialRequests,
        internalNotes: booking.internalNotes,
        bookedBy: booking.bookedBy,
        confirmedBy: booking.confirmedBy,
        cancelledBy: booking.cancelledBy,
        cancellationReason: booking.cancellationReason
      }));
      res.json(formattedBookings);
    } catch (error) {
      console.error("Error fetching admin addon bookings:", error);
      res.status(500).json({ message: "Failed to fetch admin addon bookings" });
    }
  });
  app2.put("/api/admin/addon-bookings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { id } = req.params;
      const updateData = req.body;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Admin or PM role required." });
      }
      if (updateData.status === "confirmed") {
        updateData.confirmedBy = userId;
      } else if (updateData.status === "cancelled") {
        updateData.cancelledBy = userId;
      }
      const updatedBooking = await storage.updateGuestAddonBooking(
        parseInt(id),
        organizationId2,
        updateData
      );
      if (!updatedBooking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      res.json(updatedBooking);
    } catch (error) {
      console.error("Error updating addon booking:", error);
      res.status(500).json({ message: "Failed to update addon booking" });
    }
  });
  app2.get("/api/admin/addon-bookings/export", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Admin or PM role required." });
      }
      const bookings3 = await storage.getGuestAddonBookings(organizationId2);
      const csv = [
        "ID,Service,Property,Guest Name,Guest Email,Guest Phone,Service Date,Amount,Currency,Status,Billing Route,Special Requests,Booked Date",
        ...bookings3.map(
          (b) => `${b.id},"${b.serviceName}","${b.propertyName}","${b.guestName}","${b.guestEmail || ""}","${b.guestPhone || ""}","${b.serviceDate.toISOString().split("T")[0]}","${b.totalAmount}","${b.currency}","${b.status}","${b.billingRoute}","${b.specialRequests || ""}","${b.createdAt?.toISOString().split("T")[0] || ""}"`
        )
      ].join("\n");
      res.setHeader("Content-Type", "text/csv");
      res.setHeader("Content-Disposition", `attachment; filename="addon-bookings-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv"`);
      res.send(csv);
    } catch (error) {
      console.error("Error exporting addon bookings:", error);
      res.status(500).json({ message: "Failed to export addon bookings" });
    }
  });
  app2.get("/api/admin/addon-services", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Admin or PM role required." });
      }
      const services = await storage.getGuestAddonServices(organizationId2);
      res.json(services);
    } catch (error) {
      console.error("Error fetching admin addon services:", error);
      res.status(500).json({ message: "Failed to fetch admin addon services" });
    }
  });
  app2.post("/api/admin/addon-services", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      const serviceData = {
        ...req.body,
        organizationId: organizationId2,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      const service = await storage.createGuestAddonService(serviceData);
      res.status(201).json(service);
    } catch (error) {
      console.error("Error creating addon service:", error);
      res.status(500).json({ message: "Failed to create addon service" });
    }
  });
  app2.put("/api/admin/addon-services/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { id } = req.params;
      if (role !== "admin") {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      const updatedService = await storage.updateGuestAddonService(
        parseInt(id),
        organizationId2,
        req.body
      );
      if (!updatedService) {
        return res.status(404).json({ message: "Service not found" });
      }
      res.json(updatedService);
    } catch (error) {
      console.error("Error updating addon service:", error);
      res.status(500).json({ message: "Failed to update addon service" });
    }
  });
  app2.get("/api/loyalty/guests", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { role } = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const profiles = await storage.getAllGuestLoyaltyProfiles(organizationId2);
      res.json(profiles);
    } catch (error) {
      console.error("Error fetching guest loyalty profiles:", error);
      res.status(500).json({ message: "Failed to fetch guest loyalty profiles" });
    }
  });
  app2.get("/api/loyalty/repeat-guests", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { role } = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const repeatGuests = await storage.getRepeatGuests(organizationId2);
      res.json(repeatGuests);
    } catch (error) {
      console.error("Error fetching repeat guests:", error);
      res.status(500).json({ message: "Failed to fetch repeat guests" });
    }
  });
  app2.get("/api/loyalty/tiers", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const tiers = await storage.getLoyaltyTiers(organizationId2);
      res.json(tiers);
    } catch (error) {
      console.error("Error fetching loyalty tiers:", error);
      res.status(500).json({ message: "Failed to fetch loyalty tiers" });
    }
  });
  app2.post("/api/loyalty/tiers", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      const { tierName, minStays, tierColor, benefits, perks } = req.body;
      const tierData = {
        organizationId: organizationId2,
        tierName,
        minStays,
        tierColor: tierColor || "#6B7280",
        benefits: benefits || [],
        perks: perks || {},
        isActive: true
      };
      const tier = await storage.createLoyaltyTier(tierData);
      res.status(201).json(tier);
    } catch (error) {
      console.error("Error creating loyalty tier:", error);
      res.status(500).json({ message: "Failed to create loyalty tier" });
    }
  });
  app2.post("/api/loyalty/check-repeat-guest", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { guestEmail, guestName, guestPhone } = req.body;
      const result = await storage.identifyRepeatGuest(organizationId2, guestEmail, guestName, guestPhone);
      res.json(result);
    } catch (error) {
      console.error("Error checking repeat guest:", error);
      res.status(500).json({ message: "Failed to check repeat guest status" });
    }
  });
  app2.post("/api/loyalty/update-on-booking", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const {
        guestEmail,
        guestName,
        guestPhone,
        propertyId,
        bookingAmount,
        checkInDate,
        checkOutDate
      } = req.body;
      const profile = await storage.updateGuestLoyaltyOnBooking(
        organizationId2,
        guestEmail,
        guestName,
        guestPhone,
        propertyId,
        parseFloat(bookingAmount),
        new Date(checkInDate),
        new Date(checkOutDate)
      );
      res.json(profile);
    } catch (error) {
      console.error("Error updating guest loyalty on booking:", error);
      res.status(500).json({ message: "Failed to update guest loyalty" });
    }
  });
  app2.get("/api/messages", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { threadId } = req.query;
      const messages = await storage.getGuestMessages(organizationId2, threadId);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching guest messages:", error);
      res.status(500).json({ message: "Failed to fetch messages" });
    }
  });
  app2.post("/api/messages", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const {
        threadId,
        guestLoyaltyId,
        bookingId,
        propertyId,
        messageContent,
        messageType,
        attachments,
        urgencyLevel
      } = req.body;
      const messageData = {
        organizationId: organizationId2,
        threadId,
        guestLoyaltyId,
        bookingId,
        propertyId,
        senderId: userId,
        senderType: role,
        senderName: req.user.firstName + " " + req.user.lastName,
        messageContent,
        messageType: messageType || "text",
        attachments: attachments || [],
        isAutomated: false,
        urgencyLevel: urgencyLevel || "normal",
        isRead: false
      };
      const message = await storage.createGuestMessage(messageData);
      res.status(201).json(message);
    } catch (error) {
      console.error("Error creating message:", error);
      res.status(500).json({ message: "Failed to create message" });
    }
  });
  app2.patch("/api/messages/:messageId/read", isDemoAuthenticated, async (req, res) => {
    try {
      const { id: userId } = req.user;
      const { messageId } = req.params;
      await storage.markMessageAsRead(parseInt(messageId), userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking message as read:", error);
      res.status(500).json({ message: "Failed to mark message as read" });
    }
  });
  app2.get("/api/messages/unread-count", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const count3 = await storage.getUnreadMessagesCount(organizationId2);
      res.json({ count: count3 });
    } catch (error) {
      console.error("Error fetching unread messages count:", error);
      res.status(500).json({ message: "Failed to fetch unread count" });
    }
  });
  app2.get("/api/smart-replies", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { category } = req.query;
      const suggestions = await storage.getSmartReplySuggestions(organizationId2, category);
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching smart reply suggestions:", error);
      res.status(500).json({ message: "Failed to fetch smart replies" });
    }
  });
  app2.post("/api/smart-replies", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { category, trigger, messageTemplate, userRole } = req.body;
      const suggestionData = {
        organizationId: organizationId2,
        category,
        trigger,
        messageTemplate,
        userRole: userRole || "all",
        createdBy: userId
      };
      const suggestion = await storage.createSmartReplySuggestion(suggestionData);
      res.status(201).json(suggestion);
    } catch (error) {
      console.error("Error creating smart reply suggestion:", error);
      res.status(500).json({ message: "Failed to create smart reply" });
    }
  });
  app2.post("/api/smart-replies/:suggestionId/use", isDemoAuthenticated, async (req, res) => {
    try {
      const { suggestionId } = req.params;
      await storage.incrementSmartReplyUsage(parseInt(suggestionId));
      res.json({ success: true });
    } catch (error) {
      console.error("Error incrementing smart reply usage:", error);
      res.status(500).json({ message: "Failed to update usage" });
    }
  });
  app2.get("/api/messaging-triggers", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const triggers = await storage.getMessagingTriggers(organizationId2);
      res.json(triggers);
    } catch (error) {
      console.error("Error fetching messaging triggers:", error);
      res.status(500).json({ message: "Failed to fetch messaging triggers" });
    }
  });
  app2.post("/api/messaging-triggers", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin"].includes(role)) {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      const {
        triggerName,
        triggerType,
        triggerCondition,
        delayMinutes,
        messageTemplate,
        loyaltyTierTargets,
        propertyTargets
      } = req.body;
      const triggerData = {
        organizationId: organizationId2,
        triggerName,
        triggerType,
        triggerCondition,
        delayMinutes: delayMinutes || 0,
        messageTemplate,
        isActive: true,
        loyaltyTierTargets: loyaltyTierTargets || [],
        propertyTargets: propertyTargets || [],
        triggerCount: 0
      };
      const trigger = await storage.createMessagingTrigger(triggerData);
      res.status(201).json(trigger);
    } catch (error) {
      console.error("Error creating messaging trigger:", error);
      res.status(500).json({ message: "Failed to create messaging trigger" });
    }
  });
  app2.get("/api/payroll/staff", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { staffId, year, month, paymentStatus } = req.query;
      const targetStaffId = role === "admin" ? staffId : userId;
      const records = await storage.getStaffPayrollRecords(organizationId2, {
        staffId: targetStaffId,
        year: year ? parseInt(year) : void 0,
        month: month ? parseInt(month) : void 0,
        paymentStatus
      });
      res.json(records);
    } catch (error) {
      console.error("Error fetching staff payroll records:", error);
      res.status(500).json({ message: "Failed to fetch payroll records" });
    }
  });
  app2.post("/api/payroll/staff", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const payrollData = {
        ...req.body,
        organizationId: organizationId2,
        processedBy: userId
      };
      const record = await storage.createStaffPayrollRecord(payrollData);
      res.status(201).json(record);
    } catch (error) {
      console.error("Error creating staff payroll record:", error);
      res.status(500).json({ message: "Failed to create payroll record" });
    }
  });
  app2.patch("/api/payroll/staff/:id/mark-paid", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { id } = req.params;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { paymentMethod, paymentReference, paymentSlipUrl, notes } = req.body;
      const record = await storage.markPayrollAsPaid(parseInt(id), userId, {
        paymentMethod,
        paymentReference,
        paymentSlipUrl,
        notes
      });
      res.json(record);
    } catch (error) {
      console.error("Error marking payroll as paid:", error);
      res.status(500).json({ message: "Failed to mark payroll as paid" });
    }
  });
  app2.get("/api/payroll/staff/:staffId/summary", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { staffId } = req.params;
      const { year } = req.query;
      if (role !== "admin" && staffId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      const summary = await storage.getStaffPayrollSummary(
        organizationId2,
        staffId,
        year ? parseInt(year) : void 0
      );
      res.json(summary);
    } catch (error) {
      console.error("Error fetching staff payroll summary:", error);
      res.status(500).json({ message: "Failed to fetch payroll summary" });
    }
  });
  app2.get("/api/commissions/portfolio-manager", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { managerId, year, month, payoutStatus } = req.query;
      const targetManagerId = role === "admin" ? managerId : role === "portfolio-manager" ? userId : void 0;
      if (!targetManagerId && role !== "admin") {
        return res.status(403).json({ message: "Access denied" });
      }
      const commissions = await storage.getPortfolioManagerCommissions(organizationId2, targetManagerId, {
        year: year ? parseInt(year) : void 0,
        month: month ? parseInt(month) : void 0,
        payoutStatus
      });
      res.json(commissions);
    } catch (error) {
      console.error("Error fetching portfolio manager commissions:", error);
      res.status(500).json({ message: "Failed to fetch commissions" });
    }
  });
  app2.post("/api/commissions/portfolio-manager", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const commissionData = {
        ...req.body,
        organizationId: organizationId2,
        processedBy: userId
      };
      const commission = await storage.createPortfolioManagerCommission(commissionData);
      res.status(201).json(commission);
    } catch (error) {
      console.error("Error creating portfolio manager commission:", error);
      res.status(500).json({ message: "Failed to create commission" });
    }
  });
  app2.patch("/api/commissions/portfolio-manager/:id/request-payout", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { id } = req.params;
      if (role !== "portfolio-manager" && role !== "admin") {
        return res.status(403).json({ message: "Portfolio Manager or Admin access required" });
      }
      const commission = await storage.requestPortfolioManagerPayout(parseInt(id));
      res.json(commission);
    } catch (error) {
      console.error("Error requesting portfolio manager payout:", error);
      res.status(500).json({ message: "Failed to request payout" });
    }
  });
  app2.patch("/api/commissions/portfolio-manager/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { id } = req.params;
      const { notes } = req.body;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const commission = await storage.approvePortfolioManagerPayout(parseInt(id), userId, notes);
      res.json(commission);
    } catch (error) {
      console.error("Error approving portfolio manager payout:", error);
      res.status(500).json({ message: "Failed to approve payout" });
    }
  });
  app2.post("/api/commissions/portfolio-manager/:id/generate-invoice", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { id } = req.params;
      if (role !== "portfolio-manager" && role !== "admin") {
        return res.status(403).json({ message: "Portfolio Manager or Admin access required" });
      }
      const invoiceNumber = await storage.generateInvoiceNumber(organizationId2, "commission");
      const invoicePdfUrl = `/api/invoices/${invoiceNumber}.pdf`;
      const commission = await storage.generatePortfolioManagerInvoice(parseInt(id), invoiceNumber, invoicePdfUrl);
      res.json(commission);
    } catch (error) {
      console.error("Error generating portfolio manager invoice:", error);
      res.status(500).json({ message: "Failed to generate invoice" });
    }
  });
  app2.get("/api/commissions/referral-agent", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { agentId, year, month, propertyId, paymentStatus } = req.query;
      const targetAgentId = role === "admin" ? agentId : role === "referral-agent" ? userId : void 0;
      if (!targetAgentId && role !== "admin") {
        return res.status(403).json({ message: "Access denied" });
      }
      const logs = await storage.getReferralAgentCommissionLogs(organizationId2, targetAgentId, {
        year: year ? parseInt(year) : void 0,
        month: month ? parseInt(month) : void 0,
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        paymentStatus
      });
      res.json(logs);
    } catch (error) {
      console.error("Error fetching referral agent commission logs:", error);
      res.status(500).json({ message: "Failed to fetch commission logs" });
    }
  });
  app2.post("/api/commissions/referral-agent", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const logData = {
        ...req.body,
        organizationId: organizationId2,
        processedBy: userId
      };
      const log2 = await storage.createReferralAgentCommissionLog(logData);
      res.status(201).json(log2);
    } catch (error) {
      console.error("Error creating referral agent commission log:", error);
      res.status(500).json({ message: "Failed to create commission log" });
    }
  });
  app2.patch("/api/commissions/referral-agent/:id/request-payment", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { id } = req.params;
      if (role !== "referral-agent" && role !== "admin") {
        return res.status(403).json({ message: "Referral Agent or Admin access required" });
      }
      const log2 = await storage.requestReferralAgentPayment(parseInt(id));
      res.json(log2);
    } catch (error) {
      console.error("Error requesting referral agent payment:", error);
      res.status(500).json({ message: "Failed to request payment" });
    }
  });
  app2.patch("/api/commissions/referral-agent/:id/confirm-payment", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { id } = req.params;
      const { paymentSlipUrl, notes } = req.body;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const log2 = await storage.confirmReferralAgentPayment(parseInt(id), userId, paymentSlipUrl, notes);
      res.json(log2);
    } catch (error) {
      console.error("Error confirming referral agent payment:", error);
      res.status(500).json({ message: "Failed to confirm payment" });
    }
  });
  app2.get("/api/invoices/universal", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { createdBy, invoiceType, status, fromDate, toDate } = req.query;
      const targetCreatedBy = role === "admin" ? createdBy : userId;
      const invoices2 = await storage.getUniversalInvoices(organizationId2, {
        createdBy: targetCreatedBy,
        invoiceType,
        status,
        fromDate: fromDate ? new Date(fromDate) : void 0,
        toDate: toDate ? new Date(toDate) : void 0
      });
      res.json(invoices2);
    } catch (error) {
      console.error("Error fetching universal invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });
  app2.post("/api/invoices/universal", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const invoiceNumber = await storage.generateInvoiceNumber(organizationId2, req.body.invoiceType || "custom");
      const invoiceData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId,
        invoiceNumber
      };
      const invoice = await storage.createUniversalInvoice(invoiceData);
      if (req.body.lineItems && req.body.lineItems.length > 0) {
        const lineItemsData = req.body.lineItems.map((item) => ({
          ...item,
          organizationId: organizationId2,
          invoiceId: invoice.id
        }));
        const lineItems = await storage.addInvoiceLineItems(lineItemsData);
        res.status(201).json({ ...invoice, lineItems });
      } else {
        res.status(201).json({ ...invoice, lineItems: [] });
      }
    } catch (error) {
      console.error("Error creating universal invoice:", error);
      res.status(500).json({ message: "Failed to create invoice" });
    }
  });
  app2.patch("/api/invoices/universal/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { id } = req.params;
      const existingInvoices = await storage.getUniversalInvoices(organizationId2, { createdBy: userId });
      const canEdit = role === "admin" || existingInvoices.some((inv) => inv.id === parseInt(id));
      if (!canEdit) {
        return res.status(403).json({ message: "Access denied" });
      }
      const invoice = await storage.updateUniversalInvoice(parseInt(id), req.body);
      res.json(invoice);
    } catch (error) {
      console.error("Error updating universal invoice:", error);
      res.status(500).json({ message: "Failed to update invoice" });
    }
  });
  app2.get("/api/invoices/generate-number", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { type } = req.query;
      const invoiceNumber = await storage.generateInvoiceNumber(organizationId2, type || "custom");
      res.json({ invoiceNumber });
    } catch (error) {
      console.error("Error generating invoice number:", error);
      res.status(500).json({ message: "Failed to generate invoice number" });
    }
  });
  app2.post("/api/payments/confirmations", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const confirmationData = {
        ...req.body,
        organizationId: organizationId2,
        uploadedBy: userId
      };
      const confirmation = await storage.createPaymentConfirmation(confirmationData);
      res.status(201).json(confirmation);
    } catch (error) {
      console.error("Error creating payment confirmation:", error);
      res.status(500).json({ message: "Failed to create payment confirmation" });
    }
  });
  app2.get("/api/payments/confirmations", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { paymentType, referenceEntityType, referenceEntityId, confirmationStatus } = req.query;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const confirmations = await storage.getPaymentConfirmations(organizationId2, {
        paymentType,
        referenceEntityType,
        referenceEntityId: referenceEntityId ? parseInt(referenceEntityId) : void 0,
        confirmationStatus
      });
      res.json(confirmations);
    } catch (error) {
      console.error("Error fetching payment confirmations:", error);
      res.status(500).json({ message: "Failed to fetch payment confirmations" });
    }
  });
  app2.patch("/api/payments/confirmations/:id/confirm", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { id } = req.params;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const confirmation = await storage.confirmPayment(parseInt(id), userId);
      res.json(confirmation);
    } catch (error) {
      console.error("Error confirming payment:", error);
      res.status(500).json({ message: "Failed to confirm payment" });
    }
  });
  app2.get("/api/analytics/staff-salaries", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const analytics = await storage.getStaffSalaryAnalytics(organizationId2);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching staff salary analytics:", error);
      res.status(500).json({ message: "Failed to fetch salary analytics" });
    }
  });
  app2.get("/api/analytics/commissions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const analytics = await storage.getCommissionAnalytics(organizationId2);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching commission analytics:", error);
      res.status(500).json({ message: "Failed to fetch commission analytics" });
    }
  });
  app2.get("/api/booking-calendar", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { propertyId, startDate, endDate, bookingStatus, bookingSource } = req.query;
      if (!["admin", "portfolio-manager", "owner", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const bookings3 = await storage.getBookingCalendar(organizationId2, {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        startDate,
        endDate,
        bookingStatus,
        bookingSource
      });
      res.json(bookings3);
    } catch (error) {
      console.error("Error fetching booking calendar:", error);
      res.status(500).json({ message: "Failed to fetch booking calendar" });
    }
  });
  app2.post("/api/booking-calendar", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const bookingData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId
      };
      const booking = await storage.createBookingEntry(bookingData);
      res.json(booking);
    } catch (error) {
      console.error("Error creating booking:", error);
      res.status(500).json({ message: "Failed to create booking" });
    }
  });
  app2.get("/api/properties/:propertyId/upcoming-bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { propertyId } = req.params;
      const { days = 30 } = req.query;
      if (!["admin", "portfolio-manager", "owner", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const bookings3 = await storage.getUpcomingBookings(organizationId2, parseInt(propertyId), parseInt(days));
      res.json(bookings3);
    } catch (error) {
      console.error("Error fetching upcoming bookings:", error);
      res.status(500).json({ message: "Failed to fetch upcoming bookings" });
    }
  });
  app2.get("/api/booking-analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { propertyId } = req.query;
      if (!["admin", "portfolio-manager", "owner"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const analytics = await storage.getBookingAnalytics(organizationId2, propertyId ? parseInt(propertyId) : void 0);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching booking analytics:", error);
      res.status(500).json({ message: "Failed to fetch booking analytics" });
    }
  });
  app2.get("/api/property-availability", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId, startDate, endDate, availabilityType } = req.query;
      const availability = await storage.getPropertyAvailability(organizationId2, {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        startDate,
        endDate,
        availabilityType
      });
      res.json(availability);
    } catch (error) {
      console.error("Error fetching property availability:", error);
      res.status(500).json({ message: "Failed to fetch property availability" });
    }
  });
  app2.post("/api/property-availability", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const availabilityData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId
      };
      const availability = await storage.createPropertyAvailability(availabilityData);
      res.json(availability);
    } catch (error) {
      console.error("Error creating availability entry:", error);
      res.status(500).json({ message: "Failed to create availability entry" });
    }
  });
  app2.get("/api/properties/:propertyId/check-availability", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyId } = req.params;
      const { checkIn, checkOut } = req.query;
      if (!checkIn || !checkOut) {
        return res.status(400).json({ message: "Check-in and check-out dates are required" });
      }
      const isAvailable = await storage.checkPropertyAvailability(parseInt(propertyId), checkIn, checkOut);
      res.json({ available: isAvailable });
    } catch (error) {
      console.error("Error checking property availability:", error);
      res.status(500).json({ message: "Failed to check property availability" });
    }
  });
  app2.get("/api/agent/search-properties", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (role !== "retail-agent") {
        return res.status(403).json({ message: "Retail agent access required" });
      }
      const {
        location,
        zone,
        minBedrooms,
        maxBedrooms,
        minPrice,
        maxPrice,
        amenities,
        checkIn,
        checkOut,
        maxGuests
      } = req.query;
      const filters = {
        location,
        zone,
        minBedrooms: minBedrooms ? parseInt(minBedrooms) : void 0,
        maxBedrooms: maxBedrooms ? parseInt(maxBedrooms) : void 0,
        minPrice: minPrice ? parseFloat(minPrice) : void 0,
        maxPrice: maxPrice ? parseFloat(maxPrice) : void 0,
        amenities: amenities ? JSON.parse(amenities) : void 0,
        checkIn,
        checkOut,
        maxGuests: maxGuests ? parseInt(maxGuests) : void 0
      };
      const properties2 = await storage.searchPropertiesForAgents(organizationId2, filters);
      res.json(properties2);
    } catch (error) {
      console.error("Error searching properties for agents:", error);
      res.status(500).json({ message: "Failed to search properties" });
    }
  });
  app2.get("/api/agent/search-preferences", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: agentId } = req.user;
      if (role !== "retail-agent") {
        return res.status(403).json({ message: "Retail agent access required" });
      }
      const preferences = await storage.getAgentSearchPreferences(organizationId2, agentId);
      res.json(preferences || {});
    } catch (error) {
      console.error("Error fetching agent preferences:", error);
      res.status(500).json({ message: "Failed to fetch agent preferences" });
    }
  });
  app2.put("/api/agent/search-preferences", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: agentId } = req.user;
      if (role !== "retail-agent") {
        return res.status(403).json({ message: "Retail agent access required" });
      }
      const preferences = await storage.updateAgentSearchPreferences(organizationId2, agentId, req.body);
      res.json(preferences);
    } catch (error) {
      console.error("Error updating agent preferences:", error);
      res.status(500).json({ message: "Failed to update agent preferences" });
    }
  });
  app2.post("/api/agent/booking-enquiry", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: agentId } = req.user;
      if (role !== "retail-agent") {
        return res.status(403).json({ message: "Retail agent access required" });
      }
      const enquiryReference = `ENQ-${Date.now()}-${agentId.slice(-4).toUpperCase()}`;
      const enquiryData = {
        ...req.body,
        organizationId: organizationId2,
        agentId,
        enquiryReference,
        commissionRate: "10.00"
        // Standard 10% commission
      };
      if (enquiryData.quotedPrice) {
        enquiryData.calculatedCommission = (parseFloat(enquiryData.quotedPrice) * 0.1).toString();
      }
      const enquiry = await storage.createBookingEnquiry(enquiryData);
      res.json(enquiry);
    } catch (error) {
      console.error("Error creating booking enquiry:", error);
      res.status(500).json({ message: "Failed to create booking enquiry" });
    }
  });
  app2.get("/api/agent/booking-enquiries", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: agentId } = req.user;
      if (role !== "retail-agent") {
        return res.status(403).json({ message: "Retail agent access required" });
      }
      const { status, propertyId } = req.query;
      const enquiries = await storage.getAgentBookingEnquiries(organizationId2, {
        agentId,
        enquiryStatus: status,
        propertyId: propertyId ? parseInt(propertyId) : void 0
      });
      res.json(enquiries);
    } catch (error) {
      console.error("Error fetching booking enquiries:", error);
      res.status(500).json({ message: "Failed to fetch booking enquiries" });
    }
  });
  app2.get("/api/booking-enquiries", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { agentId, propertyId, status } = req.query;
      const enquiries = await storage.getAgentBookingEnquiries(organizationId2, {
        agentId,
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        enquiryStatus: status
      });
      res.json(enquiries);
    } catch (error) {
      console.error("Error fetching booking enquiries:", error);
      res.status(500).json({ message: "Failed to fetch booking enquiries" });
    }
  });
  app2.put("/api/booking-enquiries/:id/status", isDemoAuthenticated, async (req, res) => {
    try {
      const { role, id: userId } = req.user;
      const { id } = req.params;
      const { status } = req.body;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const enquiry = await storage.updateEnquiryStatus(parseInt(id), status, userId);
      res.json(enquiry);
    } catch (error) {
      console.error("Error updating enquiry status:", error);
      res.status(500).json({ message: "Failed to update enquiry status" });
    }
  });
  app2.post("/api/booking-enquiries/:id/convert", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      const { id } = req.params;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const bookingData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId,
        agentCommissionApplicable: true,
        retailAgentId: req.body.retailAgentId,
        agentCommissionAmount: req.body.calculatedCommission
      };
      const result = await storage.convertEnquiryToBooking(parseInt(id), bookingData);
      res.json(result);
    } catch (error) {
      console.error("Error converting enquiry to booking:", error);
      res.status(500).json({ message: "Failed to convert enquiry to booking" });
    }
  });
  app2.get("/api/staff-clock-entries", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      const { staffId, workDate, status, propertyId, taskId } = req.query;
      const filterStaffId = role === "staff" ? userId : staffId;
      const entries = await storage.getStaffClockEntries(organizationId2, {
        staffId: filterStaffId,
        workDate,
        status,
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        taskId: taskId ? parseInt(taskId) : void 0
      });
      res.json(entries);
    } catch (error) {
      console.error("Error fetching staff clock entries:", error);
      res.status(500).json({ message: "Failed to fetch clock entries" });
    }
  });
  app2.get("/api/staff-clock-entries/active", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: staffId } = req.user;
      const activeEntry = await storage.getActiveStaffClockEntry(organizationId2, staffId);
      res.json(activeEntry || null);
    } catch (error) {
      console.error("Error fetching active clock entry:", error);
      res.status(500).json({ message: "Failed to fetch active clock entry" });
    }
  });
  app2.get("/api/staff-clock-entries/today", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: staffId } = req.user;
      const todayEntries = await storage.getTodayClockEntries(organizationId2, staffId);
      res.json(todayEntries);
    } catch (error) {
      console.error("Error fetching today's clock entries:", error);
      res.status(500).json({ message: "Failed to fetch today's entries" });
    }
  });
  app2.post("/api/staff-clock-entries/clock-in", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: staffId } = req.user;
      const { taskDescription, propertyId, taskId, gpsLocation, locationAccuracy } = req.body;
      const activeEntry = await storage.getActiveStaffClockEntry(organizationId2, staffId);
      if (activeEntry) {
        return res.status(400).json({
          message: "You are already clocked in. Please clock out first.",
          activeEntry
        });
      }
      const currentTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-GB", { hour12: false });
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const clockEntry = await storage.createStaffClockEntry({
        organizationId: organizationId2,
        staffId,
        taskId: taskId || null,
        propertyId: propertyId || null,
        taskDescription,
        clockInTime: currentTime,
        workDate: today,
        gpsLocationIn: gpsLocation,
        locationAccuracy: locationAccuracy ? parseFloat(locationAccuracy) : null,
        status: "active"
      });
      res.json({
        message: "Successfully clocked in",
        entry: clockEntry
      });
    } catch (error) {
      console.error("Error clocking in:", error);
      res.status(500).json({ message: "Failed to clock in" });
    }
  });
  app2.post("/api/staff-clock-entries/clock-out", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: staffId } = req.user;
      const { gpsLocation, photoEvidence } = req.body;
      const activeEntry = await storage.getActiveStaffClockEntry(organizationId2, staffId);
      if (!activeEntry) {
        return res.status(400).json({
          message: "No active clock entry found. Please clock in first."
        });
      }
      const currentTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-GB", { hour12: false });
      const clockInTime = activeEntry.clockInTime;
      const [inHours, inMinutes] = clockInTime.split(":").map(Number);
      const [outHours, outMinutes] = currentTime.split(":").map(Number);
      const clockInMinutes = inHours * 60 + inMinutes;
      const clockOutMinutes = outHours * 60 + outMinutes;
      const totalMinutes = clockOutMinutes - clockInMinutes;
      const totalHours = totalMinutes / 60;
      const standardEndTime = 18 * 60;
      const overtimeStartTime = 20 * 60;
      let overtimeHours = 0;
      if (clockOutMinutes > overtimeStartTime) {
        overtimeHours = (clockOutMinutes - overtimeStartTime) / 60;
      }
      const updatedEntry = await storage.clockOutStaffEntry(
        activeEntry.id,
        currentTime,
        gpsLocation,
        photoEvidence,
        totalHours,
        overtimeHours
      );
      res.json({
        message: "Successfully clocked out",
        entry: updatedEntry,
        totalHours: totalHours.toFixed(2),
        overtimeHours: overtimeHours.toFixed(2)
      });
    } catch (error) {
      console.error("Error clocking out:", error);
      res.status(500).json({ message: "Failed to clock out" });
    }
  });
  app2.post("/api/staff-clock-entries/:entryId/approve-overtime", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: approvedBy } = req.user;
      const { entryId } = req.params;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const approvedEntry = await storage.approveOvertimeClockEntry(
        parseInt(entryId),
        approvedBy
      );
      if (!approvedEntry) {
        return res.status(404).json({ message: "Clock entry not found" });
      }
      res.json({
        message: "Overtime approved successfully",
        entry: approvedEntry
      });
    } catch (error) {
      console.error("Error approving overtime:", error);
      res.status(500).json({ message: "Failed to approve overtime" });
    }
  });
  app2.get("/api/staff-clock-entries/:entryId", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      const { entryId } = req.params;
      const entry = await storage.getStaffClockEntry(parseInt(entryId));
      if (!entry) {
        return res.status(404).json({ message: "Clock entry not found" });
      }
      if (role === "staff" && entry.staffId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      res.json(entry);
    } catch (error) {
      console.error("Error fetching clock entry:", error);
      res.status(500).json({ message: "Failed to fetch clock entry" });
    }
  });
  app2.get("/api/invoice-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const { templateType, isActive } = req.query;
      const filters = {};
      if (templateType) filters.templateType = templateType;
      if (isActive !== void 0) filters.isActive = isActive === "true";
      const templates = await storage.getInvoiceTemplates(organizationId2, filters);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching invoice templates:", error);
      res.status(500).json({ message: "Failed to fetch invoice templates" });
    }
  });
  app2.post("/api/invoice-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: createdBy } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const templateData = {
        ...req.body,
        organizationId: organizationId2
      };
      const template = await storage.createInvoiceTemplate(templateData);
      res.json(template);
    } catch (error) {
      console.error("Error creating invoice template:", error);
      res.status(500).json({ message: "Failed to create invoice template" });
    }
  });
  app2.put("/api/invoice-templates/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      const { id } = req.params;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const template = await storage.updateInvoiceTemplate(parseInt(id), req.body);
      if (!template) {
        return res.status(404).json({ message: "Invoice template not found" });
      }
      res.json(template);
    } catch (error) {
      console.error("Error updating invoice template:", error);
      res.status(500).json({ message: "Failed to update invoice template" });
    }
  });
  app2.get("/api/generated-invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager", "owner"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { status, paymentStatus, senderType, receiverType, startDate, endDate } = req.query;
      const filters = {};
      if (status) filters.status = status;
      if (paymentStatus) filters.paymentStatus = paymentStatus;
      if (senderType) filters.senderType = senderType;
      if (receiverType) filters.receiverType = receiverType;
      if (startDate) filters.startDate = startDate;
      if (endDate) filters.endDate = endDate;
      const invoices2 = await storage.getGeneratedInvoices(organizationId2, filters);
      res.json(invoices2);
    } catch (error) {
      console.error("Error fetching generated invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });
  app2.get("/api/generated-invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      const { id } = req.params;
      if (!["admin", "portfolio-manager", "owner"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const invoice = await storage.getGeneratedInvoiceById(parseInt(id));
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      const lineItems = await storage.getInvoiceLineItems(invoice.id);
      const bookingLinks = await storage.getInvoiceBookingLinks(invoice.id);
      const serviceLinks = await storage.getInvoiceServiceLinks(invoice.id);
      res.json({
        ...invoice,
        lineItems,
        bookingLinks,
        serviceLinks
      });
    } catch (error) {
      console.error("Error fetching invoice details:", error);
      res.status(500).json({ message: "Failed to fetch invoice details" });
    }
  });
  app2.post("/api/generate-invoice", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: createdBy } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const {
        templateId,
        senderType,
        receiverType,
        senderId,
        receiverId,
        senderName,
        receiverName,
        senderEmail,
        receiverEmail,
        periodStart,
        periodEnd,
        propertyIds,
        includeBookings,
        includeAddons,
        includeCommissions,
        taxEnabled,
        taxRate,
        notes,
        dueDate
      } = req.body;
      const invoiceNumber = await storage.generateInvoiceNumber(organizationId2);
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const invoiceData = {
        organizationId: organizationId2,
        invoiceNumber,
        templateId: templateId || null,
        senderType,
        senderId,
        senderName,
        senderEmail,
        receiverType,
        receiverId,
        receiverName,
        receiverEmail,
        invoiceDate: today,
        dueDate: dueDate || today,
        periodStart,
        periodEnd,
        subtotal: "0",
        taxAmount: "0",
        totalAmount: "0",
        currency: "AUD",
        notes,
        createdBy
      };
      const invoice = await storage.createGeneratedInvoice(invoiceData);
      let subtotal = 0;
      if (includeBookings) {
        const bookings3 = await storage.getBookingsForInvoice(organizationId2, {
          propertyIds,
          startDate: periodStart,
          endDate: periodEnd,
          ownerId: receiverType === "owner" ? receiverId : void 0
        });
        for (const booking of bookings3) {
          const amount = parseFloat(booking.totalAmount);
          await storage.addInvoiceLineItem({
            invoiceId: invoice.id,
            itemType: "booking_revenue",
            description: `Booking Revenue - ${booking.guestName} (${booking.checkIn} to ${booking.checkOut})`,
            itemReference: booking.id.toString(),
            quantity: "1",
            unitPrice: amount.toString(),
            lineTotal: amount.toString(),
            category: "revenue",
            subcategory: "accommodation",
            sourceType: "booking",
            sourceId: booking.id
          });
          await storage.addInvoiceBookingLink({
            invoiceId: invoice.id,
            bookingId: booking.id,
            bookingRevenue: amount.toString(),
            managementCommission: (amount * 0.3).toString(),
            portfolioManagerCommission: (amount * 0.15).toString(),
            ownerPayout: (amount * 0.7).toString(),
            addonServicesTotal: "0"
          });
          subtotal += amount;
          if (receiverType === "owner") {
            const commissionAmount = amount * 0.3;
            await storage.addInvoiceLineItem({
              invoiceId: invoice.id,
              itemType: "commission",
              description: `Management Commission (30%) - ${booking.guestName}`,
              itemReference: booking.id.toString(),
              quantity: "1",
              unitPrice: (-commissionAmount).toString(),
              lineTotal: (-commissionAmount).toString(),
              category: "commission",
              subcategory: "management_fee",
              sourceType: "booking",
              sourceId: booking.id
            });
            subtotal -= commissionAmount;
          }
        }
      }
      if (includeAddons) {
        const addonServices2 = await storage.getAddonServicesForInvoice(organizationId2, {
          propertyIds,
          startDate: periodStart,
          endDate: periodEnd,
          billingRoute: receiverType === "owner" ? "owner_billable" : void 0
        });
        for (const service of addonServices2) {
          const amount = parseFloat(service.totalAmount);
          await storage.addInvoiceLineItem({
            invoiceId: invoice.id,
            itemType: "addon_service",
            description: `${service.serviceName} - ${service.guestName}`,
            itemReference: service.id.toString(),
            quantity: "1",
            unitPrice: amount.toString(),
            lineTotal: amount.toString(),
            category: "service",
            subcategory: service.serviceName.toLowerCase().replace(/\s+/g, "_"),
            sourceType: "addon_service",
            sourceId: service.id
          });
          await storage.addInvoiceServiceLink({
            invoiceId: invoice.id,
            serviceBookingId: service.id,
            serviceName: service.serviceName,
            serviceAmount: amount.toString(),
            billingRoute: service.billingRoute
          });
          if (service.billingRoute === "owner_billable") {
            subtotal += amount;
          } else if (service.billingRoute === "company_expense") {
            subtotal -= amount;
          }
        }
      }
      if (includeCommissions && receiverType === "portfolio_manager") {
        const commissionData = await storage.getCommissionDataForInvoice(organizationId2, {
          portfolioManagerId: receiverId,
          startDate: periodStart,
          endDate: periodEnd,
          propertyIds
        });
        for (const commission of commissionData) {
          const amount = commission.portfolioManagerShare;
          await storage.addInvoiceLineItem({
            invoiceId: invoice.id,
            itemType: "commission",
            description: `Portfolio Manager Commission (50% of management) - ${commission.guestName}`,
            itemReference: commission.id.toString(),
            quantity: "1",
            unitPrice: amount.toString(),
            lineTotal: amount.toString(),
            category: "commission",
            subcategory: "portfolio_manager_share",
            sourceType: "booking",
            sourceId: commission.id
          });
          subtotal += amount;
        }
      }
      let taxAmount = 0;
      if (taxEnabled && taxRate > 0) {
        taxAmount = subtotal * (parseFloat(taxRate) / 100);
        await storage.addInvoiceLineItem({
          invoiceId: invoice.id,
          itemType: "tax",
          description: `Tax (${taxRate}%)`,
          quantity: "1",
          unitPrice: taxAmount.toString(),
          lineTotal: taxAmount.toString(),
          category: "tax",
          isManualEntry: true
        });
      }
      const totalAmount = subtotal + taxAmount;
      await storage.updateGeneratedInvoice(invoice.id, {
        subtotal: subtotal.toString(),
        taxAmount: taxAmount.toString(),
        totalAmount: totalAmount.toString(),
        status: "draft"
      });
      res.json({
        message: "Invoice generated successfully",
        invoice: {
          ...invoice,
          subtotal: subtotal.toString(),
          taxAmount: taxAmount.toString(),
          totalAmount: totalAmount.toString()
        },
        invoiceNumber
      });
    } catch (error) {
      console.error("Error generating invoice:", error);
      res.status(500).json({ message: "Failed to generate invoice" });
    }
  });
  app2.post("/api/generated-invoices/:id/mark-paid", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      const { id } = req.params;
      const { paymentMethod, paymentReference, paymentDate } = req.body;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const invoice = await storage.markInvoiceAsPaid(parseInt(id), {
        paymentStatus: "paid",
        paymentMethod,
        paymentReference,
        paymentDate
      });
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json({
        message: "Invoice marked as paid successfully",
        invoice
      });
    } catch (error) {
      console.error("Error marking invoice as paid:", error);
      res.status(500).json({ message: "Failed to mark invoice as paid" });
    }
  });
  app2.put("/api/invoice-line-items/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      const { id } = req.params;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const lineItem = await storage.updateInvoiceLineItem(parseInt(id), req.body);
      if (!lineItem) {
        return res.status(404).json({ message: "Line item not found" });
      }
      res.json(lineItem);
    } catch (error) {
      console.error("Error updating line item:", error);
      res.status(500).json({ message: "Failed to update line item" });
    }
  });
  app2.post("/api/generated-invoices/:invoiceId/line-items", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      const { invoiceId } = req.params;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const lineItemData = {
        ...req.body,
        invoiceId: parseInt(invoiceId),
        isManualEntry: true
      };
      const lineItem = await storage.addInvoiceLineItem(lineItemData);
      res.json(lineItem);
    } catch (error) {
      console.error("Error adding line item:", error);
      res.status(500).json({ message: "Failed to add line item" });
    }
  });
  app2.delete("/api/invoice-line-items/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      const { id } = req.params;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const deleted = await storage.deleteInvoiceLineItem(parseInt(id));
      if (!deleted) {
        return res.status(404).json({ message: "Line item not found" });
      }
      res.json({ message: "Line item deleted successfully" });
    } catch (error) {
      console.error("Error deleting line item:", error);
      res.status(500).json({ message: "Failed to delete line item" });
    }
  });
  app2.get("/api/invoice-analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const { startDate, endDate } = req.query;
      const dateRange = startDate && endDate ? { startDate, endDate } : void 0;
      const analytics = await storage.getInvoiceAnalytics(organizationId2, dateRange);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching invoice analytics:", error);
      res.status(500).json({ message: "Failed to fetch invoice analytics" });
    }
  });
  app2.get("/api/invoice-preview-data", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const { startDate, endDate, propertyIds, ownerId, portfolioManagerId } = req.query;
      const bookings3 = await storage.getBookingsForInvoice(organizationId2, {
        startDate,
        endDate,
        propertyIds: propertyIds ? propertyIds.split(",").map(Number) : void 0,
        ownerId,
        portfolioManagerId
      });
      const addonServices2 = await storage.getAddonServicesForInvoice(organizationId2, {
        startDate,
        endDate,
        propertyIds: propertyIds ? propertyIds.split(",").map(Number) : void 0
      });
      const bookingTotal = bookings3.reduce((sum4, booking) => sum4 + parseFloat(booking.totalAmount), 0);
      const addonTotal = addonServices2.reduce((sum4, service) => sum4 + parseFloat(service.totalAmount), 0);
      res.json({
        bookings: bookings3,
        addonServices: addonServices2,
        totals: {
          bookingRevenue: bookingTotal,
          addonServices: addonTotal,
          managementCommission: bookingTotal * 0.3,
          portfolioManagerCommission: bookingTotal * 0.15,
          ownerPayout: bookingTotal * 0.7
        }
      });
    } catch (error) {
      console.error("Error fetching invoice preview data:", error);
      res.status(500).json({ message: "Failed to fetch preview data" });
    }
  });
  app2.put("/api/properties/:propertyId/search-index", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { propertyId } = req.params;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const indexData = {
        ...req.body,
        organizationId: organizationId2
      };
      const searchIndex = await storage.updatePropertySearchIndex(parseInt(propertyId), indexData);
      res.json(searchIndex);
    } catch (error) {
      console.error("Error updating property search index:", error);
      res.status(500).json({ message: "Failed to update property search index" });
    }
  });
  app2.get("/api/booking-platform-sync", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const syncs = await storage.getBookingPlatformSyncs(organizationId2);
      res.json(syncs);
    } catch (error) {
      console.error("Error fetching platform syncs:", error);
      res.status(500).json({ message: "Failed to fetch platform syncs" });
    }
  });
  app2.put("/api/booking-platform-sync", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const syncData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId
      };
      const sync = await storage.updateBookingPlatformSync(organizationId2, syncData);
      res.json(sync);
    } catch (error) {
      console.error("Error updating platform sync:", error);
      res.status(500).json({ message: "Failed to update platform sync" });
    }
  });
  app2.get("/api/occupancy-analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      const { propertyId, periodType, startDate, endDate } = req.query;
      if (!["admin", "portfolio-manager", "owner"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const analytics = await storage.getOccupancyAnalytics(organizationId2, {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        periodType,
        startDate,
        endDate
      });
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching occupancy analytics:", error);
      res.status(500).json({ message: "Failed to fetch occupancy analytics" });
    }
  });
  app2.post("/api/guest/portal/auth", async (req, res) => {
    try {
      const { bookingReference, guestEmail, checkInDate } = req.body;
      const booking = await storage.getBookingByReferenceAndEmail(bookingReference, guestEmail);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found or email mismatch" });
      }
      const accessToken = `gpt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const checkOutDate = new Date(booking.checkOut);
      const expiresAt = new Date(checkOutDate);
      expiresAt.setDate(expiresAt.getDate() + 30);
      const session3 = await storage.createGuestPortalSession({
        organizationId: booking.organizationId,
        bookingId: booking.id,
        guestEmail,
        accessToken,
        propertyId: booking.propertyId,
        checkInDate: new Date(checkInDate),
        checkOutDate,
        guestName: booking.guestName,
        guestPhone: booking.guestPhone,
        expiresAt
      });
      res.json({
        accessToken,
        session: {
          id: session3.id,
          propertyId: session3.propertyId,
          checkInDate: session3.checkInDate,
          checkOutDate: session3.checkOutDate,
          guestName: session3.guestName
        }
      });
    } catch (error) {
      console.error("Error creating guest portal session:", error);
      res.status(500).json({ message: "Failed to create guest session" });
    }
  });
  const guestPortalAuth = async (req, res, next) => {
    try {
      const authHeader = req.headers.authorization;
      const token = authHeader && authHeader.split(" ")[1];
      if (!token) {
        return res.status(401).json({ message: "Access token required" });
      }
      const session3 = await storage.getGuestPortalSession(token);
      if (!session3) {
        return res.status(401).json({ message: "Invalid or expired access token" });
      }
      await storage.updateGuestPortalSessionActivity(token);
      req.guestSession = session3;
      next();
    } catch (error) {
      console.error("Guest portal auth error:", error);
      res.status(401).json({ message: "Authentication failed" });
    }
  };
  app2.get("/api/guest/booking-overview", guestPortalAuth, async (req, res) => {
    try {
      const overview = await storage.getGuestBookingOverview(req.guestSession.id);
      res.json(overview);
    } catch (error) {
      console.error("Error fetching booking overview:", error);
      res.status(500).json({ message: "Failed to fetch booking overview" });
    }
  });
  app2.get("/api/guest/activity-timeline", guestPortalAuth, async (req, res) => {
    try {
      const timeline = await storage.getGuestActivityTimeline(req.guestSession.id);
      res.json(timeline);
    } catch (error) {
      console.error("Error fetching activity timeline:", error);
      res.status(500).json({ message: "Failed to fetch activity timeline" });
    }
  });
  app2.get("/api/guest/chat/messages", guestPortalAuth, async (req, res) => {
    try {
      const { limit } = req.query;
      const messages = await storage.getGuestChatMessages(
        req.guestSession.id,
        limit ? parseInt(limit) : 50
      );
      res.json(messages);
    } catch (error) {
      console.error("Error fetching chat messages:", error);
      res.status(500).json({ message: "Failed to fetch chat messages" });
    }
  });
  app2.post("/api/guest/chat/send", guestPortalAuth, async (req, res) => {
    try {
      const { messageContent } = req.body;
      if (!messageContent || messageContent.trim().length === 0) {
        return res.status(400).json({ message: "Message content is required" });
      }
      const guestMessage = await storage.createGuestChatMessage({
        organizationId: req.guestSession.organizationId,
        guestSessionId: req.guestSession.id,
        bookingId: req.guestSession.bookingId,
        messageType: "guest_message",
        senderType: "guest",
        messageContent: messageContent.trim(),
        messageThreadId: `thread_${req.guestSession.id}_${Date.now()}`
      });
      const aiResult = await storage.processGuestMessageWithAI(guestMessage.id);
      const aiResponse = await storage.createGuestChatMessage({
        organizationId: req.guestSession.organizationId,
        guestSessionId: req.guestSession.id,
        bookingId: req.guestSession.bookingId,
        messageType: "ai_response",
        senderType: "ai",
        messageContent: aiResult.aiResponse || "Thank you for your message. Our team will respond shortly.",
        messageThreadId: guestMessage.messageThreadId
      });
      res.json({
        guestMessage,
        aiResponse,
        detectedIssue: aiResult.detectedIssue,
        severity: aiResult.severity
      });
    } catch (error) {
      console.error("Error sending chat message:", error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });
  app2.get("/api/guest/faq", guestPortalAuth, async (req, res) => {
    try {
      const faqs = await storage.getGuestAiFaqResponses(
        req.guestSession.organizationId,
        req.guestSession.propertyId
      );
      res.json(faqs);
    } catch (error) {
      console.error("Error fetching FAQ responses:", error);
      res.status(500).json({ message: "Failed to fetch FAQ responses" });
    }
  });
  app2.get("/api/guest/addon-services", guestPortalAuth, async (req, res) => {
    try {
      const services = await storage.getAvailableAddonServices(
        req.guestSession.organizationId,
        req.guestSession.propertyId
      );
      res.json(services);
    } catch (error) {
      console.error("Error fetching add-on services:", error);
      res.status(500).json({ message: "Failed to fetch add-on services" });
    }
  });
  app2.post("/api/guest/addon-services/request", guestPortalAuth, async (req, res) => {
    try {
      const {
        serviceId,
        serviceName,
        serviceType,
        requestedDate,
        requestedTime,
        duration,
        guestCount,
        unitPrice,
        quantity,
        totalCost,
        chargeAssignment,
        assignmentReason,
        specialRequests,
        guestNotes
      } = req.body;
      const serviceRequest = await storage.createGuestAddonServiceRequest({
        organizationId: req.guestSession.organizationId,
        guestSessionId: req.guestSession.id,
        bookingId: req.guestSession.bookingId,
        serviceId,
        serviceName,
        serviceType,
        requestedDate: new Date(requestedDate),
        requestedTime,
        duration,
        guestCount: guestCount || 1,
        unitPrice,
        quantity: quantity || 1,
        totalCost,
        chargeAssignment: chargeAssignment || "guest",
        assignmentReason,
        specialRequests,
        guestNotes
      });
      await storage.createGuestActivityRecord({
        organizationId: req.guestSession.organizationId,
        guestSessionId: req.guestSession.id,
        bookingId: req.guestSession.bookingId,
        activityType: "addon_booking",
        title: `${serviceName} Request`,
        description: `Requested ${serviceName} for ${new Date(requestedDate).toDateString()}`,
        status: "pending",
        requestedAt: /* @__PURE__ */ new Date(),
        estimatedCost: totalCost,
        chargeAssignment: chargeAssignment || "guest"
      });
      res.json(serviceRequest);
    } catch (error) {
      console.error("Error requesting add-on service:", error);
      res.status(500).json({ message: "Failed to request add-on service" });
    }
  });
  app2.get("/api/guest/addon-services/requests", guestPortalAuth, async (req, res) => {
    try {
      const requests = await storage.getGuestAddonServiceRequests(req.guestSession.id);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching service requests:", error);
      res.status(500).json({ message: "Failed to fetch service requests" });
    }
  });
  app2.get("/api/guest/local-info", guestPortalAuth, async (req, res) => {
    try {
      const { locationType } = req.query;
      const localInfo = await storage.getGuestPropertyLocalInfo(
        req.guestSession.propertyId,
        locationType
      );
      res.json(localInfo);
    } catch (error) {
      console.error("Error fetching local info:", error);
      res.status(500).json({ message: "Failed to fetch local information" });
    }
  });
  app2.post("/api/guest/maintenance/report", guestPortalAuth, async (req, res) => {
    try {
      const {
        issueType,
        issueTitle,
        issueDescription,
        locationInProperty,
        severityLevel,
        reportImages,
        reportVideos
      } = req.body;
      const report = await storage.createGuestMaintenanceReport({
        organizationId: req.guestSession.organizationId,
        guestSessionId: req.guestSession.id,
        bookingId: req.guestSession.bookingId,
        propertyId: req.guestSession.propertyId,
        issueType,
        issueTitle,
        issueDescription,
        locationInProperty,
        severityLevel: severityLevel || "medium",
        reportImages,
        reportVideos,
        reportedAt: /* @__PURE__ */ new Date()
      });
      await storage.createGuestActivityRecord({
        organizationId: req.guestSession.organizationId,
        guestSessionId: req.guestSession.id,
        bookingId: req.guestSession.bookingId,
        activityType: "maintenance_request",
        title: `Maintenance Report: ${issueTitle}`,
        description: `Reported ${issueType} issue in ${locationInProperty}`,
        status: "pending",
        requestedAt: /* @__PURE__ */ new Date()
      });
      res.json(report);
    } catch (error) {
      console.error("Error submitting maintenance report:", error);
      res.status(500).json({ message: "Failed to submit maintenance report" });
    }
  });
  app2.get("/api/guest/maintenance/reports", guestPortalAuth, async (req, res) => {
    try {
      const reports2 = await storage.getGuestMaintenanceReports(req.guestSession.id);
      res.json(reports2);
    } catch (error) {
      console.error("Error fetching maintenance reports:", error);
      res.status(500).json({ message: "Failed to fetch maintenance reports" });
    }
  });
  app2.get("/api/guest/session", guestPortalAuth, async (req, res) => {
    try {
      const { password, accessToken, ...sessionInfo } = req.guestSession;
      res.json(sessionInfo);
    } catch (error) {
      console.error("Error fetching session info:", error);
      res.status(500).json({ message: "Failed to fetch session info" });
    }
  });
  app2.get("/api/finance/owner-balances", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const balances = await storage.getOwnerBalances(organizationId2);
      res.json(balances);
    } catch (error) {
      console.error("Error fetching owner balances:", error);
      res.status(500).json({ message: "Failed to fetch owner balances" });
    }
  });
  app2.get("/api/finance/payout-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const payouts = await storage.getOwnerPayoutRequests(organizationId2);
      res.json(payouts);
    } catch (error) {
      console.error("Error fetching payout requests:", error);
      res.status(500).json({ message: "Failed to fetch payout requests" });
    }
  });
  app2.post("/api/finance/request-payout", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const userId = req.user?.id;
      const payoutData = {
        organizationId: organizationId2,
        ownerId: userId,
        amount: parseFloat(req.body.amount),
        transferMethod: req.body.transferMethod,
        requestNotes: req.body.requestNotes,
        status: "pending"
      };
      const payout = await storage.createOwnerPayoutRequest(payoutData);
      res.json(payout);
    } catch (error) {
      console.error("Error creating payout request:", error);
      res.status(500).json({ message: "Failed to create payout request" });
    }
  });
  app2.post("/api/finance/payout-requests/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { action } = req.body;
      const updateData = {};
      if (action === "approve") {
        updateData.status = "approved";
        updateData.approvedAt = /* @__PURE__ */ new Date();
        updateData.approvedBy = req.user?.id;
      } else if (action === "reject") {
        updateData.status = "rejected";
      }
      const payout = await storage.updateOwnerPayoutRequest(parseInt(id), updateData);
      res.json(payout);
    } catch (error) {
      console.error("Error updating payout request:", error);
      res.status(500).json({ message: "Failed to update payout request" });
    }
  });
  app2.get("/api/finance/charge-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const charges = await storage.getOwnerChargeRequests(organizationId2);
      res.json(charges);
    } catch (error) {
      console.error("Error fetching charge requests:", error);
      res.status(500).json({ message: "Failed to fetch charge requests" });
    }
  });
  app2.post("/api/finance/create-charge", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const chargedBy = req.user?.id;
      const chargeData = {
        organizationId: organizationId2,
        ownerId: req.body.ownerId,
        chargedBy,
        amount: parseFloat(req.body.amount),
        reason: req.body.reason,
        description: req.body.description,
        dueDate: req.body.dueDate ? new Date(req.body.dueDate) : null,
        status: "pending"
      };
      const charge = await storage.createOwnerChargeRequest(chargeData);
      res.json(charge);
    } catch (error) {
      console.error("Error creating charge request:", error);
      res.status(500).json({ message: "Failed to create charge request" });
    }
  });
  app2.get("/api/finance/utility-accounts", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const accounts = await storage.getUtilityAccounts(organizationId2);
      res.json(accounts);
    } catch (error) {
      console.error("Error fetching utility accounts:", error);
      res.status(500).json({ message: "Failed to fetch utility accounts" });
    }
  });
  app2.post("/api/finance/utility-accounts", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const accountData = {
        organizationId: organizationId2,
        propertyId: parseInt(req.body.propertyId),
        utilityType: req.body.utilityType,
        providerName: req.body.providerName,
        accountNumber: req.body.accountNumber,
        expectedBillDate: parseInt(req.body.expectedBillDate),
        averageMonthlyAmount: req.body.averageMonthlyAmount ? parseFloat(req.body.averageMonthlyAmount) : null,
        autoRemindersEnabled: true,
        isActive: true
      };
      const account = await storage.createUtilityAccount(accountData);
      res.json(account);
    } catch (error) {
      console.error("Error creating utility account:", error);
      res.status(500).json({ message: "Failed to create utility account" });
    }
  });
  app2.get("/api/finance/recurring-services", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const services = await storage.getRecurringServices(organizationId2);
      res.json(services);
    } catch (error) {
      console.error("Error fetching recurring services:", error);
      res.status(500).json({ message: "Failed to fetch recurring services" });
    }
  });
  app2.post("/api/finance/recurring-services", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const serviceData = {
        organizationId: organizationId2,
        propertyId: parseInt(req.body.propertyId),
        serviceName: req.body.serviceName,
        serviceCategory: req.body.serviceCategory,
        monthlyRate: parseFloat(req.body.monthlyRate),
        chargeAssignment: req.body.chargeAssignment,
        startDate: new Date(req.body.startDate),
        serviceFrequency: "monthly",
        isActive: true
      };
      const service = await storage.createRecurringService(serviceData);
      res.json(service);
    } catch (error) {
      console.error("Error creating recurring service:", error);
      res.status(500).json({ message: "Failed to create recurring service" });
    }
  });
  app2.get("/api/system", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const [allProperties, allUsers, finances3, bookings3, allTasks] = await Promise.all([
        storage.getProperties(),
        // Get all properties without source filter
        storage.getUsers().catch(() => []),
        storage.getFinances(organizationId2),
        storage.getBookings(organizationId2),
        storage.getTasks()
      ]);
      console.log(`[SYSTEM] Total properties from DB: ${allProperties.length}, org filter: ${organizationId2}`);
      if (allProperties.length > 0) {
        console.log(`[SYSTEM] Sample property organizationId: ${allProperties[0].organizationId}`);
      }
      const properties2 = allProperties;
      const users3 = allUsers.filter((u) => u.organizationId === organizationId2);
      const tasks2 = allTasks.filter((t) => t.organizationId === organizationId2);
      const hostawayProperties = properties2.filter((p) => p.source === "HOSTAWAY");
      const hostawayBookings = bookings3.filter((b) => b.source === "HOSTAWAY");
      let dbHealth = "healthy";
      try {
        await db.execute(sql`SELECT 1`);
      } catch (dbError) {
        dbHealth = "error";
        console.error("Database health check failed:", dbError);
      }
      const systemInfo = {
        version: "2.0 Enterprise FIXED",
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
        status: "online",
        health: {
          database: dbHealth,
          api: "operational",
          cache: "active"
        },
        modules: {
          properties: { active: true, count: properties2.length },
          users: { active: true, count: users3.length },
          finance: { active: true, count: finances3.length },
          tasks: { active: true, count: tasks2.length },
          bookings: { active: true, count: bookings3.length }
        },
        hostaway: {
          properties: hostawayProperties.length,
          bookings: hostawayBookings.length,
          lastSync: hostawayBookings.length > 0 ? hostawayBookings[0].updatedAt : null,
          isConnected: !!process.env.HOSTAWAY_API_KEY
        },
        apiConfigs: {
          hasStripe: !!process.env.STRIPE_SECRET_KEY,
          hasHostaway: !!process.env.HOSTAWAY_API_KEY,
          hasOpenAI: !!process.env.OPENAI_API_KEY,
          hasTwilio: !!process.env.TWILIO_AUTH_TOKEN
        },
        organization: {
          id: organizationId2,
          name: "HostPilotPro"
        }
      };
      res.json(systemInfo);
    } catch (error) {
      console.error("Error fetching system info:", error);
      res.status(500).json({ message: "Failed to fetch system information" });
    }
  });
  app2.get("/api/system-diag", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const financeCount = await storage.getFinanceCount({ organizationId: organizationId2 });
      const bookings3 = await storage.getBookings(organizationId2);
      const allTasks = await storage.getTasks();
      const tasks2 = allTasks.filter((t) => t.organizationId === organizationId2);
      res.json({
        endpoint: "DIAGNOSTIC-V1",
        organizationId: organizationId2,
        counts: {
          finance: financeCount,
          bookings: bookings3.length,
          tasks: tasks2.length
        },
        raw: {
          bookingsArray: bookings3.map((b) => ({ id: b.id, org: b.organizationId })),
          tasksArray: tasks2.slice(0, 3).map((t) => ({ id: t.id, org: t.organizationId }))
        }
      });
    } catch (error) {
      console.error("Diagnostic error:", error);
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/global-search", isDemoAuthenticated, async (req, res) => {
    try {
      const query = req.query.q;
      const organizationId2 = req.user?.organizationId || "default-org";
      if (!query || query.trim().length < 3) {
        return res.json([]);
      }
      const searchTerm = query.toLowerCase().trim();
      const results = [];
      const properties2 = await storage.getProperties(organizationId2);
      properties2.forEach((property) => {
        if (property.name?.toLowerCase().includes(searchTerm) || property.address?.toLowerCase().includes(searchTerm) || property.externalId?.toLowerCase().includes(searchTerm)) {
          results.push({
            id: property.id.toString(),
            type: "property",
            title: property.name,
            subtitle: property.address,
            status: property.status,
            path: `/property/${property.id}`,
            badge: {
              text: property.status || "active",
              variant: property.status === "active" ? "default" : "secondary"
            }
          });
        }
      });
      const bookings3 = await storage.getBookings(organizationId2);
      bookings3.forEach((booking) => {
        if (booking.guestName?.toLowerCase().includes(searchTerm) || booking.guestEmail?.toLowerCase().includes(searchTerm) || booking.bookingReference?.toLowerCase().includes(searchTerm)) {
          results.push({
            id: booking.id.toString(),
            type: "booking",
            title: `Booking: ${booking.guestName}`,
            subtitle: `${booking.checkIn} - ${booking.checkOut}`,
            status: booking.status,
            path: `/bookings`,
            badge: {
              text: booking.status || "pending",
              variant: booking.status === "confirmed" ? "default" : "secondary"
            }
          });
        }
      });
      const tasks2 = await storage.getTasks();
      tasks2.forEach((task) => {
        if (task.title?.toLowerCase().includes(searchTerm) || task.description?.toLowerCase().includes(searchTerm)) {
          results.push({
            id: task.id.toString(),
            type: "task",
            title: task.title,
            subtitle: task.description,
            status: task.status,
            path: `/tasks`,
            badge: {
              text: task.priority || "normal",
              variant: task.priority === "urgent" ? "destructive" : "default"
            }
          });
        }
      });
      const users3 = await storage.getUsers(organizationId2);
      users3.forEach((user) => {
        const fullName = `${user.firstName} ${user.lastName}`.toLowerCase();
        if (fullName.includes(searchTerm) || user.email?.toLowerCase().includes(searchTerm) || user.id?.toLowerCase().includes(searchTerm)) {
          results.push({
            id: user.id,
            type: "user",
            title: `${user.firstName} ${user.lastName}`,
            subtitle: user.email,
            status: user.role,
            path: `/users`,
            badge: {
              text: user.role || "staff",
              variant: "outline"
            }
          });
        }
      });
      res.json(results.slice(0, 20));
    } catch (error) {
      console.error("Global search error:", error);
      res.status(500).json({ error: "Search failed" });
    }
  });
  app2.get("/api/users", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { role } = req.query;
      const allUsers = await storage.getUsers({ organizationId: organizationId2 });
      const filteredUsers = role ? allUsers.filter((user) => user.role === role) : allUsers;
      const users3 = filteredUsers.map((user) => ({
        id: user.id,
        email: user.email,
        name: `${user.firstName || ""} ${user.lastName || ""}`.trim() || user.email,
        role: user.role,
        status: user.isActive ? "active" : "inactive",
        organizationId: user.organizationId,
        firstName: user.firstName,
        lastName: user.lastName
      }));
      res.json(users3);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });
  app2.post("/api/users", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { name, email, role, password } = req.body;
      console.log("Creating user with data:", { name, email, role, organizationId: organizationId2 });
      if (!name || !email || !role || !password) {
        return res.status(400).json({ message: "Name, email, role, and password are required" });
      }
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(409).json({ message: "User with this email already exists" });
      }
      const userId = `user-${Date.now()}`;
      const bcrypt3 = await import("bcrypt");
      const hashedPassword = await bcrypt3.hash(password, 12);
      const userData = {
        id: userId,
        email,
        firstName: name.split(" ")[0] || name,
        lastName: name.split(" ").slice(1).join(" ") || "",
        role,
        organizationId: organizationId2,
        isActive: true,
        password: hashedPassword
      };
      const newUser = await storage.upsertUser(userData);
      console.log("User created successfully:", newUser.id);
      const { password: _, ...userResponse } = newUser;
      res.status(201).json(userResponse);
    } catch (error) {
      console.error("Error creating user:", error);
      res.status(500).json({ message: "Failed to create user", error: error.message });
    }
  });
  app2.patch("/api/users/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, email, role, status } = req.body;
      const organizationId2 = req.user?.organizationId || "default-org";
      console.log("Updating user:", id, "with data:", { name, email, role, status });
      const updatedUser = await storage.updateUser(id, {
        name,
        email,
        role,
        isActive: status === "active",
        updatedAt: /* @__PURE__ */ new Date()
      });
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating user:", error);
      res.status(500).json({ message: "Failed to update user" });
    }
  });
  app2.get("/api/users/:role", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { role } = req.params;
      if (role === "owner") {
        const owners = await storage.getOwnersForSelection(organizationId2);
        res.json(owners);
      } else {
        res.json([]);
      }
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });
  app2.get("/api/task-checklists", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const checklists = await storage.getTaskChecklists(organizationId2);
      res.json(checklists);
    } catch (error) {
      console.error("Error fetching task checklists:", error);
      res.status(500).json({ message: "Failed to fetch task checklists" });
    }
  });
  app2.get("/api/property-guides", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const guides = await storage.getPropertyGuides(organizationId2);
      res.json(guides);
    } catch (error) {
      console.error("Error fetching property guides:", error);
      res.status(500).json({ message: "Failed to fetch property guides" });
    }
  });
  app2.get("/api/ai-task-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const suggestions = await storage.getAiTaskSuggestions(organizationId2);
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching AI task suggestions:", error);
      res.status(500).json({ message: "Failed to fetch AI task suggestions" });
    }
  });
  app2.post("/api/tasks/:id/start", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = req.user?.id;
      const task = await storage.startTask(parseInt(id), userId);
      res.json(task);
    } catch (error) {
      console.error("Error starting task:", error);
      res.status(500).json({ message: "Failed to start task" });
    }
  });
  app2.post("/api/tasks/:id/complete", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { completionNotes, evidencePhotos, issuesFound } = req.body;
      const userId = req.user?.id;
      const task = await storage.completeTask(parseInt(id), {
        completionNotes,
        evidencePhotos: evidencePhotos || [],
        issuesFound: issuesFound || [],
        completedBy: userId
      });
      res.json(task);
    } catch (error) {
      console.error("Error completing task:", error);
      res.status(500).json({ message: "Failed to complete task" });
    }
  });
  app2.post("/api/ai-suggestions/:id/accept", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = req.user?.id;
      const result = await storage.acceptAiSuggestion(parseInt(id), userId);
      res.json(result);
    } catch (error) {
      console.error("Error accepting AI suggestion:", error);
      res.status(500).json({ message: "Failed to accept AI suggestion" });
    }
  });
  app2.post("/api/tasks/export-pdf", isDemoAuthenticated, async (req, res) => {
    try {
      const { month } = req.body;
      const organizationId2 = req.user?.organizationId || "default-org";
      const result = await storage.exportTasksPdf(organizationId2, month);
      res.json({ message: "PDF export initiated", exportId: result.id });
    } catch (error) {
      console.error("Error exporting tasks PDF:", error);
      res.status(500).json({ message: "Failed to export tasks PDF" });
    }
  });
  app2.get("/api/finance/owner-balance/:ownerId", isDemoAuthenticated, async (req, res) => {
    try {
      const { ownerId } = req.params;
      const { propertyId } = req.query;
      const organizationId2 = req.user?.organizationId || "default-org";
      const balance = await storage.getOwnerBalanceTracker(
        organizationId2,
        ownerId,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(balance || { message: "No balance tracker found" });
    } catch (error) {
      console.error("Error fetching owner balance:", error);
      res.status(500).json({ message: "Failed to fetch owner balance" });
    }
  });
  app2.post("/api/finance/owner-balance", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const balanceData = { ...req.body, organizationId: organizationId2 };
      const balance = await storage.createOwnerBalanceTracker(balanceData);
      res.status(201).json(balance);
    } catch (error) {
      console.error("Error creating owner balance tracker:", error);
      res.status(500).json({ message: "Failed to create owner balance tracker" });
    }
  });
  app2.patch("/api/finance/owner-balance/:ownerId", isDemoAuthenticated, async (req, res) => {
    try {
      const { ownerId } = req.params;
      const organizationId2 = req.user?.organizationId || "default-org";
      const balance = await storage.updateOwnerBalanceTracker(organizationId2, ownerId, req.body);
      res.json(balance);
    } catch (error) {
      console.error("Error updating owner balance:", error);
      res.status(500).json({ message: "Failed to update owner balance" });
    }
  });
  app2.get("/api/finance/owner-summary/:ownerId", isDemoAuthenticated, async (req, res) => {
    try {
      const { ownerId } = req.params;
      const organizationId2 = req.user?.organizationId || "default-org";
      const summary = await storage.getOwnerFinancialSummary(organizationId2, ownerId);
      res.json(summary);
    } catch (error) {
      console.error("Error fetching owner financial summary:", error);
      res.status(500).json({ message: "Failed to fetch owner financial summary" });
    }
  });
  app2.get("/api/finance/payout-routing-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyId } = req.query;
      const organizationId2 = req.user?.organizationId || "default-org";
      const rules = await storage.getPayoutRoutingRules(
        organizationId2,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(rules);
    } catch (error) {
      console.error("Error fetching payout routing rules:", error);
      res.status(500).json({ message: "Failed to fetch payout routing rules" });
    }
  });
  app2.post("/api/finance/payout-routing-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const organizationId2 = user?.organizationId || "default-org";
      if (user?.role !== "admin" && user?.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      const ruleData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: user.id
      };
      const rule = await storage.createPayoutRoutingRule(ruleData);
      res.status(201).json(rule);
    } catch (error) {
      console.error("Error creating payout routing rule:", error);
      res.status(500).json({ message: "Failed to create payout routing rule" });
    }
  });
  app2.patch("/api/finance/payout-routing-rules/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { id } = req.params;
      if (user?.role !== "admin" && user?.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      const rule = await storage.updatePayoutRoutingRule(parseInt(id), req.body);
      res.json(rule);
    } catch (error) {
      console.error("Error updating payout routing rule:", error);
      res.status(500).json({ message: "Failed to update payout routing rule" });
    }
  });
  app2.get("/api/finance/payout-breakdown/:propertyId", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyId } = req.params;
      const organizationId2 = req.user?.organizationId || "default-org";
      const breakdown = await storage.getPlatformPayoutBreakdown(organizationId2, parseInt(propertyId));
      res.json(breakdown);
    } catch (error) {
      console.error("Error fetching payout breakdown:", error);
      res.status(500).json({ message: "Failed to fetch payout breakdown" });
    }
  });
  app2.get("/api/finance/utility-bill-processing", isDemoAuthenticated, async (req, res) => {
    try {
      const { utilityBillId, processingStatus } = req.query;
      const organizationId2 = req.user?.organizationId || "default-org";
      const processing = await storage.getUtilityBillProcessing(organizationId2, {
        utilityBillId: utilityBillId ? parseInt(utilityBillId) : void 0,
        processingStatus
      });
      res.json(processing);
    } catch (error) {
      console.error("Error fetching utility bill processing:", error);
      res.status(500).json({ message: "Failed to fetch utility bill processing" });
    }
  });
  app2.post("/api/finance/process-utility-bill/:billId", isDemoAuthenticated, async (req, res) => {
    try {
      const { billId } = req.params;
      const { routingDecision, notes } = req.body;
      const user = req.user;
      if (!["admin", "portfolio-manager", "staff"].includes(user?.role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      const result = await storage.processUtilityBillWithRouting(
        parseInt(billId),
        routingDecision,
        user.id,
        notes
      );
      res.json(result);
    } catch (error) {
      console.error("Error processing utility bill:", error);
      res.status(500).json({ message: "Failed to process utility bill" });
    }
  });
  app2.get("/api/finance/transaction-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const { transactionType, relatedTableName, processedBy, fromDate, toDate } = req.query;
      const organizationId2 = req.user?.organizationId || "default-org";
      const logs = await storage.getEnhancedFinanceTransactionLogs(organizationId2, {
        transactionType,
        relatedTableName,
        processedBy,
        fromDate: fromDate ? new Date(fromDate) : void 0,
        toDate: toDate ? new Date(toDate) : void 0
      });
      res.json(logs);
    } catch (error) {
      console.error("Error fetching transaction logs:", error);
      res.status(500).json({ message: "Failed to fetch transaction logs" });
    }
  });
  app2.post("/api/finance/transaction-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const organizationId2 = user?.organizationId || "default-org";
      const logData = {
        ...req.body,
        organizationId: organizationId2,
        processedBy: user.id
      };
      const log2 = await storage.createEnhancedFinanceTransactionLog(logData);
      res.status(201).json(log2);
    } catch (error) {
      console.error("Error creating transaction log:", error);
      res.status(500).json({ message: "Failed to create transaction log" });
    }
  });
  app2.get("/api/task-checklists", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId, taskType } = req.query;
      const checklists = await storage.getTaskChecklists(organizationId2, {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        taskType: taskType || void 0
      });
      res.json(checklists);
    } catch (error) {
      console.error("Error fetching task checklists:", error);
      res.status(500).json({ message: "Failed to fetch task checklists" });
    }
  });
  app2.post("/api/task-checklists", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const checklistData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId
      };
      const checklist = await storage.createTaskChecklist(checklistData);
      res.status(201).json(checklist);
    } catch (error) {
      console.error("Error creating task checklist:", error);
      res.status(500).json({ message: "Failed to create task checklist" });
    }
  });
  app2.get("/api/property-guides", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId, taskCategory } = req.query;
      const guides = await storage.getPropertyGuides(organizationId2, {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        taskCategory: taskCategory || void 0
      });
      res.json(guides);
    } catch (error) {
      console.error("Error fetching property guides:", error);
      res.status(500).json({ message: "Failed to fetch property guides" });
    }
  });
  app2.post("/api/property-guides", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const guideData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId
      };
      const guide = await storage.createPropertyGuide(guideData);
      res.status(201).json(guide);
    } catch (error) {
      console.error("Error creating property guide:", error);
      res.status(500).json({ message: "Failed to create property guide" });
    }
  });
  app2.get("/api/task-completions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId, taskId } = req.query;
      const completions = await storage.getTaskCompletions(organizationId2, {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        taskId: taskId ? parseInt(taskId) : void 0
      });
      res.json(completions);
    } catch (error) {
      console.error("Error fetching task completions:", error);
      res.status(500).json({ message: "Failed to fetch task completions" });
    }
  });
  app2.get("/api/monthly-exports", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId, exportMonth } = req.query;
      const exports = await storage.getMonthlyExports(organizationId2, {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        exportMonth: exportMonth || void 0
      });
      res.json(exports);
    } catch (error) {
      console.error("Error fetching monthly exports:", error);
      res.status(500).json({ message: "Failed to fetch monthly exports" });
    }
  });
  app2.post("/api/monthly-exports", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const exportData = {
        ...req.body,
        organizationId: organizationId2,
        exportedBy: userId
      };
      const exportLog = await storage.createMonthlyExport(exportData);
      res.status(201).json(exportLog);
    } catch (error) {
      console.error("Error creating monthly export:", error);
      res.status(500).json({ message: "Failed to create monthly export" });
    }
  });
  app2.get("/api/enhanced-ai-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const { propertyId, status, urgencyLevel } = req.query;
      const filters = {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        status,
        urgencyLevel
      };
      const suggestions = await storage.getEnhancedAiSuggestions(organizationId2, filters);
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching AI suggestions:", error);
      res.status(500).json({ message: "Failed to fetch AI suggestions" });
    }
  });
  app2.post("/api/enhanced-ai-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const userData = req.user;
      const suggestionData = {
        ...req.body,
        organizationId: organizationId2
      };
      const suggestion = await storage.createEnhancedAiSuggestion(suggestionData);
      res.status(201).json(suggestion);
    } catch (error) {
      console.error("Error creating AI suggestion:", error);
      res.status(500).json({ message: "Failed to create AI suggestion" });
    }
  });
  app2.post("/api/enhanced-ai-suggestions/:id/accept", isDemoAuthenticated, async (req, res) => {
    try {
      const suggestionId = parseInt(req.params.id);
      const userData = req.user;
      const { taskTitle, taskDescription, assignedTo, priority } = req.body;
      const task = await storage.createTask({
        organizationId: getTenantContext(req).organizationId,
        title: taskTitle,
        description: taskDescription,
        status: "pending",
        priority: priority || "medium",
        assignedTo,
        propertyId: req.body.propertyId,
        department: req.body.department || "general"
      });
      await storage.acceptAiSuggestion(suggestionId, userData.claims.sub, task.id);
      await storage.createTimelineEvent({
        organizationId: getTenantContext(req).organizationId,
        propertyId: req.body.propertyId,
        eventType: "suggestion",
        title: "\u{1F916} AI Suggestion Accepted",
        description: `AI suggestion "${taskTitle}" was accepted and converted to a task.`,
        emoji: "\u{1F916}",
        linkedId: task.id,
        linkedType: "task",
        createdBy: userData.claims.sub,
        createdByRole: userData.role || "admin"
      });
      res.json({ success: true, taskId: task.id });
    } catch (error) {
      console.error("Error accepting AI suggestion:", error);
      res.status(500).json({ message: "Failed to accept AI suggestion" });
    }
  });
  app2.post("/api/enhanced-ai-suggestions/:id/reject", isDemoAuthenticated, async (req, res) => {
    try {
      const suggestionId = parseInt(req.params.id);
      const userData = req.user;
      await storage.rejectAiSuggestion(suggestionId, userData.claims.sub);
      res.json({ success: true });
    } catch (error) {
      console.error("Error rejecting AI suggestion:", error);
      res.status(500).json({ message: "Failed to reject AI suggestion" });
    }
  });
  app2.get("/api/property-timeline/:propertyId", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const propertyId = parseInt(req.params.propertyId);
      const limit = req.query.limit ? parseInt(req.query.limit) : 50;
      const timeline = await storage.getPropertyTimeline(organizationId2, propertyId, limit);
      res.json(timeline);
    } catch (error) {
      console.error("Error fetching property timeline:", error);
      res.status(500).json({ message: "Failed to fetch property timeline" });
    }
  });
  app2.post("/api/property-timeline", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const userData = req.user;
      const eventData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userData.claims.sub,
        createdByRole: userData.role || "admin"
      };
      const event = await storage.createTimelineEvent(eventData);
      res.status(201).json(event);
    } catch (error) {
      console.error("Error creating timeline event:", error);
      res.status(500).json({ message: "Failed to create timeline event" });
    }
  });
  app2.get("/api/smart-notifications", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const userData = req.user;
      const notifications2 = await storage.getSmartNotifications(organizationId2, userData.claims.sub);
      res.json(notifications2);
    } catch (error) {
      console.error("Error fetching smart notifications:", error);
      res.status(500).json({ message: "Failed to fetch smart notifications" });
    }
  });
  app2.post("/api/smart-notifications/:id/read", isDemoAuthenticated, async (req, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      await storage.markNotificationRead(notificationId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });
  app2.get("/api/fast-action-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : void 0;
      const suggestions = await storage.getFastActionSuggestions(organizationId2, propertyId);
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching fast action suggestions:", error);
      res.status(500).json({ message: "Failed to fetch fast action suggestions" });
    }
  });
  app2.post("/api/fast-action-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const userData = req.user;
      const suggestionData = {
        ...req.body,
        organizationId: organizationId2,
        suggestedBy: userData.claims.sub,
        suggestedByRole: userData.role || "admin"
      };
      const suggestion = await storage.createFastActionSuggestion(suggestionData);
      res.status(201).json(suggestion);
    } catch (error) {
      console.error("Error creating fast action suggestion:", error);
      res.status(500).json({ message: "Failed to create fast action suggestion" });
    }
  });
  app2.post("/api/fast-action-suggestions/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const actionId = parseInt(req.params.id);
      const userData = req.user;
      await storage.approveFastAction(actionId, userData.claims.sub);
      res.json({ success: true });
    } catch (error) {
      console.error("Error approving fast action:", error);
      res.status(500).json({ message: "Failed to approve fast action" });
    }
  });
  app2.post("/api/fast-action-suggestions/:id/reject", isDemoAuthenticated, async (req, res) => {
    try {
      const actionId = parseInt(req.params.id);
      const userData = req.user;
      const { reason } = req.body;
      await storage.rejectFastAction(actionId, userData.claims.sub, reason);
      res.json({ success: true });
    } catch (error) {
      console.error("Error rejecting fast action:", error);
      res.status(500).json({ message: "Failed to reject fast action" });
    }
  });
  app2.post("/api/ai/process-review-feedback", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const { bookingId, reviewText } = req.body;
      if (!reviewText || reviewText.trim().length === 0) {
        return res.status(400).json({ message: "Review text is required" });
      }
      const suggestions = await storage.processGuestReviewFeedback(organizationId2, bookingId, reviewText);
      for (const suggestion of suggestions) {
        await storage.createSmartNotification({
          organizationId: organizationId2,
          recipientId: "admin@test.com",
          // Should route to appropriate admin/PM
          recipientRole: "admin",
          notificationType: "ai-suggestion",
          title: "\u{1F916} New AI Task Suggestion",
          message: `AI detected potential issue: ${suggestion.suggestedTitle}`,
          priority: suggestion.urgencyLevel === "high" ? "high" : "medium",
          sourceId: suggestion.id,
          sourceType: "ai_suggestion",
          actionRequired: true,
          actionButtons: [
            { action: "accept", label: "Accept & Create Task", style: "primary" },
            { action: "reject", label: "Dismiss", style: "secondary" }
          ]
        });
      }
      res.json({ success: true, suggestions });
    } catch (error) {
      console.error("Error processing review feedback:", error);
      res.status(500).json({ message: "Failed to process review feedback" });
    }
  });
  app2.post("/api/ai/create-longstay-tasks", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = getTenantContext(req);
      const { bookingId } = req.body;
      const suggestions = await storage.createLongStayCleaningTasks(organizationId2, bookingId);
      res.json({ success: true, suggestions });
    } catch (error) {
      console.error("Error creating long-stay tasks:", error);
      res.status(500).json({ message: "Failed to create long-stay tasks" });
    }
  });
  app2.get("/api/owner-balance/:propertyId", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Access denied. Owner role required." });
      }
      const organizationId2 = user.organizationId;
      const ownerId = user.id;
      const propertyId = parseInt(req.params.propertyId);
      const balance = await storage.getOwnerBalanceByProperty(organizationId2, ownerId, propertyId);
      res.json(balance);
    } catch (error) {
      console.error("Error fetching owner balance:", error);
      res.status(500).json({ message: "Failed to fetch owner balance" });
    }
  });
  app2.get("/api/owner-balances", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Access denied. Owner role required." });
      }
      const organizationId2 = user.organizationId;
      const ownerId = user.id;
      const balances = await storage.getAllOwnerBalances(organizationId2, ownerId);
      res.json(balances);
    } catch (error) {
      console.error("Error fetching owner balances:", error);
      res.status(500).json({ message: "Failed to fetch owner balances" });
    }
  });
  app2.post("/api/owner-balance/calculate", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Access denied. Owner role required." });
      }
      const organizationId2 = user.organizationId;
      const ownerId = user.id;
      const { propertyId, period } = req.body;
      const balance = await storage.calculateOwnerBalance(
        organizationId2,
        ownerId,
        propertyId,
        { start: new Date(period.start), end: new Date(period.end) }
      );
      await storage.updateOwnerBalance({
        organizationId: organizationId2,
        ownerId,
        propertyId,
        ...balance,
        lastCalculatedAt: /* @__PURE__ */ new Date()
      });
      res.json(balance);
    } catch (error) {
      console.error("Error calculating owner balance:", error);
      res.status(500).json({ message: "Failed to calculate owner balance" });
    }
  });
  app2.post("/api/owner-payout-request", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Access denied. Owner role required." });
      }
      const organizationId2 = user.organizationId;
      const ownerId = user.id;
      const { propertyId, requestedAmount, paymentMethod, paymentDetails, notes } = req.body;
      const payoutRequest = await storage.createOwnerPayoutRequest({
        organizationId: organizationId2,
        ownerId,
        propertyId,
        requestedAmount,
        paymentMethod,
        paymentDetails,
        notes,
        requestStatus: "pending",
        requestedAt: /* @__PURE__ */ new Date()
      });
      await storage.createNotification({
        organizationId: organizationId2,
        userId: "admin@test.com",
        // Should route to appropriate admin/PM
        type: "payout_request",
        title: "New Payout Request",
        message: `Owner ${user.username} requested ${requestedAmount} payout`,
        priority: "medium",
        isRead: false
      });
      res.json(payoutRequest);
    } catch (error) {
      console.error("Error creating payout request:", error);
      res.status(500).json({ message: "Failed to create payout request" });
    }
  });
  app2.get("/api/owner-payout-requests", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId;
      let ownerId = void 0;
      if (user.role === "owner") {
        ownerId = user.id;
      } else if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied. Owner, admin, or portfolio manager role required." });
      }
      const requests = await storage.getOwnerPayoutRequests(organizationId2, ownerId);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching payout requests:", error);
      res.status(500).json({ message: "Failed to fetch payout requests" });
    }
  });
  app2.put("/api/owner-payout-request/:id/status", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied. Admin or portfolio manager role required." });
      }
      const requestId = parseInt(req.params.id);
      const { status, notes } = req.body;
      const updated = await storage.updatePayoutRequestStatus(requestId, {
        requestStatus: status,
        approvedBy: status === "approved" ? user.id : null,
        approvedAt: status === "approved" ? /* @__PURE__ */ new Date() : null,
        rejectedBy: status === "rejected" ? user.id : null,
        rejectedAt: status === "rejected" ? /* @__PURE__ */ new Date() : null,
        adminNotes: notes
      });
      res.json(updated);
    } catch (error) {
      console.error("Error updating payout request status:", error);
      res.status(500).json({ message: "Failed to update payout request status" });
    }
  });
  app2.put("/api/owner-payout-request/:id/payment-slip", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied. Admin or portfolio manager role required." });
      }
      const requestId = parseInt(req.params.id);
      const { paymentSlipUrl } = req.body;
      const updated = await storage.uploadPaymentSlip(requestId, paymentSlipUrl, user.id);
      await storage.createNotification({
        organizationId: user.organizationId,
        userId: updated.ownerId,
        type: "payment_made",
        title: "Payment Slip Uploaded",
        message: "Your payout has been processed. Please confirm receipt.",
        priority: "high",
        isRead: false
      });
      res.json(updated);
    } catch (error) {
      console.error("Error uploading payment slip:", error);
      res.status(500).json({ message: "Failed to upload payment slip" });
    }
  });
  app2.put("/api/owner-payout-request/:id/confirm", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Access denied. Owner role required." });
      }
      const requestId = parseInt(req.params.id);
      const { notes } = req.body;
      const updated = await storage.confirmPaymentReceived(requestId, user.id, notes);
      await storage.createPaymentLog({
        organizationId: user.organizationId,
        ownerId: user.id,
        propertyId: updated.propertyId,
        payoutRequestId: requestId,
        amount: updated.requestedAmount,
        paymentType: "payout",
        paymentMethod: updated.paymentMethod,
        transactionReference: `PAYOUT-${requestId}`,
        processedBy: updated.paidBy,
        processedAt: /* @__PURE__ */ new Date(),
        paymentSlipUrl: updated.paymentSlipUrl
      });
      res.json(updated);
    } catch (error) {
      console.error("Error confirming payment:", error);
      res.status(500).json({ message: "Failed to confirm payment" });
    }
  });
  app2.get("/api/owner-payment-history", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Access denied. Owner role required." });
      }
      const organizationId2 = user.organizationId;
      const ownerId = user.id;
      const { propertyId } = req.query;
      const history = await storage.getOwnerPaymentHistory(
        organizationId2,
        ownerId,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(history);
    } catch (error) {
      console.error("Error fetching payment history:", error);
      res.status(500).json({ message: "Failed to fetch payment history" });
    }
  });
  app2.get("/api/property-payout-settings/:propertyId", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager" && user.role !== "owner") {
        return res.status(403).json({ message: "Access denied." });
      }
      const organizationId2 = user.organizationId;
      const propertyId = parseInt(req.params.propertyId);
      const settings = await storage.getPropertyPayoutSettings(organizationId2, propertyId);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching property payout settings:", error);
      res.status(500).json({ message: "Failed to fetch property payout settings" });
    }
  });
  app2.put("/api/property-payout-settings/:propertyId", async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied. Admin or portfolio manager role required." });
      }
      const organizationId2 = user.organizationId;
      const propertyId = parseInt(req.params.propertyId);
      const { payoutFrequency, minimumPayoutAmount, autoPayoutEnabled, payoutDay } = req.body;
      const settings = await storage.updatePropertyPayoutSettings({
        organizationId: organizationId2,
        propertyId,
        payoutFrequency,
        minimumPayoutAmount,
        autoPayoutEnabled,
        payoutDay,
        updatedAt: /* @__PURE__ */ new Date()
      });
      res.json(settings);
    } catch (error) {
      console.error("Error updating property payout settings:", error);
      res.status(500).json({ message: "Failed to update property payout settings" });
    }
  });
  app2.get("/api/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "demo-org";
      const invoices2 = await storage.getInvoices(organizationId2);
      res.json(invoices2);
    } catch (error) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });
  app2.post("/api/invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "demo-org";
      const createdBy = req.user?.id || req.user?.sub || "demo-user";
      const { lineItems, ...invoiceData } = req.body;
      const subtotal = lineItems.reduce((sum4, item) => {
        return sum4 + parseFloat(item.quantity || "0") * parseFloat(item.unitPrice || "0");
      }, 0);
      const taxRate = parseFloat(invoiceData.taxRate || "0") / 100;
      const taxAmount = subtotal * taxRate;
      const totalAmount = subtotal + taxAmount;
      const invoice = await storage.createInvoice({
        ...invoiceData,
        organizationId: organizationId2,
        createdBy,
        subtotal: subtotal.toFixed(2),
        taxAmount: taxAmount.toFixed(2),
        totalAmount: totalAmount.toFixed(2)
      }, lineItems || []);
      res.json(invoice);
    } catch (error) {
      console.error("Error creating invoice:", error);
      res.status(500).json({ message: "Failed to create invoice" });
    }
  });
  app2.post("/api/invoices/:id/send", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "demo-org";
      const invoiceId = parseInt(req.params.id);
      const invoice = await storage.getInvoice(invoiceId, organizationId2);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      await storage.updateInvoice(invoiceId, organizationId2, { status: "sent" });
      await storage.createInvoiceDeliveryLog({
        invoiceId,
        recipientEmail: req.body.recipientEmail || invoice.toName + "@example.com",
        deliveryProvider: "sendgrid",
        deliveryStatus: "delivered",
        // Simulate successful delivery
        metadata: { subject: `Invoice ${invoice.invoiceNumber}`, from: "billing@hostpilotpro.com" }
      });
      res.json({ message: "Invoice sent successfully" });
    } catch (error) {
      console.error("Error sending invoice:", error);
      res.status(500).json({ message: "Failed to send invoice" });
    }
  });
  app2.delete("/api/invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "demo-org";
      const invoiceId = parseInt(req.params.id);
      const invoice = await storage.getInvoice(invoiceId, organizationId2);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      if (invoice.status !== "draft") {
        return res.status(400).json({ message: "Only draft invoices can be deleted" });
      }
      await storage.deleteInvoice(invoiceId, organizationId2);
      res.json({ message: "Invoice deleted successfully" });
    } catch (error) {
      console.error("Error deleting invoice:", error);
      res.status(500).json({ message: "Failed to delete invoice" });
    }
  });
  app2.get("/api/invoice-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const templates = [
        {
          id: 1,
          name: "Commission Invoice",
          description: "Standard commission invoice template",
          template: "rental_commission",
          defaultItems: [
            { description: "Booking Commission", quantity: "1", unitPrice: "150.00" }
          ]
        },
        {
          id: 2,
          name: "Service Fee",
          description: "Service fee invoice template",
          template: "service_fee",
          defaultItems: [
            { description: "Management Service", quantity: "1", unitPrice: "100.00" }
          ]
        }
      ];
      res.json(templates);
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({ message: "Failed to fetch templates" });
    }
  });
  app2.get("/api/invoice-delivery-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const logs = [
        {
          id: 1,
          invoiceNumber: "INV-001",
          recipientEmail: "owner@example.com",
          deliveryProvider: "sendgrid",
          deliveryStatus: "delivered",
          sentAt: (/* @__PURE__ */ new Date()).toISOString(),
          openedAt: (/* @__PURE__ */ new Date()).toISOString(),
          downloadedAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      ];
      res.json(logs);
    } catch (error) {
      console.error("Error fetching delivery logs:", error);
      res.status(500).json({ message: "Failed to fetch delivery logs" });
    }
  });
  app2.get("/api/invoice-analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const analytics = {
        totalInvoices: 25,
        totalAmount: "12450.00",
        pendingAmount: "3200.00",
        paidAmount: "9250.00"
      };
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });
  app2.get("/api/media/files", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : void 0;
      const files = await storage.getPropertyMediaFiles(organizationId2, propertyId);
      res.json(files);
    } catch (error) {
      console.error("Error fetching media files:", error);
      res.status(500).json({ message: "Failed to fetch media files" });
    }
  });
  app2.post("/api/media/files", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const fileData = {
        ...req.body,
        organizationId: organizationId2,
        uploadedBy: req.user.id
      };
      const file = await storage.createPropertyMediaFile(fileData);
      res.json(file);
    } catch (error) {
      console.error("Error creating media file:", error);
      res.status(500).json({ message: "Failed to create media file" });
    }
  });
  app2.put("/api/media/files/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const fileId = parseInt(req.params.id);
      const updateData = req.body;
      if (["admin", "portfolio-manager"].includes(req.user.role) && updateData.isAgentApproved) {
        updateData.approvedBy = req.user.id;
        updateData.approvedAt = /* @__PURE__ */ new Date();
      }
      const updated = await storage.updatePropertyMediaFile(fileId, updateData);
      res.json(updated);
    } catch (error) {
      console.error("Error updating media file:", error);
      res.status(500).json({ message: "Failed to update media file" });
    }
  });
  app2.delete("/api/media/files/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const fileId = parseInt(req.params.id);
      const success = await storage.deletePropertyMediaFile(fileId);
      if (success) {
        res.json({ message: "Media file deleted successfully" });
      } else {
        res.status(404).json({ message: "Media file not found" });
      }
    } catch (error) {
      console.error("Error deleting media file:", error);
      res.status(500).json({ message: "Failed to delete media file" });
    }
  });
  app2.get("/api/media/agent-accessible", isDemoAuthenticated, async (req, res) => {
    try {
      if (!["referral-agent", "retail-agent"].includes(req.user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const organizationId2 = req.user.organizationId;
      const files = await storage.getAgentAccessibleMedia(organizationId2, req.user.id, req.user.role);
      for (const file of files) {
        await storage.logAgentMediaAccess({
          organizationId: organizationId2,
          mediaFileId: file.id,
          agentId: req.user.id,
          accessType: "view",
          agentRole: req.user.role,
          ipAddress: req.ip,
          userAgent: req.get("User-Agent"),
          accessReason: "media_library_browse"
        });
      }
      res.json(files);
    } catch (error) {
      console.error("Error fetching agent accessible media:", error);
      res.status(500).json({ message: "Failed to fetch accessible media" });
    }
  });
  app2.get("/api/media/access/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const fileId = parseInt(req.params.id);
      const accessType = req.query.type || "view";
      await storage.updateMediaUsageAnalytics(fileId, accessType);
      if (["referral-agent", "retail-agent"].includes(req.user.role)) {
        await storage.logAgentMediaAccess({
          organizationId: req.user.organizationId,
          mediaFileId: fileId,
          agentId: req.user.id,
          accessType,
          agentRole: req.user.role,
          ipAddress: req.ip,
          userAgent: req.get("User-Agent"),
          accessReason: req.query.reason || "media_access",
          clientReference: req.query.clientRef
        });
      }
      res.json({ message: "Access logged successfully" });
    } catch (error) {
      console.error("Error logging media access:", error);
      res.status(500).json({ message: "Failed to log access" });
    }
  });
  app2.get("/api/media/folders", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : void 0;
      const folders = await storage.getMediaFolders(organizationId2, propertyId);
      res.json(folders);
    } catch (error) {
      console.error("Error fetching media folders:", error);
      res.status(500).json({ message: "Failed to fetch media folders" });
    }
  });
  app2.post("/api/media/folders", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const folderData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: req.user.id
      };
      const folder = await storage.createMediaFolder(folderData);
      res.json(folder);
    } catch (error) {
      console.error("Error creating media folder:", error);
      res.status(500).json({ message: "Failed to create media folder" });
    }
  });
  app2.put("/api/media/folders/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const folderId = parseInt(req.params.id);
      const updateData = req.body;
      const updated = await storage.updateMediaFolder(folderId, updateData);
      res.json(updated);
    } catch (error) {
      console.error("Error updating media folder:", error);
      res.status(500).json({ message: "Failed to update media folder" });
    }
  });
  app2.get("/api/media/settings/:propertyId", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const propertyId = parseInt(req.params.propertyId);
      const settings = await storage.getPropertyMediaSettings(organizationId2, propertyId);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching media settings:", error);
      res.status(500).json({ message: "Failed to fetch media settings" });
    }
  });
  app2.put("/api/media/settings/:propertyId", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const propertyId = parseInt(req.params.propertyId);
      const settingsData = req.body;
      const updated = await storage.updatePropertyMediaSettings(organizationId2, propertyId, settingsData);
      res.json(updated);
    } catch (error) {
      console.error("Error updating media settings:", error);
      res.status(500).json({ message: "Failed to update media settings" });
    }
  });
  app2.get("/api/media/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : void 0;
      const analytics = await storage.getMediaUsageAnalytics(organizationId2, propertyId);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching media analytics:", error);
      res.status(500).json({ message: "Failed to fetch media analytics" });
    }
  });
  app2.get("/api/media/access-logs", isDemoAuthenticated, async (req, res) => {
    try {
      if (!["admin", "portfolio-manager"].includes(req.user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const organizationId2 = req.user.organizationId;
      const mediaFileId = req.query.mediaFileId ? parseInt(req.query.mediaFileId) : void 0;
      const logs = await storage.getAgentMediaAccessLogs(organizationId2, mediaFileId);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching access logs:", error);
      res.status(500).json({ message: "Failed to fetch access logs" });
    }
  });
  app2.get("/api/media/ai-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : void 0;
      const suggestions = await storage.getAiMediaSuggestions(organizationId2, propertyId);
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching AI suggestions:", error);
      res.status(500).json({ message: "Failed to fetch AI suggestions" });
    }
  });
  app2.put("/api/media/ai-suggestions/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const suggestionId = parseInt(req.params.id);
      const updateData = {
        ...req.body,
        reviewedBy: req.user.id,
        reviewedAt: /* @__PURE__ */ new Date()
      };
      const updated = await storage.updateAiMediaSuggestion(suggestionId, updateData);
      res.json(updated);
    } catch (error) {
      console.error("Error updating AI suggestion:", error);
      res.status(500).json({ message: "Failed to update AI suggestion" });
    }
  });
  app2.get("/api/media/stats", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const stats = await storage.getMediaLibraryStats(organizationId2);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching media stats:", error);
      res.status(500).json({ message: "Failed to fetch media stats" });
    }
  });
  app2.get("/api/utility-accounts", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const accounts = await storage.getUtilityAccounts(organizationId2);
      res.json(accounts);
    } catch (error) {
      console.error("Error fetching utility accounts:", error);
      res.status(500).json({ message: "Failed to fetch utility accounts" });
    }
  });
  app2.post("/api/utility-accounts", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org-1";
      const accountData = {
        ...req.body,
        organizationId: organizationId2,
        propertyId: parseInt(req.body.propertyId),
        billArrivalDay: parseInt(req.body.billArrivalDay)
      };
      const newAccount = await storage.createUtilityAccount(accountData);
      res.json(newAccount);
    } catch (error) {
      console.error("Error creating utility account:", error);
      res.status(500).json({ message: "Failed to create utility account" });
    }
  });
  app2.get("/api/platform-routing-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const rules = await storage.getPlatformRoutingRules(organizationId2);
      res.json(rules);
    } catch (error) {
      console.error("Error fetching platform routing rules:", error);
      res.status(500).json({ message: "Failed to fetch platform routing rules" });
    }
  });
  app2.post("/api/platform-routing-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Only administrators can create platform routing rules" });
      }
      const ruleData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId
      };
      const newRule = await storage.createPlatformRoutingRule(ruleData);
      await storage.createRoutingAuditLog({
        organizationId: organizationId2,
        relatedType: "platform_rule",
        relatedId: newRule.id,
        actionType: "created",
        newValues: newRule,
        changeReason: "Platform rule created",
        performedBy: userId
      });
      res.json(newRule);
    } catch (error) {
      console.error("Error creating platform routing rule:", error);
      res.status(500).json({ message: "Failed to create platform routing rule" });
    }
  });
  app2.put("/api/platform-routing-rules/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const { id } = req.params;
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Only administrators can update platform routing rules" });
      }
      const previousRule = await storage.getPlatformRoutingRule(parseInt(id));
      if (!previousRule) {
        return res.status(404).json({ message: "Platform rule not found" });
      }
      const updatedRule = await storage.updatePlatformRoutingRule(parseInt(id), req.body);
      if (!updatedRule) {
        return res.status(404).json({ message: "Platform rule not found" });
      }
      await storage.createRoutingAuditLog({
        organizationId: organizationId2,
        relatedType: "platform_rule",
        relatedId: updatedRule.id,
        actionType: "updated",
        previousValues: previousRule,
        newValues: updatedRule,
        changeReason: "Platform rule updated",
        performedBy: userId
      });
      res.json(updatedRule);
    } catch (error) {
      console.error("Error updating platform routing rule:", error);
      res.status(500).json({ message: "Failed to update platform routing rule" });
    }
  });
  app2.get("/api/property-platform-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId, platformRuleId } = req.query;
      const rules = await storage.getPropertyPlatformRules(organizationId2, {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        platformRuleId: platformRuleId ? parseInt(platformRuleId) : void 0
      });
      res.json(rules);
    } catch (error) {
      console.error("Error fetching property platform rules:", error);
      res.status(500).json({ message: "Failed to fetch property platform rules" });
    }
  });
  app2.post("/api/property-platform-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Only administrators can create property routing rules" });
      }
      const ruleData = {
        ...req.body,
        organizationId: organizationId2,
        setBy: userId,
        propertyId: parseInt(req.body.propertyId),
        platformRuleId: parseInt(req.body.platformRuleId)
      };
      const newRule = await storage.createPropertyPlatformRule(ruleData);
      await storage.createRoutingAuditLog({
        organizationId: organizationId2,
        relatedType: "property_rule",
        relatedId: newRule.id,
        actionType: "created",
        newValues: newRule,
        changeReason: "Property-specific routing rule created",
        performedBy: userId
      });
      res.json(newRule);
    } catch (error) {
      console.error("Error creating property platform rule:", error);
      res.status(500).json({ message: "Failed to create property platform rule" });
    }
  });
  app2.get("/api/booking-platform-routing", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { bookingId, platformRuleId, routingStatus } = req.query;
      const routing = await storage.getBookingPlatformRouting(organizationId2, {
        bookingId: bookingId ? parseInt(bookingId) : void 0,
        platformRuleId: platformRuleId ? parseInt(platformRuleId) : void 0,
        routingStatus
      });
      res.json(routing);
    } catch (error) {
      console.error("Error fetching booking platform routing:", error);
      res.status(500).json({ message: "Failed to fetch booking platform routing" });
    }
  });
  app2.post("/api/booking-platform-routing", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Only administrators can create booking routing overrides" });
      }
      const { bookingId, platformRuleId, actualOwnerPercentage, actualManagementPercentage, overrideReason } = req.body;
      const booking = await storage.getBooking(parseInt(bookingId));
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      const totalAmount = parseFloat(booking.totalAmount || "0");
      const platformRule = await storage.getPlatformRoutingRule(parseInt(platformRuleId));
      if (!platformRule) {
        return res.status(404).json({ message: "Platform rule not found" });
      }
      const ownerPercentage = parseFloat(actualOwnerPercentage);
      const managementPercentage = parseFloat(actualManagementPercentage);
      const platformFeePercentage = parseFloat(platformRule.platformFeePercentage || "0");
      const platformFeeAmount = totalAmount * (platformFeePercentage / 100);
      const netAmount = totalAmount - platformFeeAmount;
      const ownerAmount = netAmount * (ownerPercentage / 100);
      const managementAmount = netAmount * (managementPercentage / 100);
      const routingData = {
        organizationId: organizationId2,
        bookingId: parseInt(bookingId),
        platformRuleId: parseInt(platformRuleId),
        actualOwnerPercentage: ownerPercentage.toString(),
        actualManagementPercentage: managementPercentage.toString(),
        actualRoutingType: req.body.actualRoutingType,
        totalBookingAmount: totalAmount.toString(),
        ownerAmount: ownerAmount.toString(),
        managementAmount: managementAmount.toString(),
        platformFeeAmount: platformFeeAmount.toString(),
        overrideReason,
        isOverride: true,
        routingStatus: "pending",
        createdBy: userId
      };
      const newRouting = await storage.createBookingPlatformRouting(routingData);
      await storage.createRoutingAuditLog({
        organizationId: organizationId2,
        relatedType: "booking_routing",
        relatedId: newRouting.id,
        actionType: "override_applied",
        newValues: newRouting,
        changeReason: overrideReason,
        impactedBookings: 1,
        financialImpact: totalAmount.toString(),
        performedBy: userId
      });
      res.json(newRouting);
    } catch (error) {
      console.error("Error creating booking platform routing:", error);
      res.status(500).json({ message: "Failed to create booking platform routing" });
    }
  });
  app2.patch("/api/booking-platform-routing/:id/process", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const { id } = req.params;
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Only administrators can process routing" });
      }
      const processed = await storage.processBookingRouting(parseInt(id), userId);
      if (!processed) {
        return res.status(404).json({ message: "Booking routing not found" });
      }
      await storage.createRoutingAuditLog({
        organizationId: organizationId2,
        relatedType: "booking_routing",
        relatedId: processed.id,
        actionType: "routing_processed",
        changeReason: "Routing marked as processed",
        performedBy: userId
      });
      res.json(processed);
    } catch (error) {
      console.error("Error processing booking routing:", error);
      res.status(500).json({ message: "Failed to process booking routing" });
    }
  });
  app2.get("/api/routing-audit-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { relatedType, relatedId, actionType, performedBy, fromDate, toDate } = req.query;
      const logs = await storage.getRoutingAuditLogs(organizationId2, {
        relatedType,
        relatedId: relatedId ? parseInt(relatedId) : void 0,
        actionType,
        performedBy,
        fromDate: fromDate ? new Date(fromDate) : void 0,
        toDate: toDate ? new Date(toDate) : void 0
      });
      res.json(logs);
    } catch (error) {
      console.error("Error fetching routing audit logs:", error);
      res.status(500).json({ message: "Failed to fetch routing audit logs" });
    }
  });
  app2.post("/api/calculate-booking-routing", isDemoAuthenticated, async (req, res) => {
    try {
      const { bookingId, platformRuleId, totalAmount, overrides } = req.body;
      const calculation = await storage.calculateBookingRouting(
        parseInt(bookingId),
        parseInt(platformRuleId),
        parseFloat(totalAmount),
        overrides
      );
      res.json(calculation);
    } catch (error) {
      console.error("Error calculating booking routing:", error);
      res.status(500).json({ message: "Failed to calculate booking routing" });
    }
  });
  app2.get("/api/properties/:propertyId/routing-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyId } = req.params;
      const rules = await storage.getRoutingRulesForProperty(parseInt(propertyId));
      res.json(rules);
    } catch (error) {
      console.error("Error fetching property routing rules:", error);
      res.status(500).json({ message: "Failed to fetch property routing rules" });
    }
  });
  app2.get("/api/inventory/categories", async (req, res) => {
    try {
      const categories = await storage.getInventoryCategories("demo-org");
      res.json(categories);
    } catch (error) {
      console.error("Error fetching inventory categories:", error);
      res.status(500).json({ message: "Failed to fetch categories" });
    }
  });
  app2.post("/api/inventory/categories", async (req, res) => {
    try {
      const data = { ...req.body, organizationId: "demo-org" };
      const category = await storage.createInventoryCategory(data);
      res.json(category);
    } catch (error) {
      console.error("Error creating inventory category:", error);
      res.status(500).json({ message: "Failed to create category" });
    }
  });
  app2.put("/api/inventory/categories/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const category = await storage.updateInventoryCategory(id, req.body);
      res.json(category);
    } catch (error) {
      console.error("Error updating inventory category:", error);
      res.status(500).json({ message: "Failed to update category" });
    }
  });
  app2.delete("/api/inventory/categories/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteInventoryCategory(id);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting inventory category:", error);
      res.status(500).json({ message: "Failed to delete category" });
    }
  });
  app2.get("/api/inventory/items", async (req, res) => {
    try {
      const { categoryId, isActive } = req.query;
      const filters = {};
      if (categoryId) filters.categoryId = parseInt(categoryId);
      if (isActive !== void 0) filters.isActive = isActive === "true";
      const items = await storage.getInventoryItems("demo-org", filters);
      res.json(items);
    } catch (error) {
      console.error("Error fetching inventory items:", error);
      res.status(500).json({ message: "Failed to fetch items" });
    }
  });
  app2.post("/api/inventory/items", async (req, res) => {
    try {
      const data = { ...req.body, organizationId: "demo-org" };
      const item = await storage.createInventoryItem(data);
      res.json(item);
    } catch (error) {
      console.error("Error creating inventory item:", error);
      res.status(500).json({ message: "Failed to create item" });
    }
  });
  app2.put("/api/inventory/items/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const item = await storage.updateInventoryItem(id, req.body);
      res.json(item);
    } catch (error) {
      console.error("Error updating inventory item:", error);
      res.status(500).json({ message: "Failed to update item" });
    }
  });
  app2.delete("/api/inventory/items/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteInventoryItem(id);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting inventory item:", error);
      res.status(500).json({ message: "Failed to delete item" });
    }
  });
  app2.get("/api/inventory/property-configs/:propertyId", async (req, res) => {
    try {
      const propertyId = parseInt(req.params.propertyId);
      const config = await storage.getPropertyWelcomePackConfig("demo-org", propertyId);
      res.json(config);
    } catch (error) {
      console.error("Error fetching property config:", error);
      res.status(500).json({ message: "Failed to fetch property config" });
    }
  });
  app2.post("/api/inventory/property-configs", async (req, res) => {
    try {
      const data = { ...req.body, organizationId: "demo-org" };
      const config = await storage.createPropertyWelcomePackConfig(data);
      res.json(config);
    } catch (error) {
      console.error("Error creating property config:", error);
      res.status(500).json({ message: "Failed to create property config" });
    }
  });
  app2.put("/api/inventory/property-configs/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const config = await storage.updatePropertyWelcomePackConfig(id, req.body);
      res.json(config);
    } catch (error) {
      console.error("Error updating property config:", error);
      res.status(500).json({ message: "Failed to update property config" });
    }
  });
  app2.get("/api/inventory/usage-logs", async (req, res) => {
    try {
      const { propertyId, staffMemberId, startDate, endDate, billingRule, isProcessed } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (staffMemberId) filters.staffMemberId = staffMemberId;
      if (startDate) filters.startDate = startDate;
      if (endDate) filters.endDate = endDate;
      if (billingRule) filters.billingRule = billingRule;
      if (isProcessed !== void 0) filters.isProcessed = isProcessed === "true";
      const logs = await storage.getInventoryUsageLogs("demo-org", filters);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching usage logs:", error);
      res.status(500).json({ message: "Failed to fetch usage logs" });
    }
  });
  app2.get("/api/inventory/usage-logs/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const log2 = await storage.getInventoryUsageLog(id);
      if (!log2) {
        return res.status(404).json({ message: "Usage log not found" });
      }
      const items = await storage.getInventoryUsageItems(id);
      res.json({ ...log2, items });
    } catch (error) {
      console.error("Error fetching usage log:", error);
      res.status(500).json({ message: "Failed to fetch usage log" });
    }
  });
  app2.post("/api/inventory/usage-logs", async (req, res) => {
    try {
      const property = await storage.getProperty(req.body.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }
      let config = await storage.getPropertyWelcomePackConfig("demo-org", req.body.propertyId);
      if (!config) {
        config = await storage.createPropertyWelcomePackConfig({
          organizationId: "demo-org",
          propertyId: req.body.propertyId,
          oneBrCost: "300.00",
          twoBrCost: "350.00",
          threePlusBrCost: "400.00",
          defaultBillingRule: "owner"
        });
      }
      let packCost = 300;
      if (property.bedrooms >= 3) {
        packCost = parseFloat(config.threePlusBrCost);
      } else if (property.bedrooms === 2) {
        packCost = parseFloat(config.twoBrCost);
      } else {
        packCost = parseFloat(config.oneBrCost);
      }
      const data = {
        ...req.body,
        organizationId: "demo-org",
        totalPackCost: packCost.toString(),
        staffMemberId: "staff@test.com"
        // Demo staff member
      };
      const log2 = await storage.createInventoryUsageLog(data);
      const categories = await storage.getInventoryCategories("demo-org");
      const items = await storage.getInventoryItems("demo-org");
      const usageItems = items.map((item) => ({
        organizationId: "demo-org",
        usageLogId: log2.id,
        inventoryItemId: item.id,
        quantityUsed: item.defaultQuantityPerBedroom * property.bedrooms,
        unitCost: item.costPerUnit,
        totalCost: (parseFloat(item.costPerUnit) * item.defaultQuantityPerBedroom * property.bedrooms).toString()
      }));
      if (usageItems.length > 0) {
        await storage.createInventoryUsageItems(usageItems);
      }
      res.json(log2);
    } catch (error) {
      console.error("Error creating usage log:", error);
      res.status(500).json({ message: "Failed to create usage log" });
    }
  });
  app2.put("/api/inventory/usage-logs/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const log2 = await storage.updateInventoryUsageLog(id, req.body);
      res.json(log2);
    } catch (error) {
      console.error("Error updating usage log:", error);
      res.status(500).json({ message: "Failed to update usage log" });
    }
  });
  app2.post("/api/inventory/usage-logs/:id/process", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const log2 = await storage.processInventoryUsageLog(id, "admin@test.com");
      res.json(log2);
    } catch (error) {
      console.error("Error processing usage log:", error);
      res.status(500).json({ message: "Failed to process usage log" });
    }
  });
  app2.get("/api/inventory/stock-levels", async (req, res) => {
    try {
      const { isLowStock, inventoryItemId } = req.query;
      const filters = {};
      if (isLowStock !== void 0) filters.isLowStock = isLowStock === "true";
      if (inventoryItemId) filters.inventoryItemId = parseInt(inventoryItemId);
      const stockLevels = await storage.getInventoryStockLevels("demo-org", filters);
      res.json(stockLevels);
    } catch (error) {
      console.error("Error fetching stock levels:", error);
      res.status(500).json({ message: "Failed to fetch stock levels" });
    }
  });
  app2.put("/api/inventory/stock-levels/:inventoryItemId", async (req, res) => {
    try {
      const inventoryItemId = parseInt(req.params.inventoryItemId);
      const data = { ...req.body, organizationId: "demo-org" };
      const stockLevel = await storage.updateInventoryStockLevel(inventoryItemId, data);
      res.json(stockLevel);
    } catch (error) {
      console.error("Error updating stock level:", error);
      res.status(500).json({ message: "Failed to update stock level" });
    }
  });
  app2.get("/api/inventory/billing-summaries", async (req, res) => {
    try {
      const { propertyId, monthYear, isProcessed } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (monthYear) filters.monthYear = monthYear;
      if (isProcessed !== void 0) filters.isProcessed = isProcessed === "true";
      const summaries = await storage.getWelcomePackBillingSummaries("demo-org", filters);
      res.json(summaries);
    } catch (error) {
      console.error("Error fetching billing summaries:", error);
      res.status(500).json({ message: "Failed to fetch billing summaries" });
    }
  });
  app2.post("/api/inventory/billing-summaries", async (req, res) => {
    try {
      const data = { ...req.body, organizationId: "demo-org" };
      const summary = await storage.createWelcomePackBillingSummary(data);
      res.json(summary);
    } catch (error) {
      console.error("Error creating billing summary:", error);
      res.status(500).json({ message: "Failed to create billing summary" });
    }
  });
  app2.put("/api/inventory/billing-summaries/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const summary = await storage.updateWelcomePackBillingSummary(id, req.body);
      res.json(summary);
    } catch (error) {
      console.error("Error updating billing summary:", error);
      res.status(500).json({ message: "Failed to update billing summary" });
    }
  });
  app2.get("/api/inventory/analytics", async (req, res) => {
    try {
      const { propertyId, startDate, endDate, period } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (startDate) filters.startDate = startDate;
      if (endDate) filters.endDate = endDate;
      if (period) filters.period = period;
      const analytics = await storage.getInventoryUsageAnalytics("demo-org", filters);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });
  app2.get("/api/inventory/reports/usage", async (req, res) => {
    try {
      const { propertyId, staffMemberId, startDate, endDate, billingRule } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (staffMemberId) filters.staffMemberId = staffMemberId;
      if (startDate) filters.startDate = startDate;
      if (endDate) filters.endDate = endDate;
      if (billingRule) filters.billingRule = billingRule;
      const reportData = await storage.getInventoryUsageReportData("demo-org", filters);
      res.json(reportData);
    } catch (error) {
      console.error("Error fetching usage report:", error);
      res.status(500).json({ message: "Failed to fetch usage report" });
    }
  });
  app2.post("/api/tasks/:taskId/photos", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const taskId = parseInt(req.params.taskId);
      const { photoUrl, description, category } = req.body;
      if (!photoUrl) {
        return res.status(400).json({ message: "Photo URL is required" });
      }
      const photoData = {
        organizationId: organizationId2,
        taskId,
        photoUrl,
        description: description || "",
        category: category || "general",
        uploadedBy: userId,
        uploadedAt: /* @__PURE__ */ new Date()
      };
      const photo = await storage.createTaskCompletionPhoto(photoData);
      res.status(201).json(photo);
    } catch (error) {
      console.error("Error uploading task photo:", error);
      res.status(500).json({ message: "Failed to upload photo" });
    }
  });
  app2.get("/api/tasks/:taskId/photos", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const taskId = parseInt(req.params.taskId);
      const photos = await storage.getTaskCompletionPhotos(organizationId2, taskId);
      res.json(photos);
    } catch (error) {
      console.error("Error fetching task photos:", error);
      res.status(500).json({ message: "Failed to fetch photos" });
    }
  });
  app2.delete("/api/tasks/:taskId/photos/:photoId", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const photoId = parseInt(req.params.photoId);
      const deleted = await storage.deleteTaskCompletionPhoto(organizationId2, photoId);
      if (!deleted) {
        return res.status(404).json({ message: "Photo not found" });
      }
      res.json({ message: "Photo deleted successfully" });
    } catch (error) {
      console.error("Error deleting task photo:", error);
      res.status(500).json({ message: "Failed to delete photo" });
    }
  });
  app2.post("/api/tasks/:taskId/notes", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const taskId = parseInt(req.params.taskId);
      const { noteText, noteType } = req.body;
      if (!noteText) {
        return res.status(400).json({ message: "Note text is required" });
      }
      const noteData = {
        organizationId: organizationId2,
        taskId,
        noteText,
        noteType: noteType || "general",
        addedBy: userId,
        addedAt: /* @__PURE__ */ new Date()
      };
      const note = await storage.createTaskCompletionNote(noteData);
      res.status(201).json(note);
    } catch (error) {
      console.error("Error adding task note:", error);
      res.status(500).json({ message: "Failed to add note" });
    }
  });
  app2.get("/api/tasks/:taskId/notes", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const taskId = parseInt(req.params.taskId);
      const notes = await storage.getTaskCompletionNotes(organizationId2, taskId);
      res.json(notes);
    } catch (error) {
      console.error("Error fetching task notes:", error);
      res.status(500).json({ message: "Failed to fetch notes" });
    }
  });
  app2.post("/api/tasks/:taskId/expenses", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const taskId = parseInt(req.params.taskId);
      const { description, amount, category, receiptUrl, vendor } = req.body;
      if (!description || !amount) {
        return res.status(400).json({ message: "Description and amount are required" });
      }
      const expenseData = {
        organizationId: organizationId2,
        taskId,
        description,
        amount: parseFloat(amount),
        category: category || "general",
        receiptUrl,
        vendor,
        addedBy: userId,
        addedAt: /* @__PURE__ */ new Date()
      };
      const expense = await storage.createTaskCompletionExpense(expenseData);
      res.status(201).json(expense);
    } catch (error) {
      console.error("Error adding task expense:", error);
      res.status(500).json({ message: "Failed to add expense" });
    }
  });
  app2.get("/api/tasks/:taskId/expenses", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const taskId = parseInt(req.params.taskId);
      const expenses = await storage.getTaskCompletionExpenses(organizationId2, taskId);
      res.json(expenses);
    } catch (error) {
      console.error("Error fetching task expenses:", error);
      res.status(500).json({ message: "Failed to fetch expenses" });
    }
  });
  app2.delete("/api/tasks/:taskId/expenses/:expenseId", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const expenseId = parseInt(req.params.expenseId);
      const deleted = await storage.deleteTaskCompletionExpense(organizationId2, expenseId);
      if (!deleted) {
        return res.status(404).json({ message: "Expense not found" });
      }
      res.json({ message: "Expense deleted successfully" });
    } catch (error) {
      console.error("Error deleting task expense:", error);
      res.status(500).json({ message: "Failed to delete expense" });
    }
  });
  app2.post("/api/tasks/:taskId/submit-for-approval", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const taskId = parseInt(req.params.taskId);
      if (role !== "staff") {
        return res.status(403).json({ message: "Only staff members can submit tasks for approval" });
      }
      const approval = await storage.submitTaskForApproval(taskId, userId, organizationId2);
      res.json(approval);
    } catch (error) {
      console.error("Error submitting task for approval:", error);
      res.status(500).json({ message: "Failed to submit task for approval" });
    }
  });
  app2.get("/api/task-approvals/pending", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (role !== "portfolio-manager" && role !== "admin") {
        return res.status(403).json({ message: "Only portfolio managers and admins can view task approvals" });
      }
      const pendingApprovals = await storage.getPendingTaskApprovals(organizationId2);
      res.json(pendingApprovals);
    } catch (error) {
      console.error("Error fetching pending approvals:", error);
      res.status(500).json({ message: "Failed to fetch pending approvals" });
    }
  });
  app2.post("/api/tasks/:taskId/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const taskId = parseInt(req.params.taskId);
      const { reviewNotes } = req.body;
      if (role !== "portfolio-manager" && role !== "admin") {
        return res.status(403).json({ message: "Only portfolio managers and admins can approve tasks" });
      }
      const approval = await storage.approveTask(organizationId2, taskId, userId, reviewNotes);
      res.json(approval);
    } catch (error) {
      console.error("Error approving task:", error);
      res.status(500).json({ message: "Failed to approve task" });
    }
  });
  app2.post("/api/tasks/:taskId/request-redo", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const taskId = parseInt(req.params.taskId);
      const { reviewNotes } = req.body;
      if (role !== "portfolio-manager" && role !== "admin") {
        return res.status(403).json({ message: "Only portfolio managers and admins can request task redo" });
      }
      if (!reviewNotes) {
        return res.status(400).json({ message: "Review notes are required for redo requests" });
      }
      const approval = await storage.requestTaskRedo(organizationId2, taskId, userId, reviewNotes);
      res.json(approval);
    } catch (error) {
      console.error("Error requesting task redo:", error);
      res.status(500).json({ message: "Failed to request task redo" });
    }
  });
  app2.get("/api/tasks/:taskId/completion-details", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const taskId = parseInt(req.params.taskId);
      const taskDetails = await storage.getTaskWithCompletionDetails(organizationId2, taskId);
      if (!taskDetails) {
        return res.status(404).json({ message: "Task not found" });
      }
      res.json(taskDetails);
    } catch (error) {
      console.error("Error fetching task completion details:", error);
      res.status(500).json({ message: "Failed to fetch task details" });
    }
  });
  app2.get("/api/tasks/ready-for-archive", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Only admins can view tasks ready for archive" });
      }
      const tasks2 = await storage.getTasksReadyForArchive(organizationId2);
      res.json(tasks2);
    } catch (error) {
      console.error("Error fetching tasks ready for archive:", error);
      res.status(500).json({ message: "Failed to fetch tasks ready for archive" });
    }
  });
  app2.post("/api/tasks/generate-pdf-archive", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { taskIds, archiveTitle, archiveDescription } = req.body;
      if (role !== "admin") {
        return res.status(403).json({ message: "Only admins can generate PDF archives" });
      }
      if (!taskIds || !Array.isArray(taskIds) || taskIds.length === 0) {
        return res.status(400).json({ message: "Task IDs array is required" });
      }
      const archiveData = {
        organizationId: organizationId2,
        title: archiveTitle || `Task Archive ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`,
        description: archiveDescription || "Automated 30-day task archive",
        taskCount: taskIds.length,
        generatedBy: userId,
        generatedAt: /* @__PURE__ */ new Date(),
        archiveStatus: "completed",
        pdfUrl: `https://demo-storage.com/archives/${Date.now()}.pdf`,
        // Demo URL
        taskIds
      };
      const archive = await storage.generateTaskPdfArchive(archiveData);
      await storage.markTasksAsArchived(taskIds, archive.id, organizationId2);
      setTimeout(async () => {
        await storage.deleteArchivedTaskPhotos(taskIds, organizationId2);
      }, 5e3);
      res.json(archive);
    } catch (error) {
      console.error("Error generating PDF archive:", error);
      res.status(500).json({ message: "Failed to generate PDF archive" });
    }
  });
  app2.get("/api/task-pdf-archives", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId } = req.query;
      const archives = await storage.getTaskPdfArchives(
        organizationId2,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(archives);
    } catch (error) {
      console.error("Error fetching PDF archives:", error);
      res.status(500).json({ message: "Failed to fetch PDF archives" });
    }
  });
  app2.get("/api/staff-overhours/work-hours", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { staffId } = req.query;
      const workHours = await storage.getStaffWorkHours(organizationId2, staffId);
      res.json(workHours);
    } catch (error) {
      console.error("Error fetching staff work hours:", error);
      res.status(500).json({ message: "Failed to fetch staff work hours" });
    }
  });
  app2.post("/api/staff-overhours/work-hours", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const workHoursData = { ...req.body, organizationId: organizationId2 };
      const workHours = await storage.createStaffWorkHours(workHoursData);
      res.status(201).json(workHours);
    } catch (error) {
      console.error("Error creating staff work hours:", error);
      res.status(500).json({ message: "Failed to create staff work hours" });
    }
  });
  app2.post("/api/staff-overhours/start-timer", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, userId } = req.user;
      if (role !== "staff") {
        return res.status(403).json({ message: "Access denied. Staff role required." });
      }
      const timerData = {
        ...req.body,
        organizationId: organizationId2,
        staffId: userId,
        startTime: /* @__PURE__ */ new Date()
      };
      const timer = await storage.startTaskTimer(timerData);
      res.status(201).json(timer);
    } catch (error) {
      console.error("Error starting task timer:", error);
      res.status(500).json({ message: "Failed to start task timer" });
    }
  });
  app2.patch("/api/staff-overhours/end-timer/:trackingId", isDemoAuthenticated, async (req, res) => {
    try {
      const { role } = req.user;
      const { trackingId } = req.params;
      const { taskNotes } = req.body;
      if (role !== "staff") {
        return res.status(403).json({ message: "Access denied. Staff role required." });
      }
      const updatedTimer = await storage.endTaskTimer(
        parseInt(trackingId),
        /* @__PURE__ */ new Date(),
        taskNotes
      );
      if (!updatedTimer) {
        return res.status(404).json({ message: "Timer not found" });
      }
      res.json(updatedTimer);
    } catch (error) {
      console.error("Error ending task timer:", error);
      res.status(500).json({ message: "Failed to end task timer" });
    }
  });
  app2.patch("/api/staff-overhours/mark-emergency/:trackingId", isDemoAuthenticated, async (req, res) => {
    try {
      const { role, firstName, lastName } = req.user;
      const { trackingId } = req.params;
      const { emergencyReason } = req.body;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const markedBy = `${firstName} ${lastName}`;
      const updatedTimer = await storage.markTaskAsEmergency(
        parseInt(trackingId),
        emergencyReason,
        markedBy
      );
      if (!updatedTimer) {
        return res.status(404).json({ message: "Timer not found" });
      }
      res.json(updatedTimer);
    } catch (error) {
      console.error("Error marking task as emergency:", error);
      res.status(500).json({ message: "Failed to mark task as emergency" });
    }
  });
  app2.get("/api/staff-overhours/time-tracking", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, userId } = req.user;
      const filters = {};
      if (role === "staff") {
        filters.staffId = userId;
      } else if (["admin", "portfolio-manager"].includes(role)) {
        if (req.query.staffId) {
          filters.staffId = req.query.staffId;
        }
      } else {
        return res.status(403).json({ message: "Access denied" });
      }
      if (req.query.taskId) filters.taskId = parseInt(req.query.taskId);
      if (req.query.status) filters.status = req.query.status;
      if (req.query.fromDate) filters.fromDate = new Date(req.query.fromDate);
      if (req.query.toDate) filters.toDate = new Date(req.query.toDate);
      if (req.query.isOutsideNormalHours !== void 0) {
        filters.isOutsideNormalHours = req.query.isOutsideNormalHours === "true";
      }
      if (req.query.isEmergencyTask !== void 0) {
        filters.isEmergencyTask = req.query.isEmergencyTask === "true";
      }
      const timeRecords = await storage.getTaskTimeTracking(organizationId2, filters);
      res.json(timeRecords);
    } catch (error) {
      console.error("Error fetching time tracking records:", error);
      res.status(500).json({ message: "Failed to fetch time tracking records" });
    }
  });
  app2.get("/api/staff-overhours/overtime-summary", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, userId } = req.user;
      const filters = {};
      if (role === "staff") {
        filters.staffId = userId;
      } else if (["admin", "portfolio-manager"].includes(role)) {
        if (req.query.staffId) {
          filters.staffId = req.query.staffId;
        }
      } else {
        return res.status(403).json({ message: "Access denied" });
      }
      if (req.query.monthYear) filters.monthYear = req.query.monthYear;
      if (req.query.status) filters.status = req.query.status;
      const summary = await storage.getOvertimeHoursSummary(organizationId2, filters);
      res.json(summary);
    } catch (error) {
      console.error("Error fetching overtime summary:", error);
      res.status(500).json({ message: "Failed to fetch overtime summary" });
    }
  });
  app2.patch("/api/staff-overhours/approve-overtime/:summaryId", isDemoAuthenticated, async (req, res) => {
    try {
      const { role, firstName, lastName } = req.user;
      const { summaryId } = req.params;
      const { approvedMinutes } = req.body;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const approvedBy = `${firstName} ${lastName}`;
      const updatedSummary = await storage.approveOvertimeHours(
        parseInt(summaryId),
        approvedBy,
        approvedMinutes
      );
      if (!updatedSummary) {
        return res.status(404).json({ message: "Overtime summary not found" });
      }
      res.json(updatedSummary);
    } catch (error) {
      console.error("Error approving overtime hours:", error);
      res.status(500).json({ message: "Failed to approve overtime hours" });
    }
  });
  app2.get("/api/staff-overhours/commission-bonuses", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, userId } = req.user;
      const filters = {};
      if (role === "staff") {
        filters.staffId = userId;
      } else if (["admin", "portfolio-manager"].includes(role)) {
        if (req.query.staffId) {
          filters.staffId = req.query.staffId;
        }
      } else {
        return res.status(403).json({ message: "Access denied" });
      }
      if (req.query.monthYear) filters.monthYear = req.query.monthYear;
      if (req.query.bonusType) filters.bonusType = req.query.bonusType;
      if (req.query.status) filters.status = req.query.status;
      const bonuses = await storage.getStaffCommissionBonuses(organizationId2, filters);
      res.json(bonuses);
    } catch (error) {
      console.error("Error fetching commission bonuses:", error);
      res.status(500).json({ message: "Failed to fetch commission bonuses" });
    }
  });
  app2.post("/api/staff-overhours/commission-bonuses", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, firstName, lastName } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const awardedBy = `${firstName} ${lastName}`;
      const bonusData = {
        ...req.body,
        organizationId: organizationId2,
        awardedBy
      };
      const bonus = await storage.createStaffCommissionBonus(bonusData);
      res.status(201).json(bonus);
    } catch (error) {
      console.error("Error creating commission bonus:", error);
      res.status(500).json({ message: "Failed to create commission bonus" });
    }
  });
  app2.get("/api/staff-overhours/emergency-reasons", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const reasons = await storage.getEmergencyTaskReasons(organizationId2);
      res.json(reasons);
    } catch (error) {
      console.error("Error fetching emergency task reasons:", error);
      res.status(500).json({ message: "Failed to fetch emergency task reasons" });
    }
  });
  app2.post("/api/staff-overhours/emergency-reasons", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      const reasonData = { ...req.body, organizationId: organizationId2 };
      const reason = await storage.createEmergencyTaskReason(reasonData);
      res.status(201).json(reason);
    } catch (error) {
      console.error("Error creating emergency task reason:", error);
      res.status(500).json({ message: "Failed to create emergency task reason" });
    }
  });
  app2.get("/api/staff-overhours/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { staffId, fromDate, toDate } = req.query;
      const analytics = await storage.getStaffOvertimeAnalytics(
        organizationId2,
        staffId,
        fromDate ? new Date(fromDate) : void 0,
        toDate ? new Date(toDate) : void 0
      );
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching overtime analytics:", error);
      res.status(500).json({ message: "Failed to fetch overtime analytics" });
    }
  });
  app2.get("/api/tasks/:taskId/attachments", isDemoAuthenticated, async (req, res) => {
    try {
      const taskId = parseInt(req.params.taskId);
      const attachments = await storage.getTaskAttachments(taskId);
      res.json(attachments);
    } catch (error) {
      console.error("Error fetching task attachments:", error);
      res.status(500).json({ message: "Failed to fetch task attachments" });
    }
  });
  app2.post("/api/tasks/:taskId/attachments", isDemoAuthenticated, async (req, res) => {
    try {
      const taskId = parseInt(req.params.taskId);
      const user = req.user;
      const attachmentData = {
        ...req.body,
        taskId,
        organizationId: user.organizationId,
        uploadedBy: user.id,
        uploadedByName: user.firstName ? `${user.firstName} ${user.lastName || ""}`.trim() : user.email || "Unknown User"
      };
      const attachment = await storage.createTaskAttachment(attachmentData);
      res.json(attachment);
    } catch (error) {
      console.error("Error creating task attachment:", error);
      res.status(500).json({ message: "Failed to create task attachment" });
    }
  });
  app2.put("/api/task-attachments/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const attachment = await storage.updateTaskAttachment(id, req.body);
      res.json(attachment);
    } catch (error) {
      console.error("Error updating task attachment:", error);
      res.status(500).json({ message: "Failed to update task attachment" });
    }
  });
  app2.delete("/api/task-attachments/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteTaskAttachment(id);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting task attachment:", error);
      res.status(500).json({ message: "Failed to delete task attachment" });
    }
  });
  app2.get("/api/properties/:propertyId/notes", isDemoAuthenticated, async (req, res) => {
    try {
      const propertyId = parseInt(req.params.propertyId);
      const { noteType, isPinned, department } = req.query;
      const filters = {};
      if (noteType) filters.noteType = noteType;
      if (isPinned !== void 0) filters.isPinned = isPinned === "true";
      if (department) filters.department = department;
      const notes = await storage.getPropertyNotes(propertyId, filters);
      res.json(notes);
    } catch (error) {
      console.error("Error fetching property notes:", error);
      res.status(500).json({ message: "Failed to fetch property notes" });
    }
  });
  app2.post("/api/properties/:propertyId/notes", isDemoAuthenticated, async (req, res) => {
    try {
      const propertyId = parseInt(req.params.propertyId);
      const user = req.user;
      const noteData = {
        ...req.body,
        propertyId,
        organizationId: user.organizationId,
        createdBy: user.id,
        createdByName: user.firstName ? `${user.firstName} ${user.lastName || ""}`.trim() : user.email || "Unknown User"
      };
      const note = await storage.createPropertyNote(noteData);
      res.json(note);
    } catch (error) {
      console.error("Error creating property note:", error);
      res.status(500).json({ message: "Failed to create property note" });
    }
  });
  app2.put("/api/property-notes/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const user = req.user;
      const updateData = {
        ...req.body,
        lastModifiedBy: user.id,
        lastModifiedByName: user.firstName ? `${user.firstName} ${user.lastName || ""}`.trim() : user.email || "Unknown User"
      };
      const note = await storage.updatePropertyNote(id, updateData);
      res.json(note);
    } catch (error) {
      console.error("Error updating property note:", error);
      res.status(500).json({ message: "Failed to update property note" });
    }
  });
  app2.delete("/api/property-notes/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deletePropertyNote(id);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting property note:", error);
      res.status(500).json({ message: "Failed to delete property note" });
    }
  });
  app2.get("/api/properties/:propertyId/attachments", isDemoAuthenticated, async (req, res) => {
    try {
      const propertyId = parseInt(req.params.propertyId);
      const { category, department } = req.query;
      const filters = {};
      if (category) filters.category = category;
      if (department) filters.department = department;
      const attachments = await storage.getPropertyAttachments(propertyId, filters);
      res.json(attachments);
    } catch (error) {
      console.error("Error fetching property attachments:", error);
      res.status(500).json({ message: "Failed to fetch property attachments" });
    }
  });
  app2.post("/api/properties/:propertyId/attachments", isDemoAuthenticated, async (req, res) => {
    try {
      const propertyId = parseInt(req.params.propertyId);
      const user = req.user;
      const attachmentData = {
        ...req.body,
        propertyId,
        organizationId: user.organizationId,
        uploadedBy: user.id,
        uploadedByName: user.firstName ? `${user.firstName} ${user.lastName || ""}`.trim() : user.email || "Unknown User"
      };
      const attachment = await storage.createPropertyAttachment(attachmentData);
      res.json(attachment);
    } catch (error) {
      console.error("Error creating property attachment:", error);
      res.status(500).json({ message: "Failed to create property attachment" });
    }
  });
  app2.put("/api/property-attachments/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const attachment = await storage.updatePropertyAttachment(id, req.body);
      res.json(attachment);
    } catch (error) {
      console.error("Error updating property attachment:", error);
      res.status(500).json({ message: "Failed to update property attachment" });
    }
  });
  app2.delete("/api/property-attachments/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deletePropertyAttachment(id);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting property attachment:", error);
      res.status(500).json({ message: "Failed to delete property attachment" });
    }
  });
  app2.get("/api/task-guide-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { category, guideType } = req.query;
      const filters = {};
      if (category) filters.category = category;
      if (guideType) filters.guideType = guideType;
      const templates = await storage.getTaskGuideTemplates(user.organizationId, filters);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching task guide templates:", error);
      res.status(500).json({ message: "Failed to fetch task guide templates" });
    }
  });
  app2.post("/api/task-guide-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const templateData = {
        ...req.body,
        organizationId: user.organizationId,
        createdBy: user.id,
        createdByName: user.firstName ? `${user.firstName} ${user.lastName || ""}`.trim() : user.email || "Unknown User"
      };
      const template = await storage.createTaskGuideTemplate(templateData);
      res.json(template);
    } catch (error) {
      console.error("Error creating task guide template:", error);
      res.status(500).json({ message: "Failed to create task guide template" });
    }
  });
  app2.put("/api/task-guide-templates/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const user = req.user;
      const updateData = {
        ...req.body,
        lastModifiedBy: user.id,
        lastModifiedByName: user.firstName ? `${user.firstName} ${user.lastName || ""}`.trim() : user.email || "Unknown User"
      };
      const template = await storage.updateTaskGuideTemplate(id, updateData);
      res.json(template);
    } catch (error) {
      console.error("Error updating task guide template:", error);
      res.status(500).json({ message: "Failed to update task guide template" });
    }
  });
  app2.delete("/api/task-guide-templates/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteTaskGuideTemplate(id);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting task guide template:", error);
      res.status(500).json({ message: "Failed to delete task guide template" });
    }
  });
  app2.post("/api/attachment-access-log", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const logData = {
        ...req.body,
        organizationId: user.organizationId,
        accessedBy: user.id,
        accessedByName: user.firstName ? `${user.firstName} ${user.lastName || ""}`.trim() : user.email || "Unknown User"
      };
      const log2 = await storage.logAttachmentAccess(logData);
      res.json(log2);
    } catch (error) {
      console.error("Error logging attachment access:", error);
      res.status(500).json({ message: "Failed to log attachment access" });
    }
  });
  app2.get("/api/attachment-access-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { attachmentId, attachmentType, accessedBy } = req.query;
      const filters = {};
      if (attachmentId) filters.attachmentId = parseInt(attachmentId);
      if (attachmentType) filters.attachmentType = attachmentType;
      if (accessedBy) filters.accessedBy = accessedBy;
      const logs = await storage.getAttachmentAccessLogs(user.organizationId, filters);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching attachment access logs:", error);
      res.status(500).json({ message: "Failed to fetch attachment access logs" });
    }
  });
  app2.get("/api/addon-services/categories", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const categories = await storage.getServiceCategories(user.organizationId);
      res.json(categories);
    } catch (error) {
      console.error("Error fetching service categories:", error);
      res.status(500).json({ message: "Failed to fetch service categories" });
    }
  });
  app2.post("/api/addon-services/categories", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!["admin", "portfolio-manager"].includes(user.role)) {
        return res.status(403).json({ message: "Unauthorized: Admin/PM access required" });
      }
      const categoryData = { ...req.body, organizationId: user.organizationId };
      const category = await storage.createServiceCategory(categoryData);
      res.json(category);
    } catch (error) {
      console.error("Error creating service category:", error);
      res.status(500).json({ message: "Failed to create service category" });
    }
  });
  app2.put("/api/addon-services/categories/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!["admin", "portfolio-manager"].includes(user.role)) {
        return res.status(403).json({ message: "Unauthorized: Admin/PM access required" });
      }
      const id = parseInt(req.params.id);
      const updates = req.body;
      const category = await storage.updateServiceCategory(id, updates);
      res.json(category);
    } catch (error) {
      console.error("Error updating service category:", error);
      res.status(500).json({ message: "Failed to update service category" });
    }
  });
  app2.delete("/api/addon-services/categories/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!["admin", "portfolio-manager"].includes(user.role)) {
        return res.status(403).json({ message: "Unauthorized: Admin/PM access required" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deleteServiceCategory(id);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting service category:", error);
      res.status(500).json({ message: "Failed to delete service category" });
    }
  });
  app2.get("/api/addon-services", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { categoryId, isActive } = req.query;
      const filters = {};
      if (categoryId) filters.categoryId = parseInt(categoryId);
      if (isActive !== void 0) filters.isActive = isActive === "true";
      const services = await storage.getAddonServices(user.organizationId, filters);
      res.json(services);
    } catch (error) {
      console.error("Error fetching addon services:", error);
      res.status(500).json({ message: "Failed to fetch addon services" });
    }
  });
  app2.get("/api/addon-services/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const service = await storage.getAddonService(id);
      if (!service) {
        return res.status(404).json({ message: "Service not found" });
      }
      res.json(service);
    } catch (error) {
      console.error("Error fetching addon service:", error);
      res.status(500).json({ message: "Failed to fetch addon service" });
    }
  });
  app2.post("/api/addon-services", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!["admin", "portfolio-manager"].includes(user.role)) {
        return res.status(403).json({ message: "Unauthorized: Admin/PM access required" });
      }
      const serviceData = { ...req.body, organizationId: user.organizationId };
      const service = await storage.createAddonService(serviceData);
      res.json(service);
    } catch (error) {
      console.error("Error creating addon service:", error);
      res.status(500).json({ message: "Failed to create addon service" });
    }
  });
  app2.put("/api/addon-services/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!["admin", "portfolio-manager"].includes(user.role)) {
        return res.status(403).json({ message: "Unauthorized: Admin/PM access required" });
      }
      const id = parseInt(req.params.id);
      const updates = req.body;
      const service = await storage.updateAddonService(id, updates);
      res.json(service);
    } catch (error) {
      console.error("Error updating addon service:", error);
      res.status(500).json({ message: "Failed to update addon service" });
    }
  });
  app2.delete("/api/addon-services/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!["admin", "portfolio-manager"].includes(user.role)) {
        return res.status(403).json({ message: "Unauthorized: Admin/PM access required" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deleteAddonService(id);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting addon service:", error);
      res.status(500).json({ message: "Failed to delete addon service" });
    }
  });
  app2.get("/api/addon-services/bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const { propertyId, status, paymentRoute } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (status) filters.status = status;
      if (paymentRoute) filters.paymentRoute = paymentRoute;
      const bookings3 = await storage.getServiceBookings(user.organizationId, filters);
      res.json(bookings3);
    } catch (error) {
      console.error("Error fetching service bookings:", error);
      res.status(500).json({ message: "Failed to fetch service bookings" });
    }
  });
  app2.get("/api/addon-services/bookings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const booking = await storage.getServiceBooking(id);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error fetching service booking:", error);
      res.status(500).json({ message: "Failed to fetch service booking" });
    }
  });
  app2.post("/api/addon-services/bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const bookingData = {
        ...req.body,
        organizationId: user.organizationId,
        createdBy: user.id
      };
      const booking = await storage.createServiceBooking(bookingData);
      res.json(booking);
    } catch (error) {
      console.error("Error creating service booking:", error);
      res.status(500).json({ message: "Failed to create service booking" });
    }
  });
  app2.put("/api/addon-services/bookings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const id = parseInt(req.params.id);
      const updates = { ...req.body, updatedBy: user.id };
      const booking = await storage.updateServiceBooking(id, updates);
      res.json(booking);
    } catch (error) {
      console.error("Error updating service booking:", error);
      res.status(500).json({ message: "Failed to update service booking" });
    }
  });
  app2.delete("/api/addon-services/bookings/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!["admin", "portfolio-manager"].includes(user.role)) {
        return res.status(403).json({ message: "Unauthorized: Admin/PM access required" });
      }
      const id = parseInt(req.params.id);
      const success = await storage.deleteServiceBooking(id);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting service booking:", error);
      res.status(500).json({ message: "Failed to delete service booking" });
    }
  });
  app2.get("/api/addon-services/pricing/:propertyId", isDemoAuthenticated, async (req, res) => {
    try {
      const propertyId = parseInt(req.params.propertyId);
      const { serviceId } = req.query;
      const pricing = await storage.getPropertyServicePricing(
        propertyId,
        serviceId ? parseInt(serviceId) : void 0
      );
      res.json(pricing);
    } catch (error) {
      console.error("Error fetching property service pricing:", error);
      res.status(500).json({ message: "Failed to fetch property service pricing" });
    }
  });
  app2.post("/api/addon-services/pricing", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!["admin", "portfolio-manager"].includes(user.role)) {
        return res.status(403).json({ message: "Unauthorized: Admin/PM access required" });
      }
      const pricingData = { ...req.body, organizationId: user.organizationId };
      const pricing = await storage.createPropertyServicePricing(pricingData);
      res.json(pricing);
    } catch (error) {
      console.error("Error creating property service pricing:", error);
      res.status(500).json({ message: "Failed to create property service pricing" });
    }
  });
  app2.get("/api/addon-services/availability/:serviceId", isDemoAuthenticated, async (req, res) => {
    try {
      const serviceId = parseInt(req.params.serviceId);
      const availability = await storage.getServiceAvailability(serviceId);
      res.json(availability);
    } catch (error) {
      console.error("Error fetching service availability:", error);
      res.status(500).json({ message: "Failed to fetch service availability" });
    }
  });
  app2.post("/api/addon-services/availability", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!["admin", "portfolio-manager"].includes(user.role)) {
        return res.status(403).json({ message: "Unauthorized: Admin/PM access required" });
      }
      const availabilityData = { ...req.body, organizationId: user.organizationId };
      const availability = await storage.createServiceAvailability(availabilityData);
      res.json(availability);
    } catch (error) {
      console.error("Error creating service availability:", error);
      res.status(500).json({ message: "Failed to create service availability" });
    }
  });
  app2.post("/api/staff/clock-in", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (role !== "staff") {
        return res.status(403).json({ message: "Staff access required" });
      }
      const activeClock = await storage.getActiveClock(organizationId2, userId);
      if (activeClock) {
        return res.status(400).json({ message: "Already clocked in" });
      }
      const clockData = {
        organizationId: organizationId2,
        userId,
        clockInTime: /* @__PURE__ */ new Date(),
        clockType: req.body.clockType || "workday",
        propertyId: req.body.propertyId ? parseInt(req.body.propertyId) : null,
        taskId: req.body.taskId ? parseInt(req.body.taskId) : null,
        clockInNotes: req.body.clockInNotes,
        isEmergencyVisit: req.body.isEmergencyVisit || false,
        isAfterHours: req.body.isAfterHours || false,
        gpsLocation: req.body.gpsLocation
      };
      const clock = await storage.clockIn(clockData);
      await storage.createStaffClockAuditLog({
        organizationId: organizationId2,
        actionType: "clock_in",
        performedBy: userId,
        affectedUserId: userId,
        clockRecordId: clock.id,
        actionDetails: JSON.stringify({
          clockType: clockData.clockType,
          isEmergency: clockData.isEmergencyVisit,
          isAfterHours: clockData.isAfterHours
        }),
        ipAddress: req.ip,
        userAgent: req.get("User-Agent")
      });
      res.json(clock);
    } catch (error) {
      console.error("Error clocking in:", error);
      res.status(500).json({ message: "Failed to clock in" });
    }
  });
  app2.post("/api/staff/clock-out", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (role !== "staff") {
        return res.status(403).json({ message: "Staff access required" });
      }
      const { clockOutNotes } = req.body;
      const clock = await storage.clockOut(organizationId2, userId, clockOutNotes);
      if (!clock) {
        return res.status(400).json({ message: "No active clock session found" });
      }
      await storage.createStaffClockAuditLog({
        organizationId: organizationId2,
        actionType: "clock_out",
        performedBy: userId,
        affectedUserId: userId,
        clockRecordId: clock.id,
        actionDetails: JSON.stringify({
          duration: clock.clockOutTime && clock.clockInTime ? (new Date(clock.clockOutTime).getTime() - new Date(clock.clockInTime).getTime()) / (1e3 * 60 * 60) : 0,
          notes: clockOutNotes
        }),
        ipAddress: req.ip,
        userAgent: req.get("User-Agent")
      });
      res.json(clock);
    } catch (error) {
      console.error("Error clocking out:", error);
      res.status(500).json({ message: "Failed to clock out" });
    }
  });
  app2.get("/api/staff/active-clock", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (role !== "staff") {
        return res.status(403).json({ message: "Staff access required" });
      }
      const activeClock = await storage.getActiveClock(organizationId2, userId);
      res.json(activeClock || null);
    } catch (error) {
      console.error("Error fetching active clock:", error);
      res.status(500).json({ message: "Failed to fetch active clock" });
    }
  });
  app2.get("/api/staff/clock-history", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (!["staff", "admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { startDate, endDate, clockType, targetUserId } = req.query;
      const filterUserId = role === "staff" ? userId : targetUserId || userId;
      const history = await storage.getStaffClockHistory(organizationId2, {
        userId: filterUserId,
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0,
        clockType
      });
      res.json(history);
    } catch (error) {
      console.error("Error fetching clock history:", error);
      res.status(500).json({ message: "Failed to fetch clock history" });
    }
  });
  app2.get("/api/staff/clock-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const settings = await storage.getStaffClockSettings(organizationId2);
      res.json(settings || {});
    } catch (error) {
      console.error("Error fetching clock settings:", error);
      res.status(500).json({ message: "Failed to fetch clock settings" });
    }
  });
  app2.put("/api/staff/clock-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const settings = await storage.updateStaffClockSettings(organizationId2, req.body);
      await storage.createStaffClockAuditLog({
        organizationId: organizationId2,
        actionType: "settings_update",
        performedBy: userId,
        affectedUserId: "system",
        actionDetails: JSON.stringify(req.body),
        ipAddress: req.ip,
        userAgent: req.get("User-Agent")
      });
      res.json(settings);
    } catch (error) {
      console.error("Error updating clock settings:", error);
      res.status(500).json({ message: "Failed to update clock settings" });
    }
  });
  app2.get("/api/staff/time-summaries", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (!["staff", "admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { periodType, periodStart, periodEnd, targetUserId } = req.query;
      const filterUserId = role === "staff" ? userId : targetUserId || userId;
      const summaries = await storage.getStaffTimeSummaries(organizationId2, {
        userId: filterUserId,
        periodType,
        periodStart: periodStart ? new Date(periodStart) : void 0,
        periodEnd: periodEnd ? new Date(periodEnd) : void 0
      });
      res.json(summaries);
    } catch (error) {
      console.error("Error fetching time summaries:", error);
      res.status(500).json({ message: "Failed to fetch time summaries" });
    }
  });
  app2.get("/api/staff/overtime-calculation", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: userId } = req.user;
      if (!["staff", "admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { startDate, endDate, targetUserId } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "Start date and end date are required" });
      }
      const filterUserId = role === "staff" ? userId : targetUserId || userId;
      const calculation = await storage.calculateOvertimeForPeriod(
        organizationId2,
        filterUserId,
        new Date(startDate),
        new Date(endDate)
      );
      res.json(calculation);
    } catch (error) {
      console.error("Error calculating overtime:", error);
      res.status(500).json({ message: "Failed to calculate overtime" });
    }
  });
  app2.get("/api/staff/time-report", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const { startDate, endDate, format, userId: targetUserId } = req.query;
      const report = await storage.generateStaffTimeReport(organizationId2, {
        userId: targetUserId,
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0,
        format
      });
      res.json(report);
    } catch (error) {
      console.error("Error generating time report:", error);
      res.status(500).json({ message: "Failed to generate time report" });
    }
  });
  app2.get("/api/staff/time-report/export", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Admin or Portfolio Manager access required" });
      }
      const { startDate, endDate, format, userId: targetUserId } = req.query;
      const report = await storage.generateStaffTimeReport(organizationId2, {
        userId: targetUserId,
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0,
        format
      });
      let csvContent = "User ID,User Name,Regular Hours,Overtime Hours,Total Hours,Emergency Visits,After Hours Total,Estimated Pay\n";
      report.staffReports.forEach((staff) => {
        csvContent += `${staff.userId},${staff.userName},${staff.regularHours},${staff.overtimeHours},${staff.totalHours},${staff.emergencyVisits},${staff.afterHoursTotal},${staff.estimatedPay}
`;
      });
      csvContent += `
Totals:,,${report.totalRegularHours},${report.totalOvertimeHours},,,,${report.totalEstimatedPay}
`;
      res.setHeader("Content-Type", "text/csv");
      res.setHeader("Content-Disposition", `attachment; filename="staff-time-report-${report.reportPeriod}.csv"`);
      res.send(csvContent);
    } catch (error) {
      console.error("Error exporting time report:", error);
      res.status(500).json({ message: "Failed to export time report" });
    }
  });
  app2.get("/api/staff/clock-audit-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { actionType, performedBy, affectedUserId, startDate, endDate } = req.query;
      const logs = await storage.getStaffClockAuditLogs(organizationId2, {
        actionType,
        performedBy,
        affectedUserId,
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0
      });
      res.json(logs);
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });
  app2.post("/api/staff/manual-override", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role, id: adminUserId } = req.user;
      if (role !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { userId, action, clockData, reason } = req.body;
      let result;
      if (action === "force_clock_out") {
        result = await storage.clockOut(organizationId2, userId, `Admin override: ${reason}`);
      } else if (action === "manual_clock_in") {
        result = await storage.clockIn({
          organizationId: organizationId2,
          userId,
          clockInTime: new Date(clockData.clockInTime),
          clockType: clockData.clockType || "workday",
          propertyId: clockData.propertyId,
          taskId: clockData.taskId,
          clockInNotes: `Admin manual entry: ${reason}`,
          isEmergencyVisit: clockData.isEmergencyVisit || false,
          isAfterHours: clockData.isAfterHours || false
        });
      }
      await storage.createStaffClockAuditLog({
        organizationId: organizationId2,
        actionType: "manual_override",
        performedBy: adminUserId,
        affectedUserId: userId,
        clockRecordId: result?.id,
        actionDetails: JSON.stringify({
          action,
          reason,
          originalData: clockData
        }),
        ipAddress: req.ip,
        userAgent: req.get("User-Agent")
      });
      res.json({ success: true, result, message: `Override completed: ${action}` });
    } catch (error) {
      console.error("Error performing manual override:", error);
      res.status(500).json({ message: "Failed to perform manual override" });
    }
  });
  app2.get("/api/maintenance-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const { propertyId, status, submittedBy } = req.query;
      const suggestions = await storage.getMaintenanceSuggestions(organizationId2, {
        propertyId: propertyId ? parseInt(propertyId) : void 0,
        status,
        submittedBy
      });
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching maintenance suggestions:", error);
      res.status(500).json({ message: "Failed to fetch maintenance suggestions" });
    }
  });
  app2.get("/api/maintenance-suggestions/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const suggestion = await storage.getMaintenanceSuggestion(id);
      if (!suggestion) {
        return res.status(404).json({ message: "Maintenance suggestion not found" });
      }
      res.json(suggestion);
    } catch (error) {
      console.error("Error fetching maintenance suggestion:", error);
      res.status(500).json({ message: "Failed to fetch maintenance suggestion" });
    }
  });
  app2.post("/api/maintenance-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const user = req.user;
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Only admin and portfolio managers can create maintenance suggestions" });
      }
      const suggestion = await storage.createMaintenanceSuggestion({
        organizationId: organizationId2,
        submittedBy: user.id,
        submittedByRole: user.role,
        ...req.body
      });
      await storage.createMaintenanceTimelineEntry({
        organizationId: organizationId2,
        suggestionId: suggestion.id,
        actionType: "created",
        actionBy: user.id,
        actionByRole: user.role,
        description: `Maintenance suggestion created: ${req.body.title}`
      });
      res.json(suggestion);
    } catch (error) {
      console.error("Error creating maintenance suggestion:", error);
      res.status(500).json({ message: "Failed to create maintenance suggestion" });
    }
  });
  app2.put("/api/maintenance-suggestions/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const user = req.user;
      if (user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Only admin and portfolio managers can update maintenance suggestions" });
      }
      const updated = await storage.updateMaintenanceSuggestion(id, req.body);
      if (!updated) {
        return res.status(404).json({ message: "Maintenance suggestion not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating maintenance suggestion:", error);
      res.status(500).json({ message: "Failed to update maintenance suggestion" });
    }
  });
  app2.delete("/api/maintenance-suggestions/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const user = req.user;
      if (user.role !== "admin") {
        return res.status(403).json({ message: "Only admin can delete maintenance suggestions" });
      }
      const success = await storage.deleteMaintenanceSuggestion(id);
      res.json({ success });
    } catch (error) {
      console.error("Error deleting maintenance suggestion:", error);
      res.status(500).json({ message: "Failed to delete maintenance suggestion" });
    }
  });
  app2.post("/api/maintenance-suggestions/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const user = req.user;
      const { comments } = req.body;
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Only owners can approve maintenance suggestions" });
      }
      const approved = await storage.approveMaintenanceSuggestion(id, user.id, comments);
      if (!approved) {
        return res.status(404).json({ message: "Maintenance suggestion not found" });
      }
      await storage.createMaintenanceTimelineEntry({
        organizationId: "demo-org",
        suggestionId: id,
        actionType: "approved",
        actionBy: user.id,
        actionByRole: user.role,
        description: `Owner approved maintenance suggestion${comments ? ": " + comments : ""}`
      });
      res.json(approved);
    } catch (error) {
      console.error("Error approving maintenance suggestion:", error);
      res.status(500).json({ message: "Failed to approve maintenance suggestion" });
    }
  });
  app2.post("/api/maintenance-suggestions/:id/decline", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const user = req.user;
      const { comments } = req.body;
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Only owners can decline maintenance suggestions" });
      }
      const declined = await storage.declineMaintenanceSuggestion(id, user.id, comments);
      if (!declined) {
        return res.status(404).json({ message: "Maintenance suggestion not found" });
      }
      await storage.createMaintenanceTimelineEntry({
        organizationId: "demo-org",
        suggestionId: id,
        actionType: "declined",
        actionBy: user.id,
        actionByRole: user.role,
        description: `Owner declined maintenance suggestion${comments ? ": " + comments : ""}`
      });
      res.json(declined);
    } catch (error) {
      console.error("Error declining maintenance suggestion:", error);
      res.status(500).json({ message: "Failed to decline maintenance suggestion" });
    }
  });
  app2.get("/api/owner/maintenance-suggestions", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const user = req.user;
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Owner access required" });
      }
      const suggestions = await storage.getOwnerMaintenanceSuggestions(organizationId2, user.id);
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching owner maintenance suggestions:", error);
      res.status(500).json({ message: "Failed to fetch owner maintenance suggestions" });
    }
  });
  app2.get("/api/owner/pending-approvals", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const user = req.user;
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Owner access required" });
      }
      const pending = await storage.getPendingOwnerApprovals(organizationId2, user.id);
      res.json(pending);
    } catch (error) {
      console.error("Error fetching pending approvals:", error);
      res.status(500).json({ message: "Failed to fetch pending approvals" });
    }
  });
  app2.get("/api/maintenance-approval-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const { suggestionId } = req.query;
      const logs = await storage.getMaintenanceApprovalLogs(
        organizationId2,
        suggestionId ? parseInt(suggestionId) : void 0
      );
      res.json(logs);
    } catch (error) {
      console.error("Error fetching approval logs:", error);
      res.status(500).json({ message: "Failed to fetch approval logs" });
    }
  });
  app2.get("/api/maintenance-suggestion-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const settings = await storage.getMaintenanceSuggestionSettings(organizationId2);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching settings:", error);
      res.status(500).json({ message: "Failed to fetch settings" });
    }
  });
  app2.post("/api/maintenance-suggestion-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "demo-org";
      const user = req.user;
      if (user.role !== "admin") {
        return res.status(403).json({ message: "Only admin can update settings" });
      }
      const settings = await storage.updateMaintenanceSuggestionSettings(organizationId2, req.body);
      res.json(settings);
    } catch (error) {
      console.error("Error updating settings:", error);
      res.status(500).json({ message: "Failed to update settings" });
    }
  });
  app2.get("/api/addon-service-categories", isDemoAuthenticated, async (req, res) => {
    try {
      const categories = await storage.getAddonServiceCategories("default");
      res.json(categories);
    } catch (error) {
      console.error("Error fetching service categories:", error);
      res.status(500).json({ message: "Failed to fetch service categories" });
    }
  });
  app2.post("/api/addon-service-categories", isDemoAuthenticated, async (req, res) => {
    try {
      const category = await storage.createAddonServiceCategory({
        ...req.body,
        organizationId: "default"
      });
      res.json(category);
    } catch (error) {
      console.error("Error creating service category:", error);
      res.status(500).json({ message: "Failed to create service category" });
    }
  });
  app2.get("/api/addon-service-catalog", isDemoAuthenticated, async (req, res) => {
    try {
      const { category } = req.query;
      const filters = {};
      if (category && category !== "all") {
        filters.category = category;
      }
      const services = await storage.getAddonServiceCatalog("default", filters);
      res.json(services);
    } catch (error) {
      console.error("Error fetching service catalog:", error);
      res.status(500).json({ message: "Failed to fetch service catalog" });
    }
  });
  app2.post("/api/addon-service-catalog", isDemoAuthenticated, async (req, res) => {
    try {
      const service = await storage.createAddonServiceCatalogItem({
        ...req.body,
        organizationId: "default"
      });
      res.json(service);
    } catch (error) {
      console.error("Error creating service:", error);
      res.status(500).json({ message: "Failed to create service" });
    }
  });
  app2.put("/api/addon-service-catalog/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const service = await storage.updateAddonServiceCatalogItem(id, req.body);
      if (!service) {
        return res.status(404).json({ message: "Service not found" });
      }
      res.json(service);
    } catch (error) {
      console.error("Error updating service:", error);
      res.status(500).json({ message: "Failed to update service" });
    }
  });
  app2.get("/api/addon-service-bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const { status, billingRule, category, dateFrom, dateTo, propertyId } = req.query;
      const filters = {};
      if (status && status !== "all") filters.status = status;
      if (billingRule && billingRule !== "all") filters.billingRule = billingRule;
      if (category && category !== "all") filters.category = category;
      if (dateFrom) filters.dateFrom = dateFrom;
      if (dateTo) filters.dateTo = dateTo;
      if (propertyId) filters.propertyId = parseInt(propertyId);
      const bookings3 = await storage.getAddonServiceBookings("default", filters);
      res.json(bookings3);
    } catch (error) {
      console.error("Error fetching service bookings:", error);
      res.status(500).json({ message: "Failed to fetch service bookings" });
    }
  });
  app2.post("/api/addon-service-bookings", isDemoAuthenticated, async (req, res) => {
    try {
      const booking = await storage.createAddonServiceBooking({
        ...req.body,
        organizationId: "default"
      });
      if (booking.commissionAmount && parseFloat(booking.commissionAmount) > 0) {
        await storage.createAddonServiceCommission({
          organizationId: "default",
          bookingId: booking.id,
          serviceId: booking.serviceId,
          category: req.body.category || "general",
          staffId: booking.bookedBy,
          commissionAmount: booking.commissionAmount,
          commissionRate: req.body.commissionRate || "15.00",
          paymentStatus: "pending",
          notes: `Commission for booking #${booking.id}`
        });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error creating service booking:", error);
      res.status(500).json({ message: "Failed to create service booking" });
    }
  });
  app2.put("/api/addon-service-bookings/:id/confirm", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const booking = await storage.confirmAddonServiceBooking(id, req.body.confirmedBy);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error confirming booking:", error);
      res.status(500).json({ message: "Failed to confirm booking" });
    }
  });
  app2.put("/api/addon-service-bookings/:id/complete", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const booking = await storage.completeAddonServiceBooking(id, new Date(req.body.completedAt), req.body.notes);
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error completing booking:", error);
      res.status(500).json({ message: "Failed to complete booking" });
    }
  });
  app2.get("/api/addon-service-commissions", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId, category, paymentStatus, dateFrom, dateTo } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (category) filters.category = category;
      if (paymentStatus) filters.paymentStatus = paymentStatus;
      if (dateFrom) filters.dateFrom = dateFrom;
      if (dateTo) filters.dateTo = dateTo;
      const commissions = await storage.getAddonServiceCommissions("default", filters);
      res.json(commissions);
    } catch (error) {
      console.error("Error fetching service commissions:", error);
      res.status(500).json({ message: "Failed to fetch service commissions" });
    }
  });
  app2.put("/api/addon-service-commissions/:id/pay", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const commission = await storage.processCommissionPayment(id, /* @__PURE__ */ new Date(), req.body.paymentMethod || "bank_transfer");
      if (!commission) {
        return res.status(404).json({ message: "Commission not found" });
      }
      res.json(commission);
    } catch (error) {
      console.error("Error processing commission payment:", error);
      res.status(500).json({ message: "Failed to process commission payment" });
    }
  });
  app2.get("/api/addon-service-reports", isDemoAuthenticated, async (req, res) => {
    try {
      const { reportMonth, category } = req.query;
      const filters = {};
      if (reportMonth) filters.reportMonth = reportMonth;
      if (category) filters.category = category;
      const reports2 = await storage.getAddonServiceReports("default", filters);
      res.json(reports2);
    } catch (error) {
      console.error("Error fetching service reports:", error);
      res.status(500).json({ message: "Failed to fetch service reports" });
    }
  });
  app2.post("/api/addon-service-reports/generate", isDemoAuthenticated, async (req, res) => {
    try {
      const { reportMonth } = req.body;
      const reports2 = await storage.generateMonthlyServiceReport("default", reportMonth);
      res.json(reports2);
    } catch (error) {
      console.error("Error generating service report:", error);
      res.status(500).json({ message: "Failed to generate service report" });
    }
  });
  app2.get("/api/addon-service-summary", isDemoAuthenticated, async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      const summary = await storage.getServiceCategorySummary(
        "default",
        startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
        endDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
      );
      res.json(summary);
    } catch (error) {
      console.error("Error fetching service summary:", error);
      res.status(500).json({ message: "Failed to fetch service summary" });
    }
  });
  app2.get("/api/addon-billing-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const { category, isActive } = req.query;
      const filters = {};
      if (category) filters.category = category;
      if (isActive !== void 0) filters.isActive = isActive === "true";
      const rules = await storage.getAddonBillingRules("default", filters);
      res.json(rules);
    } catch (error) {
      console.error("Error fetching billing rules:", error);
      res.status(500).json({ message: "Failed to fetch billing rules" });
    }
  });
  app2.post("/api/addon-billing-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const rule = await storage.createAddonBillingRule({
        ...req.body,
        organizationId: "default"
      });
      res.json(rule);
    } catch (error) {
      console.error("Error creating billing rule:", error);
      res.status(500).json({ message: "Failed to create billing rule" });
    }
  });
  app2.put("/api/addon-billing-rules/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const rule = await storage.updateAddonBillingRule(id, req.body);
      if (!rule) {
        return res.status(404).json({ message: "Billing rule not found" });
      }
      res.json(rule);
    } catch (error) {
      console.error("Error updating billing rule:", error);
      res.status(500).json({ message: "Failed to update billing rule" });
    }
  });
  app2.get("/api/staff-overtime-sessions", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId, status, dateFrom, dateTo, isEmergency, isAfterHours } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (status) filters.status = status;
      if (dateFrom) filters.dateFrom = dateFrom;
      if (dateTo) filters.dateTo = dateTo;
      if (isEmergency !== void 0) filters.isEmergency = isEmergency === "true";
      if (isAfterHours !== void 0) filters.isAfterHours = isAfterHours === "true";
      const sessions2 = await storage.getStaffOvertimeSessions("default", filters);
      res.json(sessions2);
    } catch (error) {
      console.error("Error fetching overtime sessions:", error);
      res.status(500).json({ message: "Failed to fetch overtime sessions" });
    }
  });
  app2.post("/api/staff-overtime-sessions", isDemoAuthenticated, async (req, res) => {
    try {
      const session3 = await storage.createStaffOvertimeSession(req.body);
      res.json(session3);
    } catch (error) {
      console.error("Error creating overtime session:", error);
      res.status(500).json({ message: "Failed to create overtime session" });
    }
  });
  app2.put("/api/staff-overtime-sessions/:id/clock-out", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const session3 = await storage.updateStaffOvertimeSession(id, {
        clockOutTime: new Date(req.body.clockOutTime)
      });
      if (!session3) {
        return res.status(404).json({ message: "Overtime session not found" });
      }
      res.json(session3);
    } catch (error) {
      console.error("Error clocking out:", error);
      res.status(500).json({ message: "Failed to clock out" });
    }
  });
  app2.put("/api/staff-overtime-sessions/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { approvedBy, compensationType, compensationAmount, adminNotes } = req.body;
      const session3 = await storage.approveOvertimeSession(
        id,
        approvedBy,
        compensationType,
        compensationAmount,
        adminNotes
      );
      if (!session3) {
        return res.status(404).json({ message: "Overtime session not found" });
      }
      res.json(session3);
    } catch (error) {
      console.error("Error approving overtime session:", error);
      res.status(500).json({ message: "Failed to approve overtime session" });
    }
  });
  app2.get("/api/staff-advance-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId, status, dateFrom, dateTo, urgencyLevel } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (status) filters.status = status;
      if (dateFrom) filters.dateFrom = dateFrom;
      if (dateTo) filters.dateTo = dateTo;
      if (urgencyLevel) filters.urgencyLevel = urgencyLevel;
      const requests = await storage.getStaffAdvanceRequests("default", filters);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching advance requests:", error);
      res.status(500).json({ message: "Failed to fetch advance requests" });
    }
  });
  app2.post("/api/staff-advance-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const request = await storage.createStaffAdvanceRequest(req.body);
      res.json(request);
    } catch (error) {
      console.error("Error creating advance request:", error);
      res.status(500).json({ message: "Failed to create advance request" });
    }
  });
  app2.put("/api/staff-advance-requests/:id/approve", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { approvedBy, paymentMethod, deductionStartMonth, adminNotes } = req.body;
      const request = await storage.approveAdvanceRequest(
        id,
        approvedBy,
        paymentMethod,
        deductionStartMonth,
        adminNotes
      );
      if (!request) {
        return res.status(404).json({ message: "Advance request not found" });
      }
      res.json(request);
    } catch (error) {
      console.error("Error approving advance request:", error);
      res.status(500).json({ message: "Failed to approve advance request" });
    }
  });
  app2.put("/api/staff-advance-requests/:id/reject", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { reviewedBy, rejectionReason } = req.body;
      const request = await storage.rejectAdvanceRequest(id, reviewedBy, rejectionReason);
      if (!request) {
        return res.status(404).json({ message: "Advance request not found" });
      }
      res.json(request);
    } catch (error) {
      console.error("Error rejecting advance request:", error);
      res.status(500).json({ message: "Failed to reject advance request" });
    }
  });
  app2.get("/api/staff-salary-deductions", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId, deductionMonth, deductionType } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (deductionMonth) filters.deductionMonth = deductionMonth;
      if (deductionType) filters.deductionType = deductionType;
      const deductions = await storage.getStaffSalaryDeductions("default", filters);
      res.json(deductions);
    } catch (error) {
      console.error("Error fetching salary deductions:", error);
      res.status(500).json({ message: "Failed to fetch salary deductions" });
    }
  });
  app2.post("/api/staff-salary-deductions", isDemoAuthenticated, async (req, res) => {
    try {
      const deduction = await storage.createStaffSalaryDeduction(req.body);
      res.json(deduction);
    } catch (error) {
      console.error("Error creating salary deduction:", error);
      res.status(500).json({ message: "Failed to create salary deduction" });
    }
  });
  app2.get("/api/staff-compensation-time", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId, isExpired } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (isExpired !== void 0) filters.isExpired = isExpired === "true";
      const compensationTime = await storage.getStaffCompensationTime("default", filters);
      res.json(compensationTime);
    } catch (error) {
      console.error("Error fetching compensation time:", error);
      res.status(500).json({ message: "Failed to fetch compensation time" });
    }
  });
  app2.post("/api/staff-compensation-time", isDemoAuthenticated, async (req, res) => {
    try {
      const compensationTime = await storage.createStaffCompensationTime(req.body);
      res.json(compensationTime);
    } catch (error) {
      console.error("Error creating compensation time:", error);
      res.status(500).json({ message: "Failed to create compensation time" });
    }
  });
  app2.get("/api/staff-monthly-summary", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId, month } = req.query;
      if (!staffId || !month) {
        return res.status(400).json({ message: "staffId and month are required" });
      }
      const summary = await storage.getStaffMonthlySummary("default", staffId, month);
      if (!summary) {
        return res.status(404).json({ message: "Monthly summary not found" });
      }
      res.json(summary);
    } catch (error) {
      console.error("Error fetching monthly summary:", error);
      res.status(500).json({ message: "Failed to fetch monthly summary" });
    }
  });
  app2.post("/api/staff-monthly-summary", isDemoAuthenticated, async (req, res) => {
    try {
      const summary = await storage.createStaffMonthlySummary(req.body);
      res.json(summary);
    } catch (error) {
      console.error("Error creating monthly summary:", error);
      res.status(500).json({ message: "Failed to create monthly summary" });
    }
  });
  app2.get("/api/staff-notification-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId } = req.query;
      if (!staffId) {
        return res.status(400).json({ message: "staffId is required" });
      }
      const settings = await storage.getStaffNotificationSettings("default", staffId);
      if (!settings) {
        return res.status(404).json({ message: "Notification settings not found" });
      }
      res.json(settings);
    } catch (error) {
      console.error("Error fetching notification settings:", error);
      res.status(500).json({ message: "Failed to fetch notification settings" });
    }
  });
  app2.put("/api/staff-notification-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId } = req.body;
      if (!staffId) {
        return res.status(400).json({ message: "staffId is required" });
      }
      const settings = await storage.updateStaffNotificationSettings("default", staffId, req.body);
      res.json(settings);
    } catch (error) {
      console.error("Error updating notification settings:", error);
      res.status(500).json({ message: "Failed to update notification settings" });
    }
  });
  app2.post("/api/staff-monthly-report", isDemoAuthenticated, async (req, res) => {
    try {
      const { staffId, month } = req.body;
      if (!staffId || !month) {
        return res.status(400).json({ message: "staffId and month are required" });
      }
      const result = await storage.generateStaffMonthlyReport("default", staffId, month);
      res.json(result);
    } catch (error) {
      console.error("Error generating monthly report:", error);
      res.status(500).json({ message: "Failed to generate monthly report" });
    }
  });
  app2.get("/api/staff-profiles", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user || user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const { department, isActive } = req.query;
      const filters = {};
      if (department) filters.department = department;
      if (isActive !== void 0) filters.isActive = isActive === "true";
      const profiles = await storage.getStaffProfiles(organizationId2, filters);
      res.json(profiles);
    } catch (error) {
      console.error("Error fetching staff profiles:", error);
      res.status(500).json({ message: "Failed to fetch staff profiles" });
    }
  });
  app2.get("/api/staff-profiles/:staffId", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const { staffId } = req.params;
      if (user.role === "staff" && user.id !== staffId) {
        return res.status(403).json({ message: "Access denied" });
      }
      const profile = await storage.getStaffProfile(organizationId2, staffId);
      if (!profile) {
        return res.status(404).json({ message: "Staff profile not found" });
      }
      res.json(profile);
    } catch (error) {
      console.error("Error fetching staff profile:", error);
      res.status(500).json({ message: "Failed to fetch staff profile" });
    }
  });
  app2.post("/api/staff-profiles", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user || user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const profileData = {
        ...req.body,
        organizationId: organizationId2,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      const profile = await storage.createStaffProfile(profileData);
      res.status(201).json(profile);
    } catch (error) {
      console.error("Error creating staff profile:", error);
      res.status(500).json({ message: "Failed to create staff profile" });
    }
  });
  app2.get("/api/payroll-records", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const { staffId, payrollPeriod, status } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (payrollPeriod) filters.payrollPeriod = payrollPeriod;
      if (status) filters.status = status;
      if (user.role === "staff") {
        filters.staffId = user.id;
      }
      const records = await storage.getMonthlyPayrollRecords(organizationId2, filters);
      res.json(records);
    } catch (error) {
      console.error("Error fetching payroll records:", error);
      res.status(500).json({ message: "Failed to fetch payroll records" });
    }
  });
  app2.post("/api/payroll-records", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user || user.role !== "admin" && user.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Access denied" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const recordData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: user.id,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      const record = await storage.createMonthlyPayrollRecord(recordData);
      res.status(201).json(record);
    } catch (error) {
      console.error("Error creating payroll record:", error);
      res.status(500).json({ message: "Failed to create payroll record" });
    }
  });
  app2.get("/api/task-performance", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const { staffId, taskId, propertyId } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (taskId) filters.taskId = parseInt(taskId);
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (user.role === "staff") {
        filters.staffId = user.id;
      }
      const logs = await storage.getTaskPerformanceLogs(organizationId2, filters);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching task performance logs:", error);
      res.status(500).json({ message: "Failed to fetch task performance logs" });
    }
  });
  app2.get("/api/attendance", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const { staffId, workDate, status } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (workDate) filters.workDate = workDate;
      if (status) filters.status = status;
      if (user.role === "staff") {
        filters.staffId = user.id;
      }
      const records = await storage.getAttendanceRecords(organizationId2, filters);
      res.json(records);
    } catch (error) {
      console.error("Error fetching attendance records:", error);
      res.status(500).json({ message: "Failed to fetch attendance records" });
    }
  });
  app2.post("/api/attendance", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const recordData = {
        ...req.body,
        organizationId: organizationId2,
        staffId: user.id,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      const record = await storage.createAttendanceRecord(recordData);
      res.status(201).json(record);
    } catch (error) {
      console.error("Error creating attendance record:", error);
      res.status(500).json({ message: "Failed to create attendance record" });
    }
  });
  app2.get("/api/leave-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const { staffId, status } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (status) filters.status = status;
      if (user.role === "staff") {
        filters.staffId = user.id;
      }
      const requests = await storage.getLeaveRequests(organizationId2, filters);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching leave requests:", error);
      res.status(500).json({ message: "Failed to fetch leave requests" });
    }
  });
  app2.post("/api/leave-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const requestData = {
        ...req.body,
        organizationId: organizationId2,
        staffId: user.id,
        status: "pending",
        requestedAt: /* @__PURE__ */ new Date(),
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      const request = await storage.createLeaveRequest(requestData);
      res.status(201).json(request);
    } catch (error) {
      console.error("Error creating leave request:", error);
      res.status(500).json({ message: "Failed to create leave request" });
    }
  });
  app2.get("/api/staff-commissions", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const { staffId, payrollPeriod, isPaid } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (payrollPeriod) filters.payrollPeriod = payrollPeriod;
      if (isPaid !== void 0) filters.isPaid = isPaid === "true";
      if (user.role === "staff") {
        filters.staffId = user.id;
      }
      const commissions = await storage.getStaffCommissions(organizationId2, filters);
      res.json(commissions);
    } catch (error) {
      console.error("Error fetching staff commissions:", error);
      res.status(500).json({ message: "Failed to fetch staff commissions" });
    }
  });
  app2.get("/api/pay-slips", isDemoAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const organizationId2 = user.organizationId || "default-org";
      const { staffId, period, status } = req.query;
      const filters = {};
      if (staffId) filters.staffId = staffId;
      if (period) filters.period = period;
      if (status) filters.status = status;
      if (user.role === "staff") {
        filters.staffId = user.id;
      }
      const paySlips2 = await storage.getPaySlips(organizationId2, filters);
      res.json(paySlips2);
    } catch (error) {
      console.error("Error fetching pay slips:", error);
      res.status(500).json({ message: "Failed to fetch pay slips" });
    }
  });
  app2.get("/api/communication/channels", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const channels = await storage.getCommunicationChannels(organizationId2, userId);
      res.json(channels);
    } catch (error) {
      console.error("Error fetching communication channels:", error);
      res.status(500).json({ message: "Failed to fetch channels" });
    }
  });
  app2.post("/api/communication/channels", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { name, description, isPrivate, memberIds } = req.body;
      const channelData = {
        organizationId: organizationId2,
        name,
        description,
        isPrivate: isPrivate || false,
        createdBy: userId
      };
      const channel = await storage.createCommunicationChannel(channelData, memberIds);
      res.status(201).json(channel);
    } catch (error) {
      console.error("Error creating communication channel:", error);
      res.status(500).json({ message: "Failed to create channel" });
    }
  });
  app2.get("/api/communication/channels/:channelId/messages", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const { channelId } = req.params;
      const { limit = 50, offset = 0 } = req.query;
      const messages = await storage.getChannelMessages(organizationId2, parseInt(channelId), userId, parseInt(limit), parseInt(offset));
      res.json(messages);
    } catch (error) {
      console.error("Error fetching channel messages:", error);
      res.status(500).json({ message: "Failed to fetch messages" });
    }
  });
  app2.post("/api/communication/channels/:channelId/messages", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const { channelId } = req.params;
      const { content, messageType, attachmentUrl } = req.body;
      const messageData = {
        organizationId: organizationId2,
        channelId: parseInt(channelId),
        senderId: userId,
        content,
        messageType: messageType || "text",
        attachmentUrl
      };
      const message = await storage.createInternalMessage(messageData);
      res.status(201).json(message);
    } catch (error) {
      console.error("Error sending message:", error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });
  app2.get("/api/communication/owner-pm", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const conversations = await storage.getOwnerPmCommunications(organizationId2, userId, role);
      res.json(conversations);
    } catch (error) {
      console.error("Error fetching owner-PM communications:", error);
      res.status(500).json({ message: "Failed to fetch conversations" });
    }
  });
  app2.post("/api/communication/owner-pm", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { receiverId, subject, message, priority, attachmentUrl } = req.body;
      const communicationData = {
        organizationId: organizationId2,
        senderId: userId,
        receiverId,
        subject,
        message,
        priority: priority || "medium",
        senderType: role,
        receiverType: role === "owner" ? "portfolio-manager" : "owner",
        attachmentUrl
      };
      const communication = await storage.createOwnerPmCommunication(communicationData);
      res.status(201).json(communication);
    } catch (error) {
      console.error("Error sending owner-PM message:", error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });
  app2.get("/api/communication/guest-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { status, priority, propertyId } = req.query;
      const filters = {
        status,
        priority,
        propertyId: propertyId ? parseInt(propertyId) : void 0
      };
      const requests = await storage.getGuestSmartRequests(organizationId2, filters);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching guest smart requests:", error);
      res.status(500).json({ message: "Failed to fetch requests" });
    }
  });
  app2.post("/api/communication/guest-requests", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { guestName, guestEmail, propertyId, requestType, subject, description, priority, urgencyLevel } = req.body;
      const requestData = {
        organizationId: organizationId2,
        guestName,
        guestEmail,
        propertyId,
        requestType,
        subject,
        description,
        priority: priority || "medium",
        urgencyLevel: urgencyLevel || "normal"
      };
      const request = await storage.createGuestSmartRequest(requestData);
      res.status(201).json(request);
    } catch (error) {
      console.error("Error creating guest smart request:", error);
      res.status(500).json({ message: "Failed to create request" });
    }
  });
  app2.put("/api/communication/guest-requests/:requestId", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId, role } = req.user;
      const { requestId } = req.params;
      const { status, response, assignedTo } = req.body;
      if (!["admin", "portfolio-manager", "staff"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const updateData = {
        status,
        response,
        assignedTo,
        processedBy: userId,
        processedAt: /* @__PURE__ */ new Date()
      };
      const request = await storage.updateGuestSmartRequest(organizationId2, parseInt(requestId), updateData);
      res.json(request);
    } catch (error) {
      console.error("Error updating guest smart request:", error);
      res.status(500).json({ message: "Failed to update request" });
    }
  });
  app2.get("/api/communication/config", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const config = await storage.getSmartRequestConfig(organizationId2);
      res.json(config);
    } catch (error) {
      console.error("Error fetching smart request config:", error);
      res.status(500).json({ message: "Failed to fetch configuration" });
    }
  });
  app2.put("/api/communication/config", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { autoResponseEnabled, responseTimeHours, escalationRules, requestCategories } = req.body;
      const configData = {
        organizationId: organizationId2,
        autoResponseEnabled,
        responseTimeHours,
        escalationRules,
        requestCategories
      };
      const config = await storage.updateSmartRequestConfig(configData);
      res.json(config);
    } catch (error) {
      console.error("Error updating smart request config:", error);
      res.status(500).json({ message: "Failed to update configuration" });
    }
  });
  app2.get("/api/communication/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, role } = req.user;
      if (!["admin", "portfolio-manager"].includes(role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { period = "30d" } = req.query;
      const analytics = await storage.getCommunicationAnalytics(organizationId2, period);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching communication analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });
  app2.get("/api/property-access/credentials", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { propertyId } = req.query;
      const credentials = await storage.getPropertyAccessCredentials(
        organizationId2,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(credentials);
    } catch (error) {
      console.error("Error fetching property access credentials:", error);
      res.status(500).json({ message: "Failed to fetch property access credentials" });
    }
  });
  app2.get("/api/property-access/credentials/filtered", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const userRole = req.user?.role || "staff";
      const userId = req.user?.id || "";
      const { propertyId } = req.query;
      const credentials = await storage.getFilteredAccessCredentials(
        organizationId2,
        userRole,
        userId,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(credentials);
    } catch (error) {
      console.error("Error fetching filtered property access credentials:", error);
      res.status(500).json({ message: "Failed to fetch filtered property access credentials" });
    }
  });
  app2.get("/api/property-access/credentials/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const credential = await storage.getPropertyAccessCredential(parseInt(id));
      if (!credential) {
        return res.status(404).json({ message: "Property access credential not found" });
      }
      res.json(credential);
    } catch (error) {
      console.error("Error fetching property access credential:", error);
      res.status(500).json({ message: "Failed to fetch property access credential" });
    }
  });
  app2.post("/api/property-access/credentials", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const userId = req.user?.id || "";
      const credentialData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId,
        updatedBy: userId
      };
      const newCredential = await storage.createPropertyAccessCredential(credentialData);
      await storage.createAccessChangeLog({
        credentialId: newCredential.id,
        changeType: "created",
        changedBy: userId,
        oldValue: null,
        newValue: JSON.stringify(credentialData),
        changeReason: "Initial creation"
      });
      res.status(201).json(newCredential);
    } catch (error) {
      console.error("Error creating property access credential:", error);
      res.status(500).json({ message: "Failed to create property access credential" });
    }
  });
  app2.put("/api/property-access/credentials/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = req.user?.id || "";
      const oldCredential = await storage.getPropertyAccessCredential(parseInt(id));
      if (!oldCredential) {
        return res.status(404).json({ message: "Property access credential not found" });
      }
      const updatedCredential = await storage.updatePropertyAccessCredential(
        parseInt(id),
        { ...req.body, updatedBy: userId }
      );
      if (!updatedCredential) {
        return res.status(404).json({ message: "Property access credential not found" });
      }
      await storage.createAccessChangeLog({
        credentialId: parseInt(id),
        changeType: "updated",
        changedBy: userId,
        oldValue: JSON.stringify(oldCredential),
        newValue: JSON.stringify(updatedCredential),
        changeReason: req.body.changeReason || "Manual update"
      });
      res.json(updatedCredential);
    } catch (error) {
      console.error("Error updating property access credential:", error);
      res.status(500).json({ message: "Failed to update property access credential" });
    }
  });
  app2.delete("/api/property-access/credentials/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = req.user?.id || "";
      const credential = await storage.getPropertyAccessCredential(parseInt(id));
      if (!credential) {
        return res.status(404).json({ message: "Property access credential not found" });
      }
      const deleted = await storage.deletePropertyAccessCredential(parseInt(id));
      if (!deleted) {
        return res.status(404).json({ message: "Property access credential not found" });
      }
      await storage.createAccessChangeLog({
        credentialId: parseInt(id),
        changeType: "deleted",
        changedBy: userId,
        oldValue: JSON.stringify(credential),
        newValue: null,
        changeReason: "Manual deletion"
      });
      res.json({ message: "Property access credential deleted successfully" });
    } catch (error) {
      console.error("Error deleting property access credential:", error);
      res.status(500).json({ message: "Failed to delete property access credential" });
    }
  });
  app2.get("/api/property-access/credentials/:id/photos", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const photos = await storage.getPropertyAccessPhotos(parseInt(id));
      res.json(photos);
    } catch (error) {
      console.error("Error fetching property access photos:", error);
      res.status(500).json({ message: "Failed to fetch property access photos" });
    }
  });
  app2.post("/api/property-access/credentials/:id/photos", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = req.user?.id || "";
      const photoData = {
        ...req.body,
        credentialId: parseInt(id),
        uploadedBy: userId
      };
      const newPhoto = await storage.createPropertyAccessPhoto(photoData);
      res.status(201).json(newPhoto);
    } catch (error) {
      console.error("Error creating property access photo:", error);
      res.status(500).json({ message: "Failed to create property access photo" });
    }
  });
  app2.delete("/api/property-access/photos/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deletePropertyAccessPhoto(parseInt(id));
      if (!deleted) {
        return res.status(404).json({ message: "Property access photo not found" });
      }
      res.json({ message: "Property access photo deleted successfully" });
    } catch (error) {
      console.error("Error deleting property access photo:", error);
      res.status(500).json({ message: "Failed to delete property access photo" });
    }
  });
  app2.get("/api/property-access/credentials/:id/changelog", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const changeLog = await storage.getAccessChangeLog(parseInt(id));
      res.json(changeLog);
    } catch (error) {
      console.error("Error fetching access change log:", error);
      res.status(500).json({ message: "Failed to fetch access change log" });
    }
  });
  app2.get("/api/property-access/guest-sessions", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { bookingId, credentialId, guestEmail } = req.query;
      const filters = {};
      if (bookingId) filters.bookingId = parseInt(bookingId);
      if (credentialId) filters.credentialId = parseInt(credentialId);
      if (guestEmail) filters.guestEmail = guestEmail;
      const sessions2 = await storage.getGuestAccessSessions(organizationId2, filters);
      res.json(sessions2);
    } catch (error) {
      console.error("Error fetching guest access sessions:", error);
      res.status(500).json({ message: "Failed to fetch guest access sessions" });
    }
  });
  app2.post("/api/property-access/guest-sessions", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const userId = req.user?.id || "";
      const accessToken = await storage.generateGuestAccessToken(
        req.body.bookingId,
        req.body.credentialId
      );
      const sessionData = {
        ...req.body,
        organizationId: organizationId2,
        accessToken,
        grantedBy: userId
      };
      const newSession = await storage.createGuestAccessSession(sessionData);
      res.status(201).json(newSession);
    } catch (error) {
      console.error("Error creating guest access session:", error);
      res.status(500).json({ message: "Failed to create guest access session" });
    }
  });
  app2.patch("/api/property-access/guest-sessions/:id/revoke", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const userId = req.user?.id || "";
      const revokedSession = await storage.revokeGuestAccessSession(
        parseInt(id),
        userId,
        reason || "Manual revocation"
      );
      if (!revokedSession) {
        return res.status(404).json({ message: "Guest access session not found" });
      }
      res.json(revokedSession);
    } catch (error) {
      console.error("Error revoking guest access session:", error);
      res.status(500).json({ message: "Failed to revoke guest access session" });
    }
  });
  app2.post("/api/property-access/validate-token", async (req, res) => {
    try {
      const { token } = req.body;
      if (!token) {
        return res.status(400).json({ message: "Token is required" });
      }
      const validation = await storage.validateGuestAccessToken(token);
      res.json(validation);
    } catch (error) {
      console.error("Error validating guest access token:", error);
      res.status(500).json({ message: "Failed to validate guest access token" });
    }
  });
  app2.get("/api/property-access/rotation-schedules", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const { propertyId, dueForRotation } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (dueForRotation === "true") filters.dueForRotation = true;
      const schedules = await storage.getCodeRotationSchedules(organizationId2, filters);
      res.json(schedules);
    } catch (error) {
      console.error("Error fetching code rotation schedules:", error);
      res.status(500).json({ message: "Failed to fetch code rotation schedules" });
    }
  });
  app2.post("/api/property-access/rotation-schedules", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const userId = req.user?.id || "";
      const scheduleData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: userId
      };
      const newSchedule = await storage.createCodeRotationSchedule(scheduleData);
      res.status(201).json(newSchedule);
    } catch (error) {
      console.error("Error creating code rotation schedule:", error);
      res.status(500).json({ message: "Failed to create code rotation schedule" });
    }
  });
  app2.put("/api/property-access/rotation-schedules/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const updatedSchedule = await storage.updateCodeRotationSchedule(parseInt(id), req.body);
      if (!updatedSchedule) {
        return res.status(404).json({ message: "Code rotation schedule not found" });
      }
      res.json(updatedSchedule);
    } catch (error) {
      console.error("Error updating code rotation schedule:", error);
      res.status(500).json({ message: "Failed to update code rotation schedule" });
    }
  });
  app2.get("/api/property-access/due-reminders", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const dueReminders = await storage.getDueRotationReminders(organizationId2);
      res.json(dueReminders);
    } catch (error) {
      console.error("Error fetching due rotation reminders:", error);
      res.status(500).json({ message: "Failed to fetch due rotation reminders" });
    }
  });
  app2.patch("/api/property-access/rotation-schedules/:id/mark-sent", isDemoAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const marked = await storage.markRotationReminderSent(parseInt(id));
      if (!marked) {
        return res.status(404).json({ message: "Code rotation schedule not found" });
      }
      res.json({ message: "Rotation reminder marked as sent" });
    } catch (error) {
      console.error("Error marking rotation reminder as sent:", error);
      res.status(500).json({ message: "Failed to mark rotation reminder as sent" });
    }
  });
  app2.get("/api/task-scheduling-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : void 0;
      const rules = await storage.getTaskSchedulingRules(organizationId2, propertyId);
      res.json(rules);
    } catch (error) {
      console.error("Error fetching task scheduling rules:", error);
      res.status(500).json({ message: "Failed to fetch task scheduling rules" });
    }
  });
  app2.get("/api/task-scheduling-rules/:ruleId", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const ruleId = parseInt(req.params.ruleId);
      const rule = await storage.getTaskSchedulingRule(organizationId2, ruleId);
      if (!rule) {
        return res.status(404).json({ message: "Task scheduling rule not found" });
      }
      res.json(rule);
    } catch (error) {
      console.error("Error fetching task scheduling rule:", error);
      res.status(500).json({ message: "Failed to fetch task scheduling rule" });
    }
  });
  app2.post("/api/task-scheduling-rules", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const user = req.user;
      if (user?.role !== "admin" && user?.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Insufficient permissions to create task scheduling rules" });
      }
      const ruleData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: user.id
      };
      const newRule = await storage.createTaskSchedulingRule(ruleData);
      res.status(201).json(newRule);
    } catch (error) {
      console.error("Error creating task scheduling rule:", error);
      res.status(500).json({ message: "Failed to create task scheduling rule" });
    }
  });
  app2.put("/api/task-scheduling-rules/:ruleId", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const ruleId = parseInt(req.params.ruleId);
      const user = req.user;
      if (user?.role !== "admin" && user?.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Insufficient permissions to update task scheduling rules" });
      }
      const updatedRule = await storage.updateTaskSchedulingRule(organizationId2, ruleId, req.body);
      res.json(updatedRule);
    } catch (error) {
      console.error("Error updating task scheduling rule:", error);
      res.status(500).json({ message: "Failed to update task scheduling rule" });
    }
  });
  app2.delete("/api/task-scheduling-rules/:ruleId", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const ruleId = parseInt(req.params.ruleId);
      const user = req.user;
      if (user?.role !== "admin" && user?.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Insufficient permissions to delete task scheduling rules" });
      }
      await storage.deleteTaskSchedulingRule(organizationId2, ruleId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting task scheduling rule:", error);
      res.status(500).json({ message: "Failed to delete task scheduling rule" });
    }
  });
  app2.patch("/api/task-scheduling-rules/:ruleId/toggle", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const ruleId = parseInt(req.params.ruleId);
      const { isActive } = req.body;
      const user = req.user;
      if (user?.role !== "admin" && user?.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Insufficient permissions to toggle task scheduling rules" });
      }
      const updatedRule = await storage.toggleTaskSchedulingRule(organizationId2, ruleId, isActive);
      res.json(updatedRule);
    } catch (error) {
      console.error("Error toggling task scheduling rule:", error);
      res.status(500).json({ message: "Failed to toggle task scheduling rule" });
    }
  });
  app2.get("/api/recurring-tasks", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const user = req.user;
      const filters = {};
      if (req.query.propertyId) filters.propertyId = parseInt(req.query.propertyId);
      if (req.query.department) filters.department = req.query.department;
      if (req.query.status) filters.status = req.query.status;
      if (req.query.dateFrom) filters.dateFrom = req.query.dateFrom;
      if (req.query.dateTo) filters.dateTo = req.query.dateTo;
      if (user?.role === "staff") {
        filters.assignedTo = user.id;
      }
      const tasks2 = await storage.getRecurringTasks(organizationId2, filters);
      res.json(tasks2);
    } catch (error) {
      console.error("Error fetching recurring tasks:", error);
      res.status(500).json({ message: "Failed to fetch recurring tasks" });
    }
  });
  app2.get("/api/recurring-tasks/:taskId", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const taskId = parseInt(req.params.taskId);
      const task = await storage.getRecurringTask(organizationId2, taskId);
      if (!task) {
        return res.status(404).json({ message: "Recurring task not found" });
      }
      res.json(task);
    } catch (error) {
      console.error("Error fetching recurring task:", error);
      res.status(500).json({ message: "Failed to fetch recurring task" });
    }
  });
  app2.put("/api/recurring-tasks/:taskId", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const taskId = parseInt(req.params.taskId);
      const updatedTask = await storage.updateRecurringTask(organizationId2, taskId, req.body);
      res.json(updatedTask);
    } catch (error) {
      console.error("Error updating recurring task:", error);
      res.status(500).json({ message: "Failed to update recurring task" });
    }
  });
  app2.post("/api/recurring-tasks/:taskId/complete", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const taskId = parseInt(req.params.taskId);
      const completionData = req.body;
      const completedTask = await storage.completeRecurringTask(organizationId2, taskId, completionData);
      res.json(completedTask);
    } catch (error) {
      console.error("Error completing recurring task:", error);
      res.status(500).json({ message: "Failed to complete recurring task" });
    }
  });
  app2.post("/api/recurring-tasks/:taskId/skip", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const taskId = parseInt(req.params.taskId);
      const { skipReason } = req.body;
      const skippedTask = await storage.skipRecurringTask(organizationId2, taskId, skipReason);
      res.json(skippedTask);
    } catch (error) {
      console.error("Error skipping recurring task:", error);
      res.status(500).json({ message: "Failed to skip recurring task" });
    }
  });
  app2.post("/api/generate-recurring-tasks", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const { targetDate } = req.body;
      const user = req.user;
      if (user?.role !== "admin" && user?.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Insufficient permissions to generate tasks" });
      }
      const log2 = await storage.generateRecurringTasks(organizationId2, targetDate);
      res.json(log2);
    } catch (error) {
      console.error("Error generating recurring tasks:", error);
      res.status(500).json({ message: "Failed to generate recurring tasks" });
    }
  });
  app2.get("/api/task-generation-logs", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const limit = req.query.limit ? parseInt(req.query.limit) : 50;
      const logs = await storage.getTaskGenerationLogs(organizationId2, limit);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching task generation logs:", error);
      res.status(500).json({ message: "Failed to fetch task generation logs" });
    }
  });
  app2.get("/api/recurring-task-analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const propertyId = req.query.propertyId ? parseInt(req.query.propertyId) : void 0;
      const department = req.query.department;
      const year = req.query.year ? parseInt(req.query.year) : void 0;
      const month = req.query.month ? parseInt(req.query.month) : void 0;
      const analytics = await storage.getRecurringTaskAnalytics(organizationId2, propertyId, department, year, month);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching recurring task analytics:", error);
      res.status(500).json({ message: "Failed to fetch recurring task analytics" });
    }
  });
  app2.post("/api/recurring-task-analytics/update", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const user = req.user;
      if (user?.role !== "admin" && user?.role !== "portfolio-manager") {
        return res.status(403).json({ message: "Insufficient permissions to update analytics" });
      }
      await storage.updateRecurringTaskAnalytics(organizationId2);
      res.json({ message: "Analytics updated successfully" });
    } catch (error) {
      console.error("Error updating recurring task analytics:", error);
      res.status(500).json({ message: "Failed to update recurring task analytics" });
    }
  });
  app2.get("/api/task-scheduling-alerts", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const filters = {};
      if (req.query.severity) filters.severity = req.query.severity;
      if (req.query.status) filters.status = req.query.status;
      if (req.query.propertyId) filters.propertyId = parseInt(req.query.propertyId);
      const alerts = await storage.getTaskSchedulingAlerts(organizationId2, filters);
      res.json(alerts);
    } catch (error) {
      console.error("Error fetching task scheduling alerts:", error);
      res.status(500).json({ message: "Failed to fetch task scheduling alerts" });
    }
  });
  app2.post("/api/task-scheduling-alerts", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const alertData = {
        ...req.body,
        organizationId: organizationId2
      };
      const newAlert = await storage.createTaskSchedulingAlert(alertData);
      res.status(201).json(newAlert);
    } catch (error) {
      console.error("Error creating task scheduling alert:", error);
      res.status(500).json({ message: "Failed to create task scheduling alert" });
    }
  });
  app2.patch("/api/task-scheduling-alerts/:alertId/acknowledge", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = "default-org";
      const alertId = parseInt(req.params.alertId);
      const user = req.user;
      const acknowledgedAlert = await storage.acknowledgeTaskSchedulingAlert(organizationId2, alertId, user.id);
      res.json(acknowledgedAlert);
    } catch (error) {
      console.error("Error acknowledging task scheduling alert:", error);
      res.status(500).json({ message: "Failed to acknowledge task scheduling alert" });
    }
  });
  app2.get("/api/guest-checkout-surveys", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const { guestId, propertyId, surveyType, startDate, endDate } = req.query;
      const filters = {};
      if (guestId) filters.guestId = guestId;
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (surveyType) filters.surveyType = surveyType;
      if (startDate && endDate) {
        filters.dateRange = {
          start: new Date(startDate),
          end: new Date(endDate)
        };
      }
      const surveys = await storage.getGuestCheckoutSurveys(organizationId2, filters);
      res.json(surveys);
    } catch (error) {
      console.error("Error fetching guest checkout surveys:", error);
      res.status(500).json({ message: "Failed to fetch surveys" });
    }
  });
  app2.get("/api/guest-checkout-surveys/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const survey = await storage.getGuestCheckoutSurvey(parseInt(req.params.id));
      if (!survey) {
        return res.status(404).json({ message: "Survey not found" });
      }
      res.json(survey);
    } catch (error) {
      console.error("Error fetching guest checkout survey:", error);
      res.status(500).json({ message: "Failed to fetch survey" });
    }
  });
  app2.post("/api/guest-checkout-surveys", async (req, res) => {
    try {
      const surveyData = {
        ...req.body,
        organizationId: req.body.organizationId || "default"
      };
      if (!surveyData.guestId) {
        return res.status(400).json({ message: "Guest ID is required" });
      }
      const survey = await storage.createGuestCheckoutSurvey(surveyData);
      res.status(201).json(survey);
    } catch (error) {
      console.error("Error creating guest checkout survey:", error);
      res.status(500).json({ message: "Failed to create survey" });
    }
  });
  app2.put("/api/guest-checkout-surveys/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const updated = await storage.updateGuestCheckoutSurvey(parseInt(req.params.id), req.body);
      if (!updated) {
        return res.status(404).json({ message: "Survey not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating guest checkout survey:", error);
      res.status(500).json({ message: "Failed to update survey" });
    }
  });
  app2.post("/api/guest-checkout-surveys/:id/review", isDemoAuthenticated, async (req, res) => {
    try {
      const { adminNotes } = req.body;
      const updated = await storage.reviewGuestSurvey(
        parseInt(req.params.id),
        req.user.id,
        adminNotes
      );
      if (!updated) {
        return res.status(404).json({ message: "Survey not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error reviewing guest survey:", error);
      res.status(500).json({ message: "Failed to review survey" });
    }
  });
  app2.get("/api/system-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const baseCurrencySetting = await storage.getPlatformSetting("baseCurrency");
      const displayCurrencySetting = await storage.getPlatformSetting("displayCurrency");
      const dateFormatSetting = await storage.getPlatformSetting("dateFormat");
      const companyNameSetting = await storage.getPlatformSetting("companyName");
      const timezoneSetting = await storage.getPlatformSetting("timezone");
      const baseCurrency = baseCurrencySetting?.settingValue || "USD";
      const displayCurrency = displayCurrencySetting?.settingValue || baseCurrency;
      res.json({
        id: 1,
        organizationId: organizationId2,
        baseCurrency,
        // Currency amounts are stored in DB
        displayCurrency,
        // Currency shown to user (for conversion)
        defaultCurrency: displayCurrency,
        // Backwards compatibility
        dateFormat: dateFormatSetting?.settingValue || "DD/MM/YYYY",
        companyName: companyNameSetting?.settingValue || "HostPilotPro",
        timezone: timezoneSetting?.settingValue || "Asia/Bangkok"
      });
    } catch (error) {
      console.error("Error fetching system settings:", error);
      res.status(500).json({ message: "Failed to fetch system settings" });
    }
  });
  app2.put("/api/system-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const { defaultCurrency, displayCurrency, baseCurrency, dateFormat, companyName, timezone } = req.body;
      const currencyToSave = displayCurrency || defaultCurrency;
      if (currencyToSave) {
        await storage.upsertPlatformSetting({
          settingKey: "displayCurrency",
          settingValue: currencyToSave,
          settingType: "string",
          category: "currency",
          description: "Display currency for the organization (for conversion)",
          updatedBy: req.user.id
        });
      }
      if (baseCurrency) {
        await storage.upsertPlatformSetting({
          settingKey: "baseCurrency",
          settingValue: baseCurrency,
          settingType: "string",
          category: "currency",
          description: "Base currency for stored amounts",
          updatedBy: req.user.id
        });
      }
      if (dateFormat) {
        await storage.upsertPlatformSetting({
          settingKey: "dateFormat",
          settingValue: dateFormat,
          settingType: "string",
          category: "system",
          description: "Default date format for the organization",
          updatedBy: req.user.id
        });
      }
      if (companyName) {
        await storage.upsertPlatformSetting({
          settingKey: "companyName",
          settingValue: companyName,
          settingType: "string",
          category: "system",
          description: "Organization/company name",
          updatedBy: req.user.id
        });
      }
      if (timezone) {
        await storage.upsertPlatformSetting({
          settingKey: "timezone",
          settingValue: timezone,
          settingType: "string",
          category: "system",
          description: "Default timezone for the organization",
          updatedBy: req.user.id
        });
      }
      const updatedBaseCurrency = (await storage.getPlatformSetting("baseCurrency"))?.settingValue || "USD";
      const updatedDisplayCurrency = (await storage.getPlatformSetting("displayCurrency"))?.settingValue || updatedBaseCurrency;
      console.log(`[SYSTEM-SETTINGS] Display currency updated to: ${updatedDisplayCurrency}`);
      res.json({
        id: 1,
        organizationId: organizationId2,
        baseCurrency: updatedBaseCurrency,
        displayCurrency: updatedDisplayCurrency,
        defaultCurrency: updatedDisplayCurrency,
        // Backwards compatibility
        dateFormat: dateFormat || "DD/MM/YYYY",
        companyName: companyName || "HostPilotPro",
        timezone: timezone || "Asia/Bangkok",
        message: "System settings updated successfully"
      });
    } catch (error) {
      console.error("Error updating system settings:", error);
      res.status(500).json({ message: "Failed to update system settings" });
    }
  });
  const currencyService = await Promise.resolve().then(() => (init_currencyConversionService(), currencyConversionService_exports));
  app2.get("/api/currency/rates", isDemoAuthenticated, async (req, res) => {
    try {
      const baseCurrency = req.query.base || "USD";
      const ratesData = await currencyService.getAllRatesForFrontend(baseCurrency);
      res.json(ratesData);
    } catch (error) {
      console.error("Error fetching exchange rates:", error);
      res.status(500).json({ message: "Failed to fetch exchange rates" });
    }
  });
  app2.get("/api/currency/convert", isDemoAuthenticated, async (req, res) => {
    try {
      const { amount, from, to } = req.query;
      if (!amount || !from || !to) {
        return res.status(400).json({ message: "Missing required parameters: amount, from, to" });
      }
      const numAmount = parseFloat(amount);
      if (isNaN(numAmount)) {
        return res.status(400).json({ message: "Invalid amount" });
      }
      const convertedAmount = await currencyService.convertAmount(
        numAmount,
        from,
        to
      );
      res.json({
        originalAmount: numAmount,
        fromCurrency: from,
        toCurrency: to,
        convertedAmount,
        rate: await currencyService.getConversionRate(from, to)
      });
    } catch (error) {
      console.error("Error converting currency:", error);
      res.status(500).json({ message: "Failed to convert currency" });
    }
  });
  app2.get("/api/currency/supported", async (req, res) => {
    try {
      res.json({
        currencies: currencyService.SUPPORTED_CURRENCIES,
        symbols: currencyService.CURRENCY_SYMBOLS
      });
    } catch (error) {
      console.error("Error fetching supported currencies:", error);
      res.status(500).json({ message: "Failed to fetch supported currencies" });
    }
  });
  app2.get("/api/survey-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const { propertyId } = req.query;
      const settings = await storage.getSurveySettings(
        organizationId2,
        propertyId ? parseInt(propertyId) : void 0
      );
      res.json(settings);
    } catch (error) {
      console.error("Error fetching survey settings:", error);
      res.status(500).json({ message: "Failed to fetch survey settings" });
    }
  });
  app2.post("/api/survey-settings", isDemoAuthenticated, async (req, res) => {
    try {
      const settingsData = {
        ...req.body,
        organizationId: req.user.organizationId
      };
      const settings = await storage.createSurveySettings(settingsData);
      res.status(201).json(settings);
    } catch (error) {
      console.error("Error creating survey settings:", error);
      res.status(500).json({ message: "Failed to create survey settings" });
    }
  });
  app2.get("/api/survey-alerts", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const { severity, resolved, alertType } = req.query;
      const filters = {};
      if (severity) filters.severity = severity;
      if (resolved !== void 0) filters.resolved = resolved === "true";
      if (alertType) filters.alertType = alertType;
      const alerts = await storage.getSurveyAlerts(organizationId2, filters);
      res.json(alerts);
    } catch (error) {
      console.error("Error fetching survey alerts:", error);
      res.status(500).json({ message: "Failed to fetch survey alerts" });
    }
  });
  app2.post("/api/survey-alerts/:id/resolve", isDemoAuthenticated, async (req, res) => {
    try {
      const { resolutionNotes } = req.body;
      const updated = await storage.resolveSurveyAlert(
        parseInt(req.params.id),
        req.user.id,
        resolutionNotes
      );
      if (!updated) {
        return res.status(404).json({ message: "Alert not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error resolving survey alert:", error);
      res.status(500).json({ message: "Failed to resolve alert" });
    }
  });
  app2.get("/api/survey-analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const { propertyId, period } = req.query;
      const analytics = await storage.getSurveyAnalytics(
        organizationId2,
        propertyId ? parseInt(propertyId) : void 0,
        period
      );
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching survey analytics:", error);
      res.status(500).json({ message: "Failed to fetch survey analytics" });
    }
  });
  app2.post("/api/survey-analytics/generate", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const { propertyId } = req.body;
      await storage.generateSurveyAnalytics(organizationId2, propertyId);
      res.json({ message: "Analytics generated successfully" });
    } catch (error) {
      console.error("Error generating survey analytics:", error);
      res.status(500).json({ message: "Failed to generate analytics" });
    }
  });
  app2.get("/api/guest-checkout-surveys/demo", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId;
      const demoData = await storage.getGuestSurveyDemoData(organizationId2);
      res.json(demoData);
    } catch (error) {
      console.error("Error fetching demo survey data:", error);
      res.status(500).json({ message: "Failed to fetch demo data" });
    }
  });
  app2.get("/api/marketing-packs", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const { propertyId, status, packType, targetAudience, language } = req.query;
      const filters = {};
      if (propertyId) filters.propertyId = parseInt(propertyId);
      if (status) filters.status = status;
      if (packType) filters.packType = packType;
      if (targetAudience) filters.targetAudience = targetAudience;
      if (language) filters.language = language;
      const packs = await storage.getMarketingPacks(organizationId2, filters);
      res.json(packs);
    } catch (error) {
      console.error("Error fetching marketing packs:", error);
      res.status(500).json({ message: "Failed to fetch marketing packs" });
    }
  });
  app2.post("/api/marketing-packs", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const packData = insertMarketingPackSchema.parse({
        ...req.body,
        organizationId: organizationId2,
        generatedBy: userId
      });
      if (packData.propertyId && packData.packType && packData.targetAudience && packData.language) {
        packData.aiSummary = await storage.generateMarketingContent(
          packData.propertyId,
          packData.packType,
          packData.targetAudience,
          packData.language
        );
      }
      const pack = await storage.createMarketingPack(packData);
      res.status(201).json(pack);
    } catch (error) {
      console.error("Error creating marketing pack:", error);
      res.status(500).json({ message: "Failed to create marketing pack" });
    }
  });
  app2.get("/api/marketing-packs/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const id = parseInt(req.params.id);
      const pack = await storage.getMarketingPackById(organizationId2, id);
      if (!pack) {
        return res.status(404).json({ message: "Marketing pack not found" });
      }
      res.json(pack);
    } catch (error) {
      console.error("Error fetching marketing pack:", error);
      res.status(500).json({ message: "Failed to fetch marketing pack" });
    }
  });
  app2.put("/api/marketing-packs/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const id = parseInt(req.params.id);
      const updates = req.body;
      const pack = await storage.updateMarketingPack(organizationId2, id, updates);
      if (!pack) {
        return res.status(404).json({ message: "Marketing pack not found" });
      }
      res.json(pack);
    } catch (error) {
      console.error("Error updating marketing pack:", error);
      res.status(500).json({ message: "Failed to update marketing pack" });
    }
  });
  app2.delete("/api/marketing-packs/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteMarketingPack(organizationId2, id);
      if (!deleted) {
        return res.status(404).json({ message: "Marketing pack not found" });
      }
      res.json({ message: "Marketing pack deleted successfully" });
    } catch (error) {
      console.error("Error deleting marketing pack:", error);
      res.status(500).json({ message: "Failed to delete marketing pack" });
    }
  });
  app2.get("/api/marketing-packs/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const analytics = await storage.getMarketingPackAnalytics(organizationId2);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching marketing pack analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });
  app2.get("/api/marketing-packs/property/:propertyId", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const propertyId = parseInt(req.params.propertyId);
      const packs = await storage.getMarketingPacksByProperty(organizationId2, propertyId);
      res.json(packs);
    } catch (error) {
      console.error("Error fetching marketing packs by property:", error);
      res.status(500).json({ message: "Failed to fetch marketing packs" });
    }
  });
  app2.post("/api/marketing-packs/generate-ai", isDemoAuthenticated, async (req, res) => {
    try {
      const { propertyId, packType, targetAudience, language } = req.body;
      if (!propertyId || !packType || !targetAudience || !language) {
        return res.status(400).json({
          message: "Property ID, pack type, target audience, and language are required"
        });
      }
      const aiContent = await storage.generateMarketingContent(
        propertyId,
        packType,
        targetAudience,
        language
      );
      res.json({ aiSummary: aiContent });
    } catch (error) {
      console.error("Error generating AI marketing content:", error);
      res.status(500).json({ message: "Failed to generate AI content" });
    }
  });
  app2.get("/api/ai-ops-anomalies", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const anomalies = await storage.getAiOpsAnomalies(organizationId2);
      res.json(anomalies);
    } catch (error) {
      console.error("Error fetching AI operations anomalies:", error);
      res.status(500).json({ message: "Failed to fetch AI operations anomalies" });
    }
  });
  app2.post("/api/ai-ops-anomalies", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const anomaly = await storage.createAiOpsAnomaly(organizationId2, req.body);
      res.json(anomaly);
    } catch (error) {
      console.error("Error creating AI operations anomaly:", error);
      res.status(500).json({ message: "Failed to create AI operations anomaly" });
    }
  });
  app2.get("/api/ai-ops-anomalies/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const id = parseInt(req.params.id);
      const anomaly = await storage.getAiOpsAnomalyById(organizationId2, id);
      if (!anomaly) {
        return res.status(404).json({ message: "AI operations anomaly not found" });
      }
      res.json(anomaly);
    } catch (error) {
      console.error("Error fetching AI operations anomaly:", error);
      res.status(500).json({ message: "Failed to fetch AI operations anomaly" });
    }
  });
  app2.put("/api/ai-ops-anomalies/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const id = parseInt(req.params.id);
      const anomaly = await storage.updateAiOpsAnomaly(organizationId2, id, req.body);
      if (!anomaly) {
        return res.status(404).json({ message: "AI operations anomaly not found" });
      }
      res.json(anomaly);
    } catch (error) {
      console.error("Error updating AI operations anomaly:", error);
      res.status(500).json({ message: "Failed to update AI operations anomaly" });
    }
  });
  app2.delete("/api/ai-ops-anomalies/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const id = parseInt(req.params.id);
      const success = await storage.deleteAiOpsAnomaly(organizationId2, id);
      if (!success) {
        return res.status(404).json({ message: "AI operations anomaly not found" });
      }
      res.json({ message: "AI operations anomaly deleted successfully" });
    } catch (error) {
      console.error("Error deleting AI operations anomaly:", error);
      res.status(500).json({ message: "Failed to delete AI operations anomaly" });
    }
  });
  app2.get("/api/ai-ops-anomalies/type/:type", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const anomalies = await storage.getAnomaliesByType(organizationId2, req.params.type);
      res.json(anomalies);
    } catch (error) {
      console.error("Error fetching anomalies by type:", error);
      res.status(500).json({ message: "Failed to fetch anomalies by type" });
    }
  });
  app2.get("/api/ai-ops-anomalies/property/:propertyId", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const propertyId = parseInt(req.params.propertyId);
      const anomalies = await storage.getAnomaliesByProperty(organizationId2, propertyId);
      res.json(anomalies);
    } catch (error) {
      console.error("Error fetching anomalies by property:", error);
      res.status(500).json({ message: "Failed to fetch anomalies by property" });
    }
  });
  app2.post("/api/ai-ops-anomalies/:id/resolve", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const id = parseInt(req.params.id);
      const { fixAction } = req.body;
      const anomaly = await storage.resolveAnomaly(organizationId2, id, fixAction);
      if (!anomaly) {
        return res.status(404).json({ message: "AI operations anomaly not found" });
      }
      res.json(anomaly);
    } catch (error) {
      console.error("Error resolving AI operations anomaly:", error);
      res.status(500).json({ message: "Failed to resolve AI operations anomaly" });
    }
  });
  app2.get("/api/ai-ops-anomalies/analytics", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const analytics = await storage.getAiOpsAnalytics(organizationId2);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching AI operations analytics:", error);
      res.status(500).json({ message: "Failed to fetch AI operations analytics" });
    }
  });
  app2.post("/api/ai-ops-anomalies/detect", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const detectedAnomalies = await storage.detectAnomalies(organizationId2);
      res.json({
        message: `Detected ${detectedAnomalies.length} anomalies`,
        anomalies: detectedAnomalies,
        count: detectedAnomalies.length
      });
    } catch (error) {
      console.error("Error detecting anomalies:", error);
      res.status(500).json({ message: "Failed to detect anomalies" });
    }
  });
  app2.post("/api/ai-ops-anomalies/auto-fix", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2 } = req.user;
      const fixedCount = await storage.autoFixAnomalies(organizationId2);
      res.json({
        message: `Auto-fixed ${fixedCount} anomalies`,
        fixedCount,
        success: true
      });
    } catch (error) {
      console.error("Error auto-fixing anomalies:", error);
      res.status(500).json({ message: "Failed to auto-fix anomalies" });
    }
  });
  app2.post("/api/marketing-packs/bulk-generate", isDemoAuthenticated, async (req, res) => {
    try {
      const { organizationId: organizationId2, id: userId } = req.user;
      const { propertyIds, packType, targetAudience, language } = req.body;
      if (!propertyIds || !Array.isArray(propertyIds) || propertyIds.length === 0) {
        return res.status(400).json({ message: "Property IDs array is required" });
      }
      if (!packType || !targetAudience || !language) {
        return res.status(400).json({
          message: "Pack type, target audience, and language are required"
        });
      }
      const packConfig = {
        packType,
        targetAudience,
        language,
        generatedBy: userId
      };
      const createdPacks = await storage.bulkGenerateMarketingPacks(
        organizationId2,
        propertyIds,
        packConfig
      );
      res.status(201).json({
        message: `Successfully generated ${createdPacks.length} marketing packs`,
        packs: createdPacks
      });
    } catch (error) {
      console.error("Error bulk generating marketing packs:", error);
      res.status(500).json({ message: "Failed to bulk generate marketing packs" });
    }
  });
  const httpServer = createServer(app2);
  app2.get("/api/reports", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const reports2 = await storage.getReports(organizationId2);
      res.json(reports2);
    } catch (error) {
      console.error("Error fetching reports:", error);
      res.status(500).json({ message: "Failed to fetch reports" });
    }
  });
  app2.get("/api/reports/type/:type", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const { type } = req.params;
      const reports2 = await storage.getReportsByType(organizationId2, type);
      res.json(reports2);
    } catch (error) {
      console.error("Error fetching reports by type:", error);
      res.status(500).json({ message: "Failed to fetch reports" });
    }
  });
  app2.get("/api/reports/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const report = await storage.getReport(parseInt(req.params.id));
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      res.json(report);
    } catch (error) {
      console.error("Error fetching report:", error);
      res.status(500).json({ message: "Failed to fetch report" });
    }
  });
  app2.post("/api/reports/generate", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const { type } = req.body;
      if (!type) {
        return res.status(400).json({ message: "Report type is required" });
      }
      const report = await storage.generateReport(organizationId2, type, req.user.id);
      res.status(201).json(report);
    } catch (error) {
      console.error("Error generating report:", error);
      res.status(500).json({ message: "Failed to generate report" });
    }
  });
  app2.get("/api/reports/:id/export", isDemoAuthenticated, async (req, res) => {
    try {
      const report = await storage.getReport(parseInt(req.params.id));
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      const { Parser } = await import("json2csv");
      const fields = report.data.details && report.data.details.length > 0 ? Object.keys(report.data.details[0]) : [];
      const parser = new Parser({ fields });
      const csv = parser.parse(report.data.details || []);
      res.header("Content-Type", "text/csv");
      res.attachment(`${report.type}_report_${report.id}.csv`);
      res.send(csv);
    } catch (error) {
      console.error("Error exporting report:", error);
      res.status(500).json({ message: "Failed to export report" });
    }
  });
  app2.delete("/api/reports/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const success = await storage.deleteReport(parseInt(req.params.id));
      if (!success) {
        return res.status(404).json({ message: "Report not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting report:", error);
      res.status(500).json({ message: "Failed to delete report" });
    }
  });
  app2.get("/api/automations", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const automations2 = await storage.getAutomations(organizationId2);
      res.json(automations2);
    } catch (error) {
      console.error("Error fetching automations:", error);
      res.status(500).json({ message: "Failed to fetch automations" });
    }
  });
  app2.get("/api/automations/active", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const automations2 = await storage.getActiveAutomations(organizationId2);
      res.json(automations2);
    } catch (error) {
      console.error("Error fetching active automations:", error);
      res.status(500).json({ message: "Failed to fetch automations" });
    }
  });
  app2.get("/api/automations/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const automation = await storage.getAutomation(parseInt(req.params.id));
      if (!automation) {
        return res.status(404).json({ message: "Automation not found" });
      }
      res.json(automation);
    } catch (error) {
      console.error("Error fetching automation:", error);
      res.status(500).json({ message: "Failed to fetch automation" });
    }
  });
  app2.post("/api/automations", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user.organizationId || "default-org";
      const automationData = {
        ...req.body,
        organizationId: organizationId2,
        createdBy: req.user.id
      };
      const automation = await storage.createAutomation(automationData);
      res.status(201).json(automation);
    } catch (error) {
      console.error("Error creating automation:", error);
      res.status(500).json({ message: "Failed to create automation" });
    }
  });
  app2.put("/api/automations/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const automation = await storage.updateAutomation(parseInt(req.params.id), req.body);
      if (!automation) {
        return res.status(404).json({ message: "Automation not found" });
      }
      res.json(automation);
    } catch (error) {
      console.error("Error updating automation:", error);
      res.status(500).json({ message: "Failed to update automation" });
    }
  });
  app2.patch("/api/automations/:id/toggle", isDemoAuthenticated, async (req, res) => {
    try {
      const { isActive } = req.body;
      const automation = await storage.toggleAutomation(parseInt(req.params.id), isActive);
      if (!automation) {
        return res.status(404).json({ message: "Automation not found" });
      }
      res.json(automation);
    } catch (error) {
      console.error("Error toggling automation:", error);
      res.status(500).json({ message: "Failed to toggle automation" });
    }
  });
  app2.delete("/api/automations/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const success = await storage.deleteAutomation(parseInt(req.params.id));
      if (!success) {
        return res.status(404).json({ message: "Automation not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting automation:", error);
      res.status(500).json({ message: "Failed to delete automation" });
    }
  });
  app2.get("/api/automations/:id/logs", isDemoAuthenticated, async (req, res) => {
    try {
      const logs = await storage.getAutomationLogs(parseInt(req.params.id));
      res.json(logs);
    } catch (error) {
      console.error("Error fetching automation logs:", error);
      res.status(500).json({ message: "Failed to fetch automation logs" });
    }
  });
  app2.get("/api/billing-invoices/next-number", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const nextNumber = await storage.getNextInvoiceNumber(organizationId2);
      res.json({ invoiceNumber: nextNumber });
    } catch (error) {
      console.error("Error getting next invoice number:", error);
      res.status(500).json({ message: "Failed to get next invoice number" });
    }
  });
  app2.get("/api/billing-invoices/stats", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const stats = await storage.getBillingInvoiceStats(organizationId2);
      res.json(stats);
    } catch (error) {
      console.error("Error getting invoice stats:", error);
      res.status(500).json({ message: "Failed to get invoice stats" });
    }
  });
  app2.get("/api/billing-invoices/export", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const filters = {
        status: req.query.status,
        fromDate: req.query.fromDate,
        toDate: req.query.toDate
      };
      const invoices2 = await storage.exportBillingInvoices(organizationId2, filters);
      const { Parser } = __require("json2csv");
      const fields = [
        "invoiceNumber",
        "clientType",
        "clientName",
        "issueDate",
        "dueDate",
        "status",
        "subtotal",
        "taxTotal",
        "discountTotal",
        "total"
      ];
      const parser = new Parser({ fields });
      const csv = parser.parse(invoices2);
      res.header("Content-Type", "text/csv");
      res.header("Content-Disposition", `attachment; filename=invoices-export-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv`);
      res.send(csv);
    } catch (error) {
      console.error("Error exporting invoices:", error);
      res.status(500).json({ message: "Failed to export invoices" });
    }
  });
  app2.get("/api/billing-invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const filters = {
        status: req.query.status,
        clientId: req.query.clientId,
        propertyId: req.query.propertyId ? parseInt(req.query.propertyId) : void 0,
        search: req.query.search,
        fromDate: req.query.fromDate,
        toDate: req.query.toDate,
        page: req.query.page ? parseInt(req.query.page) : 1,
        limit: req.query.limit ? parseInt(req.query.limit) : 20
      };
      const result = await storage.getBillingInvoices(organizationId2, filters);
      res.json(result);
    } catch (error) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });
  app2.get("/api/billing-invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const invoice = await storage.getBillingInvoice(id);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      const lineItems = await db.select().from(billingInvoiceLineItems).where(eq10(billingInvoiceLineItems.invoiceId, id));
      res.json({ ...invoice, lineItems });
    } catch (error) {
      console.error("Error fetching invoice:", error);
      res.status(500).json({ message: "Failed to fetch invoice" });
    }
  });
  app2.post("/api/billing-invoices", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const organizationId2 = req.user?.organizationId || "default-org";
      const { lineItems, ...invoiceData } = req.body;
      if (!invoiceData.invoiceNumber || !invoiceData.clientType || !invoiceData.clientName) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      if (!lineItems || lineItems.length === 0) {
        return res.status(400).json({ message: "At least one line item is required" });
      }
      if (invoiceData.status === "sent") {
        if (!invoiceData.issueDate || !invoiceData.dueDate) {
          return res.status(400).json({ message: "Issue date and due date are required for sent invoices" });
        }
      }
      const invoice = await storage.createBillingInvoice(
        {
          ...invoiceData,
          organizationId: organizationId2,
          createdBy: userId
        },
        lineItems
      );
      res.status(201).json(invoice);
    } catch (error) {
      console.error("Error creating invoice:", error);
      res.status(500).json({ message: "Failed to create invoice" });
    }
  });
  app2.put("/api/billing-invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { lineItems, ...invoiceData } = req.body;
      const updatedInvoice = await storage.updateBillingInvoice(id, invoiceData, lineItems);
      if (!updatedInvoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json(updatedInvoice);
    } catch (error) {
      console.error("Error updating invoice:", error);
      res.status(500).json({ message: "Failed to update invoice" });
    }
  });
  app2.delete("/api/billing-invoices/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteBillingInvoice(id);
      if (!deleted) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      res.json({ message: "Invoice deleted successfully" });
    } catch (error) {
      console.error("Error deleting invoice:", error);
      res.status(500).json({ message: "Failed to delete invoice" });
    }
  });
  app2.get("/api/billing-invoice-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const organizationId2 = req.user?.organizationId || "default-org";
      const templates = await storage.getBillingInvoiceTemplates(organizationId2);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({ message: "Failed to fetch templates" });
    }
  });
  app2.get("/api/billing-invoice-templates/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const template = await storage.getBillingInvoiceTemplate(id);
      if (!template) {
        return res.status(404).json({ message: "Template not found" });
      }
      const lineItems = await db.select().from(billingTemplateLineItems).where(eq10(billingTemplateLineItems.templateId, id));
      res.json({ ...template, lineItems });
    } catch (error) {
      console.error("Error fetching template:", error);
      res.status(500).json({ message: "Failed to fetch template" });
    }
  });
  app2.post("/api/billing-invoice-templates", isDemoAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const organizationId2 = req.user?.organizationId || "default-org";
      const { lineItems, ...templateData } = req.body;
      if (!templateData.name) {
        return res.status(400).json({ message: "Template name is required" });
      }
      const template = await storage.createBillingInvoiceTemplate(
        {
          ...templateData,
          organizationId: organizationId2,
          createdBy: userId
        },
        lineItems || []
      );
      res.status(201).json(template);
    } catch (error) {
      console.error("Error creating template:", error);
      res.status(500).json({ message: "Failed to create template" });
    }
  });
  app2.put("/api/billing-invoice-templates/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { lineItems, ...templateData } = req.body;
      const updatedTemplate = await storage.updateBillingInvoiceTemplate(id, templateData, lineItems);
      if (!updatedTemplate) {
        return res.status(404).json({ message: "Template not found" });
      }
      res.json(updatedTemplate);
    } catch (error) {
      console.error("Error updating template:", error);
      res.status(500).json({ message: "Failed to update template" });
    }
  });
  app2.delete("/api/billing-invoice-templates/:id", isDemoAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteBillingInvoiceTemplate(id);
      if (!deleted) {
        return res.status(404).json({ message: "Template not found" });
      }
      res.json({ message: "Template deleted successfully" });
    } catch (error) {
      console.error("Error deleting template:", error);
      res.status(500).json({ message: "Failed to delete template" });
    }
  });
  return httpServer;
}

// server/static.ts
import express from "express";
import fs from "fs";
import path from "path";
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
function serveStatic(app2) {
  const distPath = path.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}

// server/index.ts
init_demoAuth();

// server/seedProductionAdmin.ts
init_storage();
async function seedProductionAdmin() {
  const adminEmail = "admin@test.com";
  const adminPassword = "admin123";
  const adminId = "prod-admin-001";
  console.log("\u{1F510} Checking for production admin user...");
  try {
    const existingUser = await storage.getUserByEmail(adminEmail);
    if (existingUser) {
      console.log("\u2705 Production admin user already exists");
      console.log(`   ID: ${existingUser.id}`);
      console.log(`   Email: ${existingUser.email}`);
      console.log(`   Role: ${existingUser.role}`);
      if (!existingUser.password || existingUser.password.length < 10) {
        console.log("\u26A0\uFE0F Admin password needs to be reset, updating...");
        const hashedPassword2 = await hashPassword(adminPassword);
        await storage.upsertUser({
          ...existingUser,
          password: hashedPassword2
        });
        console.log("\u2705 Admin password updated");
      }
      return;
    }
    console.log("\u{1F4DD} Creating production admin user...");
    const hashedPassword = await hashPassword(adminPassword);
    await storage.upsertUser({
      id: adminId,
      email: adminEmail,
      firstName: "Admin",
      lastName: "User",
      password: hashedPassword,
      role: "admin",
      primaryRole: "admin",
      organizationId: "default-org",
      profileImageUrl: null,
      isActive: true
    });
    const verifyUser = await storage.getUserByEmail(adminEmail);
    if (verifyUser) {
      console.log("\u2705 Production admin user created successfully");
      console.log("   \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
      console.log("   \u2502 Email: admin@test.com");
      console.log("   \u2502 Password: admin123");
      console.log("   \u2502 Role: admin");
      console.log("   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
    } else {
      console.error("\u274C Failed to verify admin user creation");
    }
  } catch (error) {
    console.error("\u274C Failed to seed production admin:", error);
  }
}

// server/services/integrationStore.ts
import fs2 from "fs";
import crypto2 from "crypto";
import path2 from "path";
var DATA_DIR = path2.resolve(process.cwd(), "data");
var FILE = path2.join(DATA_DIR, "integrations.json");
function ensureFile() {
  if (!fs2.existsSync(DATA_DIR)) fs2.mkdirSync(DATA_DIR, { recursive: true });
  if (!fs2.existsSync(FILE)) fs2.writeFileSync(FILE, "{}", "utf-8");
}
async function getIntegrationForOrg(orgId) {
  ensureFile();
  const raw = JSON.parse(fs2.readFileSync(FILE, "utf-8") || "{}");
  return raw[orgId] || null;
}
async function saveIntegration(orgId, row) {
  ensureFile();
  const raw = JSON.parse(fs2.readFileSync(FILE, "utf-8") || "{}");
  raw[orgId] = {
    organizationId: orgId,
    isActive: true,
    connectedAt: (/* @__PURE__ */ new Date()).toISOString(),
    ...row
  };
  fs2.writeFileSync(FILE, JSON.stringify(raw, null, 2), "utf-8");
}
async function removeIntegration(orgId) {
  ensureFile();
  const raw = JSON.parse(fs2.readFileSync(FILE, "utf-8") || "{}");
  delete raw[orgId];
  fs2.writeFileSync(FILE, JSON.stringify(raw, null, 2), "utf-8");
}
var KEY = (process.env.INTEGRATION_CRYPT_KEY || "dev-dev-dev-dev-dev-dev-dev-dev").slice(0, 32);
function encrypt(plain) {
  if (!plain) return void 0;
  const iv = crypto2.randomBytes(12);
  const cipher = crypto2.createCipheriv("aes-256-gcm", Buffer.from(KEY), iv);
  const enc = Buffer.concat([cipher.update(plain, "utf8"), cipher.final()]);
  const tag = cipher.getAuthTag();
  return Buffer.concat([iv, tag, enc]).toString("base64");
}
function decrypt(token) {
  if (!token) return void 0;
  const buf = Buffer.from(token, "base64");
  const iv = buf.subarray(0, 12);
  const tag = buf.subarray(12, 28);
  const enc = buf.subarray(28);
  const decipher = crypto2.createDecipheriv("aes-256-gcm", Buffer.from(KEY), iv);
  decipher.setAuthTag(tag);
  const dec = Buffer.concat([decipher.update(enc), decipher.final()]);
  return dec.toString("utf8");
}

// server/integrations/providers/hostawayAdapter.ts
var HostawayAdapter = class {
  constructor(cfg) {
    this.cfg = cfg;
  }
  headers() {
    const token = this.cfg.apiKey || this.cfg.accessToken;
    if (!token) throw new Error("HostawayAdapter missing API key or access token");
    return {
      "Authorization": `Bearer ${token}`,
      "X-Account-Id": this.cfg.accountId,
      "Content-Type": "application/json"
    };
  }
  async get(path8, params) {
    const base = process.env.HOSTAWAY_BASE_URL || "https://api.hostaway.com/v1";
    const url = new URL(base + path8);
    if (params) Object.entries(params).forEach(([k, v]) => url.searchParams.set(k, String(v)));
    const res = await fetch(url, { headers: this.headers() });
    if (!res.ok) throw new Error(`Hostaway ${res.status}: ${await res.text()}`);
    return res.json();
  }
  async listListings(params) {
    const { limit = 50, offset = 0 } = params || {};
    const data = await this.get("/listings", { limit, offset });
    if (!data?.result) {
      throw new Error("Invalid response format from Hostaway");
    }
    return data.result.map((listing) => ({
      id: listing.id.toString(),
      title: listing.name || listing.title || "Unnamed Property",
      address: this.formatAddress(listing),
      bedrooms: parseInt(listing.bedrooms) || 0,
      bathrooms: parseInt(listing.bathrooms) || 0,
      maxGuests: parseInt(listing.maxGuests) || 1,
      propertyType: listing.propertyTypeName || "Property",
      status: listing.isActive ? "active" : "inactive",
      description: listing.description || void 0,
      images: listing.pictures?.map((pic) => pic.url).slice(0, 5) || void 0
    }));
  }
  async getAvailability(params) {
    const { listingId, start, end } = params;
    const data = await this.get(`/listings/${listingId}/calendar`, {
      startDate: start,
      endDate: end
    });
    if (!data?.result) {
      throw new Error("Invalid availability response from Hostaway");
    }
    return data.result.map((day) => ({
      date: day.date,
      available: Boolean(day.isAvailable),
      price: day.price ? parseFloat(day.price) : void 0,
      minStay: day.minStay ? parseInt(day.minStay) : void 0,
      currency: day.currency || "USD"
    }));
  }
  async testConnection() {
    try {
      await this.get("/me");
      return true;
    } catch (error) {
      console.error("Hostaway connection test failed:", error);
      return false;
    }
  }
  formatAddress(listing) {
    const parts = [
      listing.address,
      listing.city,
      listing.state,
      listing.country
    ].filter(Boolean);
    return parts.join(", ") || "Address not available";
  }
};

// server/middlewares/orgContext.ts
function orgContext() {
  return (req, _res, next) => {
    if (!req.user) req.user = {};
    req.user.organizationId = req.user.organizationId || "default-org";
    next();
  };
}

// server/routers/integrations-routes.ts
function mountIntegrationRoutes(app2) {
  app2.use(orgContext());
  app2.get("/api/integrations/me", async (req, res) => {
    const orgId = req.user.organizationId;
    const row = await getIntegrationForOrg(orgId);
    res.json({ provider: row?.provider ?? null });
  });
  app2.post("/api/integrations/connect", async (req, res) => {
    const orgId = req.user.organizationId;
    const { provider, authType, apiKey, accountId, accessToken } = req.body || {};
    if (!provider || !authType) return res.status(400).json({ message: "provider and authType required" });
    try {
      if (provider === "hostaway") {
        const client2 = new HostawayAdapter({ apiKey, accountId, accessToken });
        await client2.listListings({ limit: 1, offset: 0 });
      }
    } catch (e) {
      return res.status(400).json({ message: "Credentials test failed", error: String(e) });
    }
    await saveIntegration(orgId, {
      provider,
      authType,
      apiKeyEnc: encrypt(apiKey),
      accessTokenEnc: encrypt(accessToken),
      accountId
    });
    res.json({ ok: true });
  });
  app2.delete("/api/integrations/connect", async (req, res) => {
    const orgId = req.user.organizationId;
    await removeIntegration(orgId);
    res.json({ ok: true });
  });
}

// server/integrations/providers/demoAdapter.ts
var DemoAdapter = class {
  async listListings() {
    return {
      items: [
        { id: 1001, name: "Demo Villa A", bedrooms: 3, bathrooms: 2, pricePerNight: 180, currency: "THB" },
        { id: 1002, name: "Demo Villa B", bedrooms: 4, bathrooms: 3, pricePerNight: 240, currency: "THB" }
      ],
      total: 2
    };
  }
  async getAvailability({ listingId, start, end }) {
    return {
      listingId,
      start,
      end,
      days: [
        { date: start, available: true },
        { date: end, available: false }
      ]
    };
  }
  async testConnection() {
    return true;
  }
};

// server/integrations/factory.ts
async function getPMSClient(organizationId2) {
  const integration = await getIntegrationForOrg(organizationId2);
  if (!integration) {
    throw new Error("No PMS integration configured");
  }
  const { provider } = integration;
  switch (provider) {
    case "demo":
      return new DemoAdapter();
    case "hostaway":
      const apiKey = integration.apiKeyEnc ? decrypt(integration.apiKeyEnc) : void 0;
      const accessToken = integration.accessTokenEnc ? decrypt(integration.accessTokenEnc) : void 0;
      return new HostawayAdapter({
        apiKey,
        accessToken,
        accountId: integration.accountId
      });
    default:
      throw new Error(`Unsupported PMS provider: ${provider}`);
  }
}

// server/middlewares/requireRole.ts
function requireRole3(...roles) {
  return (req, res, next) => {
    const role = req.user?.role || "guest";
    if (!roles.includes(role)) return res.status(403).json({ message: "Forbidden" });
    next();
  };
}

// server/routers/pms-routes.ts
function mountPmsRoutes(app2) {
  app2.use(orgContext());
  app2.get(
    "/api/pms/listings",
    requireRole3("admin", "portfolio-manager", "retail-agent"),
    async (req, res) => {
      try {
        const client2 = await getPMSClient(req.user.organizationId);
        const limit = Number(req.query.limit ?? 50);
        const offset = Number(req.query.offset ?? 0);
        const out = await client2.listListings({ limit, offset });
        res.json(out);
      } catch (error) {
        console.error("PMS listings error:", error);
        res.status(500).json({
          error: "Failed to fetch listings",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app2.get(
    "/api/pms/availability",
    requireRole3("admin", "retail-agent", "owner"),
    async (req, res) => {
      try {
        const client2 = await getPMSClient(req.user.organizationId);
        const { listingId, start, end } = req.query;
        if (!listingId || !start || !end) {
          return res.status(400).json({ message: "listingId, start, end required" });
        }
        const out = await client2.getAvailability({ listingId, start, end });
        res.json(out);
      } catch (error) {
        console.error("PMS availability error:", error);
        res.status(500).json({
          error: "Failed to fetch availability",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
}

// server/routes/booking-revenue-routes.ts
init_demoAuth();
init_db();
init_schema();
init_hostawayService();
import express2 from "express";
import { eq as eq11 } from "drizzle-orm";
var bookingRevenueRouter = express2.Router();
function generateReservationCode() {
  const now = /* @__PURE__ */ new Date();
  const datePart = now.toISOString().slice(0, 10).replace(/-/g, "");
  const rand = Math.floor(1e3 + Math.random() * 9e3);
  return `RES-${datePart}-${rand}`;
}
bookingRevenueRouter.get("/", isDemoAuthenticated, async (req, res) => {
  try {
    const orgId = req.user?.organizationId || "default-org";
    const { propertyId } = req.query;
    let records;
    if (propertyId) {
      records = await db.select().from(bookingRevenue).where(eq11(bookingRevenue.organizationId, orgId)).where(eq11(bookingRevenue.propertyId, parseInt(propertyId)));
    } else {
      records = await db.select().from(bookingRevenue).where(eq11(bookingRevenue.organizationId, orgId));
    }
    res.json(records);
  } catch (err) {
    console.error("[BOOKING-REVENUE] GET error:", err);
    res.status(500).json({ error: "Failed to fetch booking revenue records" });
  }
});
bookingRevenueRouter.post("/", isDemoAuthenticated, async (req, res) => {
  console.log("[BOOKING-REVENUE] POST /api/booking-revenue hit");
  console.log("[BOOKING-REVENUE] Session userId:", req.session?.userId);
  console.log("[BOOKING-REVENUE] Authenticated user:", req.user?.id, req.user?.email);
  console.log("[BOOKING-REVENUE] Request body propertyId:", req.body?.propertyId);
  try {
    const orgId = req.user?.organizationId || "default-org";
    const userId = req.user?.id || "unknown";
    const {
      propertyId,
      guestName,
      guestEmail,
      guestPhone,
      checkInDate,
      checkOutDate,
      numberOfGuests,
      guestBookingPrice,
      otaPlatformFee,
      finalPayoutAmount,
      currency,
      paymentStatus,
      payoutDate,
      notes,
      reservationCode: clientReservationCode,
      skipHostawaySync
      // Flag to skip Hostaway API call for local-only bookings
    } = req.body;
    if (!propertyId || !guestName || !checkInDate || !checkOutDate || !numberOfGuests) {
      return res.status(400).json({
        error: "propertyId, guestName, checkInDate, checkOutDate, numberOfGuests are required"
      });
    }
    const [property] = await db.select().from(properties).where(eq11(properties.id, propertyId));
    if (!property) {
      return res.status(404).json({ error: "Property not found" });
    }
    const checkIn = new Date(checkInDate);
    const checkOut = new Date(checkOutDate);
    const msDiff = checkOut.getTime() - checkIn.getTime();
    const numberOfNights = Math.max(
      1,
      Math.round(msDiff / (1e3 * 60 * 60 * 24))
    );
    const currencySafe = currency || "THB";
    const paymentStatusSafe = paymentStatus || "pending";
    const guestBookingPriceSafe = guestBookingPrice != null ? Number(guestBookingPrice) : Number(finalPayoutAmount ?? 0);
    const otaPlatformFeeSafe = otaPlatformFee != null ? Number(otaPlatformFee) : 0;
    const finalPayoutAmountSafe = finalPayoutAmount != null ? Number(finalPayoutAmount) : guestBookingPriceSafe - otaPlatformFeeSafe;
    let hostAwayReservationId = null;
    let externalReservationId = null;
    let reservationCode = clientReservationCode || generateReservationCode();
    if (property.source === "HOSTAWAY" && !skipHostawaySync) {
      if (!property.hostawayListingMapId) {
        return res.status(400).json({
          error: "Property is marked as HOSTAWAY but hostawayListingMapId is missing. Please resync properties."
        });
      }
      try {
        const hostawayResult = await hostawayService.createReservation({
          listingMapId: property.hostawayListingMapId,
          arrivalDate: checkInDate,
          departureDate: checkOutDate,
          guestName,
          guestEmail,
          guestPhone,
          numberOfGuests: Number(numberOfGuests),
          specialRequests: notes
        });
        hostAwayReservationId = String(hostawayResult.id);
        externalReservationId = hostawayResult.reservationCode || null;
        if (hostawayResult.reservationCode) {
          reservationCode = hostawayResult.reservationCode;
        }
      } catch (err) {
        console.error("[BOOKING-REVENUE] Hostaway reservation error:", err);
        let userMessage = "Failed to create reservation in Hostaway";
        if (err.message && err.message.includes("not available")) {
          userMessage = err.message.replace(/Failed to create reservation in Hostaway: \d+ - /g, "");
          try {
            const parsed = JSON.parse(userMessage);
            userMessage = parsed.message || userMessage;
          } catch {
          }
        }
        return res.status(502).json({
          error: userMessage,
          details: err.message || String(err)
        });
      }
    }
    const bookingSource = skipHostawaySync || !hostAwayReservationId ? "LOCAL" : "HOSTAWAY";
    const platformName = property.source === "HOSTAWAY" ? "hostaway" : "direct";
    const [created] = await db.insert(bookingRevenue).values({
      organizationId: orgId,
      propertyId,
      reservationCode,
      guestName,
      guestEmail: guestEmail || null,
      checkInDate,
      checkOutDate,
      numberOfNights,
      numberOfGuests: Number(numberOfGuests),
      otaName: property.source === "HOSTAWAY" ? "Hostaway" : "Direct",
      bookingType: "OTA",
      guestBookingPrice: String(guestBookingPriceSafe),
      otaPlatformFee: String(otaPlatformFeeSafe),
      finalPayoutAmount: String(finalPayoutAmountSafe),
      currency: currencySafe,
      paymentStatus: paymentStatusSafe,
      payoutDate: payoutDate || null,
      isCommissionable: true,
      managementCommissionRate: "15.00",
      hostAwayReservationId,
      externalReservationId,
      notes: notes || null,
      createdBy: userId
    }).returning();
    let calendarBooking;
    try {
      const [booking] = await db.insert(bookings).values({
        organizationId: orgId,
        propertyId,
        source: bookingSource,
        // LOCAL for locally-created, even on Hostaway properties
        externalId: hostAwayReservationId || null,
        bookingReference: reservationCode,
        guestName,
        guestEmail: guestEmail || null,
        guestPhone: guestPhone || null,
        checkIn: checkInDate,
        checkOut: checkOutDate,
        guests: Number(numberOfGuests),
        totalAmount: String(guestBookingPriceSafe),
        status: "confirmed",
        bookingPlatform: platformName,
        currency: currencySafe,
        paymentStatus: paymentStatusSafe,
        amountPaid: paymentStatusSafe === "paid" ? String(guestBookingPriceSafe) : "0",
        amountDue: paymentStatusSafe === "paid" ? "0" : String(guestBookingPriceSafe),
        specialRequests: notes || null
      }).returning();
      calendarBooking = booking;
    } catch (calendarErr) {
      console.error("[BOOKING-REVENUE] Calendar booking failed, rolling back revenue entry:", calendarErr);
      await db.delete(bookingRevenue).where(eq11(bookingRevenue.id, created.id));
      throw calendarErr;
    }
    const result = { created, calendarBooking };
    console.log("[BOOKING-REVENUE] Created booking revenue:", result.created.id, "and calendar booking:", result.calendarBooking.id, "source:", bookingSource);
    try {
      const { clearCache: clearCache2 } = await Promise.resolve().then(() => (init_performanceOptimizer(), performanceOptimizer_exports));
      const { clearUltraFastCache: clearUltraFastCache2 } = await Promise.resolve().then(() => (init_ultraFastMiddleware(), ultraFastMiddleware_exports));
      clearCache2("bookings");
      clearCache2(`bookings-${orgId}`);
      clearCache2(`bookings-${orgId}-LOCAL`);
      clearCache2(`bookings-${orgId}-HOSTAWAY`);
      clearUltraFastCache2("/api/bookings");
      console.log("[BOOKING-REVENUE] All booking caches invalidated for immediate calendar update");
    } catch (cacheErr) {
      console.warn("[BOOKING-REVENUE] Cache invalidation failed (non-fatal):", cacheErr);
    }
    res.status(201).json({
      booking: result.created,
      calendarBooking: result.calendarBooking,
      source: bookingSource
    });
  } catch (err) {
    console.error("[BOOKING-REVENUE] ERROR creating booking:", err);
    res.status(500).json({
      error: err.message || "Server error creating booking revenue"
    });
  }
});

// server/index.ts
var __filename4 = fileURLToPath4(import.meta.url);
var __dirname4 = path7.dirname(__filename4);
var app = express5();
app.use(express5.json({ limit: "50mb" }));
app.use(express5.urlencoded({ extended: false, limit: "50mb" }));
app.use((req, res, next) => {
  const start = Date.now();
  const path8 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path8.startsWith("/api")) {
      let logLine = `${req.method} ${path8} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  process.on("uncaughtException", (error) => {
    console.error("Uncaught Exception:", error);
    if (process.env.NODE_ENV !== "production") {
      process.exit(1);
    }
  });
  process.on("unhandledRejection", (reason, promise) => {
    console.error("Unhandled Rejection at:", promise, "reason:", reason);
    if (process.env.NODE_ENV !== "production") {
      process.exit(1);
    }
  });
  console.log("Skipping seeding during debugging...");
  await setupDemoAuth(app);
  console.log("\u2705 Demo authentication middleware initialized");
  await seedProductionAdmin();
  app.use("/api/booking-revenue", bookingRevenueRouter);
  console.log("[INIT] Booking revenue routes mounted \u2705");
  const server = await registerRoutes(app);
  const { registerBulkDeleteRoutes: registerBulkDeleteRoutes2 } = await Promise.resolve().then(() => (init_bulk_delete_api(), bulk_delete_api_exports));
  registerBulkDeleteRoutes2(app);
  const utilityBillsRouter = (await Promise.resolve().then(() => (init_utility_bills_routes(), utility_bills_routes_exports))).default;
  app.use("/api/utility-bills", utilityBillsRouter);
  console.log("[INIT] Utility bills routes mounted \u2705");
  const utilityRouter = (await Promise.resolve().then(() => (init_utility_routes(), utility_routes_exports))).default;
  app.use("/api/utility", utilityRouter);
  console.log("[INIT] Comprehensive utility routes mounted \u2705");
  const { registerFastDashboardRoutes: registerFastDashboardRoutes2 } = await Promise.resolve().then(() => (init_fast_dashboard_api(), fast_dashboard_api_exports));
  registerFastDashboardRoutes2(app);
  mountIntegrationRoutes(app);
  mountPmsRoutes(app);
  const { setupAchievementRoutes: setupAchievementRoutes2 } = await Promise.resolve().then(() => (init_achievement_routes(), achievement_routes_exports));
  setupAchievementRoutes2(app);
  console.log("[INIT] Achievement routes mounted \u2705");
  const { propertyDocRouter: propertyDocRouter2 } = await Promise.resolve().then(() => (init_property_document_routes(), property_document_routes_exports));
  app.use("/api/property-documents", propertyDocRouter2);
  console.log("[INIT] Alternate property-document-routes mounted \u2705");
  const propertyImageRouter = (await Promise.resolve().then(() => (init_property_image_routes(), property_image_routes_exports))).default;
  app.use("/api/property-images", propertyImageRouter);
  console.log("[INIT] Property image routes mounted \u2705");
  const { serviceBookingRouter: serviceBookingRouter2 } = await Promise.resolve().then(() => (init_service_booking_routes(), service_booking_routes_exports));
  app.use("/api/service-bookings", serviceBookingRouter2);
  console.log("[INIT] Service booking routes mounted \u2705");
  const lodgifyRouter = (await Promise.resolve().then(() => (init_lodgify_routes(), lodgify_routes_exports))).default;
  app.use("/api", lodgifyRouter);
  console.log("[INIT] Lodgify API routes mounted \u2705");
  const makcorpsRouter = (await Promise.resolve().then(() => (init_makcorps_routes(), makcorps_routes_exports))).default;
  app.use("/api", makcorpsRouter);
  console.log("[INIT] Makcorps API routes mounted \u2705");
  const hostawayRouter = (await Promise.resolve().then(() => (init_hostaway_routes(), hostaway_routes_exports))).default;
  app.use("/api/hostaway", hostawayRouter);
  console.log("[INIT] Hostaway API routes mounted \u2705");
  const dailyOperationsRouter = (await Promise.resolve().then(() => (init_daily_operations_routes(), daily_operations_routes_exports))).default;
  app.use("/api/daily-operations", dailyOperationsRouter);
  console.log("[INIT] Daily Operations Dashboard routes mounted \u2705");
  const { registerPMDashboardRoutes: registerPMDashboardRoutes2 } = await Promise.resolve().then(() => (init_pm_dashboard_routes(), pm_dashboard_routes_exports));
  registerPMDashboardRoutes2(app);
  console.log("[INIT] Portfolio Manager Dashboard routes mounted \u2705");
  app.use("/uploads", express5.static(path7.join(__dirname4, "uploads")));
  console.log("[INIT] Static uploads directory mounted \u2705");
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  const isProduction = process.env.NODE_ENV === "production";
  if (!isProduction) {
    const { setupVite } = await import("./vite");
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = Number(process.env.PORT) || 5e3;
  const httpServer = app.listen(port, "0.0.0.0", () => {
    console.log("Server started");
  });
  process.on("SIGTERM", () => {
    console.log("SIGTERM received, shutting down gracefully");
    httpServer.close(() => {
      console.log("Process terminated");
      process.exit(0);
    });
  });
  process.on("SIGINT", () => {
    console.log("SIGINT received, shutting down gracefully");
    httpServer.close(() => {
      console.log("Process terminated");
      process.exit(0);
    });
  });
})();
